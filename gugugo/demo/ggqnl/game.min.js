function BlockData(a, b) {
    this.selMenuHander = a, this.target = b
}

function BlockCCControlData(a, b, c) {
    this.selCCControlHandler = a, this.target = b, this.controlEvents = c
}
var cc = cc || {};
cc._tmp = cc._tmp || {}, cc._LogInfos = {}, _p = window, _p = Object.prototype, delete window._p, cc.newElement = function(a) {
    return document.createElement(a)
}, cc._addEventListener = function(a, b, c, d) {
    a.addEventListener(b, c, d)
}, cc._isNodeJs = "undefined" != typeof require && require("fs"), cc.each = function(a, b, c) {
    if (a)
        if (a instanceof Array)
            for (var d = 0, e = a.length; e > d && !1 !== b.call(c, a[d], d); d++);
        else
            for (d in a)
                if (!1 === b.call(c, a[d], d)) break
}, cc.isCrossOrigin = function(a) {
    if (!a) return cc.log("invalid URL"), !1;
    var b = a.indexOf("://");
    return -1 == b ? !1 : (b = a.indexOf("/", b + 3), (-1 == b ? a : a.substring(0, b)) != location.origin)
}, cc.AsyncPool = function(a, b, c, d, e) {
    var f = this;
    f._srcObj = a, f._limit = b, f._pool = [], f._iterator = c, f._iteratorTarget = e, f._onEnd = d, f._onEndTarget = e, f._results = a instanceof Array ? [] : {}, f._isErr = !1, cc.each(a, function(a, b) {
        f._pool.push({
            index: b,
            value: a
        })
    }), f.size = f._pool.length, f.finishedSize = 0, f._workingSize = 0, f._limit = f._limit || f.size, f.onIterator = function(a, b) {
        f._iterator = a, f._iteratorTarget = b
    }, f.onEnd = function(a, b) {
        f._onEnd = a, f._onEndTarget = b
    }, f._handleItem = function() {
        var a = this;
        if (0 != a._pool.length && !(a._workingSize >= a._limit)) {
            var b = a._pool.shift(),
                c = b.value,
                d = b.index;
            a._workingSize++, a._iterator.call(a._iteratorTarget, c, d, function(b) {
                if (!a._isErr)
                    if (a.finishedSize++, a._workingSize--, b) a._isErr = !0, a._onEnd && a._onEnd.call(a._onEndTarget, b);
                    else {
                        var c = Array.prototype.slice.call(arguments, 1);
                        a._results[this.index] = c[0], a.finishedSize == a.size ? a._onEnd && a._onEnd.call(a._onEndTarget, null, a._results) : a._handleItem()
                    }
            }.bind(b), a)
        }
    }, f.flow = function() {
        if (0 == this._pool.length) this._onEnd && this._onEnd.call(this._onEndTarget, null, []);
        else
            for (var a = 0; a < this._limit; a++) this._handleItem()
    }
}, cc.async = {
    series: function(a, b, c) {
        return a = new cc.AsyncPool(a, 1, function(a, b, d) {
            a.call(c, d)
        }, b, c), a.flow(), a
    },
    parallel: function(a, b, c) {
        return a = new cc.AsyncPool(a, 0, function(a, b, d) {
            a.call(c, d)
        }, b, c), a.flow(), a
    },
    waterfall: function(a, b, c) {
        var d = [];
        return a = new cc.AsyncPool(a, 1, function(a, b, e) {
            d.push(function() {
                d = Array.prototype.slice.call(arguments, 1), e.apply(null, arguments)
            }), a.apply(c, d)
        }, function(a, d) {
            if (b) {
                if (a) return b.call(c, a);
                b.call(c, null, d[d.length - 1])
            }
        }), a.flow(), a
    },
    map: function(a, b, c, d) {
        var e = b;
        return "object" == typeof b && (c = b.cb, d = b.iteratorTarget, e = b.iterator), a = new cc.AsyncPool(a, 0, e, c, d), a.flow(), a
    },
    mapLimit: function(a, b, c, d, e) {
        return a = new cc.AsyncPool(a, b, c, d, e), a.flow(), a
    }
}, cc.path = {
    join: function() {
        for (var a = arguments.length, b = "", c = 0; a > c; c++) b = (b + ("" == b ? "" : "/") + arguments[c]).replace(/(\/|\\\\)$/, "");
        return b
    },
    extname: function(a) {
        return (a = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(a)) ? a[1] : null
    },
    mainFileName: function(a) {
        if (a) {
            var b = a.lastIndexOf(".");
            if (-1 !== b) return a.substring(0, b)
        }
        return a
    },
    basename: function(a, b) {
        var c = a.indexOf("?");
        return c > 0 && (a = a.substring(0, c)), (c = /(\/|\\\\)([^(\/|\\\\)]+)$/g.exec(a.replace(/(\/|\\\\)$/, ""))) ? (c = c[2], b && a.substring(a.length - b.length).toLowerCase() == b.toLowerCase() ? c.substring(0, c.length - b.length) : c) : null
    },
    dirname: function(a) {
        return a.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2")
    },
    changeExtname: function(a, b) {
        b = b || "";
        var c = a.indexOf("?"),
            d = "";
        return c > 0 && (d = a.substring(c), a = a.substring(0, c)), c = a.lastIndexOf("."), 0 > c ? a + b + d : a.substring(0, c) + b + d
    },
    changeBasename: function(a, b, c) {
        if (0 == b.indexOf(".")) return this.changeExtname(a, b);
        var d = a.indexOf("?"),
            e = "";
        return c = c ? this.extname(a) : "", d > 0 && (e = a.substring(d), a = a.substring(0, d)), d = a.lastIndexOf("/"), a.substring(0, 0 >= d ? 0 : d + 1) + b + c + e
    }
}, cc.loader = {
    _jsCache: {},
    _register: {},
    _langPathCache: {},
    _aliases: {},
    resPath: "",
    audioPath: "",
    cache: {},
    getXMLHttpRequest: function() {
        return window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP")
    },
    _getArgs4Js: function(a) {
        var b = a[0],
            c = a[1],
            d = a[2],
            e = ["", null, null];
        if (1 === a.length) e[1] = b instanceof Array ? b : [b];
        else if (2 === a.length) "function" == typeof c ? (e[1] = b instanceof Array ? b : [b], e[2] = c) : (e[0] = b || "", e[1] = c instanceof Array ? c : [c]);
        else {
            if (3 !== a.length) throw "arguments error to load js!";
            e[0] = b || "", e[1] = c instanceof Array ? c : [c], e[2] = d
        }
        return e
    },
    loadJs: function() {
        var a = this,
            b = a._jsCache,
            c = a._getArgs4Js(arguments),
            d = c[0],
            e = c[1],
            c = c[2]; - 1 < navigator.userAgent.indexOf("Trident/5") ? a._loadJs4Dependency(d, e, 0, c) : cc.async.map(e, function(c, e, f) {
                return c = cc.path.join(d, c), b[c] ? f(null) : void a._createScript(c, !1, f)
            }, c)
    },
    loadJsWithImg: function() {
        var a = this._loadJsImg(),
            b = this._getArgs4Js(arguments);
        this.loadJs(b[0], b[1], function(c) {
            if (c) throw c;
            a.parentNode.removeChild(a), b[2] && b[2]()
        })
    },
    _createScript: function(a, b, c) {
        var d = document,
            e = cc.newElement("script");
        e.async = b, e.src = a, this._jsCache[a] = !0, cc._addEventListener(e, "load", function() {
            e.parentNode.removeChild(e), this.removeEventListener("load", arguments.callee, !1), c()
        }, !1), cc._addEventListener(e, "error", function() {
            e.parentNode.removeChild(e), c("Load " + a + " failed!")
        }, !1), d.body.appendChild(e)
    },
    _loadJs4Dependency: function(a, b, c, d) {
        if (c >= b.length) d && d();
        else {
            var e = this;
            e._createScript(cc.path.join(a, b[c]), !1, function(f) {
                return f ? d(f) : void e._loadJs4Dependency(a, b, c + 1, d)
            })
        }
    },
    _loadJsImg: function() {
        var a = document,
            b = a.getElementById("cocos2d_loadJsImg");
        if (!b) {
            b = cc.newElement("img"), cc._loadingImage && (b.src = cc._loadingImage), a = a.getElementById(cc.game.config.id), a.style.backgroundColor = "black", a.parentNode.appendChild(b);
            var c = getComputedStyle ? getComputedStyle(a) : a.currentStyle;
            c || (c = {
                width: a.width,
                height: a.height
            }), b.style.left = a.offsetLeft + (parseFloat(c.width) - b.width) / 2 + "px", b.style.top = a.offsetTop + (parseFloat(c.height) - b.height) / 2 + "px", b.style.position = "absolute"
        }
        return b
    },
    loadTxt: function(a, b) {
        if (cc._isNodeJs) require("fs").readFile(a, function(a, c) {
            a ? b(a) : b(null, c.toString())
        });
        else {
            var c = this.getXMLHttpRequest(),
                d = "load " + a + " failed!";
            c.open("GET", a, !0), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (c.setRequestHeader("Accept-Charset", "utf-8"), c.onreadystatechange = function() {
                4 == c.readyState && (200 == c.status ? b(null, c.responseText) : b(d))
            }) : (c.overrideMimeType && c.overrideMimeType("text/plain; charset=utf-8"), c.onload = function() {
                4 == c.readyState && (200 == c.status ? b(null, c.responseText) : b(d))
            }), c.send(null)
        }
    },
    _loadTxtSync: function(a) {
        if (cc._isNodeJs) return require("fs").readFileSync(a).toString();
        var b = this.getXMLHttpRequest();
        return b.open("GET", a, !1), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? b.setRequestHeader("Accept-Charset", "utf-8") : b.overrideMimeType && b.overrideMimeType("text/plain; charset=utf-8"), b.send(null), 4 == !b.readyState || 200 != b.status ? null : b.responseText
    },
    loadJson: function(a, b) {
        this.loadTxt(a, function(c, d) {
            try {
                c ? b(c) : b(null, JSON.parse(d))
            } catch (e) {
                throw "load json [" + a + "] failed : " + e
            }
        })
    },
    _checkIsImageURL: function(a) {
        return null != /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(a)
    },
    loadImg: function(a, b, c) {
        var d = !0;
        void 0 !== c ? d = null == b.isCrossOrigin ? d : b.isCrossOrigin : void 0 !== b && (c = b);
        var e = new Image;
        return d && "file://" != location.origin && (e.crossOrigin = "Anonymous"), cc._addEventListener(e, "load", function() {
            this.removeEventListener("load", arguments.callee, !1), this.removeEventListener("error", arguments.callee, !1), c && c(null, e)
        }), cc._addEventListener(e, "error", function() {
            this.removeEventListener("error", arguments.callee, !1), c && c("load image failed")
        }), e.src = a, e
    },
    _loadResIterator: function(a, b, c) {
        var d = this,
            e = null,
            f = a.type;
        return f ? (f = "." + f.toLowerCase(), e = a.src ? a.src : a.name + f) : (e = a, f = cc.path.extname(e)), (b = d.cache[e]) ? c(null, b) : (b = d._register[f.toLowerCase()]) ? (f = b.getBasePath ? b.getBasePath() : d.resPath, f = d.getUrl(f, e), void b.load(f, e, a, function(a, b) {
            a ? (cc.log(a), d.cache[e] = null, delete d.cache[e], c()) : (d.cache[e] = b, c(null, b))
        })) : (cc.error("loader for [" + f + "] not exists!"), c())
    },
    getUrl: function(a, b) {
        var c = this._langPathCache,
            d = cc.path;
        if (void 0 !== a && void 0 === b) {
            b = a;
            var e = d.extname(b),
                e = e ? e.toLowerCase() : "";
            a = (e = this._register[e]) && e.getBasePath ? e.getBasePath() : this.resPath
        }
        if (b = cc.path.join(a || "", b), b.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
            if (c[b]) return c[b];
            d = d.extname(b) || "", b = c[b] = b.substring(0, b.length - d.length) + "_" + cc.sys.language + d
        }
        return b
    },
    load: function(a, b, c) {
        var d = this,
            e = arguments.length;
        if (0 == e) throw "arguments error!";
        return 3 == e ? "function" == typeof b && (b = "function" == typeof c ? {
            trigger: b,
            cb: c
        } : {
            cb: b,
            cbTarget: c
        }) : 2 == e ? "function" == typeof b && (b = {
            cb: b
        }) : 1 == e && (b = {}), a instanceof Array || (a = [a]), e = new cc.AsyncPool(a, 0, function(a, c, e, f) {
            d._loadResIterator(a, c, function(a) {
                if (a) return e(a);
                var c = Array.prototype.slice.call(arguments, 1);
                b.trigger && b.trigger.call(b.triggerTarget, c[0], f.size, f.finishedSize), e(null, c[0])
            })
        }, b.cb, b.cbTarget), e.flow(), e
    },
    _handleAliases: function(a, b) {
        var c, d = this._aliases,
            e = [];
        for (c in a) {
            var f = a[c];
            d[c] = f, e.push(f)
        }
        this.load(e, b)
    },
    loadAliases: function(a, b) {
        var c = this,
            d = c.getRes(a);
        d ? c._handleAliases(d.filenames, b) : c.load(a, function(a, d) {
            c._handleAliases(d[0].filenames, b)
        })
    },
    register: function(a, b) {
        if (a && b) {
            if ("string" == typeof a) return this._register[a.trim().toLowerCase()] = b;
            for (var c = 0, d = a.length; d > c; c++) this._register["." + a[c].trim().toLowerCase()] = b
        }
    },
    getRes: function(a) {
        return this.cache[a] || this.cache[this._aliases[a]]
    },
    release: function(a) {
        var b = this.cache,
            c = this._aliases;
        delete b[a], delete b[c[a]], delete c[a]
    },
    releaseAll: function() {
        var a, b = this.cache,
            c = this._aliases;
        for (a in b) delete b[a];
        for (a in c) delete c[a]
    }
}, cc.formatStr = function() {
    var a = arguments,
        b = a.length;
    if (1 > b) return "";
    var c = a[0],
        d = !0;
    "object" == typeof c && (c = JSON.stringify(c), d = !1);
    for (var e = 1; b > e; ++e) {
        var f = a[e],
            f = "object" == typeof f ? JSON.stringify(f) : f;
        if (d)
            for (;;) {
                var g = null;
                if ("number" == typeof f && (g = c.match(/(%d)|(%s)/))) {
                    c = c.replace(/(%d)|(%s)/, f);
                    break
                }
                c = (g = c.match(/%s/)) ? c.replace(/%s/, f) : c + ("    " + f);
                break
            } else c += "    " + f
    }
    return c
},
function() {
    var a, b, c = window;
    "undefined" != typeof document.hidden ? (a = "hidden", b = "visibilitychange") : "undefined" != typeof document.mozHidden ? (a = "mozHidden", b = "mozvisibilitychange") : "undefined" != typeof document.msHidden ? (a = "msHidden", b = "msvisibilitychange") : "undefined" != typeof document.webkitHidden && (a = "webkitHidden", b = "webkitvisibilitychange");
    var d = function() {
        cc.eventManager && cc.game._eventHide && cc.eventManager.dispatchEvent(cc.game._eventHide)
    }, e = function() {
            cc.eventManager && cc.game._eventShow && cc.eventManager.dispatchEvent(cc.game._eventShow), cc.game._intervalId && (window.cancelAnimationFrame(cc.game._intervalId), cc.game._runMainLoop())
        };
    a ? cc._addEventListener(document, b, function() {
        document[a] ? d() : e()
    }, !1) : (cc._addEventListener(c, "blur", d, !1), cc._addEventListener(c, "focus", e, !1)), -1 < navigator.userAgent.indexOf("MicroMessenger") && (c.onfocus = function() {
        e()
    }), "onpageshow" in window && "onpagehide" in window && (cc._addEventListener(c, "pagehide", d, !1), cc._addEventListener(c, "pageshow", e, !1)), b = c = null
}(), cc.log = cc.warn = cc.error = cc.assert = function() {}, cc.create3DContext = function(a, b) {
    for (var c = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], d = null, e = 0; e < c.length; ++e) {
        try {
            d = a.getContext(c[e], b)
        } catch (f) {}
        if (d) break
    }
    return d
}, cc._initSys = function(a, b) {
    cc._RENDER_TYPE_CANVAS = 0, cc._RENDER_TYPE_WEBGL = 1, cc.sys = {};
    var c = cc.sys;
    c.LANGUAGE_ENGLISH = "en", c.LANGUAGE_CHINESE = "zh", c.OS_WINDOWS = "Windows", c.OS_IOS = "iOS", c.OS_OSX = "OS X", c.OS_UNIX = "UNIX", c.OS_LINUX = "Linux", c.OS_ANDROID = "Android", c.OS_UNKNOWN = "Unknown", c.WINDOWS = 0, c.LINUX = 1, c.MACOS = 2, c.ANDROID = 3, c.IPHONE = 4, c.IPAD = 5, c.BLACKBERRY = 6, c.NACL = 7, c.EMSCRIPTEN = 8, c.TIZEN = 9, c.WINRT = 10, c.WP8 = 11, c.MOBILE_BROWSER = 100, c.DESKTOP_BROWSER = 101, c.BROWSER_TYPE_WECHAT = "wechat", c.BROWSER_TYPE_ANDROID = "androidbrowser", c.BROWSER_TYPE_IE = "ie", c.BROWSER_TYPE_QQ = "qqbrowser", c.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser", c.BROWSER_TYPE_UC = "ucbrowser", c.BROWSER_TYPE_360 = "360browser", c.BROWSER_TYPE_BAIDU_APP = "baiduboxapp", c.BROWSER_TYPE_BAIDU = "baidubrowser", c.BROWSER_TYPE_MAXTHON = "maxthon", c.BROWSER_TYPE_OPERA = "opera", c.BROWSER_TYPE_MIUI = "miuibrowser", c.BROWSER_TYPE_FIREFOX = "firefox", c.BROWSER_TYPE_SAFARI = "safari", c.BROWSER_TYPE_CHROME = "chrome", c.BROWSER_TYPE_UNKNOWN = "unknown", c.isNative = !1;
    var d = [c.BROWSER_TYPE_BAIDU, c.BROWSER_TYPE_OPERA, c.BROWSER_TYPE_FIREFOX, c.BROWSER_TYPE_CHROME, c.BROWSER_TYPE_SAFARI],
        e = [c.BROWSER_TYPE_BAIDU, c.BROWSER_TYPE_OPERA, c.BROWSER_TYPE_FIREFOX, c.BROWSER_TYPE_CHROME, c.BROWSER_TYPE_SAFARI, c.BROWSER_TYPE_UC, c.BROWSER_TYPE_QQ, c.BROWSER_TYPE_MOBILE_QQ, c.BROWSER_TYPE_IE],
        f = window,
        g = f.navigator,
        h = document.documentElement,
        i = g.userAgent.toLowerCase();
    c.isMobile = -1 != i.indexOf("mobile") || -1 != i.indexOf("android"), c.platform = c.isMobile ? c.MOBILE_BROWSER : c.DESKTOP_BROWSER;
    var j = g.language,
        j = (j = j ? j : g.browserLanguage) ? j.split("-")[0] : c.LANGUAGE_ENGLISH;
    c.language = j;
    var j = c.BROWSER_TYPE_UNKNOWN,
        k = i.match(/micromessenger|qqbrowser|mqqbrowser|ucbrowser|360browser|baiduboxapp|baidubrowser|maxthon|trident|opera|miuibrowser|firefox/i) || i.match(/chrome|safari/i);
    if (k && 0 < k.length && (j = k[0].toLowerCase(), "micromessenger" == j ? j = c.BROWSER_TYPE_WECHAT : "safari" === j && i.match(/android.*applewebkit/) ? j = c.BROWSER_TYPE_ANDROID : "trident" == j && (j = c.BROWSER_TYPE_IE)), c.browserType = j, c._supportMultipleAudio = -1 < e.indexOf(c.browserType), e = parseInt(a[b.renderMode]), j = cc._RENDER_TYPE_WEBGL, k = cc.newElement("Canvas"), cc._supportRender = !0, d = -1 == d.indexOf(c.browserType), (1 === e || 0 === e && (c.isMobile || d) || "file://" == location.origin) && (j = cc._RENDER_TYPE_CANVAS), c._canUseCanvasNewBlendModes = function() {
        var a = document.createElement("canvas");
        return a.width = 1, a.height = 1, a = a.getContext("2d"), a.fillStyle = "#000", a.fillRect(0, 0, 1, 1), a.globalCompositeOperation = "multiply", a.fillStyle = "#fff", a.fillRect(0, 0, 1, 1), 0 === a.getImageData(0, 0, 1, 1).data[0]
    }, c._supportCanvasNewBlendModes = c._canUseCanvasNewBlendModes(), j != cc._RENDER_TYPE_WEBGL || f.WebGLRenderingContext && cc.create3DContext(k, {
        stencil: !0,
        preserveDrawingBuffer: !0
    }) || (0 == e ? j = cc._RENDER_TYPE_CANVAS : cc._supportRender = !1), j == cc._RENDER_TYPE_CANVAS) try {
        k.getContext("2d")
    } catch (l) {
        cc._supportRender = !1
    }
    cc._renderType = j;
    try {
        c._supportWebAudio = !! new(f.AudioContext || f.webkitAudioContext || f.mozAudioContext)
    } catch (m) {
        c._supportWebAudio = !1
    }
    try {
        var n = c.localStorage = f.localStorage;
        n.setItem("storage", ""), n.removeItem("storage"), n = null
    } catch (o) {
        ("SECURITY_ERR" === o.name || "QuotaExceededError" === o.name) && cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option"), c.localStorage = function() {}
    }
    n = c.capabilities = {
        canvas: !0
    }, cc._renderType == cc._RENDER_TYPE_WEBGL && (n.opengl = !0), (void 0 !== h.ontouchstart || g.msPointerEnabled) && (n.touches = !0), void 0 !== h.onmouseup && (n.mouse = !0), void 0 !== h.onkeyup && (n.keyboard = !0), (f.DeviceMotionEvent || f.DeviceOrientationEvent) && (n.accelerometer = !0), f = i.match(/(iPad|iPhone|iPod)/i) ? !0 : !1, i = i.match(/android/i) || g.platform.match(/android/i) ? !0 : !1, h = c.OS_UNKNOWN, -1 != g.appVersion.indexOf("Win") ? h = c.OS_WINDOWS : f ? h = c.OS_IOS : -1 != g.appVersion.indexOf("Mac") ? h = c.OS_OSX : -1 != g.appVersion.indexOf("X11") ? h = c.OS_UNIX : i ? h = c.OS_ANDROID : -1 != g.appVersion.indexOf("Linux") && (h = c.OS_LINUX), c.os = h, c.garbageCollect = function() {}, c.dumpRoot = function() {}, c.restartVM = function() {}, c.dump = function() {
        var a;
        a = "" + ("isMobile : " + this.isMobile + "\r\n"), a += "language : " + this.language + "\r\n", a += "browserType : " + this.browserType + "\r\n", a += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n", a += "os : " + this.os + "\r\n", a += "platform : " + this.platform + "\r\n", cc.log(a)
    }
}, cc.ORIENTATION_PORTRAIT = 0, cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1, cc.ORIENTATION_LANDSCAPE_LEFT = 2, cc.ORIENTATION_LANDSCAPE_RIGHT = 3, cc._drawingUtil = null, cc._renderContext = null, cc._canvas = null, cc._gameDiv = null, cc._rendererInitialized = !1, cc._setupCalled = !1, cc._setup = function(a, b, c) {
    if (!cc._setupCalled) {
        cc._setupCalled = !0;
        var d = window,
            e = new Date,
            f = 1e3 / cc.game.config[cc.game.CONFIG_KEY.frameRate],
            g = function(a) {
                var b = (new Date).getTime(),
                    c = Math.max(0, f - (b - e)),
                    d = window.setTimeout(function() {
                        a()
                    }, c);
                return e = b + c, d
            }, h = function(a) {
                clearTimeout(a)
            };
        cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT ? (d.requestAnimFrame = g, d.cancelAnimationFrame = h) : 60 != cc.game.config[cc.game.CONFIG_KEY.frameRate] ? (d.requestAnimFrame = g, d.cancelAnimationFrame = h) : (d.requestAnimFrame = d.requestAnimationFrame || d.webkitRequestAnimationFrame || d.mozRequestAnimationFrame || d.oRequestAnimationFrame || d.msRequestAnimationFrame || g, d.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || h), h = cc.$(a) || cc.$("#" + a), "CANVAS" == h.tagName ? (b = b || h.width, c = c || h.height, g = cc.container = cc.newElement("DIV"), a = cc._canvas = h, a.parentNode.insertBefore(g, a), a.appendTo(g), g.setAttribute("id", "Cocos2dGameContainer")) : ("DIV" != h.tagName && cc.log("Warning: target element is not a DIV or CANVAS"), b = b || h.clientWidth, c = c || h.clientHeight, g = cc.container = h, a = cc._canvas = cc.$(cc.newElement("CANVAS")), h.appendChild(a)), a.addClass("gameCanvas"), a.setAttribute("width", b || 480), a.setAttribute("height", c || 320), a.setAttribute("tabindex", 99), a.style.outline = "none", h = g.style, h.width = (b || 480) + "px", h.height = (c || 320) + "px", h.margin = "0 auto", h.position = "relative", h.overflow = "hidden", g.top = "100%", cc._renderType == cc._RENDER_TYPE_WEBGL && (cc._renderContext = cc.webglContext = cc.create3DContext(a, {
            stencil: !0,
            preserveDrawingBuffer: !0,
            antialias: !cc.sys.isMobile,
            alpha: !1
        })), cc._renderContext ? (d.gl = cc._renderContext, cc._drawingUtil = new cc.DrawingPrimitiveWebGL(cc._renderContext), cc._rendererInitialized = !0, cc.textureCache._initializingRenderer(), cc.shaderCache._init()) : (cc._renderContext = a.getContext("2d"), cc._mainRenderContextBackup = cc._renderContext, cc._renderContext.translate(0, a.height), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(cc._renderContext) : null), cc._gameDiv = g, cc.log(cc.ENGINE_VERSION), cc._setContextMenuEnable(!1), cc.sys.isMobile && (b = cc.newElement("style"), b.type = "text/css", document.body.appendChild(b), b.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}"), cc.view = cc.EGLView._getInstance(), cc.inputManager.registerSystemEvent(cc._canvas), cc.director = cc.Director._getInstance(), cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view), cc.winSize = cc.director.getWinSize(), cc.saxParser = new cc.SAXParser, cc.plistParser = new cc.PlistParser
    }
}, cc._checkWebGLRenderMode = function() {
    if (cc._renderType !== cc._RENDER_TYPE_WEBGL) throw "This feature supports WebGL render mode only."
}, cc._isContextMenuEnable = !1, cc._setContextMenuEnable = function(a) {
    cc._isContextMenuEnable = a, cc._canvas.oncontextmenu = function() {
        return cc._isContextMenuEnable ? void 0 : !1
    }
}, cc.game = {
    DEBUG_MODE_NONE: 0,
    DEBUG_MODE_INFO: 1,
    DEBUG_MODE_WARN: 2,
    DEBUG_MODE_ERROR: 3,
    DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
    DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
    DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
    EVENT_HIDE: "game_on_hide",
    EVENT_SHOW: "game_on_show",
    _eventHide: null,
    _eventShow: null,
    _onBeforeStartArr: [],
    CONFIG_KEY: {
        engineDir: "engineDir",
        dependencies: "dependencies",
        debugMode: "debugMode",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        jsList: "jsList",
        classReleaseMode: "classReleaseMode"
    },
    _prepareCalled: !1,
    _prepared: !1,
    _paused: !0,
    _intervalId: null,
    config: null,
    onStart: null,
    onStop: null,
    setFrameRate: function(a) {
        this.config[this.CONFIG_KEY.frameRate] = a, this._intervalId && window.cancelAnimationFrame(this._intervalId), this._paused = !0, this._runMainLoop()
    },
    _runMainLoop: function() {
        var a, b = this,
            c = cc.director;
        c.setDisplayStats(b.config[b.CONFIG_KEY.showFPS]), a = function() {
            b._paused || (c.mainLoop(), b._intervalId = window.requestAnimFrame(a))
        }, window.requestAnimFrame(a), b._paused = !1
    },
    run: function(a) {
        var b = this,
            c = function() {
                a && (b.config[b.CONFIG_KEY.id] = a), b._prepareCalled || b.prepare(function() {
                    b._prepared = !0
                }), cc._supportRender && (b._checkPrepare = setInterval(function() {
                    b._prepared && (cc._setup(b.config[b.CONFIG_KEY.id]), b._runMainLoop(), b._eventHide = b._eventHide || new cc.EventCustom(b.EVENT_HIDE), b._eventHide.setUserData(b), b._eventShow = b._eventShow || new cc.EventCustom(b.EVENT_SHOW), b._eventShow.setUserData(b), b.onStart(), clearInterval(b._checkPrepare))
                }, 10))
            };
        document.body ? c() : cc._addEventListener(window, "load", function() {
            this.removeEventListener("load", arguments.callee, !1), c()
        }, !1)
    },
    _initConfig: function() {
        var a = this.CONFIG_KEY,
            b = function(b) {
                return b[a.engineDir] = b[a.engineDir] || "frameworks/cocos2d-html5", null == b[a.debugMode] && (b[a.debugMode] = 0), b[a.frameRate] = b[a.frameRate] || 60, null == b[a.renderMode] && (b[a.renderMode] = 1), b
            };
        if (document.ccConfig) this.config = b(document.ccConfig);
        else try {
            for (var c = document.getElementsByTagName("script"), d = 0; d < c.length; d++) {
                var e = c[d].getAttribute("cocos");
                if ("" == e || e) break
            }
            var f, g, h;
            d < c.length && ((f = c[d].src) && (h = /(.*)\//.exec(f)[0], cc.loader.resPath = h, f = cc.path.join(h, "res/project.json")), g = cc.loader._loadTxtSync(f)), g || (g = cc.loader._loadTxtSync("res/project.json"));
            var i = JSON.parse(g);
            this.config = b(i || {})
        } catch (j) {
            cc.log("Failed to read or parse project.json"), this.config = b({})
        }
        cc._initSys(this.config, a)
    },
    _jsAddedCache: {},
    _getJsListOfModule: function(a, b, c) {
        var d = this._jsAddedCache;
        if (d[b]) return null;
        c = c || "";
        var e = [],
            f = a[b];
        if (!f) throw "can not find module [" + b + "]";
        b = cc.path;
        for (var g = 0, h = f.length; h > g; g++) {
            var i = f[g];
            if (!d[i]) {
                var j = b.extname(i);
                j ? ".js" == j.toLowerCase() && e.push(b.join(c, i)) : (j = this._getJsListOfModule(a, i, c)) && (e = e.concat(j)), d[i] = 1
            }
        }
        return e
    },
    prepare: function(a) {
        var b = this,
            c = b.config,
            d = b.CONFIG_KEY,
            e = c[d.engineDir],
            f = cc.loader;
        if (!cc._supportRender) throw "The renderer doesn't support the renderMode " + c[d.renderMode];
        b._prepareCalled = !0;
        var g = c[d.jsList] || [];
        cc.Class ? f.loadJsWithImg("", g, function(c) {
            if (c) throw c;
            b._prepared = !0, a && a()
        }) : (d = cc.path.join(e, "moduleConfig.json"), f.loadJson(d, function(d, f) {
            if (d) throw d;
            var h = c.modules || [],
                i = f.module,
                j = [];
            cc._renderType == cc._RENDER_TYPE_WEBGL ? h.splice(0, 0, "shaders") : 0 > h.indexOf("core") && h.splice(0, 0, "core");
            for (var k = 0, l = h.length; l > k; k++) {
                var m = b._getJsListOfModule(i, h[k], e);
                m && (j = j.concat(m))
            }
            j = j.concat(g), cc.loader.loadJsWithImg(j, function(c) {
                if (c) throw c;
                b._prepared = !0, a && a()
            })
        }))
    }
}, cc.game._initConfig(), Function.prototype.bind = Function.prototype.bind || function(a) {
    var b = this;
    return function() {
        var c = Array.prototype.slice.call(arguments);
        return b.apply(a || null, c)
    }
}, cc._LogInfos = {}, cc._logToWebPage = function(a) {
    if (cc._canvas) {
        var b = cc._logList,
            c = document;
        if (!b) {
            var d = c.createElement("Div"),
                b = d.style;
            d.setAttribute("id", "logInfoDiv"), cc._canvas.parentNode.appendChild(d), d.setAttribute("width", "200"), d.setAttribute("height", cc._canvas.height), b.zIndex = "99999", b.position = "absolute", b.top = "0", b.left = "0", b = cc._logList = c.createElement("textarea"), c = b.style, b.setAttribute("rows", "20"), b.setAttribute("cols", "30"), b.setAttribute("disabled", !0), d.appendChild(b), c.backgroundColor = "transparent", c.borderBottom = "1px solid #cccccc", c.borderRightWidth = "0px", c.borderLeftWidth = "0px", c.borderTopWidth = "0px", c.borderTopStyle = "none", c.borderRightStyle = "none", c.borderLeftStyle = "none", c.padding = "0px", c.margin = 0
        }
        a = "string" == typeof a ? a : JSON.stringify(a), b.value = b.value + a + "\r\n", b.scrollTop = b.scrollHeight
    }
}, cc._formatString = function(a) {
    if ("object" != typeof a) return a;
    try {
        return JSON.stringify(a)
    } catch (b) {
        return ""
    }
}, cc._initDebugSetting = function(a) {
    var b = cc.game;
    if (a != b.DEBUG_MODE_NONE) {
        var c;
        a > b.DEBUG_MODE_ERROR ? (c = cc._logToWebPage.bind(cc), cc.error = function() {
            c("ERROR :  " + cc.formatStr.apply(cc, arguments))
        }, cc.assert = function(a, b) {
            if (!a && b) {
                for (var d = 2; d < arguments.length; d++) b = b.replace(/(%s)|(%d)/, cc._formatString(arguments[d]));
                c("Assert: " + b)
            }
        }, a != b.DEBUG_MODE_ERROR_FOR_WEB_PAGE && (cc.warn = function() {
            c("WARN :  " + cc.formatStr.apply(cc, arguments))
        }), a == b.DEBUG_MODE_INFO_FOR_WEB_PAGE && (cc.log = function() {
            c(cc.formatStr.apply(cc, arguments))
        })) : console && (cc.error = function() {
            return console.error.apply(console, arguments)
        }, cc.assert = function(a, b) {
            if (!a && b) {
                for (var c = 2; c < arguments.length; c++) b = b.replace(/(%s)|(%d)/, cc._formatString(arguments[c]));
                throw b
            }
        }, a != b.DEBUG_MODE_ERROR && (cc.warn = function() {
            return console.warn.apply(console, arguments)
        }), a == b.DEBUG_MODE_INFO && (cc.log = function() {
            return console.log.apply(console, arguments)
        }))
    }
}, cc._initDebugSetting(cc.game.config[cc.game.CONFIG_KEY.debugMode]), cc.loader.loadBinary = function(a, b) {
    var c = this,
        d = this.getXMLHttpRequest(),
        e = "load " + a + " failed!";
    d.open("GET", a, !0), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (d.setRequestHeader("Accept-Charset", "x-user-defined"), d.onreadystatechange = function() {
        if (4 == d.readyState && 200 == d.status) {
            var a = cc._convertResponseBodyToText(d.responseBody);
            b(null, c._str2Uint8Array(a))
        } else b(e)
    }) : (d.overrideMimeType && d.overrideMimeType("text/plain; charset=x-user-defined"), d.onload = function() {
        4 == d.readyState && 200 == d.status ? b(null, c._str2Uint8Array(d.responseText)) : b(e)
    }), d.send(null)
}, cc.loader._str2Uint8Array = function(a) {
    if (!a) return null;
    for (var b = new Uint8Array(a.length), c = 0; c < a.length; c++) b[c] = 255 & a.charCodeAt(c);
    return b
}, cc.loader.loadBinarySync = function(a) {
    var b = this.getXMLHttpRequest(),
        c = "load " + a + " failed!";
    if (b.open("GET", a, !1), a = null, /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
        if (b.setRequestHeader("Accept-Charset", "x-user-defined"), b.send(null), 200 != b.status) return cc.log(c), null;
        (b = cc._convertResponseBodyToText(b.responseBody)) && (a = this._str2Uint8Array(b))
    } else {
        if (b.overrideMimeType && b.overrideMimeType("text/plain; charset=x-user-defined"), b.send(null), 200 != b.status) return cc.log(c), null;
        a = this._str2Uint8Array(b.responseText)
    }
    return a
};
var Uint8Array = Uint8Array || Array;
if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
    var IEBinaryToArray_ByteStr_Script = '<!-- IEBinaryToArray_ByteStr -->\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr = CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex = LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last = Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last = ""\r\n   End If\r\nEnd Function\r\n',
        myVBScript = cc.newElement("script");
    myVBScript.type = "text/vbscript", myVBScript.textContent = IEBinaryToArray_ByteStr_Script, document.body.appendChild(myVBScript), cc._convertResponseBodyToText = function(a) {
        for (var b = {}, c = 0; 256 > c; c++)
            for (var d = 0; 256 > d; d++) b[String.fromCharCode(c + 256 * d)] = String.fromCharCode(c) + String.fromCharCode(d);
        return c = IEBinaryToArray_ByteStr(a), a = IEBinaryToArray_ByteStr_Last(a), c.replace(/[\s\S]/g, function(a) {
            return b[a]
        }) + a
    }
}
cc = cc || {}, cc._loadingImage = "", cc._fpsImage = "", cc._loaderImage = "";
var cc = cc || {}, ClassManager = {
        id: 0 | 998 * Math.random(),
        instanceId: 0 | 998 * Math.random(),
        compileSuper: function(a, b, c) {
            a = a.toString();
            var d = a.indexOf("("),
                e = a.indexOf(")"),
                d = a.substring(d + 1, e),
                d = d.trim(),
                e = a.indexOf("{"),
                f = a.lastIndexOf("}");
            for (a = a.substring(e + 1, f); - 1 != a.indexOf("this._super");) {
                var e = a.indexOf("this._super"),
                    f = a.indexOf("(", e),
                    g = a.indexOf(")", f),
                    g = a.substring(f + 1, g),
                    g = (g = g.trim()) ? "," : "";
                a = a.substring(0, e) + "ClassManager[" + c + "]." + b + ".call(this" + g + a.substring(f + 1)
            }
            return Function(d, a)
        },
        getNewID: function() {
            return this.id++
        },
        getNewInstanceId: function() {
            return this.instanceId++
        }
    };
switch (ClassManager.compileSuper.ClassManager = ClassManager, function() {
    var a = /\b_super\b/,
        b = cc.game.config[cc.game.CONFIG_KEY.classReleaseMode];
    b && console.log("release Mode"), cc.Class = function() {}, cc.Class.extend = function() {
        function c() {
            this.__instanceId = ClassManager.getNewInstanceId(), this.ctor && this.ctor.apply(this, arguments)
        }
        var d = this.prototype,
            e = Object.create(d),
            f = ClassManager.getNewID();
        ClassManager[f] = d;
        var g = {
            writable: !0,
            enumerable: !1,
            configurable: !0
        };
        e.__instanceId = null, c.id = f, g.value = f, Object.defineProperty(e, "__pid", g), c.prototype = e, g.value = c, Object.defineProperty(c.prototype, "constructor", g), this.__getters__ && (c.__getters__ = cc.clone(this.__getters__)), this.__setters__ && (c.__setters__ = cc.clone(this.__setters__));
        for (var h = 0, i = arguments.length; i > h; ++h) {
            var j, k = arguments[h];
            for (j in k) {
                var l = "function" == typeof k[j],
                    m = "function" == typeof d[j],
                    n = a.test(k[j]);
                if (b && l && m && n ? (g.value = ClassManager.compileSuper(k[j], j, f), Object.defineProperty(e, j, g)) : l && m && n ? (g.value = function(a, b) {
                    return function() {
                        var c = this._super;
                        this._super = d[a];
                        var e = b.apply(this, arguments);
                        return this._super = c, e
                    }
                }(j, k[j]), Object.defineProperty(e, j, g)) : l ? (g.value = k[j], Object.defineProperty(e, j, g)) : e[j] = k[j], l) {
                    var o, p;
                    if (this.__getters__ && this.__getters__[j]) {
                        var q, l = this.__getters__[j];
                        for (q in this.__setters__)
                            if (this.__setters__[q] == l) {
                                p = q;
                                break
                            }
                        cc.defineGetterSetter(e, l, k[j], k[p] ? k[p] : e[p], j, p)
                    }
                    if (this.__setters__ && this.__setters__[j]) {
                        l = this.__setters__[j];
                        for (q in this.__getters__)
                            if (this.__getters__[q] == l) {
                                o = q;
                                break
                            }
                        cc.defineGetterSetter(e, l, k[o] ? k[o] : e[o], k[j], o, j)
                    }
                }
            }
        }
        return c.extend = cc.Class.extend, c.implement = function(a) {
            for (var b in a) e[b] = a[b]
        }, c
    }
}(), cc.defineGetterSetter = function(a, b, c, d, e, f) {
    if (a.__defineGetter__) c && a.__defineGetter__(b, c), d && a.__defineSetter__(b, d);
    else {
        if (!Object.defineProperty) throw Error("browser does not support getters");
        var g = {
            enumerable: !1,
            configurable: !0
        };
        c && (g.get = c), d && (g.set = d), Object.defineProperty(a, b, g)
    } if (!e && !f)
        for (var g = null != c, h = void 0 != d, i = Object.getOwnPropertyNames(a), j = 0; j < i.length; j++) {
            var k = i[j];
            if ((a.__lookupGetter__ ? !a.__lookupGetter__(k) : !Object.getOwnPropertyDescriptor(a, k)) && "function" == typeof a[k]) {
                var l = a[k];
                if (g && l === c && (e = k, !h || f)) break;
                if (h && l === d && (f = k, !g || e)) break
            }
        }
    a = a.constructor, e && (a.__getters__ || (a.__getters__ = {}), a.__getters__[e] = b), f && (a.__setters__ || (a.__setters__ = {}), a.__setters__[f] = b)
}, cc.clone = function(a) {
    var b, c = a.constructor ? new a.constructor : {};
    for (b in a) {
        var d = a[b];
        c[b] = "object" != typeof d || !d || d instanceof cc.Node || d instanceof HTMLElement ? d : cc.clone(d)
    }
    return c
}, cc = cc || {}, cc._tmp = cc._tmp || {}, cc.associateWithNative = function() {}, cc.KEY = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    insert: 45,
    Delete: 46,
    0: 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    num0: 96,
    num1: 97,
    num2: 98,
    num3: 99,
    num4: 100,
    num5: 101,
    num6: 102,
    num7: 103,
    num8: 104,
    num9: 105,
    "*": 106,
    "+": 107,
    "-": 109,
    numdel: 110,
    "/": 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    numlock: 144,
    scrolllock: 145,
    semicolon: 186,
    ",": 186,
    equal: 187,
    "=": 187,
    ";": 188,
    comma: 188,
    dash: 189,
    ".": 190,
    period: 190,
    forwardslash: 191,
    grave: 192,
    "[": 219,
    openbracket: 219,
    "]": 221,
    closebracket: 221,
    backslash: 220,
    quote: 222,
    space: 32
}, cc.FMT_JPG = 0, cc.FMT_PNG = 1, cc.FMT_TIFF = 2, cc.FMT_RAWDATA = 3, cc.FMT_WEBP = 4, cc.FMT_UNKNOWN = 5, cc.getImageFormatByData = function(a) {
    return 8 < a.length && 137 == a[0] && 80 == a[1] && 78 == a[2] && 71 == a[3] && 13 == a[4] && 10 == a[5] && 26 == a[6] && 10 == a[7] ? cc.FMT_PNG : 2 < a.length && (73 == a[0] && 73 == a[1] || 77 == a[0] && 77 == a[1] || 255 == a[0] && 216 == a[1]) ? cc.FMT_TIFF : cc.FMT_UNKNOWN
}, cc.inherits = function(a, b) {
    function c() {}
    c.prototype = b.prototype, a.superClass_ = b.prototype, a.prototype = new c, a.prototype.constructor = a
}, cc.base = function(a, b) {
    var c = arguments.callee.caller;
    if (c.superClass_) return ret = c.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
    for (var d = Array.prototype.slice.call(arguments, 2), e = !1, f = a.constructor; f; f = f.superClass_ && f.superClass_.constructor)
        if (f.prototype[b] === c) e = !0;
        else if (e) return f.prototype[b].apply(a, d);
    if (a[b] === c) return a.constructor.prototype[b].apply(a, d);
    throw Error("cc.base called from a method of one name to a method of a different name")
}, cc.Point = function(a, b) {
    this.x = a || 0, this.y = b || 0
}, cc.p = function(a, b) {
    return void 0 == a ? {
        x: 0,
        y: 0
    } : void 0 == b ? {
        x: a.x,
        y: a.y
    } : {
        x: a,
        y: b
    }
}, cc.pointEqualToPoint = function(a, b) {
    return a && b && a.x === b.x && a.y === b.y
}, cc.Size = function(a, b) {
    this.width = a || 0, this.height = b || 0
}, cc.size = function(a, b) {
    return void 0 === a ? {
        width: 0,
        height: 0
    } : void 0 === b ? {
        width: a.width,
        height: a.height
    } : {
        width: a,
        height: b
    }
}, cc.sizeEqualToSize = function(a, b) {
    return a && b && a.width == b.width && a.height == b.height
}, cc.Rect = function(a, b, c, d) {
    this.x = a || 0, this.y = b || 0, this.width = c || 0, this.height = d || 0
}, cc.rect = function(a, b, c, d) {
    return void 0 === a ? {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    } : void 0 === b ? {
        x: a.x,
        y: a.y,
        width: a.width,
        height: a.height
    } : {
        x: a,
        y: b,
        width: c,
        height: d
    }
}, cc.rectEqualToRect = function(a, b) {
    return a && b && a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height
}, cc._rectEqualToZero = function(a) {
    return a && 0 === a.x && 0 === a.y && 0 === a.width && 0 === a.height
}, cc.rectContainsRect = function(a, b) {
    return a && b ? !(a.x >= b.x || a.y >= b.y || a.x + a.width <= b.x + b.width || a.y + a.height <= b.y + b.height) : !1
}, cc.rectGetMaxX = function(a) {
    return a.x + a.width
}, cc.rectGetMidX = function(a) {
    return a.x + a.width / 2
}, cc.rectGetMinX = function(a) {
    return a.x
}, cc.rectGetMaxY = function(a) {
    return a.y + a.height
}, cc.rectGetMidY = function(a) {
    return a.y + a.height / 2
}, cc.rectGetMinY = function(a) {
    return a.y
}, cc.rectContainsPoint = function(a, b) {
    return b.x >= cc.rectGetMinX(a) && b.x <= cc.rectGetMaxX(a) && b.y >= cc.rectGetMinY(a) && b.y <= cc.rectGetMaxY(a)
}, cc.rectIntersectsRect = function(a, b) {
    var c = a.y + a.height,
        d = b.x + b.width,
        e = b.y + b.height;
    return !(a.x + a.width < b.x || d < a.x || c < b.y || e < a.y)
}, cc.rectOverlapsRect = function(a, b) {
    return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y)
}, cc.rectUnion = function(a, b) {
    var c = cc.rect(0, 0, 0, 0);
    return c.x = Math.min(a.x, b.x), c.y = Math.min(a.y, b.y), c.width = Math.max(a.x + a.width, b.x + b.width) - c.x, c.height = Math.max(a.y + a.height, b.y + b.height) - c.y, c
}, cc.rectIntersection = function(a, b) {
    var c = cc.rect(Math.max(cc.rectGetMinX(a), cc.rectGetMinX(b)), Math.max(cc.rectGetMinY(a), cc.rectGetMinY(b)), 0, 0);
    return c.width = Math.min(cc.rectGetMaxX(a), cc.rectGetMaxX(b)) - cc.rectGetMinX(c), c.height = Math.min(cc.rectGetMaxY(a), cc.rectGetMaxY(b)) - cc.rectGetMinY(c), c
}, cc.SAXParser = cc.Class.extend({
    _parser: null,
    _isSupportDOMParser: null,
    ctor: function() {
        window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser) : this._isSupportDOMParser = !1
    },
    parse: function(a) {
        return this._parseXML(a)
    },
    _parseXML: function(a) {
        var b;
        return this._isSupportDOMParser ? b = this._parser.parseFromString(a, "text/xml") : (b = new ActiveXObject("Microsoft.XMLDOM"), b.async = "false", b.loadXML(a)), b
    }
}), cc.PlistParser = cc.SAXParser.extend({
    parse: function(a) {
        if (a = this._parseXML(a).documentElement, "plist" != a.tagName) throw "Not a plist file!";
        for (var b = null, c = 0, d = a.childNodes.length; d > c && (b = a.childNodes[c], !(1 == b.nodeType)); c++);
        return this._parseNode(b)
    },
    _parseNode: function(a) {
        var b = null,
            c = a.tagName;
        if ("dict" == c) b = this._parseDict(a);
        else if ("array" == c) b = this._parseArray(a);
        else if ("string" == c)
            if (1 == a.childNodes.length) b = a.firstChild.nodeValue;
            else
                for (b = "", c = 0; c < a.childNodes.length; c++) b += a.childNodes[c].nodeValue;
            else "false" == c ? b = !1 : "true" == c ? b = !0 : "real" == c ? b = parseFloat(a.firstChild.nodeValue) : "integer" == c && (b = parseInt(a.firstChild.nodeValue, 10));
        return b
    },
    _parseArray: function(a) {
        for (var b = [], c = 0, d = a.childNodes.length; d > c; c++) {
            var e = a.childNodes[c];
            1 == e.nodeType && b.push(this._parseNode(e))
        }
        return b
    },
    _parseDict: function(a) {
        for (var b = {}, c = null, d = 0, e = a.childNodes.length; e > d; d++) {
            var f = a.childNodes[d];
            1 == f.nodeType && ("key" == f.tagName ? c = f.firstChild.nodeValue : b[c] = this._parseNode(f))
        }
        return b
    }
}), cc._txtLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadTxt(a, d)
    }
}, cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader), cc._jsonLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadJson(a, d)
    }
}, cc.loader.register(["json", "ExportJson"], cc._jsonLoader), cc._imgLoader = {
    load: function(a, b, c, d) {
        cc.loader.cache[b] = cc.loader.loadImg(a, function(a, c) {
            return a ? d(a) : (cc.textureCache.handleLoadedTexture(b), void d(null, c))
        })
    }
}, cc.loader.register("png jpg bmp jpeg gif ico".split(" "), cc._imgLoader), cc._serverImgLoader = {
    load: function(a, b, c, d) {
        cc.loader.cache[b] = cc.loader.loadImg(c.src, function(a, c) {
            return a ? d(a) : (cc.textureCache.handleLoadedTexture(b), void d(null, c))
        })
    }
}, cc.loader.register(["serverImg"], cc._serverImgLoader), cc._plistLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadTxt(a, function(a, b) {
            return a ? d(a) : void d(null, cc.plistParser.parse(b))
        })
    }
}, cc.loader.register(["plist"], cc._plistLoader), cc._fontLoader = {
    TYPE: {
        ".eot": "embedded-opentype",
        ".ttf": "truetype",
        ".woff": "woff",
        ".svg": "svg"
    },
    _loadFont: function(a, b, c) {
        var d = document,
            e = cc.path,
            f = this.TYPE,
            g = cc.newElement("style");
        g.type = "text/css", d.body.appendChild(g);
        var h = "@font-face { font-family:" + a + "; src:";
        if (b instanceof Array)
            for (var i = 0, j = b.length; j > i; i++) c = e.extname(b[i]).toLowerCase(), h += "url('" + b[i] + "') format('" + f[c] + "')", h += i == j - 1 ? ";" : ",";
        else h += "url('" + b + "') format('" + f[c] + "');";
        g.textContent += h + "};", b = cc.newElement("div"), c = b.style, c.fontFamily = a, b.innerHTML = ".", c.position = "absolute", c.left = "-100px", c.top = "-100px", d.body.appendChild(b)
    },
    load: function(a, b, c, d) {
        b = c.type, a = c.name, b = c.srcs, "string" == typeof c ? (b = cc.path.extname(c), a = cc.path.basename(c, b), this._loadFont(a, c, b)) : this._loadFont(a, b), d(null, !0)
    }
}, cc.loader.register(["font", "eot", "ttf", "woff", "svg"], cc._fontLoader), cc._binaryLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadBinary(a, d)
    }
}, window.CocosEngine = cc.ENGINE_VERSION = "Cocos2d-JS v3.0 RC3", cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0, cc.DIRECTOR_STATS_POSITION = cc.p(0, 0), cc.DIRECTOR_FPS_INTERVAL = .5, cc.COCOSNODE_RENDER_SUBPIXEL = 1, cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1, cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 0, cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0, cc.TEXTURE_ATLAS_USE_VAO = 0, cc.TEXTURE_NPOT_SUPPORT = 0, cc.RETINA_DISPLAY_SUPPORT = 1, cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd", cc.USE_LA88_LABELS = 1, cc.SPRITE_DEBUG_DRAW = 0, cc.SPRITEBATCHNODE_DEBUG_DRAW = 0, cc.LABELBMFONT_DEBUG_DRAW = 0, cc.LABELATLAS_DEBUG_DRAW = 0, cc.IS_RETINA_DISPLAY_SUPPORTED = 1, cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas", cc.ENABLE_STACKABLE_ACTIONS = 1, cc.ENABLE_GL_STATE_CACHE = 1, cc.$ = function(a) {
    var b = this == cc ? document : this;
    return (a = a instanceof HTMLElement ? a : b.querySelector(a)) && (a.find = a.find || cc.$, a.hasClass = a.hasClass || function(a) {
        return this.className.match(RegExp("(\\s|^)" + a + "(\\s|$)"))
    }, a.addClass = a.addClass || function(a) {
        return this.hasClass(a) || (this.className && (this.className += " "), this.className += a), this
    }, a.removeClass = a.removeClass || function(a) {
        return this.hasClass(a) && (this.className = this.className.replace(a, "")), this
    }, a.remove = a.remove || function() {
        return this.parentNode && this.parentNode.removeChild(this), this
    }, a.appendTo = a.appendTo || function(a) {
        return a.appendChild(this), this
    }, a.prependTo = a.prependTo || function(a) {
        return a.childNodes[0] ? a.insertBefore(this, a.childNodes[0]) : a.appendChild(this), this
    }, a.transforms = a.transforms || function() {
        return this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew), this
    }, a.position = a.position || {
        x: 0,
        y: 0
    }, a.rotation = a.rotation || 0, a.scale = a.scale || {
        x: 1,
        y: 1
    }, a.skew = a.skew || {
        x: 0,
        y: 0
    }, a.translates = function(a, b) {
        return this.position.x = a, this.position.y = b, this.transforms(), this
    }, a.rotate = function(a) {
        return this.rotation = a, this.transforms(), this
    }, a.resize = function(a, b) {
        return this.scale.x = a, this.scale.y = b, this.transforms(), this
    }, a.setSkew = function(a, b) {
        return this.skew.x = a, this.skew.y = b, this.transforms(), this
    }), a
}, cc.sys.browserType) {
    case cc.sys.BROWSER_TYPE_FIREFOX:
        cc.$.pfx = "Moz", cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.$.pfx = "webkit", cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_OPERA:
        cc.$.pfx = "O", cc.$.hd = !1;
        break;
    case cc.sys.BROWSER_TYPE_IE:
        cc.$.pfx = "ms", cc.$.hd = !1;
        break;
    default:
        cc.$.pfx = "webkit", cc.$.hd = !0
}
cc.$.trans = cc.$.pfx + "Transform", cc.$.translate = cc.$.hd ? function(a) {
    return "translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function(a) {
    return "translate(" + a.x + "px, " + a.y + "px) "
}, cc.$.rotate = cc.$.hd ? function(a) {
    return "rotateZ(" + a + "deg) "
} : function(a) {
    return "rotate(" + a + "deg) "
}, cc.$.scale = function(a) {
    return "scale(" + a.x + ", " + a.y + ") "
}, cc.$.skew = function(a) {
    return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)"
}, cc.$new = function(a) {
    return cc.$(document.createElement(a))
}, cc.$.findpos = function(a) {
    var b = 0,
        c = 0;
    do b += a.offsetLeft, c += a.offsetTop; while (a = a.offsetParent);
    return {
        x: b,
        y: c
    }
}, cc.INVALID_INDEX = -1, cc.PI = Math.PI, cc.FLT_MAX = parseFloat("3.402823466e+38F"), cc.FLT_MIN = parseFloat("1.175494351e-38F"), cc.RAD = cc.PI / 180, cc.DEG = 180 / cc.PI, cc.UINT_MAX = 4294967295, cc.swap = function(a, b, c) {
    if ("object" == typeof c && "undefined" != typeof c.x && "undefined" != typeof c.y) {
        var d = c[a];
        c[a] = c[b], c[b] = d
    } else cc.log(cc._LogInfos.swap)
}, cc.lerp = function(a, b, c) {
    return a + (b - a) * c
}, cc.rand = function() {
    return 16777215 * Math.random()
}, cc.randomMinus1To1 = function() {
    return 2 * (Math.random() - .5)
}, cc.random0To1 = Math.random, cc.degreesToRadians = function(a) {
    return a * cc.RAD
}, cc.radiansToDegrees = function(a) {
    return a * cc.DEG
}, cc.radiansToDegress = function(a) {
    return cc.log(cc._LogInfos.radiansToDegress), a * cc.DEG
}, cc.REPEAT_FOREVER = Number.MAX_VALUE - 1, cc.BLEND_SRC = cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? 1 : 770, cc.BLEND_DST = 771, cc.nodeDrawSetup = function(a) {
    a._shaderProgram && (a._shaderProgram.use(), a._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4())
}, cc.enableDefaultGLStates = function() {}, cc.disableDefaultGLStates = function() {}, cc.incrementGLDraws = function(a) {
    cc.g_NumberOfDraws += a
}, cc.FLT_EPSILON = 1.192092896e-7, cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function() {
    return cc.director.getContentScaleFactor()
} : function() {
    return 1
}, cc.pointPointsToPixels = function(a) {
    var b = cc.contentScaleFactor();
    return cc.p(a.x * b, a.y * b)
}, cc.pointPixelsToPoints = function(a) {
    var b = cc.contentScaleFactor();
    return cc.p(a.x / b, a.y / b)
}, cc._pointPixelsToPointsOut = function(a, b) {
    var c = cc.contentScaleFactor();
    b.x = a.x / c, b.y = a.y / c
}, cc.sizePointsToPixels = function(a) {
    var b = cc.contentScaleFactor();
    return cc.size(a.width * b, a.height * b)
}, cc.sizePixelsToPoints = function(a) {
    var b = cc.contentScaleFactor();
    return cc.size(a.width / b, a.height / b)
}, cc._sizePixelsToPointsOut = function(a, b) {
    var c = cc.contentScaleFactor();
    b.width = a.width / c, b.height = a.height / c
}, cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(a) {
    var b = cc.contentScaleFactor();
    return cc.rect(a.x / b, a.y / b, a.width / b, a.height / b)
} : function(a) {
    return a
}, cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(a) {
    var b = cc.contentScaleFactor();
    return cc.rect(a.x * b, a.y * b, a.width * b, a.height * b)
} : function(a) {
    return a
}, cc.ONE = 1, cc.ZERO = 0, cc.SRC_ALPHA = 770, cc.SRC_ALPHA_SATURATE = 776, cc.SRC_COLOR = 768, cc.DST_ALPHA = 772, cc.DST_COLOR = 774, cc.ONE_MINUS_SRC_ALPHA = 771, cc.ONE_MINUS_SRC_COLOR = 769, cc.ONE_MINUS_DST_ALPHA = 773, cc.ONE_MINUS_DST_COLOR = 775, cc.ONE_MINUS_CONSTANT_ALPHA = 32772, cc.ONE_MINUS_CONSTANT_COLOR = 32770, cc.checkGLErrorDebug = function() {
    if (cc.renderMode == cc._RENDER_TYPE_WEBGL) {
        var a = cc._renderContext.getError();
        a && cc.log(cc._LogInfos.checkGLErrorDebug, a)
    }
}, cc.DEVICE_ORIENTATION_PORTRAIT = 0, cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1, cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2, cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3, cc.DEVICE_MAX_ORIENTATIONS = 2, cc.VERTEX_ATTRIB_FLAG_NONE = 0, cc.VERTEX_ATTRIB_FLAG_POSITION = 1, cc.VERTEX_ATTRIB_FLAG_COLOR = 2, cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4, cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS, cc.GL_ALL = 0, cc.VERTEX_ATTRIB_POSITION = 0, cc.VERTEX_ATTRIB_COLOR = 1, cc.VERTEX_ATTRIB_TEX_COORDS = 2, cc.VERTEX_ATTRIB_MAX = 3, cc.UNIFORM_PMATRIX = 0, cc.UNIFORM_MVMATRIX = 1, cc.UNIFORM_MVPMATRIX = 2, cc.UNIFORM_TIME = 3, cc.UNIFORM_SINTIME = 4, cc.UNIFORM_COSTIME = 5, cc.UNIFORM_RANDOM01 = 6, cc.UNIFORM_SAMPLER = 7, cc.UNIFORM_MAX = 8, cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor", cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest", cc.SHADER_POSITION_COLOR = "ShaderPositionColor", cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture", cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor", cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color", cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor", cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor", cc.UNIFORM_PMATRIX_S = "CC_PMatrix", cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix", cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix", cc.UNIFORM_TIME_S = "CC_Time", cc.UNIFORM_SINTIME_S = "CC_SinTime", cc.UNIFORM_COSTIME_S = "CC_CosTime", cc.UNIFORM_RANDOM01_S = "CC_Random01", cc.UNIFORM_SAMPLER_S = "CC_Texture0", cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value", cc.ATTRIBUTE_NAME_COLOR = "a_color", cc.ATTRIBUTE_NAME_POSITION = "a_position", cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord", cc.ITEM_SIZE = 32, cc.CURRENT_ITEM = 3233828865, cc.ZOOM_ACTION_TAG = 3233828866, cc.NORMAL_TAG = 8801, cc.SELECTED_TAG = 8802, cc.DISABLE_TAG = 8803, cc.arrayVerifyType = function(a, b) {
    if (a && 0 < a.length)
        for (var c = 0; c < a.length; c++)
            if (!(a[c] instanceof b)) return cc.log("element type is wrong!"), !1;
    return !0
}, cc.arrayRemoveObject = function(a, b) {
    for (var c = 0, d = a.length; d > c; c++)
        if (a[c] == b) {
            a.splice(c, 1);
            break
        }
}, cc.arrayRemoveArray = function(a, b) {
    for (var c = 0, d = b.length; d > c; c++) cc.arrayRemoveObject(a, b[c])
}, cc.arrayAppendObjectsToIndex = function(a, b, c) {
    return a.splice.apply(a, [c, 0].concat(b)), a
}, cc.copyArray = function(a) {
    var b, c = a.length,
        d = Array(c);
    for (b = 0; c > b; b += 1) d[b] = a[b];
    return d
}, cc = cc || {}, cc._tmp = cc._tmp || {}, cc._tmp.WebGLColor = function() {
    cc.color = function(a, b, c, d, e, f) {
        return void 0 === a ? new cc.Color(0, 0, 0, 255, e, f) : "string" == typeof a ? (a = cc.hexToColor(a), new cc.Color(a.r, a.g, a.b, a.a)) : "object" == typeof a ? new cc.Color(a.r, a.g, a.b, a.a, a.arrayBuffer, a.offset) : new cc.Color(a, b, c, d, e, f)
    }, cc.Color = function(a, b, c, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT), this._offset = f || 0, e = this._arrayBuffer, f = this._offset;
        var g = Uint8Array.BYTES_PER_ELEMENT;
        this._rU8 = new Uint8Array(e, f, 1), this._gU8 = new Uint8Array(e, f + g, 1), this._bU8 = new Uint8Array(e, f + 2 * g, 1), this._aU8 = new Uint8Array(e, f + 3 * g, 1), this._rU8[0] = a || 0, this._gU8[0] = b || 0, this._bU8[0] = c || 0, this._aU8[0] = null == d ? 255 : d, void 0 === d && (this.a_undefined = !0)
    }, cc.Color.BYTES_PER_ELEMENT = 4;
    var a = cc.Color.prototype;
    a._getR = function() {
        return this._rU8[0]
    }, a._setR = function(a) {
        this._rU8[0] = 0 > a ? 0 : a
    }, a._getG = function() {
        return this._gU8[0]
    }, a._setG = function(a) {
        this._gU8[0] = 0 > a ? 0 : a
    }, a._getB = function() {
        return this._bU8[0]
    }, a._setB = function(a) {
        this._bU8[0] = 0 > a ? 0 : a
    }, a._getA = function() {
        return this._aU8[0]
    }, a._setA = function(a) {
        this._aU8[0] = 0 > a ? 0 : a
    }, cc.defineGetterSetter(a, "r", a._getR, a._setR), cc.defineGetterSetter(a, "g", a._getG, a._setG), cc.defineGetterSetter(a, "b", a._getB, a._setB), cc.defineGetterSetter(a, "a", a._getA, a._setA), cc.Vertex2F = function(a, b, c, d) {
        this._arrayBuffer = c || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT), this._offset = d || 0, this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1), this._yF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1), this._xF32[0] = a || 0, this._yF32[0] = b || 0
    }, cc.Vertex2F.BYTES_PER_ELEMENT = 8, Object.defineProperties(cc.Vertex2F.prototype, {
        x: {
            get: function() {
                return this._xF32[0]
            },
            set: function(a) {
                this._xF32[0] = a
            },
            enumerable: !0
        },
        y: {
            get: function() {
                return this._yF32[0]
            },
            set: function(a) {
                this._yF32[0] = a
            },
            enumerable: !0
        }
    }), cc.Vertex3F = function(a, b, c, d, e) {
        this._arrayBuffer = d || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT), this._offset = e || 0, d = this._arrayBuffer, e = this._offset, this._xF32 = new Float32Array(d, e, 1), this._xF32[0] = a || 0, this._yF32 = new Float32Array(d, e + Float32Array.BYTES_PER_ELEMENT, 1), this._yF32[0] = b || 0, this._zF32 = new Float32Array(d, e + 2 * Float32Array.BYTES_PER_ELEMENT, 1), this._zF32[0] = c || 0
    }, cc.Vertex3F.BYTES_PER_ELEMENT = 12, Object.defineProperties(cc.Vertex3F.prototype, {
        x: {
            get: function() {
                return this._xF32[0]
            },
            set: function(a) {
                this._xF32[0] = a
            },
            enumerable: !0
        },
        y: {
            get: function() {
                return this._yF32[0]
            },
            set: function(a) {
                this._yF32[0] = a
            },
            enumerable: !0
        },
        z: {
            get: function() {
                return this._zF32[0]
            },
            set: function(a) {
                this._zF32[0] = a
            },
            enumerable: !0
        }
    }), cc.Tex2F = function(a, b, c, d) {
        this._arrayBuffer = c || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT), this._offset = d || 0, this._uF32 = new Float32Array(this._arrayBuffer, this._offset, 1), this._vF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1), this._uF32[0] = a || 0, this._vF32[0] = b || 0
    }, cc.Tex2F.BYTES_PER_ELEMENT = 8, Object.defineProperties(cc.Tex2F.prototype, {
        u: {
            get: function() {
                return this._uF32[0]
            },
            set: function(a) {
                this._uF32[0] = a
            },
            enumerable: !0
        },
        v: {
            get: function() {
                return this._vF32[0]
            },
            set: function(a) {
                this._vF32[0] = a
            },
            enumerable: !0
        }
    }), cc.Quad2 = function(a, b, c, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT), this._offset = f || 0, e = this._arrayBuffer, f = cc.Vertex2F.BYTES_PER_ELEMENT, this._tl = a ? new cc.Vertex2F(a.x, a.y, e, 0) : new cc.Vertex2F(0, 0, e, 0), this._tr = b ? new cc.Vertex2F(b.x, b.y, e, f) : new cc.Vertex2F(0, 0, e, f), this._bl = c ? new cc.Vertex2F(c.x, c.y, e, 2 * f) : new cc.Vertex2F(0, 0, e, 2 * f), this._br = d ? new cc.Vertex2F(d.x, d.y, e, 3 * f) : new cc.Vertex2F(0, 0, e, 3 * f)
    }, cc.Quad2.BYTES_PER_ELEMENT = 32, cc.Quad3 = function(a, b, c, d) {
        this.bl = a || new cc.Vertex3F(0, 0, 0), this.br = b || new cc.Vertex3F(0, 0, 0), this.tl = c || new cc.Vertex3F(0, 0, 0), this.tr = d || new cc.Vertex3F(0, 0, 0)
    }, Object.defineProperties(cc.Quad2.prototype, {
        tl: {
            get: function() {
                return this._tl
            },
            set: function(a) {
                this._tl.x = a.x, this._tl.y = a.y
            },
            enumerable: !0
        },
        tr: {
            get: function() {
                return this._tr
            },
            set: function(a) {
                this._tr.x = a.x, this._tr.y = a.y
            },
            enumerable: !0
        },
        bl: {
            get: function() {
                return this._bl
            },
            set: function(a) {
                this._bl.x = a.x, this._bl.y = a.y
            },
            enumerable: !0
        },
        br: {
            get: function() {
                return this._br
            },
            set: function(a) {
                this._br.x = a.x, this._br.y = a.y
            },
            enumerable: !0
        }
    }), cc.V3F_C4B_T2F = function(a, b, c, d, e) {
        this._arrayBuffer = d || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT), this._offset = e || 0, d = this._arrayBuffer, e = this._offset;
        var f = cc.Vertex3F.BYTES_PER_ELEMENT;
        this._vertices = a ? new cc.Vertex3F(a.x, a.y, a.z, d, e) : new cc.Vertex3F(0, 0, 0, d, e), this._colors = b ? cc.color(b.r, b.g, b.b, b.a, d, e + f) : cc.color(0, 0, 0, 0, d, e + f), this._texCoords = c ? new cc.Tex2F(c.u, c.v, d, e + f + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, d, e + f + cc.Color.BYTES_PER_ELEMENT)
    }, cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24, Object.defineProperties(cc.V3F_C4B_T2F.prototype, {
        vertices: {
            get: function() {
                return this._vertices
            },
            set: function(a) {
                var b = this._vertices;
                b.x = a.x, b.y = a.y, b.z = a.z
            },
            enumerable: !0
        },
        colors: {
            get: function() {
                return this._colors
            },
            set: function(a) {
                var b = this._colors;
                b.r = a.r, b.g = a.g, b.b = a.b, b.a = a.a
            },
            enumerable: !0
        },
        texCoords: {
            get: function() {
                return this._texCoords
            },
            set: function(a) {
                this._texCoords.u = a.u, this._texCoords.v = a.v
            },
            enumerable: !0
        }
    }), cc.V3F_C4B_T2F_Quad = function(a, b, c, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT), this._offset = f || 0, e = this._arrayBuffer, f = this._offset;
        var g = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
        this._tl = a ? new cc.V3F_C4B_T2F(a.vertices, a.colors, a.texCoords, e, f) : new cc.V3F_C4B_T2F(null, null, null, e, f), this._bl = b ? new cc.V3F_C4B_T2F(b.vertices, b.colors, b.texCoords, e, f + g) : new cc.V3F_C4B_T2F(null, null, null, e, f + g), this._tr = c ? new cc.V3F_C4B_T2F(c.vertices, c.colors, c.texCoords, e, f + 2 * g) : new cc.V3F_C4B_T2F(null, null, null, e, f + 2 * g), this._br = d ? new cc.V3F_C4B_T2F(d.vertices, d.colors, d.texCoords, e, f + 3 * g) : new cc.V3F_C4B_T2F(null, null, null, e, f + 3 * g)
    }, cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96, Object.defineProperties(cc.V3F_C4B_T2F_Quad.prototype, {
        tl: {
            get: function() {
                return this._tl
            },
            set: function(a) {
                var b = this._tl;
                b.vertices = a.vertices, b.colors = a.colors, b.texCoords = a.texCoords
            },
            enumerable: !0
        },
        bl: {
            get: function() {
                return this._bl
            },
            set: function(a) {
                var b = this._bl;
                b.vertices = a.vertices, b.colors = a.colors, b.texCoords = a.texCoords
            },
            enumerable: !0
        },
        tr: {
            get: function() {
                return this._tr
            },
            set: function(a) {
                var b = this._tr;
                b.vertices = a.vertices, b.colors = a.colors, b.texCoords = a.texCoords
            },
            enumerable: !0
        },
        br: {
            get: function() {
                return this._br
            },
            set: function(a) {
                var b = this._br;
                b.vertices = a.vertices, b.colors = a.colors, b.texCoords = a.texCoords
            },
            enumerable: !0
        },
        arrayBuffer: {
            get: function() {
                return this._arrayBuffer
            },
            enumerable: !0
        }
    }), cc.V3F_C4B_T2F_QuadZero = function() {
        return new cc.V3F_C4B_T2F_Quad
    }, cc.V3F_C4B_T2F_QuadCopy = function(a) {
        if (!a) return cc.V3F_C4B_T2F_QuadZero();
        var b = a.tl,
            c = a.bl,
            d = a.tr;
        return a = a.br, {
            tl: {
                vertices: {
                    x: b.vertices.x,
                    y: b.vertices.y,
                    z: b.vertices.z
                },
                colors: {
                    r: b.colors.r,
                    g: b.colors.g,
                    b: b.colors.b,
                    a: b.colors.a
                },
                texCoords: {
                    u: b.texCoords.u,
                    v: b.texCoords.v
                }
            },
            bl: {
                vertices: {
                    x: c.vertices.x,
                    y: c.vertices.y,
                    z: c.vertices.z
                },
                colors: {
                    r: c.colors.r,
                    g: c.colors.g,
                    b: c.colors.b,
                    a: c.colors.a
                },
                texCoords: {
                    u: c.texCoords.u,
                    v: c.texCoords.v
                }
            },
            tr: {
                vertices: {
                    x: d.vertices.x,
                    y: d.vertices.y,
                    z: d.vertices.z
                },
                colors: {
                    r: d.colors.r,
                    g: d.colors.g,
                    b: d.colors.b,
                    a: d.colors.a
                },
                texCoords: {
                    u: d.texCoords.u,
                    v: d.texCoords.v
                }
            },
            br: {
                vertices: {
                    x: a.vertices.x,
                    y: a.vertices.y,
                    z: a.vertices.z
                },
                colors: {
                    r: a.colors.r,
                    g: a.colors.g,
                    b: a.colors.b,
                    a: a.colors.a
                },
                texCoords: {
                    u: a.texCoords.u,
                    v: a.texCoords.v
                }
            }
        }
    }, cc.V3F_C4B_T2F_QuadsCopy = function(a) {
        if (!a) return [];
        for (var b = [], c = 0; c < a.length; c++) b.push(cc.V3F_C4B_T2F_QuadCopy(a[c]));
        return b
    }, cc.V2F_C4B_T2F = function(a, b, c, d, e) {
        this._arrayBuffer = d || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT), this._offset = e || 0, d = this._arrayBuffer, e = this._offset;
        var f = cc.Vertex2F.BYTES_PER_ELEMENT;
        this._vertices = a ? new cc.Vertex2F(a.x, a.y, d, e) : new cc.Vertex2F(0, 0, d, e), this._colors = b ? cc.color(b.r, b.g, b.b, b.a, d, e + f) : cc.color(0, 0, 0, 0, d, e + f), this._texCoords = c ? new cc.Tex2F(c.u, c.v, d, e + f + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, d, e + f + cc.Color.BYTES_PER_ELEMENT)
    }, cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20, Object.defineProperties(cc.V2F_C4B_T2F.prototype, {
        vertices: {
            get: function() {
                return this._vertices
            },
            set: function(a) {
                this._vertices.x = a.x, this._vertices.y = a.y
            },
            enumerable: !0
        },
        colors: {
            get: function() {
                return this._colors
            },
            set: function(a) {
                var b = this._colors;
                b.r = a.r, b.g = a.g, b.b = a.b, b.a = a.a
            },
            enumerable: !0
        },
        texCoords: {
            get: function() {
                return this._texCoords
            },
            set: function(a) {
                this._texCoords.u = a.u, this._texCoords.v = a.v
            },
            enumerable: !0
        }
    }), cc.V2F_C4B_T2F_Triangle = function(a, b, c, d, e) {
        this._arrayBuffer = d || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT), this._offset = e || 0, d = this._arrayBuffer, e = this._offset;
        var f = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
        this._a = a ? new cc.V2F_C4B_T2F(a.vertices, a.colors, a.texCoords, d, e) : new cc.V2F_C4B_T2F(null, null, null, d, e), this._b = b ? new cc.V2F_C4B_T2F(b.vertices, b.colors, b.texCoords, d, e + f) : new cc.V2F_C4B_T2F(null, null, null, d, e + f), this._c = c ? new cc.V2F_C4B_T2F(c.vertices, c.colors, c.texCoords, d, e + 2 * f) : new cc.V2F_C4B_T2F(null, null, null, d, e + 2 * f)
    }, cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60, Object.defineProperties(cc.V2F_C4B_T2F_Triangle.prototype, {
        a: {
            get: function() {
                return this._a
            },
            set: function(a) {
                var b = this._a;
                b.vertices = a.vertices, b.colors = a.colors, b.texCoords = a.texCoords
            },
            enumerable: !0
        },
        b: {
            get: function() {
                return this._b
            },
            set: function(a) {
                var b = this._b;
                b.vertices = a.vertices, b.colors = a.colors, b.texCoords = a.texCoords
            },
            enumerable: !0
        },
        c: {
            get: function() {
                return this._c
            },
            set: function(a) {
                var b = this._c;
                b.vertices = a.vertices, b.colors = a.colors, b.texCoords = a.texCoords
            },
            enumerable: !0

        }
    })
}, cc._tmp.PrototypeColor = function() {
    var a = cc.color;
    a._getWhite = function() {
        return a(255, 255, 255)
    }, a._getYellow = function() {
        return a(255, 255, 0)
    }, a._getBlue = function() {
        return a(0, 0, 255)
    }, a._getGreen = function() {
        return a(0, 255, 0)
    }, a._getRed = function() {
        return a(255, 0, 0)
    }, a._getMagenta = function() {
        return a(255, 0, 255)
    }, a._getBlack = function() {
        return a(0, 0, 0)
    }, a._getOrange = function() {
        return a(255, 127, 0)
    }, a._getGray = function() {
        return a(166, 166, 166)
    }, cc.defineGetterSetter(a, "WHITE", a._getWhite), cc.defineGetterSetter(a, "YELLOW", a._getYellow), cc.defineGetterSetter(a, "BLUE", a._getBlue), cc.defineGetterSetter(a, "GREEN", a._getGreen), cc.defineGetterSetter(a, "RED", a._getRed), cc.defineGetterSetter(a, "MAGENTA", a._getMagenta), cc.defineGetterSetter(a, "BLACK", a._getBlack), cc.defineGetterSetter(a, "ORANGE", a._getOrange), cc.defineGetterSetter(a, "GRAY", a._getGray), cc.BlendFunc._disable = function() {
        return new cc.BlendFunc(cc.ONE, cc.ZERO)
    }, cc.BlendFunc._alphaPremultiplied = function() {
        return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA)
    }, cc.BlendFunc._alphaNonPremultiplied = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA)
    }, cc.BlendFunc._additive = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE)
    }, cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable), cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied), cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied), cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive)
}, cc.Color = function(a, b, c, d) {
    this.r = a || 0, this.g = b || 0, this.b = c || 0, this.a = null == d ? 255 : d
}, cc.color = function(a, b, c) {
    return void 0 === a ? {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    } : "string" == typeof a ? cc.hexToColor(a) : "object" == typeof a ? {
        r: a.r,
        g: a.g,
        b: a.b,
        a: null == a.a ? 255 : a.a
    } : {
        r: a,
        g: b,
        b: c,
        a: null == a.a ? 255 : a.a
    }
}, cc.colorEqual = function(a, b) {
    return a.r === b.r && a.g === b.g && a.b === b.b
}, cc.Acceleration = function(a, b, c, d) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0, this.timestamp = d || 0
}, cc.Vertex2F = function(a, b) {
    this.x = a || 0, this.y = b || 0
}, cc.vertex2 = function(a, b) {
    return new cc.Vertex2F(a, b)
}, cc.Vertex3F = function(a, b, c) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0
}, cc.vertex3 = function(a, b, c) {
    return new cc.Vertex3F(a, b, c)
}, cc.Tex2F = function(a, b) {
    this.u = a || 0, this.v = b || 0
}, cc.tex2 = function(a, b) {
    return new cc.Tex2F(a, b)
}, cc.BlendFunc = function(a, b) {
    this.src = a, this.dst = b
}, cc.blendFuncDisable = function() {
    return new cc.BlendFunc(cc.ONE, cc.ZERO)
}, cc.hexToColor = function(a) {
    return a = a.replace(/^#?/, "0x"), a = parseInt(a), cc.color(a >> 16, (a >> 8) % 256, a % 256)
}, cc.colorToHex = function(a) {
    var b = a.r.toString(16),
        c = a.g.toString(16),
        d = a.b.toString(16);
    return "#" + (16 > a.r ? "0" + b : b) + (16 > a.g ? "0" + c : c) + (16 > a.b ? "0" + d : d)
}, cc.TEXT_ALIGNMENT_LEFT = 0, cc.TEXT_ALIGNMENT_CENTER = 1, cc.TEXT_ALIGNMENT_RIGHT = 2, cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0, cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2, cc._Dictionary = cc.Class.extend({
    _keyMapTb: null,
    _valueMapTb: null,
    __currId: 0,
    ctor: function() {
        this._keyMapTb = {}, this._valueMapTb = {}, this.__currId = 2 << (0 | 10 * Math.random())
    },
    __getKey: function() {
        return this.__currId++, "key_" + this.__currId
    },
    setObject: function(a, b) {
        if (null != b) {
            var c = this.__getKey();
            this._keyMapTb[c] = b, this._valueMapTb[c] = a
        }
    },
    objectForKey: function(a) {
        if (null == a) return null;
        var b, c = this._keyMapTb;
        for (b in c)
            if (c[b] === a) return this._valueMapTb[b];
        return null
    },
    valueForKey: function(a) {
        return this.objectForKey(a)
    },
    removeObjectForKey: function(a) {
        if (null != a) {
            var b, c = this._keyMapTb;
            for (b in c)
                if (c[b] === a) {
                    delete this._valueMapTb[b], delete c[b];
                    break
                }
        }
    },
    removeObjectsForKeys: function(a) {
        if (null != a)
            for (var b = 0; b < a.length; b++) this.removeObjectForKey(a[b])
    },
    allKeys: function() {
        var a, b = [],
            c = this._keyMapTb;
        for (a in c) b.push(c[a]);
        return b
    },
    removeAllObjects: function() {
        this._keyMapTb = {}, this._valueMapTb = {}
    },
    count: function() {
        return this.allKeys().length
    }
}), cc.FontDefinition = function() {
    this.fontName = "Arial", this.fontSize = 12, this.textAlign = cc.TEXT_ALIGNMENT_CENTER, this.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP, this.fillStyle = cc.color(255, 255, 255, 255), this.boundingHeight = this.boundingWidth = 0, this.strokeEnabled = !1, this.strokeStyle = cc.color(255, 255, 255, 255), this.lineWidth = 1, this.shadowEnabled = !1, this.shadowBlur = this.shadowOffsetY = this.shadowOffsetX = 0, this.shadowOpacity = 1
}, cc.assert("function" == typeof cc._tmp.WebGLColor, cc._LogInfos.MissingFile, "CCTypesWebGL.js"), cc._tmp.WebGLColor(), delete cc._tmp.WebGLColor, cc.assert("function" == typeof cc._tmp.PrototypeColor, cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js"), cc._tmp.PrototypeColor(), delete cc._tmp.PrototypeColor, cc.Touches = [], cc.TouchesIntergerDict = {}, cc.EGLView = cc.Class.extend({
    _delegate: null,
    _frameSize: null,
    _designResolutionSize: null,
    _originalDesignResolutionSize: null,
    _viewPortRect: null,
    _visibleRect: null,
    _retinaEnabled: !1,
    _autoFullScreen: !0,
    _devicePixelRatio: 1,
    _viewName: "",
    _resizeCallback: null,
    _scaleX: 1,
    _originalScaleX: 1,
    _scaleY: 1,
    _originalScaleY: 1,
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _resolutionPolicy: null,
    _rpExactFit: null,
    _rpShowAll: null,
    _rpNoBorder: null,
    _rpFixedHeight: null,
    _rpFixedWidth: null,
    _initialized: !1,
    _captured: !1,
    _wnd: null,
    _hDC: null,
    _hRC: null,
    _supportTouch: !1,
    _contentTranslateLeftTop: null,
    _frame: null,
    _frameZoomFactor: 1,
    __resizeWithBrowserSize: !1,
    _isAdjustViewPort: !0,
    ctor: function() {
        var a = document,
            b = cc.ContainerStrategy,
            c = cc.ContentStrategy;
        this._frame = cc.container.parentNode === a.body ? a.documentElement : cc.container.parentNode, this._frameSize = cc.size(0, 0), this._initFrameSize();
        var a = cc._canvas.width,
            d = cc._canvas.height;
        this._designResolutionSize = cc.size(a, d), this._originalDesignResolutionSize = cc.size(a, d), this._viewPortRect = cc.rect(0, 0, a, d), this._visibleRect = cc.rect(0, 0, a, d), this._contentTranslateLeftTop = {
            left: 0,
            top: 0
        }, this._viewName = "Cocos2dHTML5", a = cc.sys, this.enableRetina(a.os == a.OS_IOS || a.os == a.OS_OSX), cc.visibleRect && cc.visibleRect.init(this._visibleRect), this._rpExactFit = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.EXACT_FIT), this._rpShowAll = new cc.ResolutionPolicy(b.PROPORTION_TO_FRAME, c.SHOW_ALL), this._rpNoBorder = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.NO_BORDER), this._rpFixedHeight = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.FIXED_HEIGHT), this._rpFixedWidth = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.FIXED_WIDTH), this._hDC = cc._canvas, this._hRC = cc._renderContext
    },
    _resizeEvent: function() {
        var a = this._originalDesignResolutionSize.width,
            b = this._originalDesignResolutionSize.height;
        this._resizeCallback && (this._initFrameSize(), this._resizeCallback.call()), a > 0 && this.setDesignResolutionSize(a, b, this._resolutionPolicy)
    },
    resizeWithBrowserSize: function(a) {
        a ? this.__resizeWithBrowserSize || (this.__resizeWithBrowserSize = !0, a = this._resizeEvent.bind(this), cc._addEventListener(window, "resize", a, !1)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !0, a = this._resizeEvent.bind(this), window.removeEventListener("resize", a, !1))
    },
    setResizeCallback: function(a) {
        ("function" == typeof a || null == a) && (this._resizeCallback = a)
    },
    _initFrameSize: function() {
        var a = this._frameSize;
        a.width = this._frame.clientWidth, a.height = this._frame.clientHeight
    },
    _adjustSizeKeepCanvasSize: function() {
        var a = this._originalDesignResolutionSize.width,
            b = this._originalDesignResolutionSize.height;
        a > 0 && this.setDesignResolutionSize(a, b, this._resolutionPolicy)
    },
    _setViewPortMeta: function() {
        if (this._isAdjustViewPort) {
            var a, b = {
                    "user-scalable": "no",
                    "maximum-scale": "1.0",
                    "initial-scale": "1.0"
                }, c = document.getElementsByName("viewport");
            if (0 == c.length ? (c = cc.newElement("meta"), c.name = "viewport", c.content = "", document.head.appendChild(c)) : c = c[0], cc.sys.isMobile && cc.sys.browserType == cc.sys.BROWSER_TYPE_FIREFOX) c.content = "initial-scale:1";
            else {
                a = c.content;
                for (var d in b) RegExp(d).test(a) || (a += ("" == a ? "" : ",") + d + "=" + b[d]);
                c.content = a
            }
        }
    },
    _setScaleXYForRenderTexture: function() {
        var a = cc.contentScaleFactor();
        this._scaleY = this._scaleX = a
    },
    _resetScale: function() {
        this._scaleX = this._originalScaleX, this._scaleY = this._originalScaleY
    },
    _adjustSizeToBrowser: function() {},
    initialize: function() {
        this._initialized = !0
    },
    adjustViewPort: function(a) {
        this._isAdjustViewPort = a
    },
    enableRetina: function(a) {
        this._retinaEnabled = a ? !0 : !1
    },
    isRetinaEnabled: function() {
        return this._retinaEnabled
    },
    enableAutoFullScreen: function(a) {
        this._autoFullScreen = a ? !0 : !1
    },
    isAutoFullScreenEnabled: function() {
        return this._autoFullScreen
    },
    end: function() {},
    isOpenGLReady: function() {
        return null != this._hDC && null != this._hRC
    },
    setFrameZoomFactor: function(a) {
        this._frameZoomFactor = a, this.centerWindow(), cc.director.setProjection(cc.director.getProjection())
    },
    swapBuffers: function() {},
    setIMEKeyboardState: function() {},
    setContentTranslateLeftTop: function(a, b) {
        this._contentTranslateLeftTop = {
            left: a,
            top: b
        }
    },
    getContentTranslateLeftTop: function() {
        return this._contentTranslateLeftTop
    },
    getFrameSize: function() {
        return cc.size(this._frameSize.width, this._frameSize.height)
    },
    setFrameSize: function(a, b) {
        this._frameSize.width = a, this._frameSize.height = b, this._frame.style.width = a + "px", this._frame.style.height = b + "px", this._resizeEvent(), cc.director.setProjection(cc.director.getProjection())
    },
    centerWindow: function() {},
    getVisibleSize: function() {
        return cc.size(this._visibleRect.width, this._visibleRect.height)
    },
    getVisibleOrigin: function() {
        return cc.p(this._visibleRect.x, this._visibleRect.y)
    },
    canSetContentScaleFactor: function() {
        return !0
    },
    getResolutionPolicy: function() {
        return this._resolutionPolicy
    },
    setResolutionPolicy: function(a) {
        if (a instanceof cc.ResolutionPolicy) this._resolutionPolicy = a;
        else {
            var b = cc.ResolutionPolicy;
            a === b.EXACT_FIT && (this._resolutionPolicy = this._rpExactFit), a === b.SHOW_ALL && (this._resolutionPolicy = this._rpShowAll), a === b.NO_BORDER && (this._resolutionPolicy = this._rpNoBorder), a === b.FIXED_HEIGHT && (this._resolutionPolicy = this._rpFixedHeight), a === b.FIXED_WIDTH && (this._resolutionPolicy = this._rpFixedWidth)
        }
    },
    setDesignResolutionSize: function(a, b, c) {
        if (isNaN(a) || 0 == a || isNaN(b) || 0 == b) cc.log(cc._LogInfos.EGLView_setDesignResolutionSize);
        else {
            this.setResolutionPolicy(c);
            var d = this._resolutionPolicy;
            if (d) {
                d.preApply(this);
                var e = this._frameSize.width,
                    f = this._frameSize.height;
                cc.sys.isMobile && this._setViewPortMeta(this._frameSize.width, this._frameSize.height), this._initFrameSize(), c == this._resolutionPolicy && a == this._originalDesignResolutionSize.width && b == this._originalDesignResolutionSize.height && e == this._frameSize.width && f == this._frameSize.height || (this._designResolutionSize = cc.size(a, b), this._originalDesignResolutionSize = cc.size(a, b), a = d.apply(this, this._designResolutionSize), a.scale && 2 == a.scale.length && (this._scaleX = a.scale[0], this._scaleY = a.scale[1]), a.viewport && (a = this._viewPortRect = a.viewport, b = this._visibleRect, b.width = cc._canvas.width / this._scaleX, b.height = cc._canvas.height / this._scaleY, b.x = -a.x / this._scaleX, b.y = -a.y / this._scaleY), a = cc.director, cc.winSize.width = a._winSizeInPoints.width = this._visibleRect.width, cc.winSize.height = a._winSizeInPoints.height = this._visibleRect.height, d.postApply(this), cc._renderType == cc._RENDER_TYPE_WEBGL && (a._createStatsLabel(), a.setGLDefaultValues()), this._originalScaleX = this._scaleX, this._originalScaleY = this._scaleY, cc.DOM && cc.DOM._resetEGLViewDiv(), cc.visibleRect && cc.visibleRect.init(this._visibleRect))
            } else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2)
        }
    },
    getDesignResolutionSize: function() {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height)
    },
    setViewPortInPoints: function(a, b, c, d) {
        var e = this._frameZoomFactor,
            f = this._scaleX,
            g = this._scaleY;
        cc._renderContext.viewport(a * f * e + this._viewPortRect.x * e, b * g * e + this._viewPortRect.y * e, c * f * e, d * g * e)
    },
    setScissorInPoints: function(a, b, c, d) {
        var e = this._frameZoomFactor,
            f = this._scaleX,
            g = this._scaleY;
        cc._renderContext.scissor(a * f * e + this._viewPortRect.x * e, b * g * e + this._viewPortRect.y * e, c * f * e, d * g * e)
    },
    isScissorEnabled: function() {
        var a = cc._renderContext;
        return a.isEnabled(a.SCISSOR_TEST)
    },
    getScissorRect: function() {
        var a = cc._renderContext,
            b = this._scaleX,
            c = this._scaleY,
            a = a.getParameter(a.SCISSOR_BOX);
        return cc.rect((a[0] - this._viewPortRect.x) / b, (a[1] - this._viewPortRect.y) / c, a[2] / b, a[3] / c)
    },
    setViewName: function(a) {
        null != a && 0 < a.length && (this._viewName = a)
    },
    getViewName: function() {
        return this._viewName
    },
    getViewPortRect: function() {
        return this._viewPortRect
    },
    getScaleX: function() {
        return this._scaleX
    },
    getScaleY: function() {
        return this._scaleY
    },
    getDevicePixelRatio: function() {
        return this._devicePixelRatio
    },
    convertToLocationInView: function(a, b, c) {
        return {
            x: this._devicePixelRatio * (a - c.left),
            y: this._devicePixelRatio * (c.top + c.height - b)
        }
    },
    _convertMouseToLocationInView: function(a, b) {
        var c = this._viewPortRect;
        a.x = (this._devicePixelRatio * (a.x - b.left) - c.x) / this._scaleX, a.y = (this._devicePixelRatio * (b.top + b.height - a.y) - c.y) / this._scaleY
    },
    _convertTouchesWithScale: function(a) {
        for (var b, c, d, e = this._viewPortRect, f = this._scaleX, g = this._scaleY, h = 0; h < a.length; h++) b = a[h], c = b._point, d = b._prevPoint, b._setPoint((c.x - e.x) / f, (c.y - e.y) / g), b._setPrevPoint((d.x - e.x) / f, (d.y - e.y) / g)
    }
}), cc.EGLView._getInstance = function() {
    return this._instance || (this._instance = this._instance || new cc.EGLView, this._instance.initialize()), this._instance
}, cc.ContainerStrategy = cc.Class.extend({
    preApply: function() {},
    apply: function() {},
    postApply: function() {},
    _setupContainer: function(a, b, c) {
        var d = a._frame,
            d = cc._canvas,
            e = cc.container;
        e.style.width = d.style.width = b + "px", e.style.height = d.style.height = c + "px", e = a._devicePixelRatio = 1, a.isRetinaEnabled() && (e = a._devicePixelRatio = window.devicePixelRatio || 1), d.width = b * e, d.height = c * e, a = document.body;
        var f;
        a && (f = a.style) && (f.paddingTop = f.paddingTop || "0px", f.paddingRight = f.paddingRight || "0px", f.paddingBottom = f.paddingBottom || "0px", f.paddingLeft = f.paddingLeft || "0px", f.borderTop = f.borderTop || "0px", f.borderRight = f.borderRight || "0px", f.borderBottom = f.borderBottom || "0px", f.borderLeft = f.borderLeft || "0px", f.marginTop = f.marginTop || "0px", f.marginRight = f.marginRight || "0px", f.marginBottom = f.marginBottom || "0px", f.marginLeft = f.marginLeft || "0px")
    },
    _fixContainer: function() {
        document.body.insertBefore(cc.container, document.body.firstChild);
        var a = document.body.style;
        a.width = window.innerWidth + "px", a.height = window.innerHeight + "px", a.overflow = "hidden", a = cc.container.style, a.position = "fixed", a.left = a.top = "0px", document.body.scrollTop = 0
    }
}), cc.ContentStrategy = cc.Class.extend({
    _result: {
        scale: [1, 1],
        viewport: null
    },
    _buildResult: function(a, b, c, d, e, f) {
        return 2 > Math.abs(a - c) && (c = a), 2 > Math.abs(b - d) && (d = b), a = cc.rect(Math.round((a - c) / 2), Math.round((b - d) / 2), c, d), cc._renderType == cc._RENDER_TYPE_CANVAS && cc._renderContext.translate(a.x, a.y + d), this._result.scale = [e, f], this._result.viewport = a, this._result
    },
    preApply: function() {},
    apply: function() {
        return {
            scale: [1, 1]
        }
    },
    postApply: function() {}
}),
function() {
    var a = cc.ContainerStrategy.extend({
        apply: function() {}
    }),
        b = cc.ContainerStrategy.extend({
            apply: function(a, b) {
                var c, d, e = a._frameSize.width,
                    f = a._frameSize.height - 50,
                    g = cc.container.style,
                    h = b.width,
                    i = b.height,
                    j = e / h,
                    k = f / i;
                k > j ? (c = e, d = i * j) : (c = h * k, d = f), h = Math.round((e - c) / 2), d = Math.round((f - d) / 2), this._setupContainer(a, e - 2 * h, f - 2 * d), g.margin = "0 auto"
            }
        });
    a.extend({
        preApply: function(a) {
            this._super(a), a._frame = document.documentElement
        },
        apply: function(a) {
            this._super(a), this._fixContainer()
        }
    }), b.extend({
        preApply: function(a) {
            this._super(a), a._frame = document.documentElement
        },
        apply: function(a, b) {
            this._super(a, b), this._fixContainer()
        }
    });
    var c = cc.ContainerStrategy.extend({
        apply: function(a) {
            this._setupContainer(a, cc._canvas.width, cc._canvas.height)
        }
    });
    cc.ContainerStrategy.EQUAL_TO_FRAME = new a, cc.ContainerStrategy.PROPORTION_TO_FRAME = new b, cc.ContainerStrategy.ORIGINAL_CONTAINER = new c;
    var a = cc.ContentStrategy.extend({
        apply: function(a, b) {
            var c = cc._canvas.width,
                d = cc._canvas.height;
            return this._buildResult(c, d, c, d, c / b.width, d / b.height)
        }
    }),
        b = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c, d, e = cc._canvas.width,
                    f = cc._canvas.height,
                    g = b.width,
                    h = b.height,
                    i = e / g,
                    j = f / h,
                    k = 0;
                return j > i ? (k = i, c = e, d = h * k) : (k = j, c = g * k, d = f), this._buildResult(e, f, c, d, k, k)
            }
        }),
        c = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c, d, e, f = cc._canvas.width,
                    g = cc._canvas.height,
                    h = b.width,
                    i = b.height,
                    j = f / h,
                    k = g / i;
                return k > j ? (c = k, d = h * c, e = g) : (c = j, d = f, e = i * c), this._buildResult(f, g, d, e, c, c)
            }
        }),
        d = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = d / b.height;
                return this._buildResult(c, d, c, d, e, e)
            },
            postApply: function(a) {
                cc.director._winSizeInPoints = a.getVisibleSize()
            }
        }),
        e = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = c / b.width;
                return this._buildResult(c, d, c, d, e, e)
            },
            postApply: function(a) {
                cc.director._winSizeInPoints = a.getVisibleSize()
            }
        });
    cc.ContentStrategy.EXACT_FIT = new a, cc.ContentStrategy.SHOW_ALL = new b, cc.ContentStrategy.NO_BORDER = new c, cc.ContentStrategy.FIXED_HEIGHT = new d, cc.ContentStrategy.FIXED_WIDTH = new e
}(), cc.ResolutionPolicy = cc.Class.extend({
    _containerStrategy: null,
    _contentStrategy: null,
    ctor: function(a, b) {
        this.setContainerStrategy(a), this.setContentStrategy(b)
    },
    preApply: function(a) {
        this._containerStrategy.preApply(a), this._contentStrategy.preApply(a)
    },
    apply: function(a, b) {
        return this._containerStrategy.apply(a, b), this._contentStrategy.apply(a, b)
    },
    postApply: function(a) {
        this._containerStrategy.postApply(a), this._contentStrategy.postApply(a)
    },
    setContainerStrategy: function(a) {
        a instanceof cc.ContainerStrategy && (this._containerStrategy = a)
    },
    setContentStrategy: function(a) {
        a instanceof cc.ContentStrategy && (this._contentStrategy = a)
    }
}), cc.ResolutionPolicy.EXACT_FIT = 0, cc.ResolutionPolicy.NO_BORDER = 1, cc.ResolutionPolicy.SHOW_ALL = 2, cc.ResolutionPolicy.FIXED_HEIGHT = 3, cc.ResolutionPolicy.FIXED_WIDTH = 4, cc.ResolutionPolicy.UNKNOWN = 5, cc.visibleRect = {
    topLeft: cc.p(0, 0),
    topRight: cc.p(0, 0),
    top: cc.p(0, 0),
    bottomLeft: cc.p(0, 0),
    bottomRight: cc.p(0, 0),
    bottom: cc.p(0, 0),
    center: cc.p(0, 0),
    left: cc.p(0, 0),
    right: cc.p(0, 0),
    width: 0,
    height: 0,
    init: function(a) {
        var b = this.width = a.width,
            c = this.height = a.height,
            d = a.x;
        a = a.y;
        var e = a + c,
            f = d + b;
        this.topLeft.x = d, this.topLeft.y = e, this.topRight.x = f, this.topRight.y = e, this.top.x = d + b / 2, this.top.y = e, this.bottomLeft.x = d, this.bottomLeft.y = a, this.bottomRight.x = f, this.bottomRight.y = a, this.bottom.x = d + b / 2, this.bottom.y = a, this.center.x = d + b / 2, this.center.y = a + c / 2, this.left.x = d, this.left.y = a + c / 2, this.right.x = f, this.right.y = a + c / 2
    }
}, cc.UIInterfaceOrientationLandscapeLeft = -90, cc.UIInterfaceOrientationLandscapeRight = 90, cc.UIInterfaceOrientationPortraitUpsideDown = 180, cc.UIInterfaceOrientationPortrait = 0, cc.inputManager = {
    _mousePressed: !1,
    _isRegisterEvent: !1,
    _preTouchPoint: cc.p(0, 0),
    _prevMousePoint: cc.p(0, 0),
    _preTouchPool: [],
    _preTouchPoolPointer: 0,
    _touches: [],
    _touchesIntegerDict: {},
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _accelEnabled: !1,
    _accelInterval: 1 / 30,
    _accelMinus: 1,
    _accelCurTime: 0,
    _acceleration: null,
    _accelDeviceEvent: null,
    _getUnUsedIndex: function() {
        for (var a = this._indexBitsUsed, b = 0; b < this._maxTouches; b++) {
            if (!(1 & a)) return this._indexBitsUsed |= 1 << b, b;
            a >>= 1
        }
        return -1
    },
    _removeUsedIndexBit: function(a) {
        0 > a || a >= this._maxTouches || (a = ~ (1 << a), this._indexBitsUsed &= a)
    },
    _glView: null,
    handleTouchesBegin: function(a) {
        for (var b, c, d, e = [], f = this._touchesIntegerDict, g = 0, h = a.length; h > g; g++)
            if (b = a[g], d = b.getID(), c = f[d], null == c) {
                var i = this._getUnUsedIndex(); - 1 == i ? cc.log(cc._LogInfos.inputManager_handleTouchesBegin, i) : (c = this._touches[i] = new cc.Touch(b._point.x, b._point.y, b.getID()), c._setPrevPoint(b._prevPoint), f[d] = i, e.push(c))
            }
        0 < e.length && (this._glView._convertTouchesWithScale(e), a = new cc.EventTouch(e), a._eventCode = cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesMove: function(a) {
        for (var b, c, d = [], e = this._touches, f = 0, g = a.length; g > f; f++) b = a[f], c = b.getID(), c = this._touchesIntegerDict[c], null != c && e[c] && (e[c]._setPoint(b._point), e[c]._setPrevPoint(b._prevPoint), d.push(e[c]));
        0 < d.length && (this._glView._convertTouchesWithScale(d), a = new cc.EventTouch(d), a._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesEnd: function(a) {
        a = this.getSetOfTouchesEndOrCancel(a), 0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.ENDED, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesCancel: function(a) {
        a = this.getSetOfTouchesEndOrCancel(a), 0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(a))
    },
    getSetOfTouchesEndOrCancel: function(a) {
        for (var b, c, d, e = [], f = this._touches, g = this._touchesIntegerDict, h = 0, i = a.length; i > h; h++) b = a[h], d = b.getID(), c = g[d], null != c && f[c] && (f[c]._setPoint(b._point), f[c]._setPrevPoint(b._prevPoint), e.push(f[c]), this._removeUsedIndexBit(c), delete g[d]);
        return e
    },
    getHTMLElementPosition: function(a) {
        var b = document.documentElement,
            c = window,
            d = null,
            d = "function" == typeof a.getBoundingClientRect ? a.getBoundingClientRect() : a instanceof HTMLCanvasElement ? {
                left: 0,
                top: 0,
                width: a.width,
                height: a.height
            } : {
                left: 0,
                top: 0,
                width: parseInt(a.style.width),
                height: parseInt(a.style.height)
            };
        return {
            left: d.left + c.pageXOffset - b.clientLeft,
            top: d.top + c.pageYOffset - b.clientTop,
            width: d.width,
            height: d.height
        }
    },
    getPreTouch: function(a) {
        for (var b = null, c = this._preTouchPool, d = a.getID(), e = c.length - 1; e >= 0; e--)
            if (c[e].getID() == d) {
                b = c[e];
                break
            }
        return b || (b = a), b
    },
    setPreTouch: function(a) {
        for (var b = !1, c = this._preTouchPool, d = a.getID(), e = c.length - 1; e >= 0; e--)
            if (c[e].getID() == d) {
                c[e] = a, b = !0;
                break
            }
        b || (50 >= c.length ? c.push(a) : (c[this._preTouchPoolPointer] = a, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
    },
    getTouchByXY: function(a, b, c) {
        var d = this._preTouchPoint;
        return a = this._glView.convertToLocationInView(a, b, c), b = new cc.Touch(a.x, a.y), b._setPrevPoint(d.x, d.y), d.x = a.x, d.y = a.y, b
    },
    getMouseEvent: function(a, b, c) {
        var d = this._prevMousePoint;
        return this._glView._convertMouseToLocationInView(a, b), b = new cc.EventMouse(c), b.setLocation(a.x, a.y), b._setPrevCursor(d.x, d.y), d.x = a.x, d.y = a.y, b
    },
    getPointByEvent: function(a, b) {
        return null != a.pageX ? {
            x: a.pageX,
            y: a.pageY
        } : (b.left -= document.body.scrollLeft, b.top -= document.body.scrollTop, {
            x: a.clientX,
            y: a.clientY
        })
    },
    getTouchesByEvent: function(a, b) {
        for (var c, d, e = [], f = this._glView, g = this._preTouchPoint, h = a.changedTouches.length, i = 0; h > i; i++)
            if (c = a.changedTouches[i]) {
                var j;
                j = cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? f.convertToLocationInView(c.pageX, c.pageY, b) : f.convertToLocationInView(c.clientX, c.clientY, b), null != c.identifier ? (c = new cc.Touch(j.x, j.y, c.identifier), d = this.getPreTouch(c).getLocation(), c._setPrevPoint(d.x, d.y), this.setPreTouch(c)) : (c = new cc.Touch(j.x, j.y), c._setPrevPoint(g.x, g.y)), g.x = j.x, g.y = j.y, e.push(c)
            }
        return e
    },
    registerSystemEvent: function(a) {
        if (!this._isRegisterEvent) {
            var b = this._glView = cc.view,
                c = this,
                d = "touches" in cc.sys.capabilities;
            if ("mouse" in cc.sys.capabilities && (cc._addEventListener(window, "mousedown", function() {
                c._mousePressed = !0
            }, !1), cc._addEventListener(window, "mouseup", function(b) {
                var e = c._mousePressed;
                if (c._mousePressed = !1, e) {
                    var e = c.getHTMLElementPosition(a),
                        f = c.getPointByEvent(b, e);
                    cc.rectContainsPoint(new cc.Rect(e.left, e.top, e.width, e.height), f) || (d || c.handleTouchesEnd([c.getTouchByXY(f.x, f.y, e)]), e = c.getMouseEvent(f, e, cc.EventMouse.UP), e.setButton(b.button), cc.eventManager.dispatchEvent(e))
                }
            }, !1), cc._addEventListener(a, "mousedown", function(b) {
                c._mousePressed = !0;
                var e = c.getHTMLElementPosition(a),
                    f = c.getPointByEvent(b, e);
                d || c.handleTouchesBegin([c.getTouchByXY(f.x, f.y, e)]), e = c.getMouseEvent(f, e, cc.EventMouse.DOWN), e.setButton(b.button), cc.eventManager.dispatchEvent(e), b.stopPropagation(), b.preventDefault(), a.focus()
            }, !1), cc._addEventListener(a, "mouseup", function(b) {
                c._mousePressed = !1;
                var e = c.getHTMLElementPosition(a),
                    f = c.getPointByEvent(b, e);
                d || c.handleTouchesEnd([c.getTouchByXY(f.x, f.y, e)]), e = c.getMouseEvent(f, e, cc.EventMouse.UP), e.setButton(b.button), cc.eventManager.dispatchEvent(e), b.stopPropagation(), b.preventDefault()
            }, !1), cc._addEventListener(a, "mousemove", function(b) {
                var e = c.getHTMLElementPosition(a),
                    f = c.getPointByEvent(b, e);
                d || c.handleTouchesMove([c.getTouchByXY(f.x, f.y, e)]), e = c.getMouseEvent(f, e, cc.EventMouse.MOVE), e.setButton(c._mousePressed ? b.button : null), cc.eventManager.dispatchEvent(e), b.stopPropagation(), b.preventDefault()
            }, !1), cc._addEventListener(a, "mousewheel", function(b) {
                var d = c.getHTMLElementPosition(a),
                    e = c.getPointByEvent(b, d),
                    d = c.getMouseEvent(e, d, cc.EventMouse.SCROLL);
                d.setButton(b.button), d.setScrollData(0, b.wheelDelta), cc.eventManager.dispatchEvent(d), b.stopPropagation(), b.preventDefault()
            }, !1), cc._addEventListener(a, "DOMMouseScroll", function(b) {
                var d = c.getHTMLElementPosition(a),
                    e = c.getPointByEvent(b, d),
                    d = c.getMouseEvent(e, d, cc.EventMouse.SCROLL);
                d.setButton(b.button), d.setScrollData(0, -120 * b.detail), cc.eventManager.dispatchEvent(d), b.stopPropagation(), b.preventDefault()
            }, !1)), window.navigator.msPointerEnabled) {
                var e, f = {
                        MSPointerDown: c.handleTouchesBegin,
                        MSPointerMove: c.handleTouchesMove,
                        MSPointerUp: c.handleTouchesEnd,
                        MSPointerCancel: c.handleTouchesCancel
                    };
                for (e in f)(function(b, d) {
                    cc._addEventListener(a, b, function(b) {
                        var e = c.getHTMLElementPosition(a);
                        e.left -= document.documentElement.scrollLeft, e.top -= document.documentElement.scrollTop, d.call(c, [c.getTouchByXY(b.clientX, b.clientY, e)]), b.stopPropagation()
                    }, !1)
                })(e, f[e])
            }
            d && (cc._addEventListener(a, "touchstart", function(b) {
                if (b.changedTouches) {
                    var d = c.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft, d.top -= document.body.scrollTop, c.handleTouchesBegin(c.getTouchesByEvent(b, d)), b.stopPropagation(), b.preventDefault(), a.focus()
                }
            }, !1), cc._addEventListener(a, "touchmove", function(b) {
                if (b.changedTouches) {
                    var d = c.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft, d.top -= document.body.scrollTop, c.handleTouchesMove(c.getTouchesByEvent(b, d)), b.stopPropagation(), b.preventDefault()
                }
            }, !1), cc._addEventListener(a, "touchend", function(b) {
                if (b.changedTouches) {
                    var d = c.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft, d.top -= document.body.scrollTop, c.handleTouchesEnd(c.getTouchesByEvent(b, d)), b.stopPropagation(), b.preventDefault()
                }
            }, !1), cc._addEventListener(a, "touchcancel", function(d) {
                if (d.changedTouches) {
                    var e = c.getHTMLElementPosition(a);
                    e.left -= document.body.scrollLeft, e.top -= document.body.scrollTop, b.handleTouchesCancel(c.getTouchesByEvent(d, e)), d.stopPropagation(), d.preventDefault()
                }
            }, !1)), this._registerKeyboardEvent(), this._registerAccelerometerEvent(), this._isRegisterEvent = !0
        }
    },
    _registerKeyboardEvent: function() {},
    _registerAccelerometerEvent: function() {},
    update: function(a) {
        this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration))), this._accelCurTime += a
    }
};
var _p = cc.inputManager;
if (_p.setAccelerometerEnabled = function(a) {
    this._accelEnabled !== a && (this._accelEnabled = a, a = cc.director.getScheduler(), this._accelEnabled ? (this._accelCurTime = 0, a.scheduleUpdateForTarget(this)) : (this._accelCurTime = 0, a.unscheduleUpdateForTarget(this)))
}, _p.setAccelerometerInterval = function(a) {
    this._accelInterval !== a && (this._accelInterval = a)
}, _p._registerKeyboardEvent = function() {
    cc._addEventListener(cc._canvas, "keydown", function(a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !0)), a.stopPropagation(), a.preventDefault()
    }, !1), cc._addEventListener(cc._canvas, "keyup", function(a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !1)), a.stopPropagation(), a.preventDefault()
    }, !1)
}, _p._registerAccelerometerEvent = function() {
    var a = window;
    this._acceleration = new cc.Acceleration, this._accelDeviceEvent = a.DeviceMotionEvent || a.DeviceOrientationEvent, cc.sys.browserType == cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
    var b = this._accelDeviceEvent == a.DeviceMotionEvent ? "devicemotion" : "deviceorientation",
        c = navigator.userAgent;
    (/Android/.test(c) || /Adr/.test(c) && cc.sys.browserType == cc.BROWSER_TYPE_UC) && (this._minus = -1), cc._addEventListener(a, b, this.didAccelerate.bind(this), !1)
}, _p.didAccelerate = function(a) {
    var b = window;
    if (this._accelEnabled) {
        var c, d, e, f = this._acceleration;
        this._accelDeviceEvent == window.DeviceMotionEvent ? (e = a.accelerationIncludingGravity, c = .1 * this._accelMinus * e.x, d = .1 * this._accelMinus * e.y, e = .1 * e.z) : (c = .981 * (a.gamma / 90), d = .981 * -(a.beta / 90), e = .981 * (a.alpha / 90)), cc.sys.os === cc.sys.OS_ANDROID ? (f.x = -c, f.y = -d) : (f.x = c, f.y = d), f.z = e, f.timestamp = a.timeStamp || Date.now(), a = f.x, b.orientation === cc.UIInterfaceOrientationLandscapeRight ? (f.x = -f.y, f.y = a) : b.orientation === cc.UIInterfaceOrientationLandscapeLeft ? (f.x = f.y, f.y = -a) : b.orientation === cc.UIInterfaceOrientationPortraitUpsideDown && (f.x = -f.x, f.y = -f.y)
    }
}, delete _p, cc.AffineTransform = function(a, b, c, d, e, f) {
    this.a = a, this.b = b, this.c = c, this.d = d, this.tx = e, this.ty = f
}, cc.affineTransformMake = function(a, b, c, d, e, f) {
    return {
        a: a,
        b: b,
        c: c,
        d: d,
        tx: e,
        ty: f
    }
}, cc.pointApplyAffineTransform = function(a, b) {
    return {
        x: b.a * a.x + b.c * a.y + b.tx,
        y: b.b * a.x + b.d * a.y + b.ty
    }
}, cc._pointApplyAffineTransform = function(a, b, c) {
    return {
        x: c.a * a + c.c * b + c.tx,
        y: c.b * a + c.d * b + c.ty
    }
}, cc.sizeApplyAffineTransform = function(a, b) {
    return {
        width: b.a * a.width + b.c * a.height,
        height: b.b * a.width + b.d * a.height
    }
}, cc.affineTransformMakeIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
}, cc.affineTransformIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
}, cc.rectApplyAffineTransform = function(a, b) {
    var c = cc.rectGetMinY(a),
        d = cc.rectGetMinX(a),
        e = cc.rectGetMaxX(a),
        f = cc.rectGetMaxY(a),
        g = cc._pointApplyAffineTransform(d, c, b),
        c = cc._pointApplyAffineTransform(e, c, b),
        d = cc._pointApplyAffineTransform(d, f, b),
        h = cc._pointApplyAffineTransform(e, f, b),
        e = Math.min(g.x, c.x, d.x, h.x),
        f = Math.max(g.x, c.x, d.x, h.x),
        i = Math.min(g.y, c.y, d.y, h.y),
        g = Math.max(g.y, c.y, d.y, h.y);
    return cc.rect(e, i, f - e, g - i)
}, cc._rectApplyAffineTransformIn = function(a, b) {
    var c = cc.rectGetMinY(a),
        d = cc.rectGetMinX(a),
        e = cc.rectGetMaxX(a),
        f = cc.rectGetMaxY(a),
        g = cc._pointApplyAffineTransform(d, c, b),
        c = cc._pointApplyAffineTransform(e, c, b),
        d = cc._pointApplyAffineTransform(d, f, b),
        h = cc._pointApplyAffineTransform(e, f, b),
        e = Math.min(g.x, c.x, d.x, h.x),
        f = Math.max(g.x, c.x, d.x, h.x),
        i = Math.min(g.y, c.y, d.y, h.y),
        g = Math.max(g.y, c.y, d.y, h.y);
    return a.x = e, a.y = i, a.width = f - e, a.height = g - i, a
}, cc.affineTransformTranslate = function(a, b, c) {
    return {
        a: a.a,
        b: a.b,
        c: a.c,
        d: a.d,
        tx: a.tx + a.a * b + a.c * c,
        ty: a.ty + a.b * b + a.d * c
    }
}, cc.affineTransformScale = function(a, b, c) {
    return {
        a: a.a * b,
        b: a.b * b,
        c: a.c * c,
        d: a.d * c,
        tx: a.tx,
        ty: a.ty
    }
}, cc.affineTransformRotate = function(a, b) {
    var c = Math.sin(b),
        d = Math.cos(b);
    return {
        a: a.a * d + a.c * c,
        b: a.b * d + a.d * c,
        c: a.c * d - a.a * c,
        d: a.d * d - a.b * c,
        tx: a.tx,
        ty: a.ty
    }
}, cc.affineTransformConcat = function(a, b) {
    return {
        a: a.a * b.a + a.b * b.c,
        b: a.a * b.b + a.b * b.d,
        c: a.c * b.a + a.d * b.c,
        d: a.c * b.b + a.d * b.d,
        tx: a.tx * b.a + a.ty * b.c + b.tx,
        ty: a.tx * b.b + a.ty * b.d + b.ty
    }
}, cc.affineTransformEqualToTransform = function(a, b) {
    return a.a === b.a && a.b === b.b && a.c === b.c && a.d === b.d && a.tx === b.tx && a.ty === b.ty
}, cc.affineTransformInvert = function(a) {
    var b = 1 / (a.a * a.d - a.b * a.c);
    return {
        a: b * a.d,
        b: -b * a.b,
        c: -b * a.c,
        d: b * a.a,
        tx: b * (a.c * a.ty - a.d * a.tx),
        ty: b * (a.b * a.tx - a.a * a.ty)
    }
}, cc.POINT_EPSILON = parseFloat("1.192092896e-07F"), cc.pNeg = function(a) {
    return cc.p(-a.x, -a.y)
}, cc.pAdd = function(a, b) {
    return cc.p(a.x + b.x, a.y + b.y)
}, cc.pSub = function(a, b) {
    return cc.p(a.x - b.x, a.y - b.y)
}, cc.pMult = function(a, b) {
    return cc.p(a.x * b, a.y * b)
}, cc.pMidpoint = function(a, b) {
    return cc.pMult(cc.pAdd(a, b), .5)
}, cc.pDot = function(a, b) {
    return a.x * b.x + a.y * b.y
}, cc.pCross = function(a, b) {
    return a.x * b.y - a.y * b.x
}, cc.pPerp = function(a) {
    return cc.p(-a.y, a.x)
}, cc.pRPerp = function(a) {
    return cc.p(a.y, -a.x)
}, cc.pProject = function(a, b) {
    return cc.pMult(b, cc.pDot(a, b) / cc.pDot(b, b))
}, cc.pRotate = function(a, b) {
    return cc.p(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)
}, cc.pUnrotate = function(a, b) {
    return cc.p(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y)
}, cc.pLengthSQ = function(a) {
    return cc.pDot(a, a)
}, cc.pDistanceSQ = function(a, b) {
    return cc.pLengthSQ(cc.pSub(a, b))
}, cc.pLength = function(a) {
    return Math.sqrt(cc.pLengthSQ(a))
}, cc.pDistance = function(a, b) {
    return cc.pLength(cc.pSub(a, b))
}, cc.pNormalize = function(a) {
    return cc.pMult(a, 1 / cc.pLength(a))
}, cc.pForAngle = function(a) {
    return cc.p(Math.cos(a), Math.sin(a))
}, cc.pToAngle = function(a) {
    return Math.atan2(a.y, a.x)
}, cc.clampf = function(a, b, c) {
    if (b > c) {
        var d = b;
        b = c, c = d
    }
    return b > a ? b : c > a ? a : c
}, cc.pClamp = function(a, b, c) {
    return cc.p(cc.clampf(a.x, b.x, c.x), cc.clampf(a.y, b.y, c.y))
}, cc.pFromSize = function(a) {
    return cc.p(a.width, a.height)
}, cc.pCompOp = function(a, b) {
    return cc.p(b(a.x), b(a.y))
}, cc.pLerp = function(a, b, c) {
    return cc.pAdd(cc.pMult(a, 1 - c), cc.pMult(b, c))
}, cc.pFuzzyEqual = function(a, b, c) {
    return a.x - c <= b.x && b.x <= a.x + c && a.y - c <= b.y && b.y <= a.y + c ? !0 : !1
}, cc.pCompMult = function(a, b) {
    return cc.p(a.x * b.x, a.y * b.y)
}, cc.pAngleSigned = function(a, b) {
    var c = cc.pNormalize(a),
        d = cc.pNormalize(b),
        c = Math.atan2(c.x * d.y - c.y * d.x, cc.pDot(c, d));
    return Math.abs(c) < cc.POINT_EPSILON ? 0 : c
}, cc.pAngle = function(a, b) {
    var c = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
    return Math.abs(c) < cc.POINT_EPSILON ? 0 : c
}, cc.pRotateByAngle = function(a, b, c) {
    a = cc.pSub(a, b);
    var d = Math.cos(c);
    c = Math.sin(c);
    var e = a.x;
    return a.x = e * d - a.y * c + b.x, a.y = e * c + a.y * d + b.y, a
}, cc.pLineIntersect = function(a, b, c, d, e) {
    if (a.x == b.x && a.y == b.y || c.x == d.x && c.y == d.y) return !1;
    var f = b.x - a.x;
    b = b.y - a.y;
    var g = d.x - c.x;
    d = d.y - c.y;
    var h = a.x - c.x;
    return a = a.y - c.y, c = d * f - g * b, e.x = g * a - d * h, e.y = f * a - b * h, 0 == c ? 0 == e.x || 0 == e.y ? !0 : !1 : (e.x /= c, e.y /= c, !0)
}, cc.pSegmentIntersect = function(a, b, c, d) {
    var e = cc.p(0, 0);
    return cc.pLineIntersect(a, b, c, d, e) && 0 <= e.x && 1 >= e.x && 0 <= e.y && 1 >= e.y ? !0 : !1
}, cc.pIntersectPoint = function(a, b, c, d) {
    var e = cc.p(0, 0);
    return cc.pLineIntersect(a, b, c, d, e) ? (c = cc.p(0, 0), c.x = a.x + e.x * (b.x - a.x), c.y = a.y + e.x * (b.y - a.y), c) : cc.p(0, 0)
}, cc.pSameAs = function(a, b) {
    return null != a && null != b ? a.x == b.x && a.y == b.y : !1
}, cc.pZeroIn = function(a) {
    a.x = 0, a.y = 0
}, cc.pIn = function(a, b) {
    a.x = b.x, a.y = b.y
}, cc.pMultIn = function(a, b) {
    a.x *= b, a.y *= b
}, cc.pSubIn = function(a, b) {
    a.x -= b.x, a.y -= b.y
}, cc.pAddIn = function(a, b) {
    a.x += b.x, a.y += b.y
}, cc.pNormalizeIn = function(a) {
    cc.pMultIn(a, 1 / Math.sqrt(a.x * a.x + a.y * a.y))
}, cc.vertexLineToPolygon = function(a, b, c, d, e) {
    if (e += d, !(1 >= e)) {
        b *= .5;
        for (var f, g = e - 1, h = d; e > h; h++) {
            f = 2 * h;
            var i, j = cc.p(a[2 * h], a[2 * h + 1]);
            if (0 === h) i = cc.pPerp(cc.pNormalize(cc.pSub(j, cc.p(a[2 * (h + 1)], a[2 * (h + 1) + 1]))));
            else if (h === g) i = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(a[2 * (h - 1)], a[2 * (h - 1) + 1]), j)));
            else {
                i = cc.p(a[2 * (h - 1)], a[2 * (h - 1) + 1]);
                var k = cc.p(a[2 * (h + 1)], a[2 * (h + 1) + 1]),
                    l = cc.pNormalize(cc.pSub(k, j)),
                    m = cc.pNormalize(cc.pSub(i, j)),
                    n = Math.acos(cc.pDot(l, m));
                i = n < cc.degreesToRadians(70) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(l, m))) : n < cc.degreesToRadians(170) ? cc.pNormalize(cc.pMidpoint(l, m)) : cc.pPerp(cc.pNormalize(cc.pSub(k, i)))
            }
            i = cc.pMult(i, b), c[2 * f] = j.x + i.x, c[2 * f + 1] = j.y + i.y, c[2 * (f + 1)] = j.x - i.x, c[2 * (f + 1) + 1] = j.y - i.y
        }
        for (h = 0 == d ? 0 : d - 1; g > h; h++) f = 2 * h, a = f + 2, b = cc.vertex2(c[2 * f], c[2 * f + 1]), e = cc.vertex2(c[2 * (f + 1)], c[2 * (f + 1) + 1]), f = cc.vertex2(c[2 * a], c[2 * a]), d = cc.vertex2(c[2 * (a + 1)], c[2 * (a + 1) + 1]), b = !cc.vertexLineIntersect(b.x, b.y, d.x, d.y, e.x, e.y, f.x, f.y), !b.isSuccess && (0 > b.value || 1 < b.value) && (b.isSuccess = !0), b.isSuccess && (c[2 * a] = d.x, c[2 * a + 1] = d.y, c[2 * (a + 1)] = f.x, c[2 * (a + 1) + 1] = f.y)
    }
}, cc.vertexLineIntersect = function(a, b, c, d, e, f, g, h) {
    return a == c && b == d || e == g && f == h ? {
        isSuccess: !1,
        value: 0
    } : (c -= a, d -= b, e -= a, f -= b, g -= a, h -= b, a = Math.sqrt(c * c + d * d), c /= a, d /= a, b = e * c + f * d, f = f * c - e * d, e = b, b = g * c + h * d, h = h * c - g * d, g = b, f == h ? {
        isSuccess: !1,
        value: 0
    } : {
        isSuccess: !0,
        value: (g + (e - g) * h / (h - f)) / a
    })
}, cc.vertexListIsClockwise = function(a) {
    for (var b = 0, c = a.length; c > b; b++) {
        var d = a[(b + 1) % c],
            e = a[(b + 2) % c];
        if (0 < cc.pCross(cc.pSub(d, a[b]), cc.pSub(e, d))) return !1
    }
    return !0
}, cc.CGAffineToGL = function(a, b) {
    b[2] = b[3] = b[6] = b[7] = b[8] = b[9] = b[11] = b[14] = 0, b[10] = b[15] = 1, b[0] = a.a, b[4] = a.c, b[12] = a.tx, b[1] = a.b, b[5] = a.d, b[13] = a.ty
}, cc.GLToCGAffine = function(a, b) {
    b.a = a[0], b.c = a[4], b.tx = a[12], b.b = a[1], b.d = a[5], b.ty = a[13]
}, cc.Touch = cc.Class.extend({
    _point: null,
    _prevPoint: null,
    _id: 0,
    _startPointCaptured: !1,
    _startPoint: null,
    ctor: function(a, b, c) {
        this._point = cc.p(a || 0, b || 0), this._id = c || 0
    },
    getLocation: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getLocationX: function() {
        return this._point.x
    },
    getLocationY: function() {
        return this._point.y
    },
    getPreviousLocation: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocation: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getDelta: function() {
        return cc.pSub(this._point, this._prevPoint)
    },
    getLocationInView: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getPreviousLocationInView: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocationInView: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getID: function() {
        return this._id
    },
    getId: function() {
        return cc.log("getId is deprecated. Please use getID instead."), this._id
    },
    setTouchInfo: function(a, b, c) {
        this._prevPoint = this._point, this._point = cc.p(b || 0, c || 0), this._id = a, this._startPointCaptured || (this._startPoint = cc.p(this._point), this._startPointCaptured = !0)
    },
    _setPoint: function(a, b) {
        void 0 === b ? (this._point.x = a.x, this._point.y = a.y) : (this._point.x = a, this._point.y = b)
    },
    _setPrevPoint: function(a, b) {
        this._prevPoint = void 0 === b ? cc.p(a.x, a.y) : cc.p(a || 0, b || 0)
    }
}), cc.Event = cc.Class.extend({
    _type: 0,
    _isStopped: !1,
    _currentTarget: null,
    _setCurrentTarget: function(a) {
        this._currentTarget = a
    },
    ctor: function(a) {
        this._type = a
    },
    getType: function() {
        return this._type
    },
    stopPropagation: function() {
        this._isStopped = !0
    },
    isStopped: function() {
        return this._isStopped
    },
    getCurrentTarget: function() {
        return this._currentTarget
    }
}), cc.Event.TOUCH = 0, cc.Event.KEYBOARD = 1, cc.Event.ACCELERATION = 2, cc.Event.MOUSE = 3, cc.Event.CUSTOM = 4, cc.EventCustom = cc.Event.extend({
    _eventName: null,
    _userData: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM), this._eventName = a
    },
    setUserData: function(a) {
        this._userData = a
    },
    getUserData: function() {
        return this._userData
    },
    getEventName: function() {
        return this._eventName
    }
}), cc.EventMouse = cc.Event.extend({
    _eventType: 0,
    _button: 0,
    _x: 0,
    _y: 0,
    _prevX: 0,
    _prevY: 0,
    _scrollX: 0,
    _scrollY: 0,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.MOUSE), this._eventType = a
    },
    setScrollData: function(a, b) {
        this._scrollX = a, this._scrollY = b
    },
    getScrollX: function() {
        return this._scrollX
    },
    getScrollY: function() {
        return this._scrollY
    },
    setLocation: function(a, b) {
        this._x = a, this._y = b
    },
    getLocation: function() {
        return {
            x: this._x,
            y: this._y
        }
    },
    getLocationInView: function() {
        return {
            x: this._x,
            y: cc.view._designResolutionSize.height - this._y
        }
    },
    _setPrevCursor: function(a, b) {
        this._prevX = a, this._prevY = b
    },
    getDelta: function() {
        return {
            x: this._x - this._prevX,
            y: this._y - this._prevY
        }
    },
    getDeltaX: function() {
        return this._x - this._prevX
    },
    getDeltaY: function() {
        return this._y - this._prevY
    },
    setButton: function(a) {
        this._button = a
    },
    getButton: function() {
        return this._button
    },
    getLocationX: function() {
        return this._x
    },
    getLocationY: function() {
        return this._y
    }
}), cc.EventMouse.NONE = 0, cc.EventMouse.DOWN = 1, cc.EventMouse.UP = 2, cc.EventMouse.MOVE = 3, cc.EventMouse.SCROLL = 4, cc.EventMouse.BUTTON_LEFT = 0, cc.EventMouse.BUTTON_RIGHT = 2, cc.EventMouse.BUTTON_MIDDLE = 1, cc.EventMouse.BUTTON_4 = 3, cc.EventMouse.BUTTON_5 = 4, cc.EventMouse.BUTTON_6 = 5, cc.EventMouse.BUTTON_7 = 6, cc.EventMouse.BUTTON_8 = 7, cc.EventTouch = cc.Event.extend({
    _eventCode: 0,
    _touches: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.TOUCH), this._touches = a || []
    },
    getEventCode: function() {
        return this._eventCode
    },
    getTouches: function() {
        return this._touches
    },
    _setEventCode: function(a) {
        this._eventCode = a
    },
    _setTouches: function(a) {
        this._touches = a
    }
}), cc.EventTouch.MAX_TOUCHES = 5, cc.EventTouch.EventCode = {
    BEGAN: 0,
    MOVED: 1,
    ENDED: 2,
    CANCELLED: 3
}, cc.EventListener = cc.Class.extend({
    _onEvent: null,
    _type: 0,
    _listenerID: null,
    _registered: !1,
    _fixedPriority: 0,
    _node: null,
    _paused: !1,
    _isEnabled: !0,
    ctor: function(a, b, c) {
        this._onEvent = c, this._type = a || 0, this._listenerID = b || ""
    },
    _setPaused: function(a) {
        this._paused = a
    },
    _isPaused: function() {
        return this._paused
    },
    _setRegistered: function(a) {
        this._registered = a
    },
    _isRegistered: function() {
        return this._registered
    },
    _getType: function() {
        return this._type
    },
    _getListenerID: function() {
        return this._listenerID
    },
    _setFixedPriority: function(a) {
        this._fixedPriority = a
    },
    _getFixedPriority: function() {
        return this._fixedPriority
    },
    _setSceneGraphPriority: function(a) {
        this._node = a
    },
    _getSceneGraphPriority: function() {
        return this._node
    },
    checkAvailable: function() {
        return null != this._onEvent
    },
    clone: function() {
        return null
    },
    setEnabled: function(a) {
        this._isEnabled = a
    },
    isEnabled: function() {
        return this._isEnabled
    },
    retain: function() {},
    release: function() {}
}), cc.EventListener.UNKNOWN = 0, cc.EventListener.TOUCH_ONE_BY_ONE = 1, cc.EventListener.TOUCH_ALL_AT_ONCE = 2, cc.EventListener.KEYBOARD = 3, cc.EventListener.MOUSE = 4, cc.EventListener.ACCELERATION = 5, cc.EventListener.CUSTOM = 6, cc._EventListenerCustom = cc.EventListener.extend({
    _onCustomEvent: null,
    ctor: function(a, b) {
        this._onCustomEvent = b;
        var c = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, a, function(a) {
            null != c._onCustomEvent && c._onCustomEvent(a)
        })
    },
    checkAvailable: function() {
        return cc.EventListener.prototype.checkAvailable.call(this) && null != this._onCustomEvent
    },
    clone: function() {
        return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent)
    }
}), cc._EventListenerCustom.create = function(a, b) {
    return new cc._EventListenerCustom(a, b)
}, cc._EventListenerMouse = cc.EventListener.extend({
    onMouseDown: null,
    onMouseUp: null,
    onMouseMove: null,
    onMouseScroll: null,
    ctor: function() {
        var a = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, function(b) {
            var c = cc.EventMouse;
            switch (b._eventType) {
                case c.DOWN:
                    a.onMouseDown && a.onMouseDown(b);
                    break;
                case c.UP:
                    a.onMouseUp && a.onMouseUp(b);
                    break;
                case c.MOVE:
                    a.onMouseMove && a.onMouseMove(b);
                    break;
                case c.SCROLL:
                    a.onMouseScroll && a.onMouseScroll(b)
            }
        })
    },
    clone: function() {
        var a = new cc._EventListenerMouse;
        return a.onMouseDown = this.onMouseDown, a.onMouseUp = this.onMouseUp, a.onMouseMove = this.onMouseMove, a.onMouseScroll = this.onMouseScroll, a
    },
    checkAvailable: function() {
        return !0
    }
}), cc._EventListenerMouse.LISTENER_ID = "__cc_mouse", cc._EventListenerMouse.create = function() {
    return new cc._EventListenerMouse
}, cc._EventListenerTouchOneByOne = cc.EventListener.extend({
    _claimedTouches: null,
    swallowTouches: !1,
    onTouchBegan: null,
    onTouchMoved: null,
    onTouchEnded: null,
    onTouchCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null), this._claimedTouches = []
    },
    setSwallowTouches: function(a) {
        this.swallowTouches = a
    },
    clone: function() {
        var a = new cc._EventListenerTouchOneByOne;
        return a.onTouchBegan = this.onTouchBegan, a.onTouchMoved = this.onTouchMoved, a.onTouchEnded = this.onTouchEnded, a.onTouchCancelled = this.onTouchCancelled, a.swallowTouches = this.swallowTouches, a
    },
    checkAvailable: function() {
        return this.onTouchBegan ? !0 : (cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable), !1)
    }
}), cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one", cc._EventListenerTouchOneByOne.create = function() {
    return new cc._EventListenerTouchOneByOne
}, cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
    onTouchesBegan: null,
    onTouchesMoved: null,
    onTouchesEnded: null,
    onTouchesCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null)
    },
    clone: function() {
        var a = new cc._EventListenerTouchAllAtOnce;
        return a.onTouchesBegan = this.onTouchesBegan, a.onTouchesMoved = this.onTouchesMoved, a.onTouchesEnded = this.onTouchesEnded, a.onTouchesCancelled = this.onTouchesCancelled, a
    },
    checkAvailable: function() {
        return null == this.onTouchesBegan && null == this.onTouchesMoved && null == this.onTouchesEnded && null == this.onTouchesCancelled ? (cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable), !1) : !0
    }
}), cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once", cc._EventListenerTouchAllAtOnce.create = function() {
    return new cc._EventListenerTouchAllAtOnce
}, cc.EventListener.create = function(a) {
    cc.assert(a && a.event, cc._LogInfos.EventListener_create);
    var b = a.event;
    delete a.event;
    var c = null;
    b === cc.EventListener.TOUCH_ONE_BY_ONE ? c = new cc._EventListenerTouchOneByOne : b === cc.EventListener.TOUCH_ALL_AT_ONCE ? c = new cc._EventListenerTouchAllAtOnce : b === cc.EventListener.MOUSE ? c = new cc._EventListenerMouse : b === cc.EventListener.CUSTOM ? (c = new cc._EventListenerCustom(a.eventName, a.callback), delete a.eventName, delete a.callback) : b === cc.EventListener.KEYBOARD ? c = new cc._EventListenerKeyboard : b === cc.EventListener.ACCELERATION && (c = new cc._EventListenerAcceleration(a.callback), delete a.callback);
    for (var d in a) c[d] = a[d];
    return c
}, cc._EventListenerVector = cc.Class.extend({
    _fixedListeners: null,
    _sceneGraphListeners: null,
    gt0Index: 0,
    ctor: function() {
        this._fixedListeners = [], this._sceneGraphListeners = []
    },
    size: function() {
        return this._fixedListeners.length + this._sceneGraphListeners.length
    },
    empty: function() {
        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length
    },
    push: function(a) {
        0 == a._getFixedPriority() ? this._sceneGraphListeners.push(a) : this._fixedListeners.push(a)
    },
    clearSceneGraphListeners: function() {
        this._sceneGraphListeners.length = 0
    },
    clearFixedListeners: function() {
        this._fixedListeners.length = 0
    },
    clear: function() {
        this._sceneGraphListeners.length = 0, this._fixedListeners.length = 0
    },
    getFixedPriorityListeners: function() {
        return this._fixedListeners
    },
    getSceneGraphPriorityListeners: function() {
        return this._sceneGraphListeners
    }
}), cc.__getListenerID = function(a) {
    var b = cc.Event,
        c = a.getType();
    return c === b.ACCELERATION ? cc._EventListenerAcceleration.LISTENER_ID : c === b.CUSTOM ? a.getEventName() : c === b.KEYBOARD ? cc._EventListenerKeyboard.LISTENER_ID : c === b.MOUSE ? cc._EventListenerMouse.LISTENER_ID : (c === b.TOUCH && cc.log(cc._LogInfos.__getListenerID), "")
}, cc.eventManager = {
    DIRTY_NONE: 0,
    DIRTY_FIXED_PRIORITY: 1,
    DIRTY_SCENE_GRAPH_PRIORITY: 2,
    DIRTY_ALL: 3,
    _listenersMap: {},
    _priorityDirtyFlagMap: {},
    _nodeListenersMap: {},
    _nodePriorityMap: {},
    _globalZOrderNodeMap: {},
    _toAddedListeners: [],
    _dirtyNodes: [],
    _inDispatch: 0,
    _isEnabled: !1,
    _nodePriorityIndex: 0,
    _internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
    _setDirtyForNode: function(a) {
        null != this._nodeListenersMap[a.__instanceId] && this._dirtyNodes.push(a), a = a.getChildren();
        for (var b = 0, c = a.length; c > b; b++) this._setDirtyForNode(a[b])
    },
    pauseTarget: function(a, b) {
        var c, d, e = this._nodeListenersMap[a.__instanceId];
        if (e)
            for (c = 0, d = e.length; d > c; c++) e[c]._setPaused(!0);
        if (!0 === b)
            for (e = a.getChildren(), c = 0, d = e.length; d > c; c++) this.pauseTarget(e[c], !0)
    },
    resumeTarget: function(a, b) {
        var c, d, e = this._nodeListenersMap[a.__instanceId];
        if (e)
            for (c = 0, d = e.length; d > c; c++) e[c]._setPaused(!1);
        if (this._setDirtyForNode(a), !0 === b)
            for (e = a.getChildren(), c = 0, d = e.length; d > c; c++) this.resumeTarget(e[c], !0)
    },
    _addListener: function(a) {
        0 === this._inDispatch ? this._forceAddEventListener(a) : this._toAddedListeners.push(a)
    },
    _forceAddEventListener: function(a) {
        var b = a._getListenerID(),
            c = this._listenersMap[b];
        c || (c = new cc._EventListenerVector, this._listenersMap[b] = c), c.push(a), 0 == a._getFixedPriority() ? (this._setDirty(b, this.DIRTY_SCENE_GRAPH_PRIORITY), b = a._getSceneGraphPriority(), null == b && cc.log(cc._LogInfos.eventManager__forceAddEventListener), this._associateNodeAndEventListener(b, a), b.isRunning() && this.resumeTarget(b)) : this._setDirty(b, this.DIRTY_FIXED_PRIORITY)
    },
    _getListeners: function(a) {
        return this._listenersMap[a]
    },
    _updateDirtyFlagForSceneGraph: function() {
        if (0 != this._dirtyNodes.length) {
            for (var a, b, c = this._dirtyNodes, d = this._nodeListenersMap, e = 0, f = c.length; f > e; e++)
                if (a = d[c[e].__instanceId])
                    for (var g = 0, h = a.length; h > g; g++)(b = a[g]) && this._setDirty(b._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
            this._dirtyNodes.length = 0
        }
    },
    _removeAllListenersInVector: function(a) {
        if (a)
            for (var b, c = 0; c < a.length;) b = a[c], b._setRegistered(!1), null != b._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(b._getSceneGraphPriority(), b), b._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.arrayRemoveObject(a, b) : ++c
    },
    _removeListenersForListenerID: function(a) {
        var b = this._listenersMap[a];
        if (b) {
            var c = b.getFixedPriorityListeners(),
                d = b.getSceneGraphPriorityListeners();
            this._removeAllListenersInVector(d), this._removeAllListenersInVector(c), delete this._priorityDirtyFlagMap[a], this._inDispatch || (b.clear(), delete this._listenersMap[a])
        }
        for (c = this._toAddedListeners, b = 0; b < c.length;)(d = c[b]) && d._getListenerID() == a ? cc.arrayRemoveObject(c, d) : ++b
    },
    _sortEventListeners: function(a) {
        var b = this.DIRTY_NONE,
            c = this._priorityDirtyFlagMap;
        c[a] && (b = c[a]), b != this.DIRTY_NONE && (c[a] = this.DIRTY_NONE, b & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(a), b & this.DIRTY_SCENE_GRAPH_PRIORITY && ((b = cc.director.getRunningScene()) ? this._sortListenersOfSceneGraphPriority(a, b) : c[a] = this.DIRTY_SCENE_GRAPH_PRIORITY))
    },
    _sortListenersOfSceneGraphPriority: function(a, b) {
        var c = this._getListeners(a);
        if (c) {
            var d = c.getSceneGraphPriorityListeners();
            d && 0 !== d.length && (this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(b, !0), c.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes))
        }
    },
    _sortEventListenersOfSceneGraphPriorityDes: function(a, b) {
        var c = cc.eventManager._nodePriorityMap;
        return a && b && a._getSceneGraphPriority() && b._getSceneGraphPriority() ? c[b._getSceneGraphPriority().__instanceId] - c[a._getSceneGraphPriority().__instanceId] : -1
    },
    _sortListenersOfFixedPriority: function(a) {
        if (a = this._listenersMap[a]) {
            var b = a.getFixedPriorityListeners();
            if (b && 0 !== b.length) {
                b.sort(this._sortListenersOfFixedPriorityAsc);
                for (var c = 0, d = b.length; d > c && !(0 <= b[c]._getFixedPriority());)++c;
                a.gt0Index = c
            }
        }
    },
    _sortListenersOfFixedPriorityAsc: function(a, b) {
        return a._getFixedPriority() - b._getFixedPriority()
    },
    _onUpdateListeners: function(a) {
        if (a = this._listenersMap[a]) {
            var b, c, d = a.getFixedPriorityListeners(),
                e = a.getSceneGraphPriorityListeners();
            if (e)
                for (b = 0; b < e.length;) c = e[b], c._isRegistered() ? ++b : cc.arrayRemoveObject(e, c);
            if (d)
                for (b = 0; b < d.length;) c = d[b], c._isRegistered() ? ++b : cc.arrayRemoveObject(d, c);
            e && 0 === e.length && a.clearSceneGraphListeners(), d && 0 === d.length && a.clearFixedListeners()
        }
    },
    _updateListeners: function(a) {
        var b = this._inDispatch;
        if (cc.assert(b > 0, cc._LogInfos.EventManager__updateListeners), a.getType() == cc.Event.TOUCH ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(a)), !(b > 1)) {
            cc.assert(1 == b, cc._LogInfos.EventManager__updateListeners_2), a = this._listenersMap;
            var c, b = this._priorityDirtyFlagMap;
            for (c in a) a[c].empty() && (delete b[c], delete a[c]);
            if (c = this._toAddedListeners, 0 !== c.length) {
                for (a = 0, b = c.length; b > a; a++) this._forceAddEventListener(c[a]);
                this._toAddedListeners.length = 0
            }
        }
    },
    _onTouchEventCallback: function(a, b) {
        if (!a._isRegistered) return !1;
        var c = b.event,
            d = b.selTouch;
        c._setCurrentTarget(a._node);
        var e, f = !1,
            g = c.getEventCode(),
            h = cc.EventTouch.EventCode;
        return g == h.BEGAN ? a.onTouchBegan && (f = a.onTouchBegan(d, c)) && a._registered && a._claimedTouches.push(d) : 0 < a._claimedTouches.length && -1 != (e = a._claimedTouches.indexOf(d)) && (f = !0, g === h.MOVED && a.onTouchMoved ? a.onTouchMoved(d, c) : g === h.ENDED ? (a.onTouchEnded && a.onTouchEnded(d, c), a._registered && a._claimedTouches.splice(e, 1)) : g === h.CANCELLED && (a.onTouchCancelled && a.onTouchCancelled(d, c), a._registered && a._claimedTouches.splice(e, 1))), c.isStopped() ? (cc.eventManager._updateListeners(c), !0) : f && a._registered && a.swallowTouches ? (b.needsMutableSet && b.touches.splice(d, 1), !0) : !1
    },
    _dispatchTouchEvent: function(a) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var b = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID),
            c = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (null != b || null != c) {
            var d = a.getTouches(),
                e = cc.copyArray(d),
                f = {
                    event: a,
                    needsMutableSet: b && c,
                    touches: e,
                    selTouch: null
                };
            if (b)
                for (var g = 0; g < d.length; g++)
                    if (f.selTouch = d[g], this._dispatchEventToListeners(b, this._onTouchEventCallback, f), a.isStopped()) return;
            if (c && 0 < e.length && (this._dispatchEventToListeners(c, this._onTouchesEventCallback, {
                event: a,
                touches: e
            }), a.isStopped())) return;
            this._updateListeners(a)
        }
    },
    _onTouchesEventCallback: function(a, b) {
        if (!a._registered) return !1;
        var c = cc.EventTouch.EventCode,
            d = b.event,
            e = b.touches,
            f = d.getEventCode();
        return d._setCurrentTarget(a._node), f == c.BEGAN && a.onTouchesBegan ? a.onTouchesBegan(e, d) : f == c.MOVED && a.onTouchesMoved ? a.onTouchesMoved(e, d) : f == c.ENDED && a.onTouchesEnded ? a.onTouchesEnded(e, d) : f == c.CANCELLED && a.onTouchesCancelled && a.onTouchesCancelled(e, d), d.isStopped() ? (cc.eventManager._updateListeners(d), !0) : !1
    },
    _associateNodeAndEventListener: function(a, b) {
        var c = this._nodeListenersMap[a.__instanceId];
        c || (c = [], this._nodeListenersMap[a.__instanceId] = c), c.push(b)
    },
    _dissociateNodeAndEventListener: function(a, b) {
        var c = this._nodeListenersMap[a.__instanceId];
        c && (cc.arrayRemoveObject(c, b), 0 === c.length && delete this._nodeListenersMap[a.__instanceId])
    },
    _dispatchEventToListeners: function(a, b, c) {
        var d, e = !1,
            f = a.getFixedPriorityListeners(),
            g = a.getSceneGraphPriorityListeners(),
            h = 0;
        if (f && 0 !== f.length)
            for (; h < a.gt0Index; ++h)
                if (d = f[h], d.isEnabled() && !d._isPaused() && d._isRegistered() && b(d, c)) {
                    e = !0;
                    break
                }
        if (g && !e)
            for (a = 0; a < g.length; a++)
                if (d = g[a], d.isEnabled() && !d._isPaused() && d._isRegistered() && b(d, c)) {
                    e = !0;
                    break
                }
        if (f && !e)
            for (; h < f.length && (d = f[h], !(d.isEnabled() && !d._isPaused() && d._isRegistered() && b(d, c))); ++h);
    },
    _setDirty: function(a, b) {
        var c = this._priorityDirtyFlagMap;
        c[a] = null == c[a] ? b : b | c[a]
    },
    _visitTarget: function(a, b) {
        var c = a.getChildren(),
            d = 0,
            e = c.length,
            f = this._globalZOrderNodeMap,
            g = this._nodeListenersMap;
        if (e > 0) {
            for (var h; e > d && ((h = c[d]) && 0 > h.getLocalZOrder()); d++) this._visitTarget(h, !1);
            for (null != g[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId)); e > d; d++)(h = c[d]) && this._visitTarget(h, !1)
        } else null != g[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId)); if (b) {
            var i, c = [];
            for (i in f) c.push(i);
            for (c.sort(this._sortNumberAsc), i = c.length, h = this._nodePriorityMap, d = 0; i > d; d++)
                for (e = f[c[d]], g = 0; g < e.length; g++) h[e[g]] = ++this._nodePriorityIndex;
            this._globalZOrderNodeMap = {}
        }
    },
    _sortNumberAsc: function(a, b) {
        return a - b
    },
    addListener: function(a, b) {
        if (cc.assert(a && b, cc._LogInfos.eventManager_addListener_2), a instanceof cc.EventListener) {
            if (a._isRegistered()) return void cc.log(cc._LogInfos.eventManager_addListener_4)
        } else cc.assert("number" != typeof b, cc._LogInfos.eventManager_addListener_3), a = cc.EventListener.create(a);
        a.checkAvailable() && ("number" == typeof b ? 0 == b ? cc.log(cc._LogInfos.eventManager_addListener) : (a._setSceneGraphPriority(null), a._setFixedPriority(b), a._setRegistered(!0), a._setPaused(!1), this._addListener(a)) : (a._setSceneGraphPriority(b), a._setFixedPriority(0), a._setRegistered(!0), this._addListener(a)))
    },
    addCustomListener: function(a, b) {
        var c = cc._EventListenerCustom.create(a, b);
        return this.addListener(c, 1), c
    },
    removeListener: function(a) {
        if (null != a) {
            var b, c, d = this._listenersMap;
            for (c in d) {
                var e = d[c],
                    f = e.getFixedPriorityListeners();
                if (b = e.getSceneGraphPriorityListeners(), (b = this._removeListenerInVector(b, a)) ? this._setDirty(a._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY) : (b = this._removeListenerInVector(f, a)) && this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY), e.empty() && (delete this._priorityDirtyFlagMap[a._getListenerID()], delete d[c]), b) break
            }
            if (!b)
                for (d = this._toAddedListeners, c = 0, e = d.length; e > c; c++)
                    if (f = d[c], f == a) {
                        cc.arrayRemoveObject(d, f);
                        break
                    }
        }
    },
    _removeListenerInVector: function(a, b) {
        if (null == a) return !1;
        for (var c = 0, d = a.length; d > c; c++) {
            var e = a[c];
            if (e == b) return e._setRegistered(!1), null != e._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(e._getSceneGraphPriority(), e), e._setSceneGraphPriority(null)), 0 == this._inDispatch && cc.arrayRemoveObject(a, e), !0
        }
        return !1
    },
    removeListeners: function(a, b) {
        if (a instanceof cc.Node) {
            delete this._nodePriorityMap[a.__instanceId], cc.arrayRemoveObject(this._dirtyNodes, a);
            var c = this._nodeListenersMap[a.__instanceId];
            if (c) {
                for (var d = cc.copyArray(c), c = 0; c < d.length; c++) this.removeListener(d[c]);
                d.length = 0
            }
            for (d = this._toAddedListeners, c = 0; c < d.length;) {
                var e = d[c];
                e._getSceneGraphPriority() == a ? (e._setSceneGraphPriority(null), e._setRegistered(!1), d.splice(c, 1)) : ++c
            }
            if (!0 === b)
                for (d = a.getChildren(), c = 0, e = d.length; e > c; c++) this.removeListeners(d[c], !0)
        } else a == cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : a == cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : a == cc.EventListener.MOUSE ? this._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : a == cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : a == cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log(cc._LogInfos.eventManager_removeListeners)
    },
    removeCustomListeners: function(a) {
        this._removeListenersForListenerID(a)
    },
    removeAllListeners: function() {
        var a, b = this._listenersMap,
            c = this._internalCustomListenerIDs;
        for (a in b) - 1 === c.indexOf(a) && this._removeListenersForListenerID(a)
    },
    setPriority: function(a, b) {
        if (null != a) {
            var c, d = this._listenersMap;
            for (c in d) {
                var e = d[c].getFixedPriorityListeners();
                if (e && -1 != e.indexOf(a)) {
                    null != a._getSceneGraphPriority() && cc.log(cc._LogInfos.eventManager_setPriority), a._getFixedPriority() !== b && (a._setFixedPriority(b), this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY));
                    break
                }
            }
        }
    },
    setEnabled: function(a) {
        this._isEnabled = a
    },
    isEnabled: function() {
        return this._isEnabled
    },
    dispatchEvent: function(a) {
        if (this._isEnabled) {
            if (this._updateDirtyFlagForSceneGraph(), this._inDispatch++, !a || !a.getType) throw "event is undefined";
            if (a.getType() == cc.Event.TOUCH) this._dispatchTouchEvent(a);
            else {
                var b = cc.__getListenerID(a);
                this._sortEventListeners(b), b = this._listenersMap[b], null != b && this._dispatchEventToListeners(b, this._onListenerCallback, a), this._updateListeners(a)
            }
            this._inDispatch--
        }
    },
    _onListenerCallback: function(a, b) {
        return b._setCurrentTarget(a._getSceneGraphPriority()), a._onEvent(b), b.isStopped()
    },
    dispatchCustomEvent: function(a, b) {
        var c = new cc.EventCustom(a);
        c.setUserData(b), this.dispatchEvent(c)
    }
}, cc.EventAcceleration = cc.Event.extend({
    _acc: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION), this._acc = a
    }
}), cc.EventKeyboard = cc.Event.extend({
    _keyCode: 0,
    _isPressed: !1,
    ctor: function(a, b) {
        cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD), this._keyCode = a, this._isPressed = b
    }
}), cc._EventListenerAcceleration = cc.EventListener.extend({
    _onAccelerationEvent: null,
    ctor: function(a) {
        this._onAccelerationEvent = a;
        var b = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, function(a) {
            b._onAccelerationEvent(a._acc, a)
        })
    },
    checkAvailable: function() {
        return cc.assert(this._onAccelerationEvent, cc._LogInfos._EventListenerAcceleration_checkAvailable), !0
    },
    clone: function() {
        return new cc._EventListenerAcceleration(this._onAccelerationEvent)
    }
}), cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration", cc._EventListenerAcceleration.create = function(a) {
    return new cc._EventListenerAcceleration(a)
}, cc._EventListenerKeyboard = cc.EventListener.extend({
    onKeyPressed: null,
    onKeyReleased: null,
    ctor: function() {
        var a = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, function(b) {
            b._isPressed ? a.onKeyPressed && a.onKeyPressed(b._keyCode, b) : a.onKeyReleased && a.onKeyReleased(b._keyCode, b)
        })
    },
    clone: function() {
        var a = new cc._EventListenerKeyboard;
        return a.onKeyPressed = this.onKeyPressed, a.onKeyReleased = this.onKeyReleased, a
    },
    checkAvailable: function() {
        return null == this.onKeyPressed && null == this.onKeyReleased ? (cc.log(cc._LogInfos._EventListenerKeyboard_checkAvailable), !1) : !0
    }
}), cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard", cc._EventListenerKeyboard.create = function() {
    return new cc._EventListenerKeyboard
}, cc._tmp.WebGLCCNode = function() {
    var a = cc.Node.prototype;
    a._transform4x4 = null, a._stackMatrix = null, a._glServerState = null, a._camera = null, a.ctor = function() {
        this._initNode();
        var a = new cc.kmMat4;
        a.mat[2] = a.mat[3] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[14] = 0, a.mat[10] = a.mat[15] = 1, this._transform4x4 = a, this._glServerState = 0, this._stackMatrix = new cc.kmMat4
    }, a.setNodeDirty = function() {
        !1 === this._transformDirty && (this._transformDirty = this._inverseDirty = !0)
    }, a.visit = function() {
        if (this._visible) {
            var a, b = cc._renderContext,
                c = cc.current_stack;
            c.stack.push(c.top), cc.kmMat4Assign(this._stackMatrix, c.top), c.top = this._stackMatrix;
            var d = this.grid;
            d && d._active && d.beforeDraw(), this.transform();
            var e = this._children;
            if (e && 0 < e.length) {
                var f = e.length;
                for (this.sortAllChildren(), a = 0; f > a && (e[a] && 0 > e[a]._localZOrder); a++) e[a].visit();
                for (this.draw(b); f > a; a++) e[a] && e[a].visit()
            } else this.draw(b);
            this.arrivalOrder = 0, d && d._active && d.afterDraw(this), c.top = c.stack.pop()
        }
    }, a.transform = function() {
        var a = this._transform4x4,
            b = cc.current_stack.top,
            c = this.nodeToParentTransform(),
            d = a.mat;
        d[0] = c.a, d[4] = c.c, d[12] = c.tx, d[1] = c.b, d[5] = c.d, d[13] = c.ty, d[14] = this._vertexZ, cc.kmMat4Multiply(b, b, a), null != this._camera && !(null != this.grid && this.grid.isActive()) && (a = this._anchorPointInPoints.x, b = this._anchorPointInPoints.y, 0 !== a || 0 !== b ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (a |= 0, b |= 0), cc.kmGLTranslatef(a, b, 0), this._camera.locate(), cc.kmGLTranslatef(-a, -b, 0)) : this._camera.locate())
    }, a.getNodeToParentTransform = a._getNodeToParentTransformForWebGL
}, cc._tmp.PrototypeCCNode = function() {
    var a = cc.Node.prototype;
    cc.defineGetterSetter(a, "x", a.getPositionX, a.setPositionX), cc.defineGetterSetter(a, "y", a.getPositionY, a.setPositionY), cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth), cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight), cc.defineGetterSetter(a, "anchorX", a._getAnchorX, a._setAnchorX), cc.defineGetterSetter(a, "anchorY", a._getAnchorY, a._setAnchorY), cc.defineGetterSetter(a, "skewX", a.getSkewX, a.setSkewX), cc.defineGetterSetter(a, "skewY", a.getSkewY, a.setSkewY), cc.defineGetterSetter(a, "zIndex", a.getLocalZOrder, a.setLocalZOrder), cc.defineGetterSetter(a, "vertexZ", a.getVertexZ, a.setVertexZ), cc.defineGetterSetter(a, "rotation", a.getRotation, a.setRotation), cc.defineGetterSetter(a, "rotationX", a.getRotationX, a.setRotationX), cc.defineGetterSetter(a, "rotationY", a.getRotationY, a.setRotationY), cc.defineGetterSetter(a, "scale", a.getScale, a.setScale), cc.defineGetterSetter(a, "scaleX", a.getScaleX, a.setScaleX), cc.defineGetterSetter(a, "scaleY", a.getScaleY, a.setScaleY), cc.defineGetterSetter(a, "children", a.getChildren), cc.defineGetterSetter(a, "childrenCount", a.getChildrenCount), cc.defineGetterSetter(a, "parent", a.getParent, a.setParent), cc.defineGetterSetter(a, "visible", a.isVisible, a.setVisible), cc.defineGetterSetter(a, "running", a.isRunning), cc.defineGetterSetter(a, "ignoreAnchor", a.isIgnoreAnchorPointForPosition, a.ignoreAnchorPointForPosition), cc.defineGetterSetter(a, "actionManager", a.getActionManager, a.setActionManager), cc.defineGetterSetter(a, "scheduler", a.getScheduler, a.setScheduler), cc.defineGetterSetter(a, "shaderProgram", a.getShaderProgram, a.setShaderProgram), cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity), cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB), cc.defineGetterSetter(a, "cascadeOpacity", a.isCascadeOpacityEnabled, a.setCascadeOpacityEnabled), cc.defineGetterSetter(a, "color", a.getColor, a.setColor), cc.defineGetterSetter(a, "cascadeColor", a.isCascadeColorEnabled, a.setCascadeColorEnabled)
}, cc.NODE_TAG_INVALID = -1, cc.s_globalOrderOfArrival = 1, cc.Node = cc.Class.extend({
    _localZOrder: 0,
    _globalZOrder: 0,
    _vertexZ: 0,
    _rotationX: 0,
    _rotationY: 0,
    _scaleX: 1,
    _scaleY: 1,
    _position: null,
    _skewX: 0,
    _skewY: 0,
    _children: null,
    _visible: !0,
    _anchorPoint: null,
    _anchorPointInPoints: null,
    _contentSize: null,
    _running: !1,
    _parent: null,
    _ignoreAnchorPointForPosition: !1,
    tag: cc.NODE_TAG_INVALID,
    userData: null,
    userObject: null,
    _transformDirty: !0,
    _inverseDirty: !0,
    _cacheDirty: !0,
    _cachedParent: null,
    _transformGLDirty: null,
    _transform: null,
    _inverse: null,
    _reorderChildDirty: !1,
    _shaderProgram: null,
    arrivalOrder: 0,
    _actionManager: null,
    _scheduler: null,
    _eventDispatcher: null,
    _initializedNode: !1,
    _additionalTransformDirty: !1,
    _additionalTransform: null,
    _componentContainer: null,
    _isTransitionFinished: !1,
    _rotationRadiansX: 0,
    _rotationRadiansY: 0,
    _className: "Node",
    _showNode: !1,
    _name: "",
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeColorEnabled: !1,
    _cascadeOpacityEnabled: !1,
    _usingNormalizedPosition: !1,
    _hashOfName: 0,
    _initNode: function() {
        this._anchorPoint = cc.p(0, 0), this._anchorPointInPoints = cc.p(0, 0), this._contentSize = cc.size(0, 0), this._position = cc.p(0, 0), this._children = [], this._transform = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            tx: 0,
            ty: 0
        };
        var a = cc.director;
        this._actionManager = a.getActionManager(), this._scheduler = a.getScheduler(), this._initializedNode = !0, this._additionalTransform = cc.affineTransformMakeIdentity(), cc.ComponentContainer && (this._componentContainer = new cc.ComponentContainer(this)), this._realOpacity = this._displayedOpacity = 255, this._displayedColor = cc.color(255, 255, 255, 255), this._realColor = cc.color(255, 255, 255, 255), this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1
    },
    init: function() {
        return !1 === this._initializedNode && this._initNode(), !0
    },
    _arrayMakeObjectsPerformSelector: function(a, b) {
        if (a && 0 !== a.length) {
            var c, d, e = a.length;
            switch (c = cc.Node._StateCallbackType, b) {
                case c.onEnter:
                    for (c = 0; e > c; c++)(d = a[c]) && d.onEnter();
                    break;
                case c.onExit:
                    for (c = 0; e > c; c++)(d = a[c]) && d.onExit();
                    break;
                case c.onEnterTransitionDidFinish:
                    for (c = 0; e > c; c++)(d = a[c]) && d.onEnterTransitionDidFinish();
                    break;
                case c.cleanup:
                    for (c = 0; e > c; c++)(d = a[c]) && d.cleanup();
                    break;
                case c.updateTransform:
                    for (c = 0; e > c; c++)(d = a[c]) && d.updateTransform();
                    break;
                case c.onExitTransitionDidStart:
                    for (c = 0; e > c; c++)(d = a[c]) && d.onExitTransitionDidStart();
                    break;
                case c.sortAllChildren:
                    for (c = 0; e > c; c++)(d = a[c]) && d.sortAllChildren();
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector)
            }
        }
    },
    setNodeDirty: null,
    attr: function(a) {
        for (var b in a) this[b] = a[b]
    },
    getSkewX: function() {
        return this._skewX
    },
    setSkewX: function(a) {
        this._skewX = a, this.setNodeDirty()
    },
    getSkewY: function() {
        return this._skewY
    },
    setSkewY: function(a) {
        this._skewY = a, this.setNodeDirty()
    },
    setLocalZOrder: function(a) {
        this._localZOrder = a, this._parent && this._parent.reorderChild(this, a), cc.eventManager._setDirtyForNode(this)
    },
    _setLocalZOrder: function(a) {
        this._localZOrder = a
    },
    getLocalZOrder: function() {
        return this._localZOrder
    },
    getZOrder: function() {
        return cc.log(cc._LogInfos.Node_getZOrder), this.getLocalZOrder()
    },
    setZOrder: function(a) {
        cc.log(cc._LogInfos.Node_setZOrder), this.setLocalZOrder(a)
    },
    setGlobalZOrder: function(a) {
        this._globalZOrder != a && (this._globalZOrder = a, cc.eventManager._setDirtyForNode(this))
    },
    getGlobalZOrder: function() {
        return this._globalZOrder
    },
    getVertexZ: function() {
        return this._vertexZ
    },
    setVertexZ: function(a) {
        this._vertexZ = a
    },
    getRotation: function() {
        return this._rotationX !== this._rotationY && cc.log(cc._LogInfos.Node_getRotation), this._rotationX
    },
    setRotation: function(a) {
        this._rotationX = this._rotationY = a, this._rotationRadiansX = .017453292519943295 * this._rotationX, this._rotationRadiansY = .017453292519943295 * this._rotationY, this.setNodeDirty()
    },
    getRotationX: function() {
        return this._rotationX
    },
    setRotationX: function(a) {
        this._rotationX = a, this._rotationRadiansX = .017453292519943295 * this._rotationX, this.setNodeDirty()
    },
    getRotationY: function() {
        return this._rotationY
    },
    setRotationY: function(a) {
        this._rotationY = a, this._rotationRadiansY = .017453292519943295 * this._rotationY, this.setNodeDirty()
    },
    getScale: function() {
        return this._scaleX !== this._scaleY && cc.log(cc._LogInfos.Node_getScale), this._scaleX
    },
    setScale: function(a, b) {
        this._scaleX = a, this._scaleY = b || 0 === b ? b : a, this.setNodeDirty()
    },
    getScaleX: function() {
        return this._scaleX
    },
    setScaleX: function(a) {
        this._scaleX = a, this.setNodeDirty()
    },
    getScaleY: function() {
        return this._scaleY
    },
    setScaleY: function(a) {
        this._scaleY = a, this.setNodeDirty()
    },
    setPosition: function(a, b) {
        var c = this._position;
        void 0 === b ? (c.x = a.x, c.y = a.y) : (c.x = a, c.y = b), this.setNodeDirty()
    },
    getPosition: function() {
        return cc.p(this._position)
    },
    getPositionX: function() {
        return this._position.x
    },
    setPositionX: function(a) {
        this._position.x = a, this.setNodeDirty()
    },
    getPositionY: function() {
        return this._position.y
    },
    setPositionY: function(a) {
        this._position.y = a, this.setNodeDirty()
    },
    getChildrenCount: function() {
        return this._children.length
    },
    getChildren: function() {
        return this._children
    },
    isVisible: function() {
        return this._visible
    },
    setVisible: function(a) {
        this._visible != a && (this._visible = a) && this.setNodeDirty()
    },
    getAnchorPoint: function() {
        return cc.p(this._anchorPoint)
    },
    setAnchorPoint: function(a, b) {
        var c = this._anchorPoint;
        if (void 0 === b) {
            if (a.x === c.x && a.y === c.y) return;
            c.x = a.x, c.y = a.y
        } else {
            if (a === c.x && b === c.y) return;
            c.x = a, c.y = b
        }
        var d = this._anchorPointInPoints,
            e = this._contentSize;
        d.x = e.width * c.x, d.y = e.height * c.y, this.setNodeDirty()
    },
    _getAnchor: function() {
        return this._anchorPoint
    },
    _setAnchor: function(a) {
        var b = a.x;
        a = a.y, this._anchorPoint.x !== b && (this._anchorPoint.x = b, this._anchorPointInPoints.x = this._contentSize.width * b), this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._anchorPointInPoints.y = this._contentSize.height * a), this.setNodeDirty()
    },
    _getAnchorX: function() {
        return this._anchorPoint.x
    },
    _setAnchorX: function(a) {
        this._anchorPoint.x !== a && (this._anchorPoint.x = a, this._anchorPointInPoints.x = this._contentSize.width * a, this.setNodeDirty())
    },
    _getAnchorY: function() {
        return this._anchorPoint.y
    },
    _setAnchorY: function(a) {
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._anchorPointInPoints.y = this._contentSize.height * a, this.setNodeDirty())
    },
    getAnchorPointInPoints: function() {
        return cc.p(this._anchorPointInPoints)
    },
    _getWidth: function() {
        return this._contentSize.width
    },
    _setWidth: function(a) {
        this._contentSize.width = a, this._anchorPointInPoints.x = a * this._anchorPoint.x, this.setNodeDirty()
    },
    _getHeight: function() {
        return this._contentSize.height
    },
    _setHeight: function(a) {
        this._contentSize.height = a, this._anchorPointInPoints.y = a * this._anchorPoint.y, this.setNodeDirty()
    },
    getContentSize: function() {
        return cc.size(this._contentSize)
    },
    setContentSize: function(a, b) {
        var c = this._contentSize;
        if (void 0 === b) {
            if (a.width === c.width && a.height === c.height) return;
            c.width = a.width, c.height = a.height
        } else {
            if (a === c.width && b === c.height) return;
            c.width = a, c.height = b
        }
        var d = this._anchorPointInPoints,
            e = this._anchorPoint;
        d.x = c.width * e.x, d.y = c.height * e.y, this.setNodeDirty()
    },
    isRunning: function() {
        return this._running
    },
    getParent: function() {
        return this._parent
    },
    setParent: function(a) {
        this._parent = a
    },
    isIgnoreAnchorPointForPosition: function() {
        return this._ignoreAnchorPointForPosition
    },
    ignoreAnchorPointForPosition: function(a) {
        a != this._ignoreAnchorPointForPosition && (this._ignoreAnchorPointForPosition = a, this.setNodeDirty())
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(a) {
        this.tag = a
    },
    setName: function(a) {
        this._name = a
    },
    getName: function() {
        return this._name
    },
    getUserData: function() {
        return this.userData
    },
    setUserData: function(a) {
        this.userData = a
    },
    getUserObject: function() {
        return this.userObject
    },
    setUserObject: function(a) {
        this.userObject != a && (this.userObject = a)
    },
    getOrderOfArrival: function() {
        return this.arrivalOrder
    },
    setOrderOfArrival: function(a) {
        0 / 0 == this.arrivalOrder, this.arrivalOrder = a
    },
    getActionManager: function() {
        return this._actionManager || (this._actionManager = cc.director.getActionManager()), this._actionManager
    },
    setActionManager: function(a) {
        this._actionManager != a && (this.stopAllActions(), this._actionManager = a)
    },
    getScheduler: function() {
        return this._scheduler || (this._scheduler = cc.director.getScheduler()), this._scheduler
    },
    setScheduler: function(a) {
        this._scheduler != a && (this.unscheduleAllCallbacks(), this._scheduler = a)
    },
    boundingBox: function() {
        return cc.log(cc._LogInfos.Node_boundingBox), this.getBoundingBox()
    },
    getBoundingBox: function() {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._rectApplyAffineTransformIn(a, this.getNodeToParentTransform())
    },
    cleanup: function() {
        this.stopAllActions(), this.unscheduleAllCallbacks(), cc.eventManager.removeListeners(this), this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.cleanup)
    },
    getChildByTag: function(a) {
        var b = this._children;
        if (null != b)
            for (var c = 0; c < b.length; c++) {
                var d = b[c];
                if (d && d.tag == a) return d
            }
        return null
    },
    getChildByName: function(a) {
        if (!a) return cc.log("Invalid name"), null;
        for (var b = this._children, c = 0, d = b.length; d > c; c++)
            if (b[c]._name == a) return b[c];
        return null
    },
    addChild: function(a, b, c) {
        b = void 0 === b ? a._localZOrder : b;
        var d, e = !1;
        switch (typeof c) {
            case "undefined":
                c = void 0, d = a._name;
                break;
            case "string":
                d = c, c = void 0;
                break;
            case "number":
                e = !0, d = ""
        }
        cc.assert(a, cc._LogInfos.Node_addChild_3), cc.assert(null === a._parent, "child already added. It can't be added again"), this._addChildHelper(a, b, c, d, e)
    },
    _addChildHelper: function(a, b, c, d, e) {
        this._children || (this._children = []), this._insertChild(a, b), e ? a.setTag(c) : a.setName(d), a.setParent(this), a.setOrderOfArrival(cc.s_globalOrderOfArrival++), this._running && (a.onEnter(), this._isTransitionFinished) && a.onEnterTransitionDidFinish(), this._cascadeColorEnabled && this._enableCascadeColor(), this._cascadeOpacityEnabled && this._enableCascadeOpacity()
    },
    removeFromParent: function(a) {
        this._parent && (null == a && (a = !0), this._parent.removeChild(this, a))
    },
    removeFromParentAndCleanup: function(a) {
        cc.log(cc._LogInfos.Node_removeFromParentAndCleanup), this.removeFromParent(a)
    },
    removeChild: function(a, b) {
        0 !== this._children.length && (null == b && (b = !0), -1 < this._children.indexOf(a) && this._detachChild(a, b), this.setNodeDirty())
    },
    removeChildByTag: function(a, b) {
        a === cc.NODE_TAG_INVALID && cc.log(cc._LogInfos.Node_removeChildByTag);
        var c = this.getChildByTag(a);
        null == c ? cc.log(cc._LogInfos.Node_removeChildByTag_2, a) : this.removeChild(c, b)
    },
    removeAllChildrenWithCleanup: function(a) {
        cc.log(cc._LogInfos.Node_removeAllChildrenWithCleanup), this.removeAllChildren(a)
    },
    removeAllChildren: function(a) {
        var b = this._children;
        if (null != b) {
            null == a && (a = !0);
            for (var c = 0; c < b.length; c++) {
                var d = b[c];
                d && (this._running && (d.onExitTransitionDidStart(), d.onExit()), a && d.cleanup(), d.parent = null)
            }
            this._children.length = 0
        }
    },
    _detachChild: function(a, b) {
        this._running && (a.onExitTransitionDidStart(), a.onExit()), b && a.cleanup(), a.parent = null, cc.arrayRemoveObject(this._children, a)
    },
    _insertChild: function(a, b) {
        this._reorderChildDirty = !0, this._children.push(a), a._setLocalZOrder(b)
    },
    reorderChild: function(a, b) {
        cc.assert(a, cc._LogInfos.Node_reorderChild), this._reorderChildDirty = !0, a.arrivalOrder = cc.s_globalOrderOfArrival, cc.s_globalOrderOfArrival++, a._setLocalZOrder(b), this.setNodeDirty()
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a, b, c, d = this._children,
                e = d.length;
            for (a = 1; e > a; a++) {
                for (c = d[a], b = a - 1; b >= 0;) {
                    if (c._localZOrder < d[b]._localZOrder) d[b + 1] = d[b];
                    else {
                        if (!(c._localZOrder === d[b]._localZOrder && c.arrivalOrder < d[b].arrivalOrder)) break;
                        d[b + 1] = d[b]
                    }
                    b--
                }
                d[b + 1] = c
            }
            this._reorderChildDirty = !1
        }
    },
    draw: function() {},
    transformAncestors: function() {
        null != this._parent && (this._parent.transformAncestors(), this._parent.transform())
    },
    onEnter: function() {
        this._isTransitionFinished = !1, this._running = !0, this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onEnter), this.resume()
    },
    onEnterTransitionDidFinish: function() {
        this._isTransitionFinished = !0, this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onEnterTransitionDidFinish)
    },
    onExitTransitionDidStart: function() {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onExitTransitionDidStart)
    },
    onExit: function() {
        this._running = !1, this.pause(), this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onExit)
    },
    runAction: function(a) {
        return cc.assert(a, cc._LogInfos.Node_runAction), this.actionManager.addAction(a, this, !this._running), a
    },
    stopAllActions: function() {
        this.actionManager && this.actionManager.removeAllActionsFromTarget(this)
    },
    stopAction: function(a) {
        this.actionManager.removeAction(a)
    },
    stopActionByTag: function(a) {
        a === cc.ACTION_TAG_INVALID ? cc.log(cc._LogInfos.Node_stopActionByTag) : this.actionManager.removeActionByTag(a, this)
    },
    getActionByTag: function(a) {
        return a === cc.ACTION_TAG_INVALID ? (cc.log(cc._LogInfos.Node_getActionByTag), null) : this.actionManager.getActionByTag(a, this)
    },
    getNumberOfRunningActions: function() {
        return this.actionManager.numberOfRunningActionsInTarget(this)
    },
    scheduleUpdate: function() {
        this.scheduleUpdateWithPriority(0)
    },
    scheduleUpdateWithPriority: function(a) {
        this.scheduler.scheduleUpdateForTarget(this, a, !this._running)
    },
    unscheduleUpdate: function() {
        this.scheduler.unscheduleUpdateForTarget(this)
    },
    schedule: function(a, b, c, d) {
        b = b || 0, cc.assert(a, cc._LogInfos.Node_schedule), cc.assert(b >= 0, cc._LogInfos.Node_schedule_2), c = null == c ? cc.REPEAT_FOREVER : c, this.scheduler.scheduleCallbackForTarget(this, a, b, c, d || 0, !this._running)
    },
    scheduleOnce: function(a, b) {
        this.schedule(a, 0, 0, b)
    },
    unschedule: function(a) {
        a && this.scheduler.unscheduleCallbackForTarget(this, a)
    },
    unscheduleAllCallbacks: function() {
        this.scheduler.unscheduleAllCallbacksForTarget(this)
    },
    resumeSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_resumeSchedulerAndActions), this.resume()
    },
    resume: function() {
        this.scheduler.resumeTarget(this), this.actionManager && this.actionManager.resumeTarget(this), cc.eventManager.resumeTarget(this)
    },
    pauseSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_pauseSchedulerAndActions), this.pause()
    },
    pause: function() {
        this.scheduler.pauseTarget(this), this.actionManager && this.actionManager.pauseTarget(this), cc.eventManager.pauseTarget(this)
    },
    setAdditionalTransform: function(a) {
        this._additionalTransform = a, this._additionalTransformDirty = this._transformDirty = !0
    },
    getParentToNodeTransform: function() {
        return this._inverseDirty && (this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform()), this._inverseDirty = !1), this._inverse
    },
    parentToNodeTransform: function() {
        return this.getParentToNodeTransform()
    },
    getNodeToWorldTransform: function() {
        for (var a = this.getNodeToParentTransform(), b = this._parent; null != b; b = b.parent) a = cc.affineTransformConcat(a, b.getNodeToParentTransform());
        return a
    },
    nodeToWorldTransform: function() {
        return this.getNodeToWorldTransform()
    },
    getWorldToNodeTransform: function() {
        return cc.affineTransformInvert(this.getNodeToWorldTransform())
    },
    worldToNodeTransform: function() {
        return this.getWorldToNodeTransform()
    },
    convertToNodeSpace: function(a) {
        return cc.pointApplyAffineTransform(a, this.getWorldToNodeTransform())
    },
    convertToWorldSpace: function(a) {
        return a = a || cc.p(0, 0), cc.pointApplyAffineTransform(a, this.getNodeToWorldTransform())
    },
    convertToNodeSpaceAR: function(a) {
        return cc.pSub(this.convertToNodeSpace(a), this._anchorPointInPoints)
    },
    convertToWorldSpaceAR: function(a) {
        return a = a || cc.p(0, 0), a = cc.pAdd(a, this._anchorPointInPoints), this.convertToWorldSpace(a)
    },
    _convertToWindowSpace: function(a) {
        return a = this.convertToWorldSpace(a), cc.director.convertToUI(a)
    },
    convertTouchToNodeSpace: function(a) {
        return a = a.getLocation(), this.convertToNodeSpace(a)
    },
    convertTouchToNodeSpaceAR: function(a) {
        return a = a.getLocation(), a = cc.director.convertToGL(a), this.convertToNodeSpaceAR(a)
    },
    update: function(a) {
        this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(a)
    },
    updateTransform: function() {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.updateTransform)
    },
    retain: function() {},
    release: function() {},
    getComponent: function(a) {
        return this._componentContainer.getComponent(a)
    },
    addComponent: function(a) {
        this._componentContainer.add(a)
    },
    removeComponent: function(a) {
        return this._componentContainer.remove(a)
    },
    removeAllComponents: function() {
        this._componentContainer.removeAll()
    },
    grid: null,
    ctor: null,
    visit: null,
    transform: null,
    nodeToParentTransform: function() {
        return this.getNodeToParentTransform()
    },
    getNodeToParentTransform: null,
    _setNodeDirtyForCache: function() {
        if (!1 === this._cacheDirty) {
            this._cacheDirty = !0;
            var a = this._cachedParent;
            a && a != this && a._setNodeDirtyForCache()
        }
    },
    _setCachedParent: function(a) {
        if (this._cachedParent != a) {
            this._cachedParent = a;
            for (var b = this._children, c = 0, d = b.length; d > c; c++) b[c]._setCachedParent(a)
        }
    },
    getCamera: function() {
        return this._camera || (this._camera = new cc.Camera), this._camera
    },
    getGrid: function() {
        return this.grid
    },
    setGrid: function(a) {
        this.grid = a
    },
    getShaderProgram: function() {
        return this._shaderProgram
    },
    setShaderProgram: function(a) {
        this._shaderProgram = a
    },
    getGLServerState: function() {
        return this._glServerState
    },
    setGLServerState: function(a) {
        this._glServerState = a
    },
    getBoundingBoxToWorld: function() {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
            b = this.getNodeToWorldTransform(),
            a = cc.rectApplyAffineTransform(a, this.getNodeToWorldTransform());
        if (!this._children) return a;
        for (var c = this._children, d = 0; d < c.length; d++) {
            var e = c[d];
            e && e._visible && (e = e._getBoundingBoxToCurrentNode(b)) && (a = cc.rectUnion(a, e))
        }
        return a
    },
    _getBoundingBoxToCurrentNode: function(a) {
        var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        if (a = null == a ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), a), b = cc.rectApplyAffineTransform(b, a), !this._children) return b;
        for (var c = this._children, d = 0; d < c.length; d++) {
            var e = c[d];
            e && e._visible && (e = e._getBoundingBoxToCurrentNode(a)) && (b = cc.rectUnion(b, e))
        }
        return b
    },
    _getNodeToParentTransformForWebGL: function() {
        if (this._transformDirty) {
            var a = this._position.x,
                b = this._position.y,
                c = this._anchorPointInPoints.x,
                d = -c,
                e = this._anchorPointInPoints.y,
                f = -e,
                g = this._scaleX,
                h = this._scaleY;
            this._ignoreAnchorPointForPosition && (a += c, b += e);
            var i = 1,
                j = 0,
                k = 1,
                l = 0;
            (0 !== this._rotationX || 0 !== this._rotationY) && (i = Math.cos(-this._rotationRadiansX), j = Math.sin(-this._rotationRadiansX), k = Math.cos(-this._rotationRadiansY), l = Math.sin(-this._rotationRadiansY));
            var m = this._skewX || this._skewY;
            m || 0 === c && 0 === e || (a += k * d * g + -j * f * h, b += l * d * g + i * f * h);
            var n = this._transform;
            n.a = k * g, n.b = l * g, n.c = -j * h, n.d = i * h, n.tx = a, n.ty = b, m && (n = cc.affineTransformConcat({
                a: 1,
                b: Math.tan(cc.degreesToRadians(this._skewY)),
                c: Math.tan(cc.degreesToRadians(this._skewX)),
                d: 1,
                tx: 0,
                ty: 0
            }, n), 0 !== c || 0 !== e) && (n = cc.affineTransformTranslate(n, d, f)), this._additionalTransformDirty && (n = cc.affineTransformConcat(n, this._additionalTransform), this._additionalTransformDirty = !1), this._transform = n, this._transformDirty = !1
        }
        return this._transform
    },
    _updateColor: function() {},
    getOpacity: function() {
        return this._realOpacity
    },
    getDisplayedOpacity: function() {
        return this._displayedOpacity
    },
    setOpacity: function(a) {
        this._displayedOpacity = this._realOpacity = a;
        var b = 255,
            c = this._parent;
        c && c.cascadeOpacity && (b = c.getDisplayedOpacity()), this.updateDisplayedOpacity(b), this._displayedColor.a = this._realColor.a = a
    },
    updateDisplayedOpacity: function(a) {
        if (this._displayedOpacity = this._realOpacity * a / 255, this._cascadeOpacityEnabled) {
            a = this._children;
            for (var b = 0; b < a.length; b++) {
                var c = a[b];
                c && c.updateDisplayedOpacity(this._displayedOpacity)
            }
        }
    },
    isCascadeOpacityEnabled: function() {
        return this._cascadeOpacityEnabled
    },
    setCascadeOpacityEnabled: function(a) {
        this._cascadeOpacityEnabled !== a && ((this._cascadeOpacityEnabled = a) ? this._enableCascadeOpacity() : this._disableCascadeOpacity())
    },
    _enableCascadeOpacity: function() {
        var a = 255,
            b = this._parent;
        b && b.cascadeOpacity && (a = b.getDisplayedOpacity()), this.updateDisplayedOpacity(a)
    },
    _disableCascadeOpacity: function() {
        this._displayedOpacity = this._realOpacity;
        for (var a = this._children, b = 0; b < a.length; b++) {
            var c = a[b];
            c && c.updateDisplayedOpacity(255)
        }
    },
    getColor: function() {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedColor: function() {
        var a = this._displayedColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setColor: function(a) {
        var b = this._displayedColor,
            c = this._realColor;
        b.r = c.r = a.r, b.g = c.g = a.g, b.b = c.b = a.b, a = (a = this._parent) && a.cascadeColor ? a.getDisplayedColor() : cc.color.WHITE, this.updateDisplayedColor(a)
    },
    updateDisplayedColor: function(a) {
        var b = this._displayedColor,
            c = this._realColor;
        if (b.r = 0 | c.r * a.r / 255, b.g = 0 | c.g * a.g / 255, b.b = 0 | c.b * a.b / 255, this._cascadeColorEnabled)
            for (a = this._children, c = 0; c < a.length; c++) {
                var d = a[c];
                d && d.updateDisplayedColor(b)
            }
    },
    isCascadeColorEnabled: function() {
        return this._cascadeColorEnabled
    },
    setCascadeColorEnabled: function(a) {
        this._cascadeColorEnabled !== a && ((this._cascadeColorEnabled = a) ? this._enableCascadeColor() : this._disableCascadeColor())
    },
    _enableCascadeColor: function() {
        var a;
        a = (a = this._parent) && a.cascadeColor ? a.getDisplayedColor() : cc.color.WHITE, this.updateDisplayedColor(a)
    },
    _disableCascadeColor: function() {
        var a = this._displayedColor,
            b = this._realColor;
        a.r = b.r, a.g = b.g, a.b = b.b;
        for (var a = this._children, b = cc.color.WHITE, c = 0; c < a.length; c++) {
            var d = a[c];
            d && d.updateDisplayedColor(b)
        }
    },
    setOpacityModifyRGB: function() {},
    isOpacityModifyRGB: function() {
        return !1
    }
}), cc.Node.create = function() {
    return new cc.Node
}, cc.Node._StateCallbackType = {
    onEnter: 1,
    onExit: 2,
    cleanup: 3,
    onEnterTransitionDidFinish: 4,
    updateTransform: 5,
    onExitTransitionDidStart: 6,
    sortAllChildren: 7
}, cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Node.prototype, _p.ctor = function() {
    this._initNode()
}, _p.setNodeDirty = function() {
    this._setNodeDirtyForCache(), !1 === this._transformDirty && (this._transformDirty = this._inverseDirty = !0)
}, _p.visit = function(a) {
    if (this._visible) {
        a = a || cc._renderContext;
        var b, c, d = this._children;
        a.save(), this.transform(a);
        var e = d.length;
        if (e > 0) {
            for (this.sortAllChildren(), b = 0; e > b && (c = d[b], 0 > c._localZOrder); b++) c.visit(a);
            for (this.draw(a); e > b; b++) d[b].visit(a)
        } else this.draw(a);
        this._cacheDirty = !1, this.arrivalOrder = 0, a.restore()
    }
}, _p.transform = function(a) {
    a = a || cc._renderContext;
    var b = cc.view,
        c = this.getNodeToParentTransform();
    a.transform(c.a, c.c, c.b, c.d, c.tx * b.getScaleX(), -c.ty * b.getScaleY())
}, _p.getNodeToParentTransform = function() {
    if (this._transformDirty) {
        var a = this._transform;
        a.tx = this._position.x, a.ty = this._position.y;
        var b = 1,
            c = 0;
        this._rotationX && (b = Math.cos(this._rotationRadiansX), c = Math.sin(this._rotationRadiansX)), a.a = a.d = b, a.b = -c, a.c = c;
        var d = this._scaleX,
            e = this._scaleY,
            f = this._anchorPointInPoints.x,
            g = this._anchorPointInPoints.y,
            h = 1e-6 > d && d > -1e-6 ? 1e-6 : d,
            i = 1e-6 > e && e > -1e-6 ? 1e-6 : e;
        if (this._skewX || this._skewY) {
            var j = Math.tan(-this._skewX * Math.PI / 180),
                k = Math.tan(-this._skewY * Math.PI / 180);
            1 / 0 === j && (j = 99999999), 1 / 0 === k && (k = 99999999);
            var l = g * j * h,
                m = f * k * i;
            a.a = b + -c * k, a.b = b * j + -c, a.c = c + b * k, a.d = c * j + b, a.tx += b * l + -c * m, a.ty += c * l + b * m
        }(1 !== d || 1 !== e) && (a.a *= h, a.c *= h, a.b *= i, a.d *= i), a.tx += b * -f * h + -c * g * i, a.ty -= c * -f * h + b * g * i, this._ignoreAnchorPointForPosition && (a.tx += f, a.ty += g), this._additionalTransformDirty && (this._transform = cc.affineTransformConcat(a, this._additionalTransform), this._additionalTransformDirty = !1), this._transformDirty = !1
    }
    return this._transform
}, _p = null) : (cc.assert("function" == typeof cc._tmp.WebGLCCNode, cc._LogInfos.MissingFile, "BaseNodesWebGL.js"), cc._tmp.WebGLCCNode(), delete cc._tmp.WebGLCCNode), cc.assert("function" == typeof cc._tmp.PrototypeCCNode, cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js"), cc._tmp.PrototypeCCNode(), delete cc._tmp.PrototypeCCNode, cc.AtlasNode = cc.Node.extend({
    textureAtlas: null,
    quadsToDraw: 0,
    _itemsPerRow: 0,
    _itemsPerColumn: 0,
    _itemWidth: 0,
    _itemHeight: 0,
    _colorUnmodified: null,
    _opacityModifyRGB: !1,
    _blendFunc: null,
    _ignoreContentScaleFactor: !1,
    _className: "AtlasNode",
    ctor: function(a, b, c, d) {
        cc.Node.prototype.ctor.call(this), this._colorUnmodified = cc.color.WHITE, this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        }, this._ignoreContentScaleFactor = !1, void 0 !== d && this.initWithTileFile(a, b, c, d)
    },
    updateAtlasValues: function() {
        cc.log(cc._LogInfos.AtlasNode_updateAtlasValues)
    },
    getColor: function() {
        return this._opacityModifyRGB ? this._colorUnmodified : cc.Node.prototype.getColor.call(this)
    },
    setOpacityModifyRGB: function(a) {
        var b = this.color;
        this._opacityModifyRGB = a, this.color = b
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        this._blendFunc = void 0 === b ? a : {
            src: a,
            dst: b
        }
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    getQuadsToDraw: function() {
        return this.quadsToDraw
    },
    setQuadsToDraw: function(a) {
        this.quadsToDraw = a
    },
    _textureForCanvas: null,
    _originalTexture: null,
    _uniformColor: null,
    _colorF32Array: null,
    initWithTileFile: function(a, b, c, d) {
        if (!a) throw "cc.AtlasNode.initWithTileFile(): title should not be null";
        return a = cc.textureCache.addImage(a), this.initWithTexture(a, b, c, d)
    },
    initWithTexture: null,
    _initWithTextureForCanvas: function(a, b, c, d) {
        return this._itemWidth = b, this._itemHeight = c, this._opacityModifyRGB = !0, this._originalTexture = a, this._originalTexture ? (this._textureForCanvas = this._originalTexture, this._calculateMaxItems(), this.quadsToDraw = d, !0) : (cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1)
    },
    _initWithTextureForWebGL: function(a, b, c, d) {
        return this._itemWidth = b, this._itemHeight = c, this._colorUnmodified = cc.color.WHITE, this._opacityModifyRGB = !0, this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, b = this._realColor, this._colorF32Array = new Float32Array([b.r / 255, b.g / 255, b.b / 255, this._realOpacity / 255]), this.textureAtlas = new cc.TextureAtlas, this.textureAtlas.initWithTexture(a, d), this.textureAtlas ? (this._updateBlendFunc(), this._updateOpacityModifyRGB(), this._calculateMaxItems(), this.quadsToDraw = d, this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR), this._uniformColor = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), "u_color"), !0) : (cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1)
    },
    draw: null,
    _drawForWebGL: function(a) {
        a = a || cc._renderContext, cc.nodeDrawSetup(this), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), this._uniformColor && this._colorF32Array && (a.uniform4fv(this._uniformColor, this._colorF32Array), this.textureAtlas.drawNumberOfQuads(this.quadsToDraw, 0))
    },
    setColor: null,
    _setColorForCanvas: function(a) {
        var b = this._realColor;
        if (b.r != a.r || b.g != a.g || b.b != a.b) {
            if (b = cc.color(a.r, a.g, a.b), this._colorUnmodified = a, this._opacityModifyRGB) {
                var c = this._displayedOpacity;
                b.r = b.r * c / 255, b.g = b.g * c / 255, b.b = b.b * c / 255
            }
            cc.Node.prototype.setColor.call(this, a), this._changeTextureColor()
        }
    },
    _changeTextureColor: function() {
        var a = this.getTexture();
        if (a && this._originalTexture) {
            var b = this._originalTexture.getHtmlElementObj();
            if (b) {
                var c = a.getHtmlElementObj(),
                    a = cc.rect(0, 0, b.width, b.height);
                c instanceof HTMLCanvasElement ? cc.generateTintImageWithMultiply(b, this._displayedColor, a, c) : (c = cc.generateTintImageWithMultiply(b, this._displayedColor, a), a = new cc.Texture2D, a.initWithElement(c), a.handleLoadedTexture(), this.setTexture(a))
            }
        }
    },
    _setColorForWebGL: function(a) {
        var b = cc.color(a.r, a.g, a.b);
        this._colorUnmodified = a;
        var c = this._displayedOpacity;
        this._opacityModifyRGB && (b.r = b.r * c / 255, b.g = b.g * c / 255, b.b = b.b * c / 255), cc.Node.prototype.setColor.call(this, a), a = this._displayedColor, this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, c / 255])
    },
    setOpacity: function() {},
    _setOpacityForCanvas: function(a) {
        cc.Node.prototype.setOpacity.call(this, a), this._opacityModifyRGB && (this.color = this._colorUnmodified)
    },
    _setOpacityForWebGL: function(a) {
        cc.Node.prototype.setOpacity.call(this, a), this._opacityModifyRGB ? this.color = this._colorUnmodified : (a = this._displayedColor, this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, this._displayedOpacity / 255]))
    },
    getTexture: null,
    _getTextureForCanvas: function() {
        return this._textureForCanvas
    },
    _getTextureForWebGL: function() {
        return this.textureAtlas.texture
    },
    setTexture: null,
    _setTextureForCanvas: function(a) {
        this._textureForCanvas = a
    },
    _setTextureForWebGL: function(a) {
        this.textureAtlas.texture = a, this._updateBlendFunc(), this._updateOpacityModifyRGB()
    },
    _calculateMaxItems: null,
    _calculateMaxItemsForCanvas: function() {
        var a = this.texture.getContentSize();
        this._itemsPerColumn = 0 | a.height / this._itemHeight, this._itemsPerRow = 0 | a.width / this._itemWidth
    },
    _calculateMaxItemsForWebGL: function() {
        var a = this.texture,
            b = a.getContentSize();
        this._ignoreContentScaleFactor && (b = a.getContentSizeInPixels()), this._itemsPerColumn = 0 | b.height / this._itemHeight, this._itemsPerRow = 0 | b.width / this._itemWidth
    },
    _updateBlendFunc: function() {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    _updateOpacityModifyRGB: function() {
        this._opacityModifyRGB = this.textureAtlas.texture.hasPremultipliedAlpha()
    },
    _setIgnoreContentScaleFactor: function(a) {
        this._ignoreContentScaleFactor = a
    }
}), _p = cc.AtlasNode.prototype, cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.initWithTexture = _p._initWithTextureForWebGL, _p.draw = _p._drawForWebGL, _p.setColor = _p._setColorForWebGL, _p.setOpacity = _p._setOpacityForWebGL, _p.getTexture = _p._getTextureForWebGL, _p.setTexture = _p._setTextureForWebGL, _p._calculateMaxItems = _p._calculateMaxItemsForWebGL) : (_p.initWithTexture = _p._initWithTextureForCanvas, _p.draw = cc.Node.prototype.draw, _p.setColor = _p._setColorForCanvas, _p.setOpacity = _p._setOpacityForCanvas, _p.getTexture = _p._getTextureForCanvas, _p.setTexture = _p._setTextureForCanvas, _p._calculateMaxItems = _p._calculateMaxItemsForCanvas, cc.sys._supportCanvasNewBlendModes || (_p._changeTextureColor = function() {
    var a, b = this.getTexture();
    if (b && this._originalTexture && (a = b.getHtmlElementObj())) {
        var c = this._originalTexture.getHtmlElementObj();
        (b = cc.textureCache.getTextureColors(c)) && (c = cc.rect(0, 0, c.width, c.height), a instanceof HTMLCanvasElement ? cc.generateTintImage(a, b, this._displayedColor, c, a) : (a = cc.generateTintImage(a, b, this._displayedColor, c), b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.setTexture(b)))
    }
})), cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity), cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor), cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture), cc.AtlasNode.create = function(a, b, c, d) {
    return new cc.AtlasNode(a, b, c, d)
}, cc._tmp.WebGLTexture2D = function() {
    cc.Texture2D = cc.Class.extend({
        _pVRHaveAlphaPremultiplied: !0,
        _pixelFormat: null,
        _pixelsWide: 0,
        _pixelsHigh: 0,
        _name: "",
        _contentSize: null,
        maxS: 0,
        maxT: 0,
        _hasPremultipliedAlpha: !1,
        _hasMipmaps: !1,
        shaderProgram: null,
        _isLoaded: !1,
        _htmlElementObj: null,
        _webTextureObj: null,
        url: null,
        _loadedEventListeners: null,
        ctor: function() {
            this._contentSize = cc.size(0, 0), this._pixelFormat = cc.Texture2D.defaultPixelFormat
        },
        releaseTexture: function() {
            this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj), cc.loader.release(this.url)
        },
        getPixelFormat: function() {
            return this._pixelFormat
        },
        getPixelsWide: function() {
            return this._pixelsWide
        },
        getPixelsHigh: function() {
            return this._pixelsHigh
        },
        getName: function() {
            return this._webTextureObj
        },
        getContentSize: function() {
            return cc.size(this._contentSize.width / cc.contentScaleFactor(), this._contentSize.height / cc.contentScaleFactor())
        },
        _getWidth: function() {
            return this._contentSize.width / cc.contentScaleFactor()
        },
        _getHeight: function() {
            return this._contentSize.height / cc.contentScaleFactor()
        },
        getContentSizeInPixels: function() {
            return this._contentSize
        },
        getMaxS: function() {
            return this.maxS
        },
        setMaxS: function(a) {
            this.maxS = a
        },
        getMaxT: function() {
            return this.maxT
        },
        setMaxT: function(a) {
            this.maxT = a
        },
        getShaderProgram: function() {
            return this.shaderProgram
        },
        setShaderProgram: function(a) {
            this.shaderProgram = a
        },
        hasPremultipliedAlpha: function() {
            return this._hasPremultipliedAlpha
        },
        hasMipmaps: function() {
            return this._hasMipmaps
        },
        description: function() {
            return "<cc.Texture2D | Name = " + this._name + " | Dimensions = " + this._pixelsWide + " x " + this._pixelsHigh + " | Coordinates = (" + this.maxS + ", " + this.maxT + ")>"
        },
        releaseData: function() {},
        keepData: function(a) {
            return a
        },
        initWithData: function(a, b, c, d, e) {
            var f = cc.Texture2D,
                g = cc._renderContext,
                h = g.RGBA,
                i = g.UNSIGNED_BYTE,
                j = c * cc.Texture2D._B[b] / 8;
            switch (0 === j % 8 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 8) : 0 === j % 4 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 4) : 0 === j % 2 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 2) : g.pixelStorei(g.UNPACK_ALIGNMENT, 1), this._webTextureObj = g.createTexture(), cc.glBindTexture2D(this), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, g.LINEAR), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, g.LINEAR), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE), b) {
                case f.PIXEL_FORMAT_RGBA8888:
                    h = g.RGBA;
                    break;
                case f.PIXEL_FORMAT_RGB888:
                    h = g.RGB;
                    break;
                case f.PIXEL_FORMAT_RGBA4444:
                    i = g.UNSIGNED_SHORT_4_4_4_4;
                    break;
                case f.PIXEL_FORMAT_RGB5A1:
                    i = g.UNSIGNED_SHORT_5_5_5_1;
                    break;
                case f.PIXEL_FORMAT_RGB565:
                    i = g.UNSIGNED_SHORT_5_6_5;
                    break;
                case f.PIXEL_FORMAT_AI88:
                    h = g.LUMINANCE_ALPHA;
                    break;
                case f.PIXEL_FORMAT_A8:
                    h = g.ALPHA;
                    break;
                case f.PIXEL_FORMAT_I8:
                    h = g.LUMINANCE;
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Texture2D_initWithData)
            }
            return g.texImage2D(g.TEXTURE_2D, 0, h, c, d, 0, h, i, a), this._contentSize.width = e.width, this._contentSize.height = e.height, this._pixelsWide = c, this._pixelsHigh = d, this._pixelFormat = b, this.maxS = e.width / c, this.maxT = e.height / d, this._hasMipmaps = this._hasPremultipliedAlpha = !1, this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), this._isLoaded = !0
        },
        drawAtPoint: function(a) {
            var b = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0],
                c = this._pixelsWide * this.maxS,
                d = this._pixelsHigh * this.maxT;
            a = [a.x, a.y, 0, c + a.x, a.y, 0, a.x, d + a.y, 0, c + a.x, d + a.y, 0], cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS), this._shaderProgram.use(), this._shaderProgram.setUniformsForBuiltins(), cc.glBindTexture2D(this), c = cc._renderContext, c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, a), c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, c.FLOAT, !1, 0, b), c.drawArrays(c.TRIANGLE_STRIP, 0, 4)
        },
        drawInRect: function(a) {
            var b = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0];
            a = [a.x, a.y, a.x + a.width, a.y, a.x, a.y + a.height, a.x + a.width, a.y + a.height], cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS), this._shaderProgram.use(), this._shaderProgram.setUniformsForBuiltins(), cc.glBindTexture2D(this);
            var c = cc._renderContext;
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, a), c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, c.FLOAT, !1, 0, b), c.drawArrays(c.TRIANGLE_STRIP, 0, 4)
        },
        initWithImage: function(a) {
            if (null == a) return cc.log(cc._LogInfos.Texture2D_initWithImage), !1;
            var b = a.getWidth(),
                c = a.getHeight(),
                d = cc.configuration.getMaxTextureSize();
            return b > d || c > d ? (cc.log(cc._LogInfos.Texture2D_initWithImage_2, b, c, d, d), !1) : (this._isLoaded = !0, this._initPremultipliedATextureWithImage(a, b, c))
        },
        initWithElement: function(a) {
            a && (this._webTextureObj = cc._renderContext.createTexture(), this._htmlElementObj = a)
        },
        getHtmlElementObj: function() {
            return this._htmlElementObj
        },
        isLoaded: function() {
            return this._isLoaded
        },
        handleLoadedTexture: function() {
            if (cc._rendererInitialized) {
                if (!this._htmlElementObj) {
                    var a = cc.loader.getRes(this.url);
                    if (!a) return;
                    this.initWithElement(a)
                }
                this._htmlElementObj.width && this._htmlElementObj.height && (this._isLoaded = !0, a = cc._renderContext, cc.glBindTexture2D(this), a.pixelStorei(a.UNPACK_ALIGNMENT, 4), a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, this._htmlElementObj), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), cc.glBindTexture2D(null), a = this._htmlElementObj.height, this._pixelsWide = this._contentSize.width = this._htmlElementObj.width, this._pixelsHigh = this._contentSize.height = a, this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.maxT = this.maxS = 1, this._hasMipmaps = this._hasPremultipliedAlpha = !1, this._callLoadedEventCallbacks())
            }
        },
        initWithString: function() {
            return cc.log(cc._LogInfos.Texture2D_initWithString), null
        },
        initWithETCFile: function() {
            return cc.log(cc._LogInfos.Texture2D_initWithETCFile_2), !1
        },
        initWithPVRFile: function() {
            return cc.log(cc._LogInfos.Texture2D_initWithPVRFile_2), !1
        },
        initWithPVRTCData: function() {
            return cc.log(cc._LogInfos.Texture2D_initWithPVRTCData_2), !1
        },
        setTexParameters: function(a, b, c, d) {
            var e = cc._renderContext;
            void 0 !== b && (a = {
                minFilter: a,
                magFilter: b,
                wrapS: c,
                wrapT: d
            }), cc.assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh) || a.wrapS == e.CLAMP_TO_EDGE && a.wrapT == e.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures"), cc.glBindTexture2D(this), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, a.minFilter), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, a.magFilter), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, a.wrapS), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, a.wrapT)
        },
        setAntiAliasTexParameters: function() {
            var a = cc._renderContext;
            cc.glBindTexture2D(this), this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST)
        },
        setAliasTexParameters: function() {
            var a = cc._renderContext;
            cc.glBindTexture2D(this), this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST)
        },
        generateMipmap: function() {
            cc.assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures"), cc.glBindTexture2D(this), cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D), this._hasMipmaps = !0
        },
        stringForFormat: function() {
            return cc.Texture2D._M[this._pixelFormat]
        },
        bitsPerPixelForFormat: function(a) {
            a = a || this._pixelFormat;
            var b = cc.Texture2D._B[a];
            return null != b ? b : (cc.log(cc._LogInfos.Texture2D_bitsPerPixelForFormat, a), -1)
        },
        _initPremultipliedATextureWithImage: function(a, b, c) {
            var d = cc.Texture2D,
                e = a.getData(),
                f = null,
                f = null,
                g = a.hasAlpha(),
                h = cc.size(a.getWidth(), a.getHeight()),
                i = d.defaultPixelFormat,
                j = a.getBitsPerComponent();
            g || (j >= 8 ? i = d.PIXEL_FORMAT_RGB888 : (cc.log(cc._LogInfos.Texture2D__initPremultipliedATextureWithImage), i = d.PIXEL_FORMAT_RGB565));
            var k = b * c;
            if (i == d.PIXEL_FORMAT_RGB565)
                if (g)
                    for (e = new Uint16Array(b * c), f = a.getData(), j = 0; k > j; ++j) e[j] = (f[j] >> 0 & 255) >> 3 << 11 | (f[j] >> 8 & 255) >> 2 << 5 | (f[j] >> 16 & 255) >> 3 << 0;
                else
                    for (e = new Uint16Array(b * c), f = a.getData(), j = 0; k > j; ++j) e[j] = (255 & f[j]) >> 3 << 11 | (255 & f[j]) >> 2 << 5 | (255 & f[j]) >> 3 << 0;
                else if (i == d.PIXEL_FORMAT_RGBA4444)
                for (e = new Uint16Array(b * c), f = a.getData(), j = 0; k > j; ++j) e[j] = (f[j] >> 0 & 255) >> 4 << 12 | (f[j] >> 8 & 255) >> 4 << 8 | (f[j] >> 16 & 255) >> 4 << 4 | (f[j] >> 24 & 255) >> 4 << 0;
            else if (i == d.PIXEL_FORMAT_RGB5A1)
                for (e = new Uint16Array(b * c), f = a.getData(), j = 0; k > j; ++j) e[j] = (f[j] >> 0 & 255) >> 3 << 11 | (f[j] >> 8 & 255) >> 3 << 6 | (f[j] >> 16 & 255) >> 3 << 1 | (f[j] >> 24 & 255) >> 7 << 0;
            else if (i == d.PIXEL_FORMAT_A8)
                for (e = new Uint8Array(b * c), f = a.getData(), j = 0; k > j; ++j) e[j] = f >> 24 & 255;
            if (g && i == d.PIXEL_FORMAT_RGB888)
                for (f = a.getData(), e = new Uint8Array(3 * b * c), j = 0; k > j; ++j) e[3 * j] = f >> 0 & 255, e[3 * j + 1] = f >> 8 & 255, e[3 * j + 2] = f >> 16 & 255;
            return this.initWithData(e, i, b, c, h), a.getData(), this._hasPremultipliedAlpha = a.isPremultipliedAlpha(), !0
        },
        addLoadedEventListener: function(a, b) {
            this._loadedEventListeners || (this._loadedEventListeners = []), this._loadedEventListeners.push({
                eventCallback: a,
                eventTarget: b
            })
        },
        removeLoadedEventListener: function(a) {
            if (this._loadedEventListeners)
                for (var b = this._loadedEventListeners, c = 0; c < b.length; c++) b[c].eventTarget == a && b.splice(c, 1)
        },
        _callLoadedEventCallbacks: function() {
            if (this._loadedEventListeners) {
                for (var a = this._loadedEventListeners, b = 0, c = a.length; c > b; b++) {
                    var d = a[b];
                    d.eventCallback.call(d.eventTarget, this)
                }
                a.length = 0
            }
        }
    })
}, cc._tmp.WebGLTextureAtlas = function() {
    var a = cc.TextureAtlas.prototype;
    a._setupVBO = function() {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer(), this._buffersVBO[1] = a.createBuffer(), this._quadsWebBuffer = a.createBuffer(), this._mapBuffers()
    }, a._mapBuffers = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer), a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
    }, a.drawNumberOfQuads = function(a, b) {
        if (b = b || 0, 0 !== a && this.texture && this.texture.isLoaded()) {
            var c = cc._renderContext;
            cc.glBindTexture2D(this.texture), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), c.bindBuffer(c.ARRAY_BUFFER, this._quadsWebBuffer), this.dirty && c.bufferData(c.ARRAY_BUFFER, this._quadsArrayBuffer, c.DYNAMIC_DRAW), c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, c.FLOAT, !1, 24, 0), c.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, c.UNSIGNED_BYTE, !0, 24, 12), c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, c.FLOAT, !1, 24, 16), this.dirty && (this.dirty = !1), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? c.drawElements(c.TRIANGLE_STRIP, 6 * a, c.UNSIGNED_SHORT, 6 * b * this._indices.BYTES_PER_ELEMENT) : c.drawElements(c.TRIANGLES, 6 * a, c.UNSIGNED_SHORT, 6 * b * this._indices.BYTES_PER_ELEMENT), cc.g_NumberOfDraws++
        }
    }
}, cc._tmp.WebGLTextureCache = function() {
    var a = cc.textureCache;
    a.handleLoadedTexture = function(a) {
        var b = this._textures;
        cc._rendererInitialized || (b = this._loadedTexturesBefore);
        var c = b[a];
        c || (c = b[a] = new cc.Texture2D, c.url = a), c.handleLoadedTexture()
    }, a.addImage = function(a, b, c) {
        cc.assert(a, cc._LogInfos.Texture2D_addImage_2);
        var d = this._textures;
        cc._rendererInitialized || (d = this._loadedTexturesBefore);
        var e = d[a] || d[cc.loader._aliases[a]];
        return e ? (b && b.call(c), e) : (cc.loader.getRes(a) || (cc.loader._checkIsImageURL(a) ? cc.loader.load(a, function() {
            b && b.call(c)
        }) : cc.loader.cache[a] = cc.loader.loadImg(a, function(d, e) {
            return d ? b ? b(d) : d : (cc.textureCache.handleLoadedTexture(a), void(b && b(c, e)))
        })), e = d[a] = new cc.Texture2D, e.url = a, e)
    }, delete a
}, cc._tmp.PrototypeTexture2D = function() {
    var a = cc.Texture2D;
    a.PVRImagesHavePremultipliedAlpha = function(a) {
        cc.PVRHaveAlphaPremultiplied_ = a
    }, a.PIXEL_FORMAT_RGBA8888 = 2, a.PIXEL_FORMAT_RGB888 = 3, a.PIXEL_FORMAT_RGB565 = 4, a.PIXEL_FORMAT_A8 = 5, a.PIXEL_FORMAT_I8 = 6, a.PIXEL_FORMAT_AI88 = 7, a.PIXEL_FORMAT_RGBA4444 = 8, a.PIXEL_FORMAT_RGB5A1 = 7, a.PIXEL_FORMAT_PVRTC4 = 9, a.PIXEL_FORMAT_PVRTC2 = 10, a.PIXEL_FORMAT_DEFAULT = a.PIXEL_FORMAT_RGBA8888;
    var b = cc.Texture2D._M = {};
    b[a.PIXEL_FORMAT_RGBA8888] = "RGBA8888", b[a.PIXEL_FORMAT_RGB888] = "RGB888", b[a.PIXEL_FORMAT_RGB565] = "RGB565", b[a.PIXEL_FORMAT_A8] = "A8", b[a.PIXEL_FORMAT_I8] = "I8", b[a.PIXEL_FORMAT_AI88] = "AI88", b[a.PIXEL_FORMAT_RGBA4444] = "RGBA4444", b[a.PIXEL_FORMAT_RGB5A1] = "RGB5A1", b[a.PIXEL_FORMAT_PVRTC4] = "PVRTC4", b[a.PIXEL_FORMAT_PVRTC2] = "PVRTC2", b = cc.Texture2D._B = {}, b[a.PIXEL_FORMAT_RGBA8888] = 32, b[a.PIXEL_FORMAT_RGB888] = 24, b[a.PIXEL_FORMAT_RGB565] = 16, b[a.PIXEL_FORMAT_A8] = 8, b[a.PIXEL_FORMAT_I8] = 8, b[a.PIXEL_FORMAT_AI88] = 16, b[a.PIXEL_FORMAT_RGBA4444] = 16, b[a.PIXEL_FORMAT_RGB5A1] = 16, b[a.PIXEL_FORMAT_PVRTC4] = 4, b[a.PIXEL_FORMAT_PVRTC2] = 3, b = cc.Texture2D.prototype, cc.defineGetterSetter(b, "name", b.getName), cc.defineGetterSetter(b, "pixelFormat", b.getPixelFormat), cc.defineGetterSetter(b, "pixelsWidth", b.getPixelsWide), cc.defineGetterSetter(b, "pixelsHeight", b.getPixelsHigh), cc.defineGetterSetter(b, "width", b._getWidth), cc.defineGetterSetter(b, "height", b._getHeight), a.defaultPixelFormat = a.PIXEL_FORMAT_DEFAULT
}, cc._tmp.PrototypeTextureAtlas = function() {
    var a = cc.TextureAtlas.prototype;
    cc.defineGetterSetter(a, "totalQuads", a.getTotalQuads), cc.defineGetterSetter(a, "capacity", a.getCapacity), cc.defineGetterSetter(a, "quads", a.getQuads, a.setQuads)
}, cc.ALIGN_CENTER = 51, cc.ALIGN_TOP = 19, cc.ALIGN_TOP_RIGHT = 18, cc.ALIGN_RIGHT = 50, cc.ALIGN_BOTTOM_RIGHT = 34, cc.ALIGN_BOTTOM = 35, cc.ALIGN_BOTTOM_LEFT = 33, cc.ALIGN_LEFT = 49, cc.ALIGN_TOP_LEFT = 17, cc.PVRHaveAlphaPremultiplied_ = !1, cc._renderType === cc._RENDER_TYPE_CANVAS ? cc.Texture2D = cc.Class.extend({
    _contentSize: null,
    _isLoaded: !1,
    _htmlElementObj: null,
    _loadedEventListeners: null,
    url: null,
    ctor: function() {
        this._contentSize = cc.size(0, 0), this._isLoaded = !1, this._htmlElementObj = null
    },
    getPixelsWide: function() {
        return this._contentSize.width
    },
    getPixelsHigh: function() {
        return this._contentSize.height
    },
    getContentSize: function() {
        var a = cc.contentScaleFactor();
        return cc.size(this._contentSize.width / a, this._contentSize.height / a)
    },
    _getWidth: function() {
        return this._contentSize.width / cc.contentScaleFactor()
    },
    _getHeight: function() {
        return this._contentSize.height / cc.contentScaleFactor()
    },
    getContentSizeInPixels: function() {
        return this._contentSize
    },
    initWithElement: function(a) {
        a && (this._htmlElementObj = a)
    },
    getHtmlElementObj: function() {
        return this._htmlElementObj
    },
    isLoaded: function() {
        return this._isLoaded
    },
    handleLoadedTexture: function() {
        if (!this._isLoaded) {
            if (!this._htmlElementObj) {
                var a = cc.loader.getRes(this.url);
                if (!a) return;
                this.initWithElement(a)
            }
            this._isLoaded = !0, a = this._htmlElementObj, this._contentSize.width = a.width, this._contentSize.height = a.height, this._callLoadedEventCallbacks()
        }
    },
    description: function() {
        return "<cc.Texture2D | width = " + this._contentSize.width + " height " + this._contentSize.height + ">"
    },
    initWithData: function() {
        return !1
    },
    initWithImage: function() {
        return !1
    },
    initWithString: function() {
        return !1
    },
    releaseTexture: function() {},
    getName: function() {
        return null
    },
    getMaxS: function() {
        return 1
    },
    setMaxS: function() {},
    getMaxT: function() {
        return 1
    },
    setMaxT: function() {},
    getPixelFormat: function() {
        return null
    },
    getShaderProgram: function() {
        return null
    },
    setShaderProgram: function() {},
    hasPremultipliedAlpha: function() {
        return !1
    },
    hasMipmaps: function() {
        return !1
    },
    releaseData: function() {},
    keepData: function(a) {
        return a
    },
    drawAtPoint: function() {},
    drawInRect: function() {},
    initWithETCFile: function() {
        return cc.log(cc._LogInfos.Texture2D_initWithETCFile), !1
    },
    initWithPVRFile: function() {
        return cc.log(cc._LogInfos.Texture2D_initWithPVRFile), !1
    },
    initWithPVRTCData: function() {
        return cc.log(cc._LogInfos.Texture2D_initWithPVRTCData), !1
    },
    setTexParameters: function() {},
    setAntiAliasTexParameters: function() {},
    setAliasTexParameters: function() {},
    generateMipmap: function() {},
    stringForFormat: function() {
        return ""
    },
    bitsPerPixelForFormat: function() {
        return -1
    },
    addLoadedEventListener: function(a, b) {
        this._loadedEventListeners || (this._loadedEventListeners = []), this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: b
        })
    },
    removeLoadedEventListener: function(a) {
        if (this._loadedEventListeners)
            for (var b = this._loadedEventListeners, c = 0; c < b.length; c++) b[c].eventTarget == a && b.splice(c, 1)
    },
    _callLoadedEventCallbacks: function() {
        if (this._loadedEventListeners) {
            for (var a = this._loadedEventListeners, b = 0, c = a.length; c > b; b++) {
                var d = a[b];
                d.eventCallback.call(d.eventTarget, this)
            }
            a.length = 0
        }
    }
}) : (cc.assert("function" == typeof cc._tmp.WebGLTexture2D, cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTexture2D(), delete cc._tmp.WebGLTexture2D), cc.assert("function" == typeof cc._tmp.PrototypeTexture2D, cc._LogInfos.MissingFile, "TexturesPropertyDefine.js"), cc._tmp.PrototypeTexture2D(), delete cc._tmp.PrototypeTexture2D, cc.textureCache = {
    _textures: {},
    _textureColorsCache: {},
    _textureKeySeq: 0 | 1e3 * Math.random(),
    _loadedTexturesBefore: {},
    _initializingRenderer: function() {
        var a, b = this._loadedTexturesBefore,
            c = this._textures;
        for (a in b) {
            var d = b[a];
            d.handleLoadedTexture(), c[a] = d
        }
        this._loadedTexturesBefore = {}
    },
    addPVRTCImage: function() {
        cc.log(cc._LogInfos.textureCache_addPVRTCImage)
    },
    addETCImage: function() {
        cc.log(cc._LogInfos.textureCache_addETCImage)
    },
    description: function() {
        return "<TextureCache | Number of textures = " + this._textures.length + ">"
    },
    textureForKey: function(a) {
        return cc.log(cc._LogInfos.textureCache_textureForKey), this.getTextureForKey(a)
    },
    getTextureForKey: function(a) {
        return this._textures[a] || this._textures[cc.loader._aliases[a]]
    },
    getKeyByTexture: function(a) {
        for (var b in this._textures)
            if (this._textures[b] == a) return b;
        return null
    },
    _generalTextureKey: function() {
        return this._textureKeySeq++, "_textureKey_" + this._textureKeySeq
    },
    getTextureColors: function(a) {
        var b = this.getKeyByTexture(a);
        return b || (b = a instanceof HTMLImageElement ? a.src : this._generalTextureKey()), this._textureColorsCache[b] || (this._textureColorsCache[b] = cc.generateTextureCacheForColor(a)), this._textureColorsCache[b]
    },
    addPVRImage: function() {
        cc.log(cc._LogInfos.textureCache_addPVRImage)
    },
    removeAllTextures: function() {
        var a, b = this._textures;
        for (a in b) b[a] && b[a].releaseTexture();
        this._textures = {}
    },
    removeTexture: function(a) {
        if (a) {
            var b, c = this._textures;
            for (b in c) c[b] == a && (c[b].releaseTexture(), delete c[b])
        }
    },
    removeTextureForKey: function(a) {
        null != a && this._textures[a] && delete this._textures[a]
    },
    cacheImage: function(a, b) {
        if (b instanceof cc.Texture2D) this._textures[a] = b;
        else {
            var c = new cc.Texture2D;
            c.initWithElement(b), c.handleLoadedTexture(), this._textures[a] = c
        }
    },
    addUIImage: function(a, b) {
        if (cc.assert(a, cc._LogInfos.textureCache_addUIImage_2), b && this._textures[b]) return this._textures[b];
        var c = new cc.Texture2D;
        return c.initWithImage(a), null != b && null != c ? this._textures[b] = c : cc.log(cc._LogInfos.textureCache_addUIImage), c
    },
    dumpCachedTextureInfo: function() {
        var a, b = 0,
            c = 0,
            d = this._textures;
        for (a in d) {
            var e = d[a];
            b++, e.getHtmlElementObj() instanceof HTMLImageElement ? cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, a, e.getHtmlElementObj().src, e.pixelsWidth, e.pixelsHeight) : cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, a, e.pixelsWidth, e.pixelsHeight), c += 4 * e.pixelsWidth * e.pixelsHeight
        }
        d = this._textureColorsCache;
        for (a in d) {
            var f, e = d[a];
            for (f in e) {
                var g = e[f];
                b++, cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, a, g.width, g.height), c += 4 * g.width * g.height
            }
        }
        cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, b, c / 1024, (c / 1048576).toFixed(2))
    },
    _clear: function() {
        this._textures = {}, this._textureColorsCache = {}, this._textureKeySeq = 0 | 1e3 * Math.random(), this._loadedTexturesBefore = {}
    }
}, cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.textureCache, _p.handleLoadedTexture = function(a) {
    var b = this._textures,
        c = b[a];
    c || (c = b[a] = new cc.Texture2D, c.url = a), c.handleLoadedTexture()
}, _p.addImage = function(a, b, c) {
    cc.assert(a, cc._LogInfos.Texture2D_addImage);
    var d = this._textures,
        e = d[a] || d[cc.loader._aliases[a]];
    return e ? (b && b.call(c), e) : (e = d[a] = new cc.Texture2D, e.url = a, cc.loader.getRes(a) ? e.handleLoadedTexture() : cc.loader._checkIsImageURL(a) ? cc.loader.load(a, function() {
        b && b.call(c)
    }) : cc.loader.cache[a] = cc.loader.loadImg(a, function(d, e) {
        return d ? b ? b(d) : d : (cc.textureCache.handleLoadedTexture(a), void(b && b(c, e)))
    }), e)
}, _p = null) : (cc.assert("function" == typeof cc._tmp.WebGLTextureCache, cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureCache(), delete cc._tmp.WebGLTextureCache), cc.TextureAtlas = cc.Class.extend({
    dirty: !1,
    texture: null,
    _indices: null,
    _buffersVBO: null,
    _capacity: 0,
    _quads: null,
    _quadsArrayBuffer: null,
    _quadsWebBuffer: null,
    _quadsReader: null,
    ctor: function(a, b) {
        this._buffersVBO = [], "string" == typeof a ? this.initWithFile(a, b) : a instanceof cc.Texture2D && this.initWithTexture(a, b)
    },
    getTotalQuads: function() {
        return this._totalQuads
    },
    getCapacity: function() {
        return this._capacity
    },
    getTexture: function() {
        return this.texture
    },
    setTexture: function(a) {
        this.texture = a
    },
    setDirty: function(a) {
        this.dirty = a
    },
    isDirty: function() {
        return this.dirty
    },
    getQuads: function() {
        return this._quads
    },
    setQuads: function(a) {
        this._quads = a
    },
    _copyQuadsToTextureAtlas: function(a, b) {
        if (a)
            for (var c = 0; c < a.length; c++) this._setQuadToArray(a[c], b + c)
    },
    _setQuadToArray: function(a, b) {
        var c = this._quads;
        c[b] ? (c[b].bl = a.bl, c[b].br = a.br, c[b].tl = a.tl, c[b].tr = a.tr) : c[b] = new cc.V3F_C4B_T2F_Quad(a.tl, a.bl, a.tr, a.br, this._quadsArrayBuffer, b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
    },
    description: function() {
        return "<cc.TextureAtlas | totalQuads =" + this._totalQuads + ">"
    },
    _setupIndices: function() {
        if (0 !== this._capacity)
            for (var a = this._indices, b = this._capacity, c = 0; b > c; c++) cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (a[6 * c + 0] = 4 * c + 0, a[6 * c + 1] = 4 * c + 0, a[6 * c + 2] = 4 * c + 2, a[6 * c + 3] = 4 * c + 1, a[6 * c + 4] = 4 * c + 3, a[6 * c + 5] = 4 * c + 3) : (a[6 * c + 0] = 4 * c + 0, a[6 * c + 1] = 4 * c + 1, a[6 * c + 2] = 4 * c + 2, a[6 * c + 3] = 4 * c + 3, a[6 * c + 4] = 4 * c + 2, a[6 * c + 5] = 4 * c + 1)
    },
    _setupVBO: function() {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer(), this._buffersVBO[1] = a.createBuffer(), this._quadsWebBuffer = a.createBuffer(), this._mapBuffers()
    },
    _mapBuffers: function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer), a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
    },
    initWithFile: function(a, b) {
        var c = cc.textureCache.addImage(a);
        return c ? this.initWithTexture(c, b) : (cc.log(cc._LogInfos.TextureAtlas_initWithFile, a), !1)
    },
    initWithTexture: function(a, b) {
        cc.assert(a, cc._LogInfos.TextureAtlas_initWithTexture), this._capacity = b |= 0, this._totalQuads = 0, this.texture = a, this._quads = [], this._indices = new Uint16Array(6 * b);
        var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        if (this._quadsArrayBuffer = new ArrayBuffer(c * b), this._quadsReader = new Uint8Array(this._quadsArrayBuffer), (!this._quads || !this._indices) && b > 0) return !1;
        for (var d = this._quads, e = 0; b > e; e++) d[e] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, e * c);
        return this._setupIndices(), this._setupVBO(), this.dirty = !0
    },
    updateQuad: function(a, b) {
        cc.assert(a, cc._LogInfos.TextureAtlas_updateQuad), cc.assert(b >= 0 && b < this._capacity, cc._LogInfos.TextureAtlas_updateQuad_2), this._totalQuads = Math.max(b + 1, this._totalQuads), this._setQuadToArray(a, b), this.dirty = !0
    },
    insertQuad: function(a, b) {
        if (cc.assert(b < this._capacity, cc._LogInfos.TextureAtlas_insertQuad_2), this._totalQuads++, this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
        else {
            var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                d = b * c,
                e = (this._totalQuads - 1 - b) * c;
            this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * c), this._quadsReader.set(this._quadsReader.subarray(d, d + e), d + c), this._setQuadToArray(a, b), this.dirty = !0
        }
    },
    insertQuads: function(a, b, c) {
        c = c || a.length, cc.assert(b + c <= this._capacity, cc._LogInfos.TextureAtlas_insertQuads);
        var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        if (this._totalQuads += c, this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
        else {
            var e, f = b * d,
                g = (this._totalQuads - 1 - b - c) * d,
                h = this._totalQuads - 1 - c;
            for (e = 0; c > e; e++) this._quads[h + e] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * d);
            for (this._quadsReader.set(this._quadsReader.subarray(f, f + g), f + d * c), e = 0; c > e; e++) this._setQuadToArray(a[e], b + e);
            this.dirty = !0
        }
    },
    insertQuadFromIndex: function(a, b) {
        if (a !== b) {
            cc.assert(b >= 0 || b < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex), cc.assert(a >= 0 || a < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex_2);
            var c, d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                e = this._quadsReader,
                f = e.subarray(a * d, d);
            a > b ? (c = b * d, e.set(e.subarray(c, c + (a - b) * d), c + d), e.set(f, c)) : (c = (a + 1) * d, e.set(e.subarray(c, c + (b - a) * d), c - d), e.set(f, b * d)), this.dirty = !0
        }
    },
    removeQuadAtIndex: function(a) {
        cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadAtIndex);
        var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        if (this._totalQuads--, this._quads.length = this._totalQuads, a !== this._totalQuads) {
            var c = (a + 1) * b;
            this._quadsReader.set(this._quadsReader.subarray(c, c + (this._totalQuads - a) * b), c - b)
        }
        this.dirty = !0
    },
    removeQuadsAtIndex: function(a, b) {
        if (cc.assert(a + b <= this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadsAtIndex), this._totalQuads -= b, a !== this._totalQuads) {
            var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                d = (a + b) * c;
            this._quadsReader.set(this._quadsReader.subarray(d, d + (this._totalQuads - a) * c), a * c)
        }
        this.dirty = !0
    },
    removeAllQuads: function() {
        this._totalQuads = this._quads.length = 0
    },
    _setDirty: function(a) {
        this.dirty = a
    },
    resizeCapacity: function(a) {
        if (a == this._capacity) return !0;
        var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            c = this._capacity;
        this._totalQuads = Math.min(this._totalQuads, a);
        var d = this._capacity = 0 | a,
            e = this._totalQuads;
        if (null == this._quads)
            for (this._quads = [], this._quadsArrayBuffer = new ArrayBuffer(b * d), this._quadsReader = new Uint8Array(this._quadsArrayBuffer), a = 0; d > a; a++) this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, a * b);
        else {
            var f, g, h = this._quads;
            if (d > c) {
                for (f = [], g = new ArrayBuffer(b * d), a = 0; e > a; a++) f[a] = new cc.V3F_C4B_T2F_Quad(h[a].tl, h[a].bl, h[a].tr, h[a].br, g, a * b);
                for (; d > a; a++) f[a] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, g, a * b)
            } else
                for (e = Math.max(e, d), f = [], g = new ArrayBuffer(b * d), a = 0; e > a; a++) f[a] = new cc.V3F_C4B_T2F_Quad(h[a].tl, h[a].bl, h[a].tr, h[a].br, g, a * b);
            this._quadsReader = new Uint8Array(g), this._quads = f, this._quadsArrayBuffer = g
        }
        return null == this._indices ? this._indices = new Uint16Array(6 * d) : d > c ? (b = new Uint16Array(6 * d), b.set(this._indices, 0), this._indices = b) : this._indices = this._indices.subarray(0, 6 * d), this._setupIndices(), this._mapBuffers(), this.dirty = !0
    },
    increaseTotalQuadsWith: function(a) {
        this._totalQuads += a
    },
    moveQuadsFromIndex: function(a, b, c) {
        if (void 0 === c) {
            if (c = b, b = this._totalQuads - a, cc.assert(c + (this._totalQuads - a) <= this._capacity, cc._LogInfos.TextureAtlas_moveQuadsFromIndex), 0 === b) return
        } else if (cc.assert(c + b <= this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_2), cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_3), a == c) return;
        var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            e = a * d,
            f = b * d,
            g = this._quadsReader,
            h = g.subarray(e, e + f),
            i = c * d;
        a > c ? (b = c * d, g.set(g.subarray(b, b + (a - c) * d), b + f)) : (b = (a + b) * d, g.set(g.subarray(b, b + (c - a) * d), e)), g.set(h, i), this.dirty = !0
    },
    fillWithEmptyQuadsFromIndex: function(a, b) {
        for (var c = b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d = new Uint8Array(this._quadsArrayBuffer, a * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, c), e = 0; c > e; e++) d[e] = 0
    },
    drawQuads: function() {
        this.drawNumberOfQuads(this._totalQuads, 0)
    },
    _releaseBuffer: function() {
        var a = cc._renderContext;
        this._buffersVBO && (this._buffersVBO[0] && a.deleteBuffer(this._buffersVBO[0]), this._buffersVBO[1] && a.deleteBuffer(this._buffersVBO[1])), this._quadsWebBuffer && a.deleteBuffer(this._quadsWebBuffer)
    }
}), _p = cc.TextureAtlas.prototype, cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads), cc.defineGetterSetter(_p, "capacity", _p.getCapacity), cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads), cc.TextureAtlas.create = function(a, b) {
    return new cc.TextureAtlas(a, b)
}, cc.TextureAtlas.createWithTexture = cc.TextureAtlas.create, cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert("function" == typeof cc._tmp.WebGLTextureAtlas, cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureAtlas(), delete cc._tmp.WebGLTextureAtlas), cc.assert("function" == typeof cc._tmp.PrototypeTextureAtlas, cc._LogInfos.MissingFile, "TexturesPropertyDefine.js"), cc._tmp.PrototypeTextureAtlas(), delete cc._tmp.PrototypeTextureAtlas, cc.Scene = cc.Node.extend({
    _className: "Scene",
    ctor: function() {
        cc.Node.prototype.ctor.call(this), this._ignoreAnchorPointForPosition = !0, this.setAnchorPoint(.5, .5), this.setContentSize(cc.director.getWinSize())
    }
}), cc.Scene.create = function() {
    return new cc.Scene
}, cc.LoaderScene = cc.Scene.extend({
    _interval: null,
    _label: null,
    _className: "LoaderScene",
    init: function() {
        var a = this,
            b = 200,
            c = a._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
        c.setPosition(cc.visibleRect.bottomLeft), a.addChild(c, 0);
        var d = 24,
            e = -b / 2 + 100;
        return cc._loaderImage && (cc.loader.loadImg(cc._loaderImage, {
            isCrossOrigin: !1
        }, function(c, d) {
            b = d.height, a._initStage(d, cc.visibleRect.center)
        }), d = 14, e = -b / 2 - 10), d = a._label = cc.LabelTTF.create("Loading... 0%", "Arial", d), d.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, e))), d.setColor(cc.color(180, 180, 180)), c.addChild(this._label, 10), !0
    },
    _initStage: function(a, b) {
        var c = this._texture2d = new cc.Texture2D;
        c.initWithElement(a), c.handleLoadedTexture(), c = cc.Sprite.create(c), c.setScale(cc.contentScaleFactor()), c.x = b.x, c.y = b.y, this._bgLayer.addChild(c, 10)
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this), this.schedule(this._startLoading, .3)
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this), this._label.setString("Loading... 0%")
    },
    initWithResources: function(a, b) {
        "string" == typeof a && (a = [a]), this.resources = a || [], this.cb = b
    },
    _startLoading: function() {
        var a = this;
        a.unschedule(a._startLoading), cc.loader.load(a.resources, function(b, c, d) {
            b = Math.min(100 * (d / c) | 0, 100), a._label.setString("Loading... " + b + "%")
        }, function() {
            a.cb && a.cb()
        })
    }
}), cc.LoaderScene.preload = function(a, b) {
    var c = cc;
    return c.loaderScene || (c.loaderScene = new cc.LoaderScene, c.loaderScene.init()), c.loaderScene.initWithResources(a, b), cc.director.runScene(c.loaderScene), c.loaderScene
}, cc._tmp.LayerDefineForWebGL = function() {
    var a = cc.Layer.prototype;
    a.bake = function() {}, a.unbake = function() {}, a.visit = cc.Node.prototype.visit
}, cc._tmp.WebGLLayerColor = function() {
    var a = cc.LayerColor.prototype;
    a._squareVertices = null, a._squareColors = null, a._verticesFloat32Buffer = null, a._colorsUint8Buffer = null, a._squareVerticesAB = null, a._squareColorsAB = null, a.ctor = function(a, b, c) {
        this._squareVerticesAB = new ArrayBuffer(32), this._squareColorsAB = new ArrayBuffer(16);
        var d = this._squareVerticesAB,
            e = this._squareColorsAB,
            f = cc.Vertex2F.BYTES_PER_ELEMENT,
            g = cc.Color.BYTES_PER_ELEMENT;
        this._squareVertices = [new cc.Vertex2F(0, 0, d, 0), new cc.Vertex2F(0, 0, d, f), new cc.Vertex2F(0, 0, d, 2 * f), new cc.Vertex2F(0, 0, d, 3 * f)], this._squareColors = [cc.color(0, 0, 0, 255, e, 0), cc.color(0, 0, 0, 255, e, g), cc.color(0, 0, 0, 255, e, 2 * g), cc.color(0, 0, 0, 255, e, 3 * g)], this._verticesFloat32Buffer = cc._renderContext.createBuffer(), this._colorsUint8Buffer = cc._renderContext.createBuffer(), cc.Layer.prototype.ctor.call(this), this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), cc.LayerColor.prototype.init.call(this, a, b, c)
    }, a.setContentSize = function(a, b) {
        var c = this._squareVertices;
        void 0 === b ? (c[1].x = a.width, c[2].y = a.height, c[3].x = a.width, c[3].y = a.height) : (c[1].x = a, c[2].y = b, c[3].x = a, c[3].y = b), this._bindLayerVerticesBufferData(), cc.Layer.prototype.setContentSize.call(this, a, b)
    }, a._setWidth = function(a) {
        var b = this._squareVertices;
        b[1].x = a, b[3].x = a, this._bindLayerVerticesBufferData(), cc.Layer.prototype._setWidth.call(this, a)
    }, a._setHeight = function(a) {
        var b = this._squareVertices;
        b[2].y = a, b[3].y = a, this._bindLayerVerticesBufferData(), cc.Layer.prototype._setHeight.call(this, a)
    }, a._updateColor = function() {
        for (var a = this._displayedColor, b = this._displayedOpacity, c = this._squareColors, d = 0; 4 > d; d++) c[d].r = a.r, c[d].g = a.g, c[d].b = a.b, c[d].a = b;
        this._bindLayerColorsBufferData()
    }, a.draw = function(a) {
        a = a || cc._renderContext, cc.nodeDrawSetup(this), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR), a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)
    }, a._bindLayerVerticesBufferData = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer), a.bufferData(a.ARRAY_BUFFER, this._squareVerticesAB, a.STATIC_DRAW)
    }, a._bindLayerColorsBufferData = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer), a.bufferData(a.ARRAY_BUFFER, this._squareColorsAB, a.STATIC_DRAW)
    }
}, cc._tmp.WebGLLayerGradient = function() {
    var a = cc.LayerGradient.prototype;
    a.draw = cc.LayerColor.prototype.draw, a._updateColor = function() {
        var a = this._alongVector,
            b = cc.pLength(a);
        if (0 !== b) {
            var c = Math.sqrt(2),
                a = cc.p(a.x / b, a.y / b);
            this._compressedInterpolation && (b = 1 / (Math.abs(a.x) + Math.abs(a.y)), a = cc.pMult(a, b * c));
            var d = this._displayedOpacity / 255,
                b = this._displayedColor,
                e = this._endColor,
                b = {
                    r: b.r,
                    g: b.g,
                    b: b.b,
                    a: this._startOpacity * d
                }, d = {
                    r: e.r,
                    g: e.g,
                    b: e.b,
                    a: this._endOpacity * d
                }, f = this._squareColors,
                e = f[0],
                g = f[1],
                h = f[2],
                f = f[3];
            e.r = d.r + (b.r - d.r) * ((c + a.x + a.y) / (2 * c)), e.g = d.g + (b.g - d.g) * ((c + a.x + a.y) / (2 * c)), e.b = d.b + (b.b - d.b) * ((c + a.x + a.y) / (2 * c)), e.a = d.a + (b.a - d.a) * ((c + a.x + a.y) / (2 * c)), g.r = d.r + (b.r - d.r) * ((c - a.x + a.y) / (2 * c)), g.g = d.g + (b.g - d.g) * ((c - a.x + a.y) / (2 * c)), g.b = d.b + (b.b - d.b) * ((c - a.x + a.y) / (2 * c)), g.a = d.a + (b.a - d.a) * ((c - a.x + a.y) / (2 * c)), h.r = d.r + (b.r - d.r) * ((c + a.x - a.y) / (2 * c)), h.g = d.g + (b.g - d.g) * ((c + a.x - a.y) / (2 * c)), h.b = d.b + (b.b - d.b) * ((c + a.x - a.y) / (2 * c)), h.a = d.a + (b.a - d.a) * ((c + a.x - a.y) / (2 * c)), f.r = d.r + (b.r - d.r) * ((c - a.x - a.y) / (2 * c)), f.g = d.g + (b.g - d.g) * ((c - a.x - a.y) / (2 * c)), f.b = d.b + (b.b - d.b) * ((c - a.x - a.y) / (2 * c)), f.a = d.a + (b.a - d.a) * ((c - a.x - a.y) / (2 * c)), this._bindLayerColorsBufferData()
        }
    }
}, cc._tmp.PrototypeLayerColor = function() {
    var a = cc.LayerColor.prototype;
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth), cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight)
}, cc._tmp.PrototypeLayerGradient = function() {
    var a = cc.LayerGradient.prototype;
    cc.defineGetterSetter(a, "startColor", a.getStartColor, a.setStartColor), cc.defineGetterSetter(a, "endColor", a.getEndColor, a.setEndColor), cc.defineGetterSetter(a, "startOpacity", a.getStartOpacity, a.setStartOpacity), cc.defineGetterSetter(a, "endOpacity", a.getEndOpacity, a.setEndOpacity), cc.defineGetterSetter(a, "vector", a.getVector, a.setVector)
}, cc.Layer = cc.Node.extend({
    _isBaked: !1,
    _bakeSprite: null,
    _className: "Layer",
    ctor: function() {
        var a = cc.Node.prototype;
        a.ctor.call(this), this._ignoreAnchorPointForPosition = !0, a.setAnchorPoint.call(this, .5, .5), a.setContentSize.call(this, cc.winSize)
    },
    init: function() {
        return this._ignoreAnchorPointForPosition = !0, this.setAnchorPoint(.5, .5), this.setContentSize(cc.winSize), this.cascadeColor = this.cascadeOpacity = !1, !0
    },
    bake: null,
    unbake: null,
    isBaked: function() {
        return this._isBaked
    },
    visit: null
}), cc.Layer.create = function() {
    return new cc.Layer
}, cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var p = cc.Layer.prototype;
    p.bake = function() {
        if (!this._isBaked) {
            this._isBaked = this._cacheDirty = !0, this._cachedParent = this;
            for (var a = this._children, b = 0, c = a.length; c > b; b++) a[b]._setCachedParent(this);
            this._bakeSprite || (this._bakeSprite = new cc.BakeSprite)
        }
    }, p.unbake = function() {
        if (this._isBaked) {
            this._isBaked = !1, this._cacheDirty = !0, this._cachedParent = null;
            for (var a = this._children, b = 0, c = a.length; c > b; b++) a[b]._setCachedParent(null)
        }
    }, p.visit = function(a) {
        if (this._isBaked) {
            a = a || cc._renderContext;
            var b, c = this._children,
                d = c.length;
            if (this._visible && 0 !== d) {
                var e = this._bakeSprite;
                if (a.save(), this.transform(a), this._cacheDirty) {
                    b = this._getBoundingBoxForBake(), b.width |= 0, b.height |= 0;
                    var f = e.getCacheContext();
                    e.resetCanvasSize(b.width, b.height), f.translate(0 - b.x, b.height + b.y);
                    var g = e.getAnchorPointInPoints();
                    for (e.setPosition(g.x + b.x, g.y + b.y), this.sortAllChildren(), cc.view._setScaleXYForRenderTexture(), b = 0; d > b; b++) c[b].visit(f);
                    cc.view._resetScale(), this._cacheDirty = !1
                }
                e.visit(a), this.arrivalOrder = 0, a.restore()
            }
        } else cc.Node.prototype.visit.call(this, a)
    }, p._getBoundingBoxForBake = function() {
        var a = null;
        if (!this._children || 0 === this._children.length) return cc.rect(0, 0, 10, 10);
        for (var b = this._children, c = 0; c < b.length; c++) {
            var d = b[c];
            d && d._visible && (a ? (d = d._getBoundingBoxToCurrentNode()) && (a = cc.rectUnion(a, d)) : a = d._getBoundingBoxToCurrentNode())
        }
        return a
    }, p = null
} else cc.assert("function" == typeof cc._tmp.LayerDefineForWebGL, cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.LayerDefineForWebGL(), delete cc._tmp.LayerDefineForWebGL;
cc.LayerColor = cc.Layer.extend({
    _blendFunc: null,
    _className: "LayerColor",
    getBlendFunc: function() {
        return this._blendFunc
    },
    changeWidthAndHeight: function(a, b) {
        this.width = a, this.height = b
    },
    changeWidth: function(a) {
        this.width = a
    },
    changeHeight: function(a) {
        this.height = a
    },
    setOpacityModifyRGB: function() {},
    isOpacityModifyRGB: function() {
        return !1
    },
    setColor: function(a) {
        cc.Layer.prototype.setColor.call(this, a), this._updateColor()
    },
    setOpacity: function(a) {
        cc.Layer.prototype.setOpacity.call(this, a), this._updateColor()
    },
    _blendFuncStr: "source",
    ctor: null,
    init: function(a, b, c) {
        cc._renderType !== cc._RENDER_TYPE_CANVAS && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
        var d = cc.director.getWinSize();
        return a = a || cc.color(0, 0, 0, 255), b = void 0 === b ? d.width : b, c = void 0 === c ? d.height : c, d = this._displayedColor, d.r = a.r, d.g = a.g, d.b = a.b, d = this._realColor, d.r = a.r, d.g = a.g, d.b = a.b, this._realOpacity = this._displayedOpacity = a.a, a = cc.LayerColor.prototype, a.setContentSize.call(this, b, c), a._updateColor.call(this), !0
    },
    setBlendFunc: function(a, b) {
        var c = this._blendFunc;
        void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b), cc._renderType === cc._RENDER_TYPE_CANVAS && (this._blendFuncStr = cc._getCompositeOperationByBlendFunc(c))
    },
    _setWidth: null,
    _setHeight: null,
    _updateColor: null,
    updateDisplayedColor: function(a) {
        cc.Layer.prototype.updateDisplayedColor.call(this, a), this._updateColor()
    },
    updateDisplayedOpacity: function(a) {
        cc.Layer.prototype.updateDisplayedOpacity.call(this, a), this._updateColor()
    },
    draw: null
}), cc.LayerColor.create = function(a, b, c) {
    return new cc.LayerColor(a, b, c)
}, cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.LayerColor.prototype, _p.ctor = function(a, b, c) {
    cc.Layer.prototype.ctor.call(this), this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), cc.LayerColor.prototype.init.call(this, a, b, c)
}, _p._setWidth = cc.Layer.prototype._setWidth, _p._setHeight = cc.Layer.prototype._setHeight, _p._updateColor = function() {}, _p.draw = function(a) {
    a = a || cc._renderContext;
    var b = cc.view,
        c = this._displayedColor;
    a.fillStyle = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + "," + this._displayedOpacity / 255 + ")", a.fillRect(0, 0, this.width * b.getScaleX(), -this.height * b.getScaleY()), cc.g_NumberOfDraws++
}, _p.visit = function(a) {
    if (this._isBaked) {
        a = a || cc._renderContext;
        var b, c = this._children,
            d = c.length;
        if (this._visible) {
            var e = this._bakeSprite;
            if (a.save(), this.transform(a), this._cacheDirty) {
                b = this._getBoundingBoxForBake(), b.width |= 0, b.height |= 0;
                var f = e.getCacheContext();
                e.resetCanvasSize(b.width, b.height);
                var g = e.getAnchorPointInPoints(),
                    h = this._position;
                if (this._ignoreAnchorPointForPosition) f.translate(0 - b.x + h.x, b.height + b.y - h.y), e.setPosition(g.x + b.x - h.x, g.y + b.y - h.y);
                else {
                    var i = this.getAnchorPointInPoints(),
                        j = h.x - i.x,
                        h = h.y - i.y;
                    f.translate(0 - b.x + j, b.height + b.y - h), e.setPosition(g.x + b.x - j, g.y + b.y - h)
                } if (cc.view._setScaleXYForRenderTexture(), d > 0) {
                    for (this.sortAllChildren(), b = 0; d > b && (g = c[b], 0 > g._localZOrder); b++) g.visit(f);
                    for (this.draw(f); d > b; b++) c[b].visit(f)
                } else this.draw(f);
                cc.view._resetScale(), this._cacheDirty = !1
            }
            e.visit(a), this.arrivalOrder = 0, a.restore()
        }
    } else cc.Node.prototype.visit.call(this, a)
}, _p._getBoundingBoxForBake = function() {
    var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
        b = this.nodeToWorldTransform(),
        a = cc.rectApplyAffineTransform(a, this.nodeToWorldTransform());
    if (!this._children || 0 === this._children.length) return a;
    for (var c = this._children, d = 0; d < c.length; d++) {
        var e = c[d];
        e && e._visible && (e = e._getBoundingBoxToCurrentNode(b), a = cc.rectUnion(a, e))
    }
    return a
}, _p = null) : (cc.assert("function" == typeof cc._tmp.WebGLLayerColor, cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.WebGLLayerColor(), delete cc._tmp.WebGLLayerColor), cc.assert("function" == typeof cc._tmp.PrototypeLayerColor, cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js"), cc._tmp.PrototypeLayerColor(), delete cc._tmp.PrototypeLayerColor, cc.LayerGradient = cc.LayerColor.extend({
    _startColor: null,
    _endColor: null,
    _startOpacity: 255,
    _endOpacity: 255,
    _alongVector: null,
    _compressedInterpolation: !1,
    _gradientStartPoint: null,
    _gradientEndPoint: null,
    _className: "LayerGradient",
    ctor: function(a, b, c) {
        cc.LayerColor.prototype.ctor.call(this), this._startColor = cc.color(0, 0, 0, 255), this._endColor = cc.color(0, 0, 0, 255), this._alongVector = cc.p(0, -1), this._endOpacity = this._startOpacity = 255, this._gradientStartPoint = cc.p(0, 0), this._gradientEndPoint = cc.p(0, 0), cc.LayerGradient.prototype.init.call(this, a, b, c)
    },
    init: function(a, b, c) {
        a = a || cc.color(0, 0, 0, 255), b = b || cc.color(0, 0, 0, 255), c = c || cc.p(0, -1);
        var d = this._startColor,
            e = this._endColor;
        return d.r = a.r, d.g = a.g, d.b = a.b, this._startOpacity = a.a, e.r = b.r, e.g = b.g, e.b = b.b, this._endOpacity = b.a, this._alongVector = c, this._compressedInterpolation = !0, this._gradientStartPoint = cc.p(0, 0), this._gradientEndPoint = cc.p(0, 0), cc.LayerColor.prototype.init.call(this, cc.color(a.r, a.g, a.b, 255)), cc.LayerGradient.prototype._updateColor.call(this), !0
    },
    setContentSize: function(a, b) {
        cc.LayerColor.prototype.setContentSize.call(this, a, b), this._updateColor()
    },
    _setWidth: function(a) {
        cc.LayerColor.prototype._setWidth.call(this, a), this._updateColor()
    },
    _setHeight: function(a) {
        cc.LayerColor.prototype._setHeight.call(this, a), this._updateColor()
    },
    getStartColor: function() {
        return this._realColor
    },
    setStartColor: function(a) {
        this.color = a
    },
    setEndColor: function(a) {
        this._endColor = a, this._updateColor()
    },
    getEndColor: function() {
        return this._endColor
    },
    setStartOpacity: function(a) {
        this._startOpacity = a, this._updateColor()
    },
    getStartOpacity: function() {
        return this._startOpacity
    },
    setEndOpacity: function(a) {
        this._endOpacity = a, this._updateColor()
    },
    getEndOpacity: function() {
        return this._endOpacity
    },
    setVector: function(a) {
        this._alongVector.x = a.x, this._alongVector.y = a.y, this._updateColor()
    },
    getVector: function() {
        return cc.p(this._alongVector.x, this._alongVector.y)
    },
    isCompressedInterpolation: function() {
        return this._compressedInterpolation
    },
    setCompressedInterpolation: function(a) {
        this._compressedInterpolation = a, this._updateColor()
    },
    _draw: null,
    _updateColor: null
}), cc.LayerGradient.create = function(a, b, c) {
    return new cc.LayerGradient(a, b, c)
}, cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.LayerGradient.prototype, _p.draw = function(a) {
    a = a || cc._renderContext, "source" != this._blendFuncStr && (a.globalCompositeOperation = this._blendFuncStr), a.save();
    var b = this._displayedOpacity / 255,
        c = cc.view.getScaleX(),
        d = cc.view.getScaleY(),
        e = this.width * c,
        f = this.height * d,
        c = a.createLinearGradient(this._gradientStartPoint.x * c, this._gradientStartPoint.y * d, this._gradientEndPoint.x * c, this._gradientEndPoint.y * d),
        d = this._displayedColor,
        g = this._endColor;
    c.addColorStop(0, "rgba(" + Math.round(d.r) + "," + Math.round(d.g) + "," + Math.round(d.b) + "," + (b * (this._startOpacity / 255)).toFixed(4) + ")"), c.addColorStop(1, "rgba(" + Math.round(g.r) + "," + Math.round(g.g) + "," + Math.round(g.b) + "," + (b * (this._endOpacity / 255)).toFixed(4) + ")"), a.fillStyle = c, a.fillRect(0, 0, e, -f), 0 != this._rotation && a.rotate(this._rotationRadians), a.restore(), cc.g_NumberOfDraws++
}, _p._updateColor = function() {
    var a = this._alongVector,
        b = .5 * this.width,
        c = .5 * this.height;
    this._gradientStartPoint.x = b * -a.x + b, this._gradientStartPoint.y = c * a.y - c, this._gradientEndPoint.x = b * a.x + b, this._gradientEndPoint.y = c * -a.y - c
}, _p = null) : (cc.assert("function" == typeof cc._tmp.WebGLLayerGradient, cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.WebGLLayerGradient(), delete cc._tmp.WebGLLayerGradient), cc.assert("function" == typeof cc._tmp.PrototypeLayerGradient, cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js"), cc._tmp.PrototypeLayerGradient(), delete cc._tmp.PrototypeLayerGradient, cc.LayerMultiplex = cc.Layer.extend({
    _enabledLayer: 0,
    _layers: null,
    _className: "LayerMultiplex",
    ctor: function(a) {
        cc.Layer.prototype.ctor.call(this), a instanceof Array ? cc.LayerMultiplex.prototype.initWithLayers.call(this, a) : cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments))
    },
    initWithLayers: function(a) {
        return 0 < a.length && null == a[a.length - 1] && cc.log(cc._LogInfos.LayerMultiplex_initWithLayers), this._layers = a, this._enabledLayer = 0, this.addChild(this._layers[this._enabledLayer]), !0
    },
    switchTo: function(a) {
        a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchTo) : (this.removeChild(this._layers[this._enabledLayer], !0), this._enabledLayer = a, this.addChild(this._layers[a]))
    },
    switchToAndReleaseMe: function(a) {
        a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe) : (this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = a, this.addChild(this._layers[a]))
    },
    addLayer: function(a) {
        a ? this._layers.push(a) : cc.log(cc._LogInfos.LayerMultiplex_addLayer)
    }
}), cc.LayerMultiplex.create = function() {
    return new cc.LayerMultiplex(Array.prototype.slice.call(arguments))
}, cc._tmp.WebGLSprite = function() {
    var a = cc.Sprite.prototype;
    a._spriteFrameLoadedCallback = function(a) {
        this.setNodeDirty(!0), this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize()), this._callLoadedEventCallbacks()
    }, a.setOpacityModifyRGB = function(a) {
        this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this.updateColor())
    }, a.updateDisplayedOpacity = function(a) {
        cc.Node.prototype.updateDisplayedOpacity.call(this, a), this.updateColor()
    }, a.ctor = function(a, b, c) {
        cc.Node.prototype.ctor.call(this), this._shouldBeHidden = !1, this._offsetPosition = cc.p(0, 0), this._unflippedOffsetPositionFromCenter = cc.p(0, 0), this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        }, this._rect = cc.rect(0, 0, 0, 0), this._quad = new cc.V3F_C4B_T2F_Quad, this._quadWebBuffer = cc._renderContext.createBuffer(), this._textureLoaded = this._quadDirty = !0, this._softInit(a, b, c)
    }, a.setBlendFunc = function(a, b) {
        var c = this._blendFunc;
        void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b)
    }, a.init = function() {
        if (0 < arguments.length) return this.initWithFile(arguments[0], arguments[1]);
        cc.Node.prototype.init.call(this), this.dirty = this._recursiveDirty = !1, this._opacityModifyRGB = !0, this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, this.texture = null, this._textureLoaded = !0, this._flippedX = this._flippedY = !1, this.anchorY = this.anchorX = .5, this._offsetPosition.x = 0, this._offsetPosition.y = 0, this._hasChildren = !1;
        var a = {
            r: 255,
            g: 255,
            b: 255,
            a: 255
        };
        return this._quad.bl.colors = a, this._quad.br.colors = a, this._quad.tl.colors = a, this._quad.tr.colors = a, this._quadDirty = !0, this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0)), !0
    }, a.initWithTexture = function(a, b, c) {
        if (cc.assert(0 != arguments.length, cc._LogInfos.Sprite_initWithTexture), c = c || !1, !cc.Node.prototype.init.call(this)) return !1;
        this._batchNode = null, this.dirty = this._recursiveDirty = !1, this._opacityModifyRGB = !0, this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, this._flippedX = this._flippedY = !1, this.anchorY = this.anchorX = .5, this._offsetPosition.x = 0, this._offsetPosition.y = 0, this._hasChildren = !1;
        var d = cc.color(255, 255, 255, 255),
            e = this._quad;
        return e.bl.colors = d, e.br.colors = d, e.tl.colors = d, e.tr.colors = d, this._textureLoaded = d = a.isLoaded(), d ? (b || (b = cc.rect(0, 0, a.width, a.height)), a && a.url && (c ? (d = b.x + b.height, e = b.y + b.width) : (d = b.x + b.width, e = b.y + b.height), d > a.width && cc.error(cc._LogInfos.RectWidth, a.url), e > a.height && cc.error(cc._LogInfos.RectHeight, a.url)), this.texture = a, this.setTextureRect(b, c), this.batchNode = null, this._quadDirty = !0) : (this._rectRotated = c || !1, b && (d = this._rect, d.x = b.x, d.y = b.y, d.width = b.width, d.height = b.height), a.addLoadedEventListener(this._textureLoadedCallback, this), !0)
    }, a._textureLoadedCallback = function(a) {
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var b = this._rect;
            b ? cc._rectEqualToZero(b) && (b.width = a.width, b.height = a.height) : b = cc.rect(0, 0, a.width, a.height), this.texture = a, this.setTextureRect(b, this._rectRotated), this.batchNode = this._batchNode, this._quadDirty = !0, this._callLoadedEventCallbacks()
        }
    }, a.setTextureRect = function(a, b, c) {
        this._rectRotated = b || !1, this.setContentSize(c || a), this.setVertexRect(a), this._setTextureCoords(a), a = this._unflippedOffsetPositionFromCenter, this._flippedX && (a.x = -a.x), this._flippedY && (a.y = -a.y);
        var d = this._rect;
        if (this._offsetPosition.x = a.x + (this._contentSize.width - d.width) / 2, this._offsetPosition.y = a.y + (this._contentSize.height - d.height) / 2, this._batchNode) this.dirty = !0;
        else {
            a = 0 + this._offsetPosition.x, b = 0 + this._offsetPosition.y, c = a + d.width;
            var d = b + d.height,
                e = this._quad;
            e.bl.vertices = {
                x: a,
                y: b,
                z: 0
            }, e.br.vertices = {
                x: c,
                y: b,
                z: 0
            }, e.tl.vertices = {
                x: a,
                y: d,
                z: 0
            }, e.tr.vertices = {
                x: c,
                y: d,
                z: 0
            }, this._quadDirty = !0
        }
    }, a.updateTransform = function() {
        if (this.dirty) {
            var a = this._quad,
                b = this._parent;
            if (!this._visible || b && b != this._batchNode && b._shouldBeHidden) a.br.vertices = a.tl.vertices = a.tr.vertices = a.bl.vertices = {
                x: 0,
                y: 0,
                z: 0
            }, this._shouldBeHidden = !0;
            else {
                this._shouldBeHidden = !1;
                var c = this._transformToBatch = b && b != this._batchNode ? cc.affineTransformConcat(this.nodeToParentTransform(), b._transformToBatch) : this.nodeToParentTransform(),
                    d = this._rect,
                    b = this._offsetPosition.x,
                    e = this._offsetPosition.y,
                    f = b + d.width,
                    g = e + d.height,
                    h = c.tx,
                    i = c.ty,
                    j = c.a,
                    k = c.b,
                    l = c.d,
                    m = -c.c,
                    c = b * j - e * m + h,
                    d = b * k + e * l + i,
                    n = f * j - e * m + h,
                    e = f * k + e * l + i,
                    o = f * j - g * m + h,
                    f = f * k + g * l + i,
                    h = b * j - g * m + h,
                    b = b * k + g * l + i,
                    g = this._vertexZ;
                cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (c |= 0, d |= 0, n |= 0, e |= 0, o |= 0, f |= 0, h |= 0, b |= 0), a.bl.vertices = {
                    x: c,
                    y: d,
                    z: g
                }, a.br.vertices = {
                    x: n,
                    y: e,
                    z: g
                }, a.tl.vertices = {
                    x: h,
                    y: b,
                    z: g
                }, a.tr.vertices = {
                    x: o,
                    y: f,
                    z: g
                }
            }
            this.textureAtlas.updateQuad(a, this.atlasIndex), this.dirty = this._recursiveDirty = !1
        }
        this._hasChildren && this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.updateTransform), cc.SPRITE_DEBUG_DRAW && (a = [cc.p(this._quad.bl.vertices.x, this._quad.bl.vertices.y), cc.p(this._quad.br.vertices.x, this._quad.br.vertices.y), cc.p(this._quad.tr.vertices.x, this._quad.tr.vertices.y), cc.p(this._quad.tl.vertices.x, this._quad.tl.vertices.y)], cc._drawingUtil.drawPoly(a, 4, !0))
    }, a.addChild = function(a, b, c) {
        if (cc.assert(a, cc._LogInfos.Sprite_addChild_3), null == b && (b = a._localZOrder), null == c && (c = a.tag), this._batchNode) {
            if (!(a instanceof cc.Sprite)) return void cc.log(cc._LogInfos.Sprite_addChild);
            a.texture._webTextureObj !== this.textureAtlas.texture._webTextureObj && cc.log(cc._LogInfos.Sprite_addChild_2), this._batchNode.appendChild(a), this._reorderChildDirty || this._setReorderChildDirtyRecursively()
        }
        cc.Node.prototype.addChild.call(this, a, b, c), this._hasChildren = !0
    }, a.setOpacity = function(a) {
        cc.Node.prototype.setOpacity.call(this, a), this.updateColor()
    }, a.setColor = function(a) {
        cc.Node.prototype.setColor.call(this, a), this.updateColor()
    }, a.updateDisplayedColor = function(a) {
        cc.Node.prototype.updateDisplayedColor.call(this, a), this.updateColor()
    }, a.setSpriteFrame = function(a) {
        var b = this;
        "string" == typeof a && (a = cc.spriteFrameCache.getSpriteFrame(a), cc.assert(a, cc._LogInfos.Sprite_setSpriteFrame)), b.setNodeDirty(!0);
        var c = a.getOffset();
        b._unflippedOffsetPositionFromCenter.x = c.x, b._unflippedOffsetPositionFromCenter.y = c.y, c = a.getTexture(), a.textureLoaded() || (b._textureLoaded = !1, a.addLoadedEventListener(function(a) {
            b._textureLoaded = !0;
            var c = a.getTexture();
            c != b._texture && (b.texture = c), b.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize()), b._callLoadedEventCallbacks()
        }, b)), c != b._texture && (b.texture = c), b._rectRotated = a.isRotated(), b.setTextureRect(a.getRect(), b._rectRotated, a.getOriginalSize())
    }, a.isFrameDisplayed = function(a) {
        return cc.rectEqualToRect(a.getRect(), this._rect) && a.getTexture().getName() == this._texture.getName() && cc.pointEqualToPoint(a.getOffset(), this._unflippedOffsetPositionFromCenter)
    }, a.setBatchNode = function(a) {
        if (this._batchNode = a) this._transformToBatch = cc.affineTransformIdentity(), this.textureAtlas = this._batchNode.textureAtlas;
        else {
            this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED, this.textureAtlas = null, this.dirty = this._recursiveDirty = !1, a = this._offsetPosition.x;
            var b = this._offsetPosition.y,
                c = a + this._rect.width,
                d = b + this._rect.height,
                e = this._quad;
            e.bl.vertices = {
                x: a,
                y: b,
                z: 0
            }, e.br.vertices = {
                x: c,
                y: b,
                z: 0
            }, e.tl.vertices = {
                x: a,
                y: d,
                z: 0
            }, e.tr.vertices = {
                x: c,
                y: d,
                z: 0
            }, this._quadDirty = !0
        }
    }, a.setTexture = function(a) {
        a && "string" == typeof a ? (a = cc.textureCache.addImage(a), this.setTexture(a), a = a.getContentSize(), this.setTextureRect(cc.rect(0, 0, a.width, a.height))) : (cc.assert(!a || a instanceof cc.Texture2D, cc._LogInfos.Sprite_setTexture_2), this._batchNode && this._batchNode.texture != a ? cc.log(cc._LogInfos.Sprite_setTexture) : (this.shaderProgram = cc.shaderCache.programForKey(a ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_COLOR), !this._batchNode && this._texture != a && (this._texture = a, this._updateBlendFunc())))
    }, a.draw = function() {
        if (this._textureLoaded) {
            var a = cc._renderContext,
                b = this._texture;
            b ? b._isLoaded && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2DN(0, b), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.DYNAMIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(0, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(1, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(2, 2, a.FLOAT, !1, 24, 16), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)) : (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(null), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (cc._renderContext.bufferData(cc._renderContext.ARRAY_BUFFER, this._quad.arrayBuffer, cc._renderContext.STATIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)), cc.g_NumberOfDraws++, (0 !== cc.SPRITE_DEBUG_DRAW || this._showNode) && (1 === cc.SPRITE_DEBUG_DRAW || this._showNode ? (a = this._quad, a = [cc.p(a.tl.vertices.x, a.tl.vertices.y), cc.p(a.bl.vertices.x, a.bl.vertices.y), cc.p(a.br.vertices.x, a.br.vertices.y), cc.p(a.tr.vertices.x, a.tr.vertices.y)], cc._drawingUtil.drawPoly(a, 4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (a = this.getTextureRect(), b = this.getOffsetPosition(), a = [cc.p(b.x, b.y), cc.p(b.x + a.width, b.y), cc.p(b.x + a.width, b.y + a.height), cc.p(b.x, b.y + a.height)], cc._drawingUtil.drawPoly(a, 4, !0)))
        }
    }, delete a
}, cc._tmp.PrototypeSprite = function() {
    var a = cc.Sprite.prototype;
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB, a.setOpacityModifyRGB), cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity), cc.defineGetterSetter(a, "color", a.getColor, a.setColor), cc.defineGetterSetter(a, "flippedX", a.isFlippedX, a.setFlippedX), cc.defineGetterSetter(a, "flippedY", a.isFlippedY, a.setFlippedY), cc.defineGetterSetter(a, "offsetX", a._getOffsetX), cc.defineGetterSetter(a, "offsetY", a._getOffsetY), cc.defineGetterSetter(a, "texture", a.getTexture, a.setTexture), cc.defineGetterSetter(a, "textureRectRotated", a.isTextureRectRotated), cc.defineGetterSetter(a, "batchNode", a.getBatchNode, a.setBatchNode), cc.defineGetterSetter(a, "quad", a.getQuad)
}, cc.generateTintImageWithMultiply = function(a, b, c, d) {
    d = d || cc.newElement("canvas"), c = c || cc.rect(0, 0, a.width, a.height);
    var e = d.getContext("2d");
    return d.width != c.width || d.height != c.height ? (d.width = c.width, d.height = c.height) : e.globalCompositeOperation = "source-over", e.fillStyle = "rgb(" + (0 | b.r) + "," + (0 | b.g) + "," + (0 | b.b) + ")", e.fillRect(0, 0, c.width, c.height), e.globalCompositeOperation = "multiply", e.drawImage(a, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height), e.globalCompositeOperation = "destination-atop", e.drawImage(a, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height), d
}, cc.generateTintImage = function(a, b, c, d, e) {
    d || (d = cc.rect(0, 0, a.width, a.height)), a = c.r / 255;
    var f = c.g / 255;
    c = c.b / 255;
    var g, h = Math.min(d.width, b[0].width),
        i = Math.min(d.height, b[0].height);
    e ? (g = e.getContext("2d"), g.clearRect(0, 0, h, i)) : (e = cc.newElement("canvas"), e.width = h, e.height = i, g = e.getContext("2d")), g.save(), g.globalCompositeOperation = "lighter";
    var j = g.globalAlpha;
    return a > 0 && (g.globalAlpha = a * j, g.drawImage(b[0], d.x, d.y, h, i, 0, 0, h, i)), f > 0 && (g.globalAlpha = f * j, g.drawImage(b[1], d.x, d.y, h, i, 0, 0, h, i)), c > 0 && (g.globalAlpha = c * j, g.drawImage(b[2], d.x, d.y, h, i, 0, 0, h, i)), 1 > a + f + c && (g.globalAlpha = j, g.drawImage(b[3], d.x, d.y, h, i, 0, 0, h, i)), g.restore(), e
}, cc.generateTextureCacheForColor = function(a) {
    function b() {
        var b = cc.generateTextureCacheForColor,
            d = a.width,
            e = a.height;
        c[0].width = d, c[0].height = e, c[1].width = d, c[1].height = e, c[2].width = d, c[2].height = e, c[3].width = d, c[3].height = e, b.canvas.width = d, b.canvas.height = e;
        var f = b.canvas.getContext("2d");
        f.drawImage(a, 0, 0), b.tempCanvas.width = d, b.tempCanvas.height = e;
        for (var f = f.getImageData(0, 0, d, e).data, g = 0; 4 > g; g++) {
            var h = c[g].getContext("2d");
            h.getImageData(0, 0, d, e).data, b.tempCtx.drawImage(a, 0, 0);
            for (var i = b.tempCtx.getImageData(0, 0, d, e), j = i.data, k = 0; k < f.length; k += 4) j[k] = 0 === g ? f[k] : 0, j[k + 1] = 1 === g ? f[k + 1] : 0, j[k + 2] = 2 === g ? f[k + 2] : 0, j[k + 3] = f[k + 3];
            h.putImageData(i, 0, 0)
        }
        a.onload = null
    }
    if (a.channelCache) return a.channelCache;
    var c = [cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas")];
    try {
        b()
    } catch (d) {
        a.onload = b
    }
    return a.channelCache = c
}, cc.generateTextureCacheForColor.canvas = cc.newElement("canvas"), cc.generateTextureCacheForColor.tempCanvas = cc.newElement("canvas"), cc.generateTextureCacheForColor.tempCtx = cc.generateTextureCacheForColor.tempCanvas.getContext("2d"), cc.cutRotateImageToCanvas = function(a, b) {
    if (!a) return null;
    if (!b) return a;
    var c = cc.newElement("canvas");
    c.width = b.width, c.height = b.height;
    var d = c.getContext("2d");
    return d.translate(c.width / 2, c.height / 2), d.rotate(-1.5707963267948966), d.drawImage(a, b.x, b.y, b.height, b.width, -b.height / 2, -b.width / 2, b.height, b.width), c
}, cc._getCompositeOperationByBlendFunc = function(a) {
    return a ? a.src == cc.SRC_ALPHA && a.dst == cc.ONE || a.src == cc.ONE && a.dst == cc.ONE ? "lighter" : a.src == cc.ZERO && a.dst == cc.SRC_ALPHA ? "destination-in" : a.src == cc.ZERO && a.dst == cc.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source" : "source"
}, cc.Sprite = cc.Node.extend({
    dirty: !1,
    atlasIndex: 0,
    textureAtlas: null,
    _batchNode: null,
    _recursiveDirty: null,
    _hasChildren: null,
    _shouldBeHidden: !1,
    _transformToBatch: null,
    _blendFunc: null,
    _texture: null,
    _rect: null,
    _rectRotated: !1,
    _offsetPosition: null,
    _unflippedOffsetPositionFromCenter: null,
    _opacityModifyRGB: !1,
    _flippedX: !1,
    _flippedY: !1,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _newTextureWhenChangeColor: null,
    _className: "Sprite",
    _oldDisplayColor: cc.color.WHITE,
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this._loadedEventListeners || (this._loadedEventListeners = []), this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: b
        })
    },
    _callLoadedEventCallbacks: function() {
        if (this._loadedEventListeners) {
            for (var a = this._loadedEventListeners, b = 0, c = a.length; c > b; b++) {
                var d = a[b];
                d.eventCallback.call(d.eventTarget, this)
            }
            a.length = 0
        }
    },
    isDirty: function() {
        return this.dirty
    },
    setDirty: function(a) {
        this.dirty = a
    },
    isTextureRectRotated: function() {
        return this._rectRotated
    },
    getAtlasIndex: function() {
        return this.atlasIndex
    },
    setAtlasIndex: function(a) {
        this.atlasIndex = a
    },
    getTextureRect: function() {
        return cc.rect(this._rect.x, this._rect.y, this._rect.width, this._rect.height)
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    },
    getOffsetPosition: function() {
        return cc.p(this._offsetPosition)
    },
    _getOffsetX: function() {
        return this._offsetPosition.x
    },
    _getOffsetY: function() {
        return this._offsetPosition.y
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    initWithSpriteFrame: function(a) {
        cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrame), a.textureLoaded() || (this._textureLoaded = !1, a.addLoadedEventListener(this._spriteFrameLoadedCallback, this));
        var b = cc._renderType === cc._RENDER_TYPE_CANVAS ? !1 : a._rotated,
            b = this.initWithTexture(a.getTexture(), a.getRect(), b);
        return this.setSpriteFrame(a), b
    },
    _spriteFrameLoadedCallback: null,
    initWithSpriteFrameName: function(a) {
        cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrameName);
        var b = cc.spriteFrameCache.getSpriteFrame(a);
        return cc.assert(b, a + cc._LogInfos.Sprite_initWithSpriteFrameName1), this.initWithSpriteFrame(b)
    },
    useBatchNode: function(a) {
        this.textureAtlas = a.textureAtlas, this._batchNode = a
    },
    setVertexRect: function(a) {
        this._rect.x = a.x, this._rect.y = a.y, this._rect.width = a.width, this._rect.height = a.height
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a, b, c, d = this._children,
                e = d.length;
            for (a = 1; e > a; a++) {
                for (c = d[a], b = a - 1; b >= 0;) {
                    if (c._localZOrder < d[b]._localZOrder) d[b + 1] = d[b];
                    else {
                        if (!(c._localZOrder === d[b]._localZOrder && c.arrivalOrder < d[b].arrivalOrder)) break;
                        d[b + 1] = d[b]
                    }
                    b--
                }
                d[b + 1] = c
            }
            this._batchNode && this._arrayMakeObjectsPerformSelector(d, cc.Node._StateCallbackType.sortAllChildren), this._reorderChildDirty = !1
        }
    },
    reorderChild: function(a, b) {
        cc.assert(a, cc._LogInfos.Sprite_reorderChild_2), -1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.Sprite_reorderChild) : b !== a.zIndex && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(), this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, a, b))
    },
    removeChild: function(a, b) {
        this._batchNode && this._batchNode.removeSpriteFromAtlas(a), cc.Node.prototype.removeChild.call(this, a, b)
    },
    setVisible: function(a) {
        cc.Node.prototype.setVisible.call(this, a), this.setDirtyRecursively(!0)
    },
    removeAllChildren: function(a) {
        var b = this._children,
            c = this._batchNode;
        if (c && null != b)
            for (var d = 0, e = b.length; e > d; d++) c.removeSpriteFromAtlas(b[d]);
        cc.Node.prototype.removeAllChildren.call(this, a), this._hasChildren = !1
    },
    setDirtyRecursively: function(a) {
        this.dirty = this._recursiveDirty = a, a = this._children;
        for (var b, c = a ? a.length : 0, d = 0; c > d; d++) b = a[d], b instanceof cc.Sprite && b.setDirtyRecursively(!0)
    },
    setNodeDirty: function(a) {
        cc.Node.prototype.setNodeDirty.call(this), !a && this._batchNode && !this._recursiveDirty && (this._hasChildren ? this.setDirtyRecursively(!0) : this.dirty = this._recursiveDirty = !0)
    },
    ignoreAnchorPointForPosition: function(a) {
        this._batchNode ? cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition) : cc.Node.prototype.ignoreAnchorPointForPosition.call(this, a)
    },
    setFlippedX: function(a) {
        this._flippedX != a && (this._flippedX = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    setFlippedY: function(a) {
        this._flippedY != a && (this._flippedY = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    isFlippedX: function() {
        return this._flippedX
    },
    isFlippedY: function() {
        return this._flippedY
    },
    setOpacityModifyRGB: null,
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    updateDisplayedOpacity: null,
    setDisplayFrameWithAnimationName: function(a, b) {
        cc.assert(a, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
        var c = cc.animationCache.getAnimation(a);
        c ? (c = c.getFrames()[b]) ? this.setSpriteFrame(c.getSpriteFrame()) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName)
    },
    getBatchNode: function() {
        return this._batchNode
    },
    _setReorderChildDirtyRecursively: function() {
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = !0;
            for (var a = this._parent; a && a != this._batchNode;) a._setReorderChildDirtyRecursively(), a = a.parent
        }
    },
    getTexture: function() {
        return this._texture
    },
    _quad: null,
    _quadWebBuffer: null,
    _quadDirty: !1,
    _colorized: !1,
    _blendFuncStr: "source",
    _originalTexture: null,
    _textureRect_Canvas: null,
    _drawSize_Canvas: null,
    ctor: null,
    _softInit: function(a, b, c) {
        void 0 === a ? cc.Sprite.prototype.init.call(this) : "string" == typeof a ? "#" === a[0] ? (a = a.substr(1, a.length - 1), a = cc.spriteFrameCache.getSpriteFrame(a), this.initWithSpriteFrame(a)) : cc.Sprite.prototype.init.call(this, a, b) : "object" == typeof a && (a instanceof cc.Texture2D ? this.initWithTexture(a, b, c) : a instanceof cc.SpriteFrame ? this.initWithSpriteFrame(a) : (a instanceof HTMLImageElement || a instanceof HTMLCanvasElement) && (b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.initWithTexture(b)))
    },
    getQuad: function() {
        return this._quad
    },
    setBlendFunc: null,
    init: null,
    initWithFile: function(a, b) {
        cc.assert(a, cc._LogInfos.Sprite_initWithFile);
        var c = cc.textureCache.getTextureForKey(a);
        if (c) {
            if (!b) {
                var d = c.getContentSize();
                b = cc.rect(0, 0, d.width, d.height)
            }
            return this.initWithTexture(c, b)
        }
        return c = cc.textureCache.addImage(a), this.initWithTexture(c, b || cc.rect(0, 0, c._contentSize.width, c._contentSize.height))
    },
    initWithTexture: null,
    _textureLoadedCallback: null,
    setTextureRect: null,
    updateTransform: null,
    addChild: null,
    updateColor: function() {
        var a = this._displayedColor,
            b = this._displayedOpacity,
            a = {
                r: a.r,
                g: a.g,
                b: a.b,
                a: b
            };
        this._opacityModifyRGB && (a.r *= b / 255, a.g *= b / 255, a.b *= b / 255), b = this._quad, b.bl.colors = a, b.br.colors = a, b.tl.colors = a, b.tr.colors = a, this._batchNode && (this.atlasIndex != cc.Sprite.INDEX_NOT_INITIALIZED ? this.textureAtlas.updateQuad(b, this.atlasIndex) : this.dirty = !0), this._quadDirty = !0
    },
    setOpacity: null,
    setColor: null,
    updateDisplayedColor: null,
    setSpriteFrame: null,
    setDisplayFrame: function(a) {
        cc.log(cc._LogInfos.Sprite_setDisplayFrame), this.setSpriteFrame(a)
    },
    isFrameDisplayed: null,
    displayFrame: function() {
        return cc.SpriteFrame.create(this._texture, cc.rectPointsToPixels(this._rect), this._rectRotated, cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter), cc.sizePointsToPixels(this._contentSize))
    },
    setBatchNode: null,
    setTexture: null,
    _updateBlendFunc: function() {
        this._batchNode ? cc.log(cc._LogInfos.Sprite__updateBlendFunc) : this._texture && this._texture.hasPremultipliedAlpha() ? (this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, this.opacityModifyRGB = !0) : (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA, this.opacityModifyRGB = !1)
    },
    _changeTextureColor: function() {
        var a, b = this._texture,
            c = this._textureRect_Canvas;
        b && c.validRect && this._originalTexture && (a = b.getHtmlElementObj()) && (this._colorized = !0, a instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor && this._originalTexture._htmlElementObj != a ? cc.generateTintImageWithMultiply(this._originalTexture._htmlElementObj, this._displayedColor, c, a) : (a = cc.generateTintImageWithMultiply(this._originalTexture._htmlElementObj, this._displayedColor, c), b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.texture = b))
    },
    _setTextureCoords: function(a) {
        a = cc.rectPointsToPixels(a);
        var b = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (b) {
            var c, d = b.pixelsWidth,
                e = b.pixelsHeight,
                f = this._quad;
            this._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * d), d = b + (2 * a.height - 2) / (2 * d), c = (2 * a.y + 1) / (2 * e), a = c + (2 * a.width - 2) / (2 * e)) : (b = a.x / d, d = (a.x + a.height) / d, c = a.y / e, a = (a.y + a.width) / e), this._flippedX && (e = c, c = a, a = e), this._flippedY && (e = b, b = d, d = e), f.bl.texCoords.u = b, f.bl.texCoords.v = c, f.br.texCoords.u = b, f.br.texCoords.v = a, f.tl.texCoords.u = d, f.tl.texCoords.v = c, f.tr.texCoords.u = d, f.tr.texCoords.v = a) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * d), d = b + (2 * a.width - 2) / (2 * d), c = (2 * a.y + 1) / (2 * e), a = c + (2 * a.height - 2) / (2 * e)) : (b = a.x / d, d = (a.x + a.width) / d, c = a.y / e, a = (a.y + a.height) / e), this._flippedX && (e = b, b = d, d = e), this._flippedY && (e = c, c = a, a = e), f.bl.texCoords.u = b, f.bl.texCoords.v = a, f.br.texCoords.u = d, f.br.texCoords.v = a, f.tl.texCoords.u = b, f.tl.texCoords.v = c, f.tr.texCoords.u = d, f.tr.texCoords.v = c), this._quadDirty = !0
        }
    },
    draw: null
}), cc.Sprite.create = function(a, b, c) {
    return new cc.Sprite(a, b, c)
}, cc.Sprite.createWithTexture = cc.Sprite.create, cc.Sprite.createWithSpriteFrameName = cc.Sprite.create, cc.Sprite.createWithSpriteFrame = cc.Sprite.create, cc.Sprite.INDEX_NOT_INITIALIZED = -1, cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Sprite.prototype, _p._spriteFrameLoadedCallback = function(a) {
    this.setNodeDirty(!0), this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize()), a = this.color, (255 !== a.r || 255 !== a.g || 255 !== a.b) && this._changeTextureColor(), this._callLoadedEventCallbacks()
}, _p.setOpacityModifyRGB = function(a) {
    this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this.setNodeDirty(!0))
}, _p.updateDisplayedOpacity = function(a) {
    cc.Node.prototype.updateDisplayedOpacity.call(this, a), this._setNodeDirtyForCache()
}, _p.ctor = function(a, b, c) {
    cc.Node.prototype.ctor.call(this), this._shouldBeHidden = !1, this._offsetPosition = cc.p(0, 0), this._unflippedOffsetPositionFromCenter = cc.p(0, 0), this._blendFunc = {
        src: cc.BLEND_SRC,
        dst: cc.BLEND_DST
    }, this._rect = cc.rect(0, 0, 0, 0), this._newTextureWhenChangeColor = !1, this._textureLoaded = !0, this._textureRect_Canvas = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        validRect: !1
    }, this._drawSize_Canvas = cc.size(0, 0), this._softInit(a, b, c)
}, _p.setBlendFunc = function(a, b) {
    var c = this._blendFunc;
    void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b), cc._renderType === cc._RENDER_TYPE_CANVAS && (this._blendFuncStr = cc._getCompositeOperationByBlendFunc(c))
}, _p.init = function() {
    return 0 < arguments.length ? this.initWithFile(arguments[0], arguments[1]) : (cc.Node.prototype.init.call(this), this.dirty = this._recursiveDirty = !1, this._opacityModifyRGB = !0, this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, this.texture = null, this._textureLoaded = !0, this._flippedX = this._flippedY = !1, this.anchorY = this.anchorX = .5, this._offsetPosition.x = 0, this._offsetPosition.y = 0, this._hasChildren = !1, this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0)), !0)
}, _p.initWithTexture = function(a, b, c) {
    if (cc.assert(0 != arguments.length, cc._LogInfos.CCSpriteBatchNode_initWithTexture), (c = c || !1) && a.isLoaded()) {
        var d = a.getHtmlElementObj(),
            d = cc.cutRotateImageToCanvas(d, b),
            e = new cc.Texture2D;
        e.initWithElement(d), e.handleLoadedTexture(), a = e, this._rect = cc.rect(0, 0, b.width, b.height)
    }
    return cc.Node.prototype.init.call(this) ? (this._batchNode = null, this.dirty = this._recursiveDirty = !1, this._opacityModifyRGB = !0, this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, this._flippedX = this._flippedY = !1, this.anchorY = this.anchorX = .5, this._offsetPosition.x = 0, this._offsetPosition.y = 0, this._hasChildren = !1, this._textureLoaded = d = a.isLoaded(), d ? (b || (b = cc.rect(0, 0, a.width, a.height)), a && a.url && (d = b.y + b.height, b.x + b.width > a.width && cc.error(cc._LogInfos.RectWidth, a.url), d > a.height && cc.error(cc._LogInfos.RectHeight, a.url)), this.texture = this._originalTexture = a, this.setTextureRect(b, c), this.batchNode = null, !0) : (this._rectRotated = c, b && (this._rect.x = b.x, this._rect.y = b.y, this._rect.width = b.width, this._rect.height = b.height), this.texture && this.texture.removeLoadedEventListener(this), a.addLoadedEventListener(this._textureLoadedCallback, this), this.texture = a, !0)) : !1
}, _p._textureLoadedCallback = function(a) {
    if (!this._textureLoaded) {
        this._textureLoaded = !0;
        var b = this._rect;
        b ? cc._rectEqualToZero(b) && (b.width = a.width, b.height = a.height) : b = cc.rect(0, 0, a.width, a.height), this.texture = this._originalTexture = a, this.setTextureRect(b, this._rectRotated), a = this._displayedColor, (255 != a.r || 255 != a.g || 255 != a.b) && this._changeTextureColor(), this.batchNode = this._batchNode, this._callLoadedEventCallbacks()
    }
}, _p.setTextureRect = function(a, b, c) {
    this._rectRotated = b || !1, this.setContentSize(c || a), this.setVertexRect(a), b = this._textureRect_Canvas, c = cc.contentScaleFactor(), b.x = 0 | a.x * c, b.y = 0 | a.y * c, b.width = 0 | a.width * c, b.height = 0 | a.height * c, b.validRect = !(0 === b.width || 0 === b.height || 0 > b.x || 0 > b.y), a = this._unflippedOffsetPositionFromCenter, this._flippedX && (a.x = -a.x), this._flippedY && (a.y = -a.y), this._offsetPosition.x = a.x + (this._contentSize.width - this._rect.width) / 2, this._offsetPosition.y = a.y + (this._contentSize.height - this._rect.height) / 2, this._batchNode && (this.dirty = !0)
}, _p.updateTransform = function() {
    if (this.dirty) {
        var a = this._parent;
        !this._visible || a && a != this._batchNode && a._shouldBeHidden ? this._shouldBeHidden = !0 : (this._shouldBeHidden = !1, this._transformToBatch = a && a != this._batchNode ? cc.affineTransformConcat(this.nodeToParentTransform(), a._transformToBatch) : this.nodeToParentTransform()), this.dirty = this._recursiveDirty = !1
    }
    this._hasChildren && this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.updateTransform)
}, _p.addChild = function(a, b, c) {
    cc.assert(a, cc._LogInfos.CCSpriteBatchNode_addChild_2), null == b && (b = a._localZOrder), null == c && (c = a.tag), cc.Node.prototype.addChild.call(this, a, b, c), this._hasChildren = !0
}, _p.setOpacity = function(a) {
    cc.Node.prototype.setOpacity.call(this, a), this._setNodeDirtyForCache()
}, _p.setColor = function(a) {
    var b = this.color;
    this._oldDisplayColor = b, b.r === a.r && b.g === a.g && b.b === a.b || cc.Node.prototype.setColor.call(this, a)
}, _p.updateDisplayedColor = function(a) {
    cc.Node.prototype.updateDisplayedColor.call(this, a), a = this._oldDisplayColor;
    var b = this._displayedColor;
    a.r === b.r && a.g === b.g && a.b === b.b || (this._changeTextureColor(), this._setNodeDirtyForCache())
}, _p.setSpriteFrame = function(a) {
    var b = this;
    "string" == typeof a && (a = cc.spriteFrameCache.getSpriteFrame(a), cc.assert(a, cc._LogInfos.CCSpriteBatchNode_setSpriteFrame)), b.setNodeDirty(!0);
    var c = a.getOffset();
    b._unflippedOffsetPositionFromCenter.x = c.x, b._unflippedOffsetPositionFromCenter.y = c.y, b._rectRotated = a.isRotated();
    var c = a.getTexture(),
        d = a.textureLoaded();
    d || (b._textureLoaded = !1, a.addLoadedEventListener(function(a) {
        b._textureLoaded = !0;
        var c = a.getTexture();
        c != b._texture && (b.texture = c), b.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize()), b._callLoadedEventCallbacks()
    }, b)), c != b._texture && (b.texture = c), b._rectRotated && (b._originalTexture = c), b.setTextureRect(a.getRect(), b._rectRotated, a.getOriginalSize()), b._colorized = !1, d && (a = b.color, (255 !== a.r || 255 !== a.g || 255 !== a.b) && b._changeTextureColor())
}, _p.isFrameDisplayed = function(a) {
    return a.getTexture() != this._texture ? !1 : cc.rectEqualToRect(a.getRect(), this._rect)
}, _p.setBatchNode = function(a) {
    (this._batchNode = a) ? (this._transformToBatch = cc.affineTransformIdentity(), this.textureAtlas = this._batchNode.textureAtlas) : (this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED, this.textureAtlas = null, this.dirty = this._recursiveDirty = !1)
}, _p.setTexture = function(a) {
    a && "string" == typeof a ? (a = cc.textureCache.addImage(a), this.setTexture(a), a = a.getContentSize(), this.setTextureRect(cc.rect(0, 0, a.width, a.height))) : (cc.assert(!a || a instanceof cc.Texture2D, cc._LogInfos.CCSpriteBatchNode_setTexture), this._texture != a && (a && a.getHtmlElementObj() instanceof HTMLImageElement && (this._originalTexture = a), this._texture = a))
}, _p.draw = function(a) {
    if (this._textureLoaded) {
        a = a || cc._renderContext, "source" != this._blendFuncStr && (a.globalCompositeOperation = this._blendFuncStr);
        var b = cc.view.getScaleX(),
            c = cc.view.getScaleY();
        a.globalAlpha = this._displayedOpacity / 255;
        var d = this._rect,
            e = this._contentSize,
            f = this._offsetPosition,
            g = this._drawSize_Canvas,
            h = 0 | f.x,
            i = -f.y - d.height,
            j = this._textureRect_Canvas;
        g.width = d.width * b, g.height = d.height * c, (this._flippedX || this._flippedY) && (a.save(), this._flippedX && (h = -f.x - d.width, a.scale(-1, 1)), this._flippedY && (i = f.y, a.scale(1, -1))), h *= b, i *= c, this._texture && j.validRect ? (e = this._texture.getHtmlElementObj(), this._colorized ? a.drawImage(e, 0, 0, j.width, j.height, h, i, g.width, g.height) : a.drawImage(e, j.x, j.y, j.width, j.height, h, i, g.width, g.height)) : !this._texture && j.validRect && (g = this.color, a.fillStyle = "rgba(" + g.r + "," + g.g + "," + g.b + ",1)", a.fillRect(h, i, e.width * b, e.height * c)), 1 === cc.SPRITE_DEBUG_DRAW || this._showNode ? (a.strokeStyle = "rgba(0,255,0,1)", h /= b, i = -(i / c), h = [cc.p(h, i), cc.p(h + d.width, i), cc.p(h + d.width, i - d.height), cc.p(h, i - d.height)], cc._drawingUtil.drawPoly(h, 4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (a.strokeStyle = "rgba(0,255,0,1)", b = this._rect, i = -i, h = [cc.p(h, i), cc.p(h + b.width, i), cc.p(h + b.width, i - b.height), cc.p(h, i - b.height)], cc._drawingUtil.drawPoly(h, 4, !0)), (this._flippedX || this._flippedY) && a.restore(), cc.g_NumberOfDraws++
    }
}, cc.sys._supportCanvasNewBlendModes || (_p._changeTextureColor = function() {
    var a, b = this._texture,
        c = this._textureRect_Canvas;
    b && c.validRect && this._originalTexture && (a = b.getHtmlElementObj()) && (b = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj())) && (this._colorized = !0, a instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor ? cc.generateTintImage(a, b, this._displayedColor, c, a) : (a = cc.generateTintImage(a, b, this._displayedColor, c), b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.texture = b))
}), delete _p) : (cc.assert("function" == typeof cc._tmp.WebGLSprite, cc._LogInfos.MissingFile, "SpritesWebGL.js"), cc._tmp.WebGLSprite(), delete cc._tmp.WebGLSprite), cc.assert("function" == typeof cc._tmp.PrototypeSprite, cc._LogInfos.MissingFile, "SpritesPropertyDefine.js"), cc._tmp.PrototypeSprite(), delete cc._tmp.PrototypeSprite, cc.DEFAULT_SPRITE_BATCH_CAPACITY = 29, cc.SpriteBatchNode = cc.Node.extend({
    textureAtlas: null,
    _blendFunc: null,
    _descendants: null,
    _className: "SpriteBatchNode",
    addSpriteWithoutQuad: function(a, b, c) {
        if (cc.assert(a, cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad_2), !(a instanceof cc.Sprite)) return cc.log(cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad), null;
        a.atlasIndex = b;
        var d = 0,
            e = this._descendants;
        if (e && 0 < e.length)
            for (var f = 0; f < e.length; f++) {
                var g = e[f];
                g && g.atlasIndex >= b && ++d
            }
        return e.splice(d, 0, a), cc.Node.prototype.addChild.call(this, a, b, c), this.reorderBatch(!1), this
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(a) {
        a != this.textureAtlas && (this.textureAtlas = a)
    },
    getDescendants: function() {
        return this._descendants
    },
    initWithFile: function(a, b) {
        var c = cc.textureCache.getTextureForKey(a);
        return c || (c = cc.textureCache.addImage(a)), this.initWithTexture(c, b)
    },
    _setNodeDirtyForCache: function() {
        this._cacheDirty = !0
    },
    init: function(a, b) {
        var c = cc.textureCache.getTextureForKey(a);
        return c || (c = cc.textureCache.addImage(a)), this.initWithTexture(c, b)
    },
    increaseAtlasCapacity: function() {
        var a = this.textureAtlas.capacity,
            b = Math.floor(4 * (a + 1) / 3);
        cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity, a, b), this.textureAtlas.resizeCapacity(b) || cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity_2)
    },
    removeChildAtIndex: function(a, b) {
        this.removeChild(this._children[a], b)
    },
    rebuildIndexInOrder: function(a, b) {
        var c = a.children;
        if (c && 0 < c.length)
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                e && 0 > e.zIndex && (b = this.rebuildIndexInOrder(e, b))
            }
        if (!a == this && (a.atlasIndex = b, b++), c && 0 < c.length)
            for (d = 0; d < c.length; d++)(e = c[d]) && 0 <= e.zIndex && (b = this.rebuildIndexInOrder(e, b));
        return b
    },
    highestAtlasIndexInChild: function(a) {
        var b = a.children;
        return b && 0 != b.length ? this.highestAtlasIndexInChild(b[b.length - 1]) : a.atlasIndex
    },
    lowestAtlasIndexInChild: function(a) {
        var b = a.children;
        return b && 0 != b.length ? this.lowestAtlasIndexInChild(b[b.length - 1]) : a.atlasIndex
    },
    atlasIndexForChild: function(a, b) {
        var c = a.parent,
            d = c.children,
            e = d.indexOf(a),
            f = null;
        return e > 0 && e < cc.UINT_MAX && (f = d[e - 1]), c == this ? 0 == e ? 0 : this.highestAtlasIndexInChild(f) + 1 : 0 == e ? 0 > b ? c.atlasIndex : c.atlasIndex + 1 : 0 > f.zIndex && 0 > b || 0 <= f.zIndex && b >= 0 ? this.highestAtlasIndexInChild(f) + 1 : c.atlasIndex + 1
    },
    reorderBatch: function(a) {
        this._reorderChildDirty = a
    },
    setBlendFunc: function(a, b) {
        this._blendFunc = void 0 === b ? a : {
            src: a,
            dst: b
        }
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    reorderChild: function(a, b) {
        cc.assert(a, cc._LogInfos.SpriteBatchNode_reorderChild_2), -1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_reorderChild) : b !== a.zIndex && (cc.Node.prototype.reorderChild.call(this, a, b), this.setNodeDirty())
    },
    removeChild: function(a, b) {
        null != a && (-1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_removeChild) : (this.removeSpriteFromAtlas(a), cc.Node.prototype.removeChild.call(this, a, b)))
    },
    _mvpMatrix: null,
    _textureForCanvas: null,
    _useCache: !1,
    _originalTexture: null,
    ctor: null,
    _ctorForCanvas: function(a, b) {
        cc.Node.prototype.ctor.call(this);
        var c;
        b = b || cc.DEFAULT_SPRITE_BATCH_CAPACITY, "string" == typeof a ? (c = cc.textureCache.getTextureForKey(a)) || (c = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (c = a), c && this.initWithTexture(c, b)
    },
    _ctorForWebGL: function(a, b) {
        cc.Node.prototype.ctor.call(this), this._mvpMatrix = new cc.kmMat4;
        var c;
        b = b || cc.DEFAULT_SPRITE_BATCH_CAPACITY, "string" == typeof a ? (c = cc.textureCache.getTextureForKey(a)) || (c = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (c = a), c && this.initWithTexture(c, b)
    },
    updateQuadFromSprite: null,
    _updateQuadFromSpriteForCanvas: function(a, b) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite_2), a instanceof cc.Sprite ? (a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform()) : cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
    },
    _updateQuadFromSpriteForWebGL: function(a, b) {
        if (cc.assert(a, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite), a instanceof cc.Sprite) {
            for (var c = this.textureAtlas.capacity; b >= c || c == this.textureAtlas.totalQuads;) this.increaseAtlasCapacity();
            a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform()
        } else cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
    },
    _swap: function(a, b) {
        var c = this._descendants,
            d = this.textureAtlas,
            e = d.quads,
            f = c[a],
            g = cc.V3F_C4B_T2F_QuadCopy(e[a]);
        c[b].atlasIndex = a, c[a] = c[b], d.updateQuad(e[b], a), c[b] = f, d.updateQuad(g, b)
    },
    insertQuadFromSprite: null,
    _insertQuadFromSpriteForCanvas: function(a, b) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite_2), a instanceof cc.Sprite ? (a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform(), a._setCachedParent(this), this._children.splice(b, 0, a)) : cc.log(cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite)
    },
    _insertQuadFromSpriteForWebGL: function(a, b) {
        if (cc.assert(a, cc._LogInfos.Sprite_insertQuadFromSprite_2), a instanceof cc.Sprite) {
            for (var c = this.textureAtlas; b >= c.capacity || c.capacity === c.totalQuads;) this.increaseAtlasCapacity();
            a.batchNode = this, a.atlasIndex = b, c.insertQuad(a.quad, b), a.dirty = !0, a.updateTransform()
        } else cc.log(cc._LogInfos.Sprite_insertQuadFromSprite)
    },
    _updateAtlasIndex: function(a, b) {
        var c = 0,
            d = a.children;
        d && (c = d.length);
        var e = 0;
        if (0 === c) e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++;
        else {
            for (e = !0, 0 <= d[0].zIndex && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++, e = !1), c = 0; c < d.length; c++) {
                var f = d[c];
                e && 0 <= f.zIndex && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++, e = !1), b = this._updateAtlasIndex(f, b)
            }
            e && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++)
        }
        return b
    },
    _updateBlendFunc: function() {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    initWithTexture: null,
    _initWithTextureForCanvas: function(a) {
        return this._children = [], this._descendants = [], this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), this._textureForCanvas = this._originalTexture = a, !0
    },
    _initWithTextureForWebGL: function(a, b) {
        return this._children = [], this._descendants = [], this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), b = b || cc.DEFAULT_SPRITE_BATCH_CAPACITY, this.textureAtlas = new cc.TextureAtlas, this.textureAtlas.initWithTexture(a, b), this._updateBlendFunc(), this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR), !0
    },
    insertChild: function(a, b) {
        a.batchNode = this, a.atlasIndex = b, a.dirty = !0;
        var c = this.textureAtlas;
        c.totalQuads >= c.capacity && this.increaseAtlasCapacity(), c.insertQuad(a.quad, b), this._descendants.splice(b, 0, a);
        var c = b + 1,
            d = this._descendants;
        if (d && 0 < d.length)
            for (; c < d.length; c++) d[c].atlasIndex++;
        var e, d = a.children;
        if (d)
            for (c = 0, l = d.length || 0; l > c; c++)
                if (e = d[c]) {
                    var f = this.atlasIndexForChild(e, e.zIndex);
                    this.insertChild(e, f)
                }
    },
    appendChild: null,
    _appendChildForCanvas: function(a) {
        this._reorderChildDirty = !0, a.batchNode = this, a.dirty = !0, this._descendants.push(a), a.atlasIndex = this._descendants.length - 1, a = a.children;
        for (var b = 0, c = a.length || 0; c > b; b++) this.appendChild(a[b])
    },
    _appendChildForWebGL: function(a) {
        this._reorderChildDirty = !0, a.batchNode = this, a.dirty = !0, this._descendants.push(a);
        var b = this._descendants.length - 1;
        a.atlasIndex = b;
        var c = this.textureAtlas;
        for (c.totalQuads == c.capacity && this.increaseAtlasCapacity(), c.insertQuad(a.quad, b), a = a.children, b = 0, c = a.length || 0; c > b; b++) this.appendChild(a[b])
    },
    removeSpriteFromAtlas: null,
    _removeSpriteFromAtlasForCanvas: function(a) {
        a.batchNode = null;
        var b = this._descendants,
            c = b.indexOf(a);
        if (-1 != c) {
            b.splice(c, 1);
            for (var d = b.length; d > c; ++c) b[c].atlasIndex--
        }
        if (a = a.children)
            for (b = 0, c = a.length || 0; c > b; b++) a[b] && this.removeSpriteFromAtlas(a[b])
    },
    _removeSpriteFromAtlasForWebGL: function(a) {
        this.textureAtlas.removeQuadAtIndex(a.atlasIndex), a.batchNode = null;
        var b = this._descendants,
            c = b.indexOf(a);
        if (-1 != c) {
            b.splice(c, 1);
            for (var d = b.length; d > c; ++c) b[c].atlasIndex--
        }
        if (a = a.children)
            for (b = 0, c = a.length || 0; c > b; b++) a[b] && this.removeSpriteFromAtlas(a[b])
    },
    getTexture: null,
    _getTextureForCanvas: function() {
        return this._textureForCanvas
    },
    _getTextureForWebGL: function() {
        return this.textureAtlas.texture
    },
    setTexture: null,
    _setTextureForCanvas: function(a) {
        this._textureForCanvas = a;
        for (var b = this._children, c = 0; c < b.length; c++) b[c].texture = a
    },
    _setTextureForWebGL: function(a) {
        this.textureAtlas.texture = a, this._updateBlendFunc()
    },
    visit: null,
    _visitForCanvas: function(a) {
        var b = a || cc._renderContext;
        if (this._visible) {
            b.save(), this.transform(a);
            var c = this._children;
            if (c)
                for (this.sortAllChildren(), a = 0; a < c.length; a++) c[a] && c[a].visit(b);
            b.restore()
        }
    },
    _visitForWebGL: function(a) {
        if (a = a || cc._renderContext, this._visible) {
            cc.kmGLPushMatrix();
            var b = this.grid;
            b && b.isActive() && (b.beforeDraw(), this.transformAncestors()), this.sortAllChildren(), this.transform(a), this.draw(a), b && b.isActive() && b.afterDraw(this), cc.kmGLPopMatrix(), this.arrivalOrder = 0
        }
    },
    addChild: null,
    _addChildForCanvas: function(a, b, c) {
        cc.assert(null != a, cc._LogInfos.CCSpriteBatchNode_addChild_3), a instanceof cc.Sprite ? (b = null == b ? a.zIndex : b, c = null == c ? a.tag : c, cc.Node.prototype.addChild.call(this, a, b, c), this.appendChild(a), this.setNodeDirty()) : cc.log(cc._LogInfos.CCSpriteBatchNode_addChild)
    },
    _addChildForWebGL: function(a, b, c) {
        cc.assert(null != a, cc._LogInfos.Sprite_addChild_6), a instanceof cc.Sprite ? a.texture != this.textureAtlas.texture ? cc.log(cc._LogInfos.Sprite_addChild_5) : (b = null == b ? a.zIndex : b, c = null == c ? a.tag : c, cc.Node.prototype.addChild.call(this, a, b, c), this.appendChild(a), this.setNodeDirty()) : cc.log(cc._LogInfos.Sprite_addChild_4)
    },
    removeAllChildren: null,
    _removeAllChildrenForCanvas: function(a) {
        var b = this._descendants;
        if (b && 0 < b.length)
            for (var c = 0, d = b.length; d > c; c++) b[c] && (b[c].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, a), this._descendants.length = 0
    },
    _removeAllChildrenForWebGL: function(a) {
        var b = this._descendants;
        if (b && 0 < b.length)
            for (var c = 0, d = b.length; d > c; c++) b[c] && (b[c].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, a), this._descendants.length = 0, this.textureAtlas.removeAllQuads()
    },
    sortAllChildren: null,
    _sortAllChildrenForCanvas: function() {
        if (this._reorderChildDirty) {
            var a, b, c = 0,
                d = this._children,
                e = d.length;
            for (a = 1; e > a; a++) {
                var f = d[a],
                    c = a - 1;
                for (b = d[c]; c >= 0 && (f._localZOrder < b._localZOrder || f._localZOrder == b._localZOrder && f.arrivalOrder < b.arrivalOrder);) d[c + 1] = b, c -= 1, b = d[c];
                d[c + 1] = f
            }
            0 < d.length && this._arrayMakeObjectsPerformSelector(d, cc.Node._StateCallbackType.sortAllChildren), this._reorderChildDirty = !1
        }
    },
    _sortAllChildrenForWebGL: function() {
        if (this._reorderChildDirty) {
            var a, b, c = this._children,
                d = 0,
                e = c.length;
            for (a = 1; e > a; a++) {
                var f = c[a],
                    d = a - 1;
                for (b = c[d]; d >= 0 && (f._localZOrder < b._localZOrder || f._localZOrder == b._localZOrder && f.arrivalOrder < b.arrivalOrder);) c[d + 1] = b, d -= 1, b = c[d];
                c[d + 1] = f
            }
            if (0 < c.length)
                for (this._arrayMakeObjectsPerformSelector(c, cc.Node._StateCallbackType.sortAllChildren), a = d = 0; a < c.length; a++) d = this._updateAtlasIndex(c[a], d);
            this._reorderChildDirty = !1
        }
    },
    draw: null,
    _drawForWebGL: function() {
        0 !== this.textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.updateTransform), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), this.textureAtlas.drawQuads())
    }
}), _p = cc.SpriteBatchNode.prototype, cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.updateQuadFromSprite = _p._updateQuadFromSpriteForWebGL, _p.insertQuadFromSprite = _p._insertQuadFromSpriteForWebGL, _p.initWithTexture = _p._initWithTextureForWebGL, _p.appendChild = _p._appendChildForWebGL, _p.removeSpriteFromAtlas = _p._removeSpriteFromAtlasForWebGL, _p.getTexture = _p._getTextureForWebGL, _p.setTexture = _p._setTextureForWebGL, _p.visit = _p._visitForWebGL, _p.addChild = _p._addChildForWebGL, _p.removeAllChildren = _p._removeAllChildrenForWebGL, _p.sortAllChildren = _p._sortAllChildrenForWebGL, _p.draw = _p._drawForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.updateQuadFromSprite = _p._updateQuadFromSpriteForCanvas, _p.insertQuadFromSprite = _p._insertQuadFromSpriteForCanvas, _p.initWithTexture = _p._initWithTextureForCanvas, _p.appendChild = _p._appendChildForCanvas, _p.removeSpriteFromAtlas = _p._removeSpriteFromAtlasForCanvas, _p.getTexture = _p._getTextureForCanvas, _p.setTexture = _p._setTextureForCanvas, _p.visit = _p._visitForCanvas, _p.removeAllChildren = _p._removeAllChildrenForCanvas, _p.addChild = _p._addChildForCanvas, _p.sortAllChildren = _p._sortAllChildrenForCanvas, _p.draw = cc.Node.prototype.draw), cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture), cc.defineGetterSetter(_p, "descendants", _p.getDescendants), cc.SpriteBatchNode.create = function(a, b) {
    return new cc.SpriteBatchNode(a, b)
}, cc.SpriteBatchNode.createWithTexture = cc.SpriteBatchNode.create, cc.BakeSprite = cc.Sprite.extend({
    _cacheCanvas: null,
    _cacheContext: null,
    ctor: function() {
        cc.Sprite.prototype.ctor.call(this);
        var a = document.createElement("canvas");
        a.width = a.height = 10, this._cacheCanvas = a, this._cacheContext = a.getContext("2d");
        var b = new cc.Texture2D;
        b.initWithElement(a), b.handleLoadedTexture(), this.setTexture(b)
    },
    getCacheContext: function() {
        return this._cacheContext
    },
    getCacheCanvas: function() {
        return this._cacheCanvas
    },
    resetCanvasSize: function(a, b) {
        void 0 === b && (b = a.height, a = a.width);
        var c = this._cacheCanvas;
        c.width = a, c.height = b, this.getTexture().handleLoadedTexture(), this.setTextureRect(cc.rect(0, 0, a, b), !1)
    }
}), cc.AnimationFrame = cc.Class.extend({
    _spriteFrame: null,
    _delayPerUnit: 0,
    _userInfo: null,
    ctor: function(a, b, c) {
        this._spriteFrame = a || null, this._delayPerUnit = b || 0, this._userInfo = c || null
    },
    clone: function() {
        var a = new cc.AnimationFrame;
        return a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo), a
    },
    copyWithZone: function() {
        return cc.clone(this)
    },
    copy: function(a) {
        return a = new cc.AnimationFrame, a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo), a
    },
    initWithSpriteFrame: function(a, b, c) {
        return this._spriteFrame = a, this._delayPerUnit = b, this._userInfo = c, !0
    },
    getSpriteFrame: function() {
        return this._spriteFrame
    },
    setSpriteFrame: function(a) {
        this._spriteFrame = a
    },
    getDelayUnits: function() {
        return this._delayPerUnit
    },
    setDelayUnits: function(a) {
        this._delayPerUnit = a
    },
    getUserInfo: function() {
        return this._userInfo
    },
    setUserInfo: function(a) {
        this._userInfo = a
    }
}), cc.AnimationFrame.create = function(a, b, c) {
    return new cc.AnimationFrame(a, b, c)
}, cc.Animation = cc.Class.extend({
    _frames: null,
    _loops: 0,
    _restoreOriginalFrame: !1,
    _duration: 0,
    _delayPerUnit: 0,
    _totalDelayUnits: 0,
    ctor: function(a, b, c) {
        if (this._frames = [], void 0 === a) this.initWithSpriteFrames(null, 0);
        else {
            var d = a[0];
            d && (d instanceof cc.SpriteFrame ? this.initWithSpriteFrames(a, b, c) : d instanceof cc.AnimationFrame && this.initWithAnimationFrames(a, b, c))
        }
    },
    getFrames: function() {
        return this._frames
    },
    setFrames: function(a) {
        this._frames = a
    },
    addSpriteFrame: function(a) {
        var b = new cc.AnimationFrame;
        b.initWithSpriteFrame(a, 1, null), this._frames.push(b), this._totalDelayUnits++
    },
    addSpriteFrameWithFile: function(a) {
        a = cc.textureCache.addImage(a);
        var b = cc.rect(0, 0, 0, 0);
        b.width = a.width, b.height = a.height, a = cc.SpriteFrame.create(a, b), this.addSpriteFrame(a)
    },
    addSpriteFrameWithTexture: function(a, b) {
        var c = cc.SpriteFrame.create(a, b);
        this.addSpriteFrame(c)
    },
    initWithAnimationFrames: function(a, b, c) {
        for (cc.arrayVerifyType(a, cc.AnimationFrame), this._delayPerUnit = b, this._loops = void 0 === c ? 1 : c, this._totalDelayUnits = 0, b = this._frames, c = b.length = 0; c < a.length; c++) {
            var d = a[c];
            b.push(d), this._totalDelayUnits += d.getDelayUnits()
        }
        return !0
    },
    clone: function() {
        var a = new cc.Animation;
        return a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops), a.setRestoreOriginalFrame(this._restoreOriginalFrame), a
    },
    copyWithZone: function(a) {
        return a = new cc.Animation, a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops), a.setRestoreOriginalFrame(this._restoreOriginalFrame), a
    },
    _copyFrames: function() {
        for (var a = [], b = 0; b < this._frames.length; b++) a.push(this._frames[b].clone());
        return a
    },
    copy: function() {
        return this.copyWithZone(null)
    },
    getLoops: function() {
        return this._loops
    },
    setLoops: function(a) {
        this._loops = a
    },
    setRestoreOriginalFrame: function(a) {
        this._restoreOriginalFrame = a
    },
    getRestoreOriginalFrame: function() {
        return this._restoreOriginalFrame
    },
    getDuration: function() {
        return this._totalDelayUnits * this._delayPerUnit
    },
    getDelayPerUnit: function() {
        return this._delayPerUnit
    },
    setDelayPerUnit: function(a) {
        this._delayPerUnit = a
    },
    getTotalDelayUnits: function() {
        return this._totalDelayUnits
    },
    initWithSpriteFrames: function(a, b, c) {
        if (cc.arrayVerifyType(a, cc.SpriteFrame), this._loops = void 0 === c ? 1 : c, this._delayPerUnit = b || 0, this._totalDelayUnits = 0, b = this._frames, b.length = 0, a) {
            for (c = 0; c < a.length; c++) {
                var d = a[c],
                    e = new cc.AnimationFrame;
                e.initWithSpriteFrame(d, 1, null), b.push(e)
            }
            this._totalDelayUnits += a.length
        }
        return !0
    },
    retain: function() {},
    release: function() {}
}), cc.Animation.create = function(a, b, c) {
    return new cc.Animation(a, b, c)
}, cc.Animation.createWithAnimationFrames = cc.Animation.create, cc.animationCache = {
    _animations: {},
    addAnimation: function(a, b) {
        this._animations[b] = a
    },
    removeAnimation: function(a) {
        a && this._animations[a] && delete this._animations[a]
    },
    getAnimation: function(a) {
        return this._animations[a] ? this._animations[a] : null
    },
    _addAnimationsWithDictionary: function(a, b) {
        var c = a.animations;
        if (c) {
            var d = 1,
                e = a.properties;
            if (e)
                for (var d = null != e.format ? parseInt(e.format) : d, e = e.spritesheets, f = cc.spriteFrameCache, g = cc.path, h = 0; h < e.length; h++) f.addSpriteFrames(g.changeBasename(b, e[h]));
            switch (d) {
                case 1:
                    this._parseVersion1(c);
                    break;
                case 2:
                    this._parseVersion2(c);
                    break;
                default:
                    cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2)
            }
        } else cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary)
    },
    addAnimations: function(a) {
        cc.assert(a, cc._LogInfos.animationCache_addAnimations_2);
        var b = cc.loader.getRes(a);
        b ? this._addAnimationsWithDictionary(b, a) : cc.log(cc._LogInfos.animationCache_addAnimations)
    },
    _parseVersion1: function(a) {
        var b, c = cc.spriteFrameCache;
        for (b in a) {
            var d = a[b],
                e = d.frames,
                d = parseFloat(d.delay) || 0,
                f = null;
            if (e) {
                for (var f = [], g = 0; g < e.length; g++) {
                    var h = c.getSpriteFrame(e[g]);
                    if (h) {
                        var i = new cc.AnimationFrame;
                        i.initWithSpriteFrame(h, 1, null), f.push(i)
                    } else cc.log(cc._LogInfos.animationCache__parseVersion1_2, b, e[g])
                }
                0 === f.length ? cc.log(cc._LogInfos.animationCache__parseVersion1_3, b) : (f.length != e.length && cc.log(cc._LogInfos.animationCache__parseVersion1_4, b), f = cc.Animation.create(f, d, 1), cc.animationCache.addAnimation(f, b))
            } else cc.log(cc._LogInfos.animationCache__parseVersion1, b)
        }
    },
    _parseVersion2: function(a) {
        var b, c = cc.spriteFrameCache;
        for (b in a) {
            var d = a[b],
                e = d.loop,
                f = parseInt(d.loops),
                e = e ? cc.REPEAT_FOREVER : isNaN(f) ? 1 : f,
                f = d.restoreOriginalFrame && 1 == d.restoreOriginalFrame ? !0 : !1,
                g = d.frames;
            if (g) {
                for (var h = [], i = 0; i < g.length; i++) {
                    var j = g[i],
                        k = j.spriteframe,
                        l = c.getSpriteFrame(k);
                    if (l) {
                        var k = parseFloat(j.delayUnits) || 0,
                            j = j.notification,
                            m = new cc.AnimationFrame;
                        m.initWithSpriteFrame(l, k, j), h.push(m)
                    } else cc.log(cc._LogInfos.animationCache__parseVersion2_2, b, k)
                }
                d = parseFloat(d.delayPerUnit) || 0, g = new cc.Animation, g.initWithAnimationFrames(h, d, e), g.setRestoreOriginalFrame(f), cc.animationCache.addAnimation(g, b)
            } else cc.log(cc._LogInfos.animationCache__parseVersion2, b)
        }
    },
    _clear: function() {
        this._animations = {}
    }
}, cc.SpriteFrame = cc.Class.extend({
    _offset: null,
    _originalSize: null,
    _rectInPixels: null,
    _rotated: !1,
    _rect: null,
    _offsetInPixels: null,
    _originalSizeInPixels: null,
    _texture: null,
    _textureFilename: "",
    _textureLoaded: !1,
    _eventListeners: null,
    ctor: function(a, b, c, d, e) {
        this._offset = cc.p(0, 0), this._offsetInPixels = cc.p(0, 0), this._originalSize = cc.size(0, 0), this._rotated = !1, this._originalSizeInPixels = cc.size(0, 0), this._textureFilename = "", this._texture = null, this._textureLoaded = !1, void 0 !== a && void 0 !== b && (void 0 === c || void 0 === d || void 0 === e ? this.initWithTexture(a, b) : this.initWithTexture(a, b, c, d, e))
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        null == this._eventListeners && (this._eventListeners = []), this._eventListeners.push({
            eventCallback: a,
            eventTarget: b
        })
    },
    _callLoadedEventCallbacks: function() {
        var a = this._eventListeners;
        if (a) {
            for (var b = 0, c = a.length; c > b; b++) {
                var d = a[b];
                d.eventCallback.call(d.eventTarget, this)
            }
            a.length = 0
        }
    },
    getRectInPixels: function() {
        var a = this._rectInPixels;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRectInPixels: function(a) {
        this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0)), this._rectInPixels.x = a.x, this._rectInPixels.y = a.y, this._rectInPixels.width = a.width, this._rectInPixels.height = a.height, this._rect = cc.rectPixelsToPoints(a)
    },
    isRotated: function() {
        return this._rotated
    },
    setRotated: function(a) {
        this._rotated = a
    },
    getRect: function() {
        var a = this._rect;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRect: function(a) {
        this._rect || (this._rect = cc.rect(0, 0, 0, 0)), this._rect.x = a.x, this._rect.y = a.y, this._rect.width = a.width, this._rect.height = a.height, this._rectInPixels = cc.rectPointsToPixels(this._rect)
    },
    getOffsetInPixels: function() {
        return cc.p(this._offsetInPixels)
    },
    setOffsetInPixels: function(a) {
        this._offsetInPixels.x = a.x, this._offsetInPixels.y = a.y, cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset)
    },
    getOriginalSizeInPixels: function() {
        return cc.size(this._originalSizeInPixels)
    },
    setOriginalSizeInPixels: function(a) {
        this._originalSizeInPixels.width = a.width, this._originalSizeInPixels.height = a.height
    },
    getOriginalSize: function() {
        return cc.size(this._originalSize)
    },
    setOriginalSize: function(a) {
        this._originalSize.width = a.width, this._originalSize.height = a.height
    },
    getTexture: function() {
        if (this._texture) return this._texture;
        if ("" !== this._textureFilename) {
            var a = cc.textureCache.addImage(this._textureFilename);
            return a && (this._textureLoaded = a.isLoaded()), a
        }
        return null
    },
    setTexture: function(a) {
        if (this._texture != a) {
            var b = a.isLoaded();
            this._textureLoaded = b, this._texture = a, b || a.addLoadedEventListener(function(a) {
                if (this._textureLoaded = !0, this._rotated && cc._renderType === cc._RENDER_TYPE_CANVAS) {
                    var b = a.getHtmlElementObj(),
                        b = cc.cutRotateImageToCanvas(b, this.getRect()),
                        c = new cc.Texture2D;
                    c.initWithElement(b), c.handleLoadedTexture(), this.setTexture(c), b = this.getRect(), this.setRect(cc.rect(0, 0, b.width, b.height))
                }
                b = this._rect, 0 === b.width && 0 === b.height && (b = a.width, a = a.height, this._rect.width = b, this._rect.height = a, this._rectInPixels = cc.rectPointsToPixels(this._rect), this._originalSizeInPixels.width = this._rectInPixels.width, this._originalSizeInPixels.height = this._rectInPixels.height, this._originalSize.width = b, this._originalSize.height = a), this._callLoadedEventCallbacks()
            }, this)
        }
    },
    getOffset: function() {
        return cc.p(this._offset)
    },
    setOffset: function(a) {
        this._offset.x = a.x, this._offset.y = a.y
    },
    clone: function() {
        var a = new cc.SpriteFrame;
        return a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels), a.setTexture(this._texture), a
    },
    copyWithZone: function() {
        var a = new cc.SpriteFrame;
        return a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels), a.setTexture(this._texture), a
    },
    copy: function() {
        return this.copyWithZone()
    },
    initWithTexture: function(a, b, c, d, e) {
        if (2 === arguments.length && (b = cc.rectPointsToPixels(b)), d = d || cc.p(0, 0), e = e || b, c = c || !1, "string" == typeof a ? (this._texture = null, this._textureFilename = a) : a instanceof cc.Texture2D && this.setTexture(a), a = this.getTexture(), this._rectInPixels = b, b = this._rect = cc.rectPixelsToPoints(b), a && a.url && a.isLoaded()) {
            var f, g;
            c ? (f = b.x + b.height, g = b.y + b.width) : (f = b.x + b.width, g = b.y + b.height), f > a.getPixelsWide() && cc.error(cc._LogInfos.RectWidth, a.url), g > a.getPixelsHigh() && cc.error(cc._LogInfos.RectHeight, a.url)
        }
        return this._offsetInPixels.x = d.x, this._offsetInPixels.y = d.y, cc._pointPixelsToPointsOut(d, this._offset), this._originalSizeInPixels.width = e.width, this._originalSizeInPixels.height = e.height, cc._sizePixelsToPointsOut(e, this._originalSize), this._rotated = c, !0
    }
}), cc.SpriteFrame.create = function(a, b, c, d, e) {
    return new cc.SpriteFrame(a, b, c, d, e)
}, cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create, cc.SpriteFrame._frameWithTextureForCanvas = function(a, b, c, d, e) {
    var f = new cc.SpriteFrame;
    return f._texture = a, f._rectInPixels = b, f._rect = cc.rectPixelsToPoints(b), f._offsetInPixels.x = d.x, f._offsetInPixels.y = d.y, cc._pointPixelsToPointsOut(f._offsetInPixels, f._offset), f._originalSizeInPixels.width = e.width, f._originalSizeInPixels.height = e.height, cc._sizePixelsToPointsOut(f._originalSizeInPixels, f._originalSize), f._rotated = c, f
}, cc.spriteFrameCache = {
    _CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
    _CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
    _spriteFrames: {},
    _spriteFramesAliases: {},
    _frameConfigCache: {},
    _rectFromString: function(a) {
        return a = this._CCNS_REG2.exec(a), a ? cc.rect(parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]), parseFloat(a[4])) : cc.rect(0, 0, 0, 0)
    },
    _pointFromString: function(a) {
        return a = this._CCNS_REG1.exec(a), a ? cc.p(parseFloat(a[1]), parseFloat(a[2])) : cc.p(0, 0)
    },
    _sizeFromString: function(a) {
        return a = this._CCNS_REG1.exec(a), a ? cc.size(parseFloat(a[1]), parseFloat(a[2])) : cc.size(0, 0)
    },
    _getFrameConfig: function(a) {
        var b = cc.loader.getRes(a);
        if (cc.assert(b, cc._LogInfos.spriteFrameCache__getFrameConfig_2, a), cc.loader.release(a), b._inited) return this._frameConfigCache[a] = b;
        var c = b.frames,
            d = b.metadata || b.meta,
            b = {}, e = {}, f = 0;
        d && (f = d.format, f = 1 >= f.length ? parseInt(f) : f, e.image = d.textureFileName || d.textureFileName || d.image);
        for (var g in c) {
            var h = c[g];
            if (h) {
                if (d = {}, 0 == f) {
                    d.rect = cc.rect(h.x, h.y, h.width, h.height), d.rotated = !1, d.offset = cc.p(h.offsetX, h.offsetY);
                    var i = h.originalWidth,
                        h = h.originalHeight;
                    (!i || !h) && cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig), i = Math.abs(i), h = Math.abs(h), d.size = cc.size(i, h)
                } else if (1 == f || 2 == f) d.rect = this._rectFromString(h.frame), d.rotated = h.rotated || !1, d.offset = this._pointFromString(h.offset), d.size = this._sizeFromString(h.sourceSize);
                else if (3 == f) {
                    var i = this._sizeFromString(h.spriteSize),
                        j = this._rectFromString(h.textureRect);
                    i && (j = cc.rect(j.x, j.y, i.width, i.height)), d.rect = j, d.rotated = h.textureRotated || !1, d.offset = this._pointFromString(h.spriteOffset), d.size = this._sizeFromString(h.spriteSourceSize), d.aliases = h.aliases
                } else i = h.frame, j = h.sourceSize, g = h.filename || g, d.rect = cc.rect(i.x, i.y, i.w, i.h), d.rotated = h.rotated || !1, d.offset = cc.p(0, 0), d.size = cc.size(j.w, j.h);
                b[g] = d
            }
        }
        return this._frameConfigCache[a] = {
            _inited: !0,
            frames: b,
            meta: e
        }
    },
    addSpriteFrames: function(a, b) {
        cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
        var c = this._frameConfigCache[a] || cc.loader.getRes(a);
        if (c && c.frames) {
            var d = this._frameConfigCache[a] || this._getFrameConfig(a),
                c = d.frames,
                d = d.meta;
            b ? b instanceof cc.Texture2D || ("string" == typeof b ? b = cc.textureCache.addImage(b) : cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3)) : (d = cc.path.changeBasename(a, d.image || ".png"), b = cc.textureCache.addImage(d));
            var e, d = this._spriteFramesAliases,
                f = this._spriteFrames;
            for (e in c) {
                var g = c[e],
                    h = f[e];
                if (!h) {
                    if (h = cc.SpriteFrame.create(b, g.rect, g.rotated, g.offset, g.size), g = g.aliases)
                        for (var i = 0, j = g.length; j > i; i++) {
                            var k = g[i];
                            d[k] && cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, k), d[k] = e
                        }
                    cc._renderType === cc._RENDER_TYPE_CANVAS && h.isRotated() && h.getTexture().isLoaded() && (g = h.getTexture().getHtmlElementObj(), g = cc.cutRotateImageToCanvas(g, h.getRectInPixels()), i = new cc.Texture2D, i.initWithElement(g), i.handleLoadedTexture(), h.setTexture(i), g = h._rect, h.setRect(cc.rect(0, 0, g.width, g.height))), f[e] = h
                }
            }
        }
    },
    _checkConflict: function(a) {
        a = a.frames;
        for (var b in a) this._spriteFrames[b] && cc.log(cc._LogInfos.spriteFrameCache__checkConflict, b)
    },
    addSpriteFrame: function(a, b) {
        this._spriteFrames[b] = a
    },
    removeSpriteFrames: function() {
        this._spriteFrames = {}, this._spriteFramesAliases = {}
    },
    removeSpriteFrameByName: function(a) {
        a && (this._spriteFramesAliases[a] && delete this._spriteFramesAliases[a], this._spriteFrames[a] && delete this._spriteFrames[a])
    },
    removeSpriteFramesFromFile: function(a) {
        var b = this._spriteFrames,
            c = this._spriteFramesAliases;
        if (a = this._frameConfigCache[a]) {
            a = a.frames;
            for (var d in a)
                if (b[d]) {
                    delete b[d];
                    for (var e in c) c[e] == d && delete c[e]
                }
        }
    },
    removeSpriteFramesFromTexture: function(a) {
        var b, c = this._spriteFrames,
            d = this._spriteFramesAliases;
        for (b in c) {
            var e = c[b];
            if (e && e.getTexture() == a) {
                delete c[b];
                for (var f in d) d[f] == b && delete d[f]
            }
        }
    },
    getSpriteFrame: function(a) {
        var b = this._spriteFrames[a];
        if (!b) {
            var c = this._spriteFramesAliases[a];
            c && ((b = this._spriteFrames[c.toString()]) || delete this._spriteFramesAliases[a])
        }
        return b || cc.log(cc._LogInfos.spriteFrameCache_getSpriteFrame, a), b
    },
    _clear: function() {
        this._spriteFrames = {}, this._spriteFramesAliases = {}, this._frameConfigCache = {}
    }
}, cc.configuration = {
    ERROR: 0,
    STRING: 1,
    INT: 2,
    DOUBLE: 3,
    BOOLEAN: 4,
    _maxTextureSize: 0,
    _maxModelviewStackDepth: 0,
    _supportsPVRTC: !1,
    _supportsNPOT: !1,
    _supportsBGRA8888: !1,
    _supportsDiscardFramebuffer: !1,
    _supportsShareableVAO: !1,
    _maxSamplesAllowed: 0,
    _maxTextureUnits: 0,
    _GlExtensions: "",
    _valueDict: {},
    _inited: !1,
    _init: function() {
        var a = this._valueDict;
        a["cocos2d.x.version"] = cc.ENGINE_VERSION, a["cocos2d.x.compiled_with_profiler"] = !1, a["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE, this._inited = !0
    },
    getMaxTextureSize: function() {
        return this._maxTextureSize
    },
    getMaxModelviewStackDepth: function() {
        return this._maxModelviewStackDepth
    },
    getMaxTextureUnits: function() {
        return this._maxTextureUnits
    },
    supportsNPOT: function() {
        return this._supportsNPOT
    },
    supportsPVRTC: function() {
        return this._supportsPVRTC
    },
    supportsETC: function() {
        return !1
    },
    supportsS3TC: function() {
        return !1
    },
    supportsATITC: function() {
        return !1
    },
    supportsBGRA8888: function() {
        return this._supportsBGRA8888
    },
    supportsDiscardFramebuffer: function() {
        return this._supportsDiscardFramebuffer
    },
    supportsShareableVAO: function() {
        return this._supportsShareableVAO
    },
    checkForGLExtension: function(a) {
        return -1 < this._GlExtensions.indexOf(a)
    },
    getValue: function(a, b) {
        this._inited || this._init();
        var c = this._valueDict;
        return c[a] ? c[a] : b
    },
    setValue: function(a, b) {
        this._valueDict[a] = b
    },
    dumpInfo: function() {
        0 === cc.ENABLE_GL_STATE_CACHE && (cc.log(""), cc.log(cc._LogInfos.configuration_dumpInfo), cc.log(""))
    },
    gatherGPUInfo: function() {
        if (cc._renderType !== cc._RENDER_TYPE_CANVAS) {
            this._inited || this._init();
            var a = cc._renderContext,
                b = this._valueDict;
            b["gl.vendor"] = a.getParameter(a.VENDOR), b["gl.renderer"] = a.getParameter(a.RENDERER), b["gl.version"] = a.getParameter(a.VERSION), this._GlExtensions = "";
            for (var c = a.getSupportedExtensions(), d = 0; d < c.length; d++) this._GlExtensions += c[d] + " ";
            this._maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE), b["gl.max_texture_size"] = this._maxTextureSize, this._maxTextureUnits = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS), b["gl.max_texture_units"] = this._maxTextureUnits, this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc"), b["gl.supports_PVRTC"] = this._supportsPVRTC, this._supportsNPOT = !1, b["gl.supports_NPOT"] = this._supportsNPOT, this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888"), b["gl.supports_BGRA8888"] = this._supportsBGRA8888, this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer"), b["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer, this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object"), b["gl.supports_vertex_array_object"] = this._supportsShareableVAO, cc.checkGLErrorDebug()
        }
    },
    loadConfigFile: function(a) {
        this._inited || this._init();
        var b = cc.loader.getRes(a);
        if (!b) throw "Please load the resource first : " + a;
        if (cc.assert(b, cc._LogInfos.configuration_loadConfigFile_2, a), b = b.data)
            for (var c in b) this._valueDict[c] = b[c];
        else cc.log(cc._LogInfos.configuration_loadConfigFile, a)
    }
}, cc._tmp.DirectorWebGL = function() {
    cc.DirectorDelegate = cc.Class.extend({
        updateProjection: function() {}
    });
    var a = cc.Director.prototype;
    a.setProjection = function(a) {
        var b = this._winSizeInPoints;
        this.setViewport();
        var c = this._openGLView,
            d = c._viewPortRect.x / c._scaleX,
            e = c._viewPortRect.y / c._scaleY;
        switch (a) {
            case cc.Director.PROJECTION_2D:
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLLoadIdentity(), c = new cc.kmMat4, cc.kmMat4OrthographicProjection(c, 0, b.width, 0, b.height, -1024, 1024), cc.kmGLMultMatrix(c), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLLoadIdentity();
                break;
            case cc.Director.PROJECTION_3D:
                var f = this.getZEye(),
                    g = new cc.kmMat4,
                    c = new cc.kmMat4;
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLLoadIdentity(), cc.kmMat4PerspectiveProjection(g, 60, b.width / b.height, .1, 2 * f), cc.kmGLMultMatrix(g), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLLoadIdentity(), f = cc.kmVec3Fill(null, -d + b.width / 2, -e + b.height / 2, f), b = cc.kmVec3Fill(null, -d + b.width / 2, -e + b.height / 2, 0), d = cc.kmVec3Fill(null, 0, 1, 0), cc.kmMat4LookAt(c, f, b, d), cc.kmGLMultMatrix(c);
                break;
            case cc.Director.PROJECTION_CUSTOM:
                this._projectionDelegate && this._projectionDelegate.updateProjection();
                break;
            default:
                cc.log(cc._LogInfos.Director_setProjection)
        }
        this._projection = a, cc.eventManager.dispatchEvent(this._eventProjectionChanged), cc.setProjectionMatrixDirty()
    }, a.setDepthTest = function(a) {
        var b = cc._renderContext;
        a ? (b.clearDepth(1), b.enable(b.DEPTH_TEST), b.depthFunc(b.LEQUAL)) : b.disable(b.DEPTH_TEST)
    }, a.setOpenGLView = function(a) {
        this._winSizeInPoints.width = cc._canvas.width, this._winSizeInPoints.height = cc._canvas.height, this._openGLView = a || cc.view, a = cc.configuration, a.gatherGPUInfo(), a.dumpInfo(), this._createStatsLabel(), this.setGLDefaultValues(), cc.eventManager && cc.eventManager.setEnabled(!0)
    }, a._clear = function() {
        var a = cc._renderContext;
        a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
    }, a._beforeVisitScene = function() {
        cc.kmGLPushMatrix()
    }, a._afterVisitScene = function() {
        cc.kmGLPopMatrix()
    }, a._createStatsLabel = function() {
        if (cc.LabelAtlas) {
            if (null != cc.Director._fpsImageLoaded && 0 != cc.Director._fpsImageLoaded) {
                var a = new cc.Texture2D;
                a.initWithElement(cc.Director._fpsImage), a.handleLoadedTexture();
                var b = cc.view.getDesignResolutionSize().height / 320;
                0 === b && (b = this._winSizeInPoints.height / 320);
                var c = new cc.LabelAtlas;
                c._setIgnoreContentScaleFactor(!0), c.initWithString("00.0", a, 12, 32, "."), c.scale = b, this._FPSLabel = c, c = new cc.LabelAtlas, c._setIgnoreContentScaleFactor(!0), c.initWithString("0.000", a, 12, 32, "."), c.scale = b, this._SPFLabel = c, c = new cc.LabelAtlas, c._setIgnoreContentScaleFactor(!0), c.initWithString("000", a, 12, 32, "."), c.scale = b, this._drawsLabel = c, a = cc.DIRECTOR_STATS_POSITION, this._drawsLabel.setPosition(a.x, 34 * b + a.y), this._SPFLabel.setPosition(a.x, 17 * b + a.y), this._FPSLabel.setPosition(a)
            }
        } else this._createStatsLabelForCanvas()
    }, a._createStatsLabelForCanvas = function() {
        var a = 0,
            a = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | 24 * (this._winSizeInPoints.height / 320) : 0 | 24 * (this._winSizeInPoints.width / 320);
        this._FPSLabel = cc.LabelTTF.create("000.0", "Arial", a), this._SPFLabel = cc.LabelTTF.create("0.000", "Arial", a), this._drawsLabel = cc.LabelTTF.create("0000", "Arial", a), a = cc.DIRECTOR_STATS_POSITION, this._drawsLabel.setPosition(this._drawsLabel.width / 2 + a.x, 5 * this._drawsLabel.height / 2 + a.y), this._SPFLabel.setPosition(this._SPFLabel.width / 2 + a.x, 3 * this._SPFLabel.height / 2 + a.y), this._FPSLabel.setPosition(this._FPSLabel.width / 2 + a.x, this._FPSLabel.height / 2 + a.y)
    }, a.convertToGL = function(a) {
        var b = new cc.kmMat4;
        cc.GLToClipTransform(b);
        var c = new cc.kmMat4;
        cc.kmMat4Inverse(c, b);
        var b = b.mat[14] / b.mat[15],
            d = this._openGLView.getDesignResolutionSize();
        return a = new cc.kmVec3(2 * a.x / d.width - 1, 1 - 2 * a.y / d.height, b), b = new cc.kmVec3, cc.kmVec3TransformCoord(b, a, c), cc.p(b.x, b.y)
    }, a.convertToUI = function(a) {
        var b = new cc.kmMat4;
        cc.GLToClipTransform(b);
        var c = new cc.kmVec3;
        return a = new cc.kmVec3(a.x, a.y, 0), cc.kmVec3TransformCoord(c, a, b), b = this._openGLView.getDesignResolutionSize(), cc.p(b.width * (.5 * c.x + .5), b.height * (.5 * -c.y + .5))
    }, a.getVisibleSize = function() {
        return this._openGLView.getVisibleSize()
    }, a.getVisibleOrigin = function() {
        return this._openGLView.getVisibleOrigin()
    }, a.getZEye = function() {
        return this._winSizeInPoints.height / 1.1566
    }, a.setViewport = function() {
        var a = this._openGLView;
        if (a) {
            var b = this._winSizeInPoints;
            a.setViewPortInPoints(-a._viewPortRect.x / a._scaleX, -a._viewPortRect.y / a._scaleY, b.width, b.height)
        }
    }, a.getOpenGLView = function() {
        return this._openGLView
    }, a.getProjection = function() {
        return this._projection
    }, a.setAlphaBlending = function(a) {
        a ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO)
    }, a.setGLDefaultValues = function() {
        this.setAlphaBlending(!0), this.setDepthTest(!1), this.setProjection(this._projection), cc._renderContext.clearColor(0, 0, 0, 1)
    }
}, cc.g_NumberOfDraws = 0, cc.GLToClipTransform = function(a) {
    var b = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, b);
    var c = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, c), cc.kmMat4Multiply(a, b, c)
}, cc.Director = cc.Class.extend({
    _landscape: !1,
    _nextDeltaTimeZero: !1,
    _paused: !1,
    _purgeDirectorInNextLoop: !1,
    _sendCleanupToScene: !1,
    _animationInterval: 0,
    _oldAnimationInterval: 0,
    _projection: 0,
    _accumDt: 0,
    _contentScaleFactor: 1,
    _displayStats: !1,
    _deltaTime: 0,
    _frameRate: 0,
    _FPSLabel: null,
    _SPFLabel: null,
    _drawsLabel: null,
    _winSizeInPoints: null,
    _lastUpdate: null,
    _nextScene: null,
    _notificationNode: null,
    _openGLView: null,
    _scenesStack: null,
    _projectionDelegate: null,
    _runningScene: null,
    _frames: 0,
    _totalFrames: 0,
    _secondsPerFrame: 0,
    _dirtyRegion: null,
    _scheduler: null,
    _actionManager: null,
    _eventProjectionChanged: null,
    _eventAfterDraw: null,
    _eventAfterVisit: null,
    _eventAfterUpdate: null,
    ctor: function() {
        var a = this;
        a._lastUpdate = Date.now(), cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
            a._lastUpdate = Date.now()
        })
    },
    init: function() {
        return this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS, this._scenesStack = [], this._projection = cc.Director.PROJECTION_DEFAULT, this._projectionDelegate = null, this._frameRate = this._accumDt = 0, this._displayStats = !1, this._totalFrames = this._frames = 0, this._lastUpdate = Date.now(), this._purgeDirectorInNextLoop = this._paused = !1, this._winSizeInPoints = cc.size(0, 0), this._openGLView = null, this._contentScaleFactor = 1, this._scheduler = new cc.Scheduler, this._actionManager = cc.ActionManager ? new cc.ActionManager : null, this._scheduler.scheduleUpdateForTarget(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1), this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW), this._eventAfterDraw.setUserData(this), this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT), this._eventAfterVisit.setUserData(this), this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE), this._eventAfterUpdate.setUserData(this), this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED), this._eventProjectionChanged.setUserData(this), !0
    },
    calculateDeltaTime: function() {
        var a = Date.now();
        this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime = (a - this._lastUpdate) / 1e3, 0 < cc.game.config[cc.game.CONFIG_KEY.debugMode] && .2 < this._deltaTime && (this._deltaTime = 1 / 60), this._lastUpdate = a
    },
    convertToGL: null,
    convertToUI: null,
    drawScene: function() {
        this.calculateDeltaTime(), this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate)), this._clear(), this._nextScene && this.setNextScene(), this._beforeVisitScene && this._beforeVisitScene(), this._runningScene && (this._runningScene.visit(), cc.eventManager.dispatchEvent(this._eventAfterVisit)), this._notificationNode && this._notificationNode.visit(), this._displayStats && this._showStats(), this._afterVisitScene && this._afterVisitScene(), cc.eventManager.dispatchEvent(this._eventAfterDraw), this._totalFrames++, this._displayStats && this._calculateMPF()
    },
    _beforeVisitScene: null,
    _afterVisitScene: null,
    end: function() {
        this._purgeDirectorInNextLoop = !0
    },
    getContentScaleFactor: function() {
        return this._contentScaleFactor
    },
    getNotificationNode: function() {
        return this._notificationNode
    },
    getWinSize: function() {
        return cc.size(this._winSizeInPoints)
    },
    getWinSizeInPixels: function() {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
    },
    getVisibleSize: null,
    getVisibleOrigin: null,
    getZEye: null,
    pause: function() {
        this._paused || (this._oldAnimationInterval = this._animationInterval, this.setAnimationInterval(.25), this._paused = !0)
    },
    popScene: function() {
        cc.assert(this._runningScene, cc._LogInfos.Director_popScene), this._scenesStack.pop();
        var a = this._scenesStack.length;
        0 == a ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = this._scenesStack[a - 1])
    },
    purgeCachedData: function() {
        cc.animationCache._clear(), cc.spriteFrameCache._clear(), cc.textureCache._clear()
    },
    purgeDirector: function() {
        this.getScheduler().unscheduleAllCallbacks(), cc.eventManager && cc.eventManager.setEnabled(!1), this._runningScene && (this._runningScene.onExitTransitionDidStart(), this._runningScene.onExit(), this._runningScene.cleanup()), this._nextScene = this._runningScene = null, this._scenesStack.length = 0, this.stopAnimation(), this.purgeCachedData(), cc.checkGLErrorDebug()
    },
    pushScene: function(a) {
        cc.assert(a, cc._LogInfos.Director_pushScene), this._sendCleanupToScene = !1, this._scenesStack.push(a), this._nextScene = a
    },
    runScene: function(a) {
        if (cc.assert(a, cc._LogInfos.Director_pushScene), this._runningScene) {
            var b = this._scenesStack.length;
            0 === b ? (this._sendCleanupToScene = !0, this._scenesStack[b] = a) : (this._sendCleanupToScene = !0, this._scenesStack[b - 1] = a), this._nextScene = a
        } else this.pushScene(a), this.startAnimation()
    },
    resume: function() {
        this._paused && (this.setAnimationInterval(this._oldAnimationInterval), (this._lastUpdate = Date.now()) || cc.log(cc._LogInfos.Director_resume), this._paused = !1, this._deltaTime = 0)
    },
    setContentScaleFactor: function(a) {
        a != this._contentScaleFactor && (this._contentScaleFactor = a, this._createStatsLabel())
    },
    setDepthTest: null,
    setDefaultValues: function() {},
    setNextDeltaTimeZero: function(a) {
        this._nextDeltaTimeZero = a
    },
    setNextScene: function() {
        var a = !1,
            b = !1;
        cc.TransitionScene && (a = this._runningScene ? this._runningScene instanceof cc.TransitionScene : !1, b = this._nextScene ? this._nextScene instanceof cc.TransitionScene : !1), b || ((b = this._runningScene) && (b.onExitTransitionDidStart(), b.onExit()), this._sendCleanupToScene && b && b.cleanup()), this._runningScene = this._nextScene, this._nextScene = null, !a && null != this._runningScene && (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish())
    },
    setNotificationNode: function(a) {
        this._notificationNode = a
    },
    getDelegate: function() {
        return this._projectionDelegate
    },
    setDelegate: function(a) {
        this._projectionDelegate = a
    },
    setOpenGLView: null,
    setProjection: null,
    setViewport: null,
    getOpenGLView: null,
    getProjection: null,
    setAlphaBlending: null,
    _showStats: function() {
        this._frames++, this._accumDt += this._deltaTime, this._FPSLabel && this._SPFLabel && this._drawsLabel ? (this._accumDt > cc.DIRECTOR_FPS_INTERVAL && (this._SPFLabel.string = this._secondsPerFrame.toFixed(3), this._frameRate = this._frames / this._accumDt, this._accumDt = this._frames = 0, this._FPSLabel.string = this._frameRate.toFixed(1), this._drawsLabel.string = (0 | cc.g_NumberOfDraws).toString()), this._FPSLabel.visit(), this._SPFLabel.visit(), this._drawsLabel.visit()) : this._createStatsLabel(), cc.g_NumberOfDraws = 0
    },
    isSendCleanupToScene: function() {
        return this._sendCleanupToScene
    },
    getRunningScene: function() {
        return this._runningScene
    },
    getAnimationInterval: function() {
        return this._animationInterval
    },
    isDisplayStats: function() {
        return this._displayStats
    },
    setDisplayStats: function(a) {
        this._displayStats = a
    },
    getSecondsPerFrame: function() {
        return this._secondsPerFrame
    },
    isNextDeltaTimeZero: function() {
        return this._nextDeltaTimeZero
    },
    isPaused: function() {
        return this._paused
    },
    getTotalFrames: function() {
        return this._totalFrames
    },
    popToRootScene: function() {
        this.popToSceneStackLevel(1)
    },
    popToSceneStackLevel: function(a) {
        cc.assert(this._runningScene, cc._LogInfos.Director_popToSceneStackLevel_2);
        var b = this._scenesStack,
            c = b.length;
        if (0 == c) this.end();
        else if (!(a > c)) {
            for (; c > a;) {
                var d = b.pop();
                d.running && (d.onExitTransitionDidStart(), d.onExit()), d.cleanup(), c--
            }
            this._nextScene = b[b.length - 1], this._sendCleanupToScene = !1
        }
    },
    getScheduler: function() {
        return this._scheduler
    },
    setScheduler: function(a) {
        this._scheduler != a && (this._scheduler = a)
    },
    getActionManager: function() {
        return this._actionManager
    },
    setActionManager: function(a) {
        this._actionManager != a && (this._actionManager = a)
    },
    getDeltaTime: function() {
        return this._deltaTime
    },
    _createStatsLabel: null,
    _calculateMPF: function() {
        this._secondsPerFrame = (Date.now() - this._lastUpdate) / 1e3
    }
}), cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed", cc.Director.EVENT_AFTER_DRAW = "director_after_draw", cc.Director.EVENT_AFTER_VISIT = "director_after_visit", cc.Director.EVENT_AFTER_UPDATE = "director_after_update", cc.DisplayLinkDirector = cc.Director.extend({
    invalid: !1,
    startAnimation: function() {
        this._nextDeltaTimeZero = !0, this.invalid = !1
    },
    mainLoop: function() {
        this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || this.drawScene()
    },
    stopAnimation: function() {
        this.invalid = !0
    },
    setAnimationInterval: function(a) {
        this._animationInterval = a, this.invalid || (this.stopAnimation(), this.startAnimation())
    }
}), cc.Director.sharedDirector = null, cc.Director.firstUseDirector = !0, cc.Director._getInstance = function() {
    return cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1, cc.Director.sharedDirector = new cc.DisplayLinkDirector, cc.Director.sharedDirector.init()), cc.Director.sharedDirector
}, cc.defaultFPS = 60, cc.Director.PROJECTION_2D = 0, cc.Director.PROJECTION_3D = 1, cc.Director.PROJECTION_CUSTOM = 3, cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D, cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Director.prototype, _p.setProjection = function(a) {
    this._projection = a, cc.eventManager.dispatchEvent(this._eventProjectionChanged)
}, _p.setDepthTest = function() {}, _p.setOpenGLView = function(a) {
    this._winSizeInPoints.width = cc._canvas.width, this._winSizeInPoints.height = cc._canvas.height, this._openGLView = a || cc.view, cc.eventManager && cc.eventManager.setEnabled(!0)
}, _p._clear = function() {
    var a = this._openGLView.getViewPortRect();
    cc._renderContext.clearRect(-a.x, a.y, a.width, -a.height)
}, _p._createStatsLabel = function() {
    var a = 0,
        a = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | 24 * (this._winSizeInPoints.height / 320) : 0 | 24 * (this._winSizeInPoints.width / 320);
    this._FPSLabel = cc.LabelTTF.create("000.0", "Arial", a), this._SPFLabel = cc.LabelTTF.create("0.000", "Arial", a), this._drawsLabel = cc.LabelTTF.create("0000", "Arial", a), a = cc.DIRECTOR_STATS_POSITION, this._drawsLabel.setPosition(this._drawsLabel.width / 2 + a.x, 5 * this._drawsLabel.height / 2 + a.y), this._SPFLabel.setPosition(this._SPFLabel.width / 2 + a.x, 3 * this._SPFLabel.height / 2 + a.y), this._FPSLabel.setPosition(this._FPSLabel.width / 2 + a.x, this._FPSLabel.height / 2 + a.y)
}, _p.getVisibleSize = function() {
    return this.getWinSize()
}, _p.getVisibleOrigin = function() {
    return cc.p(0, 0)
}) : (cc.Director._fpsImage = new Image, cc._addEventListener(cc.Director._fpsImage, "load", function() {
    cc.Director._fpsImageLoaded = !0
}), cc._fpsImage && (cc.Director._fpsImage.src = cc._fpsImage), cc.assert("function" == typeof cc._tmp.DirectorWebGL, cc._LogInfos.MissingFile, "CCDirectorWebGL.js"), cc._tmp.DirectorWebGL(), delete cc._tmp.DirectorWebGL), cc.Camera = cc.Class.extend({
    _eyeX: null,
    _eyeY: null,
    _eyeZ: null,
    _centerX: null,
    _centerY: null,
    _centerZ: null,
    _upX: null,
    _upY: null,
    _upZ: null,
    _dirty: null,
    _lookupMatrix: null,
    ctor: function() {
        this._lookupMatrix = new cc.kmMat4, this.restore()
    },
    description: function() {
        return "<CCCamera | center =(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")>"
    },
    setDirty: function(a) {
        this._dirty = a
    },
    isDirty: function() {
        return this._dirty
    },
    restore: function() {
        this._eyeX = this._eyeY = 0, this._eyeZ = cc.Camera.getZEye(), this._upX = this._centerX = this._centerY = this._centerZ = 0, this._upY = 1, this._upZ = 0, cc.kmMat4Identity(this._lookupMatrix), this._dirty = !1
    },
    locate: function() {
        if (this._dirty) {
            var a = new cc.kmVec3,
                b = new cc.kmVec3,
                c = new cc.kmVec3;
            cc.kmVec3Fill(a, this._eyeX, this._eyeY, this._eyeZ), cc.kmVec3Fill(b, this._centerX, this._centerY, this._centerZ), cc.kmVec3Fill(c, this._upX, this._upY, this._upZ), cc.kmMat4LookAt(this._lookupMatrix, a, b, c), this._dirty = !1
        }
        cc.kmGLMultMatrix(this._lookupMatrix)
    },
    setEyeXYZ: function(a, b, c) {
        this.setEye(a, b, c)
    },
    setEye: function(a, b, c) {
        this._eyeX = a, this._eyeY = b, this._eyeZ = c, this._dirty = !0
    },
    setCenterXYZ: function(a, b, c) {
        this.setCenter(a, b, c)
    },
    setCenter: function(a, b, c) {
        this._centerX = a, this._centerY = b, this._centerZ = c, this._dirty = !0
    },
    setUpXYZ: function(a, b, c) {
        this.setUp(a, b, c)
    },
    setUp: function(a, b, c) {
        this._upX = a, this._upY = b, this._upZ = c, this._dirty = !0
    },
    getEyeXYZ: function() {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getEye: function() {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getCenterXYZ: function() {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getCenter: function() {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getUpXYZ: function() {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    getUp: function() {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    _DISALLOW_COPY_AND_ASSIGN: function() {}
}), cc.Camera.getZEye = function() {
    return cc.FLT_EPSILON
}, cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1, cc.ListEntry = function(a, b, c, d, e, f) {
    this.prev = a, this.next = b, this.target = c, this.priority = d, this.paused = e, this.markedForDeletion = f
}, cc.HashUpdateEntry = function(a, b, c, d) {
    this.list = a, this.entry = b, this.target = c, this.hh = d
}, cc.HashTimerEntry = function(a, b, c, d, e, f, g) {
    this.timers = a, this.target = b, this.timerIndex = c, this.currentTimer = d, this.currentTimerSalvaged = e, this.paused = f, this.hh = g
}, cc.Timer = cc.Class.extend({
    _interval: 0,
    _callback: null,
    _target: null,
    _elapsed: 0,
    _runForever: !1,
    _useDelay: !1,
    _timesExecuted: 0,
    _repeat: 0,
    _delay: 0,
    getInterval: function() {
        return this._interval
    },
    setInterval: function(a) {
        this._interval = a
    },
    getCallback: function() {
        return this._callback
    },
    ctor: function(a, b, c, d, e) {
        this._target = a, this._callback = b, this._elapsed = -1, this._interval = c || 0, this._delay = e || 0, this._useDelay = 0 < this._delay, this._repeat = null == d ? cc.REPEAT_FOREVER : d, this._runForever = this._repeat == cc.REPEAT_FOREVER
    },
    _doCallback: function() {
        "string" == typeof this._callback ? this._target[this._callback](this._elapsed) : this._callback.call(this._target, this._elapsed)
    },
    update: function(a) {
        if (-1 == this._elapsed) this._timesExecuted = this._elapsed = 0;
        else {
            var b = this._target,
                c = this._callback;
            this._elapsed += a, this._runForever && !this._useDelay ? this._elapsed >= this._interval && (b && c && this._doCallback(), this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (b && c && this._doCallback(), this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (b && c && this._doCallback(), this._elapsed = 0, this._timesExecuted += 1), this._timesExecuted > this._repeat && cc.director.getScheduler().unscheduleCallbackForTarget(b, c))
        }
    }
}), cc.Scheduler = cc.Class.extend({
    _timeScale: 1,
    _updates: null,
    _hashForUpdates: null,
    _arrayForUpdates: null,
    _hashForTimers: null,
    _arrayForTimes: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _updateHashLocked: !1,
    ctor: function() {
        this._timeScale = 1, this._updates = [
            [],
            [],
            []
        ], this._hashForUpdates = {}, this._arrayForUpdates = [], this._hashForTimers = {}, this._arrayForTimers = [], this._currentTarget = null, this._updateHashLocked = this._currentTargetSalvaged = !1
    },
    _removeHashElement: function(a) {
        delete this._hashForTimers[a.target.__instanceId], cc.arrayRemoveObject(this._arrayForTimers, a), a.Timer = null, a.target = null
    },
    _removeUpdateFromHash: function(a) {
        (a = this._hashForUpdates[a.target.__instanceId]) && (cc.arrayRemoveObject(a.list, a.entry), delete this._hashForUpdates[a.target.__instanceId], cc.arrayRemoveObject(this._arrayForUpdates, a), a.entry = null, a.target = null)
    },
    _priorityIn: function(a, b, c, d) {
        if (d = new cc.ListEntry(null, null, b, c, d, !1), a) {
            for (var e = a.length - 1, f = 0; e >= f && !(c < a[f].priority); f++);
            a.splice(f, 0, d)
        } else a = [], a.push(d);
        return c = new cc.HashUpdateEntry(a, d, b, null), this._arrayForUpdates.push(c), this._hashForUpdates[b.__instanceId] = c, a
    },
    _appendIn: function(a, b, c) {
        c = new cc.ListEntry(null, null, b, 0, c, !1), a.push(c), a = new cc.HashUpdateEntry(a, c, b, null), this._arrayForUpdates.push(a), this._hashForUpdates[b.__instanceId] = a
    },
    setTimeScale: function(a) {
        this._timeScale = a
    },
    getTimeScale: function() {
        return this._timeScale
    },
    update: function(a) {
        var b, c, d, e = this._updates,
            f = this._arrayForTimers;
        for (this._updateHashLocked = !0, 1 != this._timeScale && (a *= this._timeScale), c = 0, d = e.length; d > c && c >= 0; c++)
            for (var g = this._updates[c], h = 0, i = g.length; i > h; h++) b = g[h], !b.paused && !b.markedForDeletion && b.target.update(a);
        for (c = 0, d = f.length; d > c && (b = f[c], b); c++) {
            if (this._currentTarget = b, this._currentTargetSalvaged = !1, !b.paused)
                for (b.timerIndex = 0; b.timerIndex < b.timers.length; b.timerIndex++) b.currentTimer = b.timers[b.timerIndex], b.currentTimerSalvaged = !1, b.currentTimer.update(a), b.currentTimer = null;
            this._currentTargetSalvaged && 0 == b.timers.length && (this._removeHashElement(b), c--)
        }
        for (c = 0, d = e.length; d > c; c++)
            for (g = this._updates[c], h = 0, i = g.length; i > h && (b = g[h], b);) b.markedForDeletion ? this._removeUpdateFromHash(b) : h++;
        this._updateHashLocked = !1, this._currentTarget = null
    },
    scheduleCallbackForTarget: function(a, b, c, d, e, f) {
        cc.assert(b, cc._LogInfos.Scheduler_scheduleCallbackForTarget_2), cc.assert(a, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3), c = c || 0, d = null == d ? cc.REPEAT_FOREVER : d, e = e || 0, f = f || !1;
        var g = this._hashForTimers[a.__instanceId];
        if (g || (g = new cc.HashTimerEntry(null, a, 0, null, null, f, null), this._arrayForTimers.push(g), this._hashForTimers[a.__instanceId] = g), null == g.timers) g.timers = [];
        else
            for (var h = 0; h < g.timers.length; h++)
                if (f = g.timers[h], b == f._callback) return cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, f.getInterval().toFixed(4), c.toFixed(4)), void(f._interval = c); f = new cc.Timer(a, b, c, d, e), g.timers.push(f)
    },
    scheduleUpdateForTarget: function(a, b, c) {
        if (null !== a) {
            var d = this._updates,
                e = this._hashForUpdates[a.__instanceId];
            e ? e.entry.markedForDeletion = !1 : 0 == b ? this._appendIn(d[1], a, c) : 0 > b ? d[0] = this._priorityIn(d[0], a, b, c) : d[2] = this._priorityIn(d[2], a, b, c)
        }
    },
    unscheduleCallbackForTarget: function(a, b) {
        if (null != a && null != b) {
            var c = this._hashForTimers[a.__instanceId];
            if (c)
                for (var d = c.timers, e = 0, f = d.length; f > e; e++) {
                    var g = d[e];
                    if (b == g._callback) {
                        g == c.currentTimer && !c.currentTimerSalvaged && (c.currentTimerSalvaged = !0), d.splice(e, 1), c.timerIndex >= e && c.timerIndex--, 0 == d.length && (this._currentTarget == c ? this._currentTargetSalvaged = !0 : this._removeHashElement(c));
                        break
                    }
                }
        }
    },
    unscheduleUpdateForTarget: function(a) {
        null != a && (a = this._hashForUpdates[a.__instanceId], null != a && (this._updateHashLocked ? a.entry.markedForDeletion = !0 : this._removeUpdateFromHash(a.entry)))
    },
    unscheduleAllCallbacksForTarget: function(a) {
        if (null != a) {
            var b = this._hashForTimers[a.__instanceId];
            if (b) {
                var c = b.timers;
                !b.currentTimerSalvaged && 0 <= c.indexOf(b.currentTimer) && (b.currentTimerSalvaged = !0), c.length = 0, this._currentTarget == b ? this._currentTargetSalvaged = !0 : this._removeHashElement(b)
            }
            this.unscheduleUpdateForTarget(a)
        }
    },
    unscheduleAllCallbacks: function() {
        this.unscheduleAllCallbacksWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    unscheduleAllCallbacksWithMinPriority: function(a) {
        for (var b = this._arrayForTimers, c = this._updates, d = 0, e = b.length; e > d; d++) this.unscheduleAllCallbacksForTarget(b[d].target);
        for (d = 2; d >= 0; d--)
            if (!(1 == d && a > 0 || 0 == d && a >= 0))
                for (var b = c[d], e = 0, f = b.length; f > e; e++) this.unscheduleUpdateForTarget(b[e].target)
    },
    pauseAllTargets: function() {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    pauseAllTargetsWithMinPriority: function(a) {
        a = [];
        for (var b, c = this._arrayForTimers, d = this._updates, e = 0, f = c.length; f > e; e++)(b = c[e]) && (b.paused = !0, a.push(b.target));
        for (e = 0, f = d.length; f > e; e++)
            for (var c = d[e], g = 0, h = c.length; h > g; g++)(b = c[g]) && (b.paused = !0, a.push(b.target));
        return a
    },
    resumeTargets: function(a) {
        if (a)
            for (var b = 0; b < a.length; b++) this.resumeTarget(a[b])
    },
    pauseTarget: function(a) {
        cc.assert(a, cc._LogInfos.Scheduler_pauseTarget);
        var b = this._hashForTimers[a.__instanceId];
        b && (b.paused = !0), (a = this._hashForUpdates[a.__instanceId]) && (a.entry.paused = !0)
    },
    resumeTarget: function(a) {
        cc.assert(a, cc._LogInfos.Scheduler_resumeTarget);
        var b = this._hashForTimers[a.__instanceId];
        b && (b.paused = !1), (a = this._hashForUpdates[a.__instanceId]) && (a.entry.paused = !1)
    },
    isTargetPaused: function(a) {
        return cc.assert(a, cc._LogInfos.Scheduler_isTargetPaused), (a = this._hashForTimers[a.__instanceId]) ? a.paused : !1
    }
}), cc.Scheduler.PRIORITY_SYSTEM = -2147483648, cc.PI2 = 2 * Math.PI, cc.DrawingPrimitiveCanvas = cc.Class.extend({
    _cacheArray: [],
    _renderContext: null,
    ctor: function(a) {
        this._renderContext = a
    },
    drawPoint: function(a, b) {
        b || (b = 1);
        var c = cc.view.getScaleX(),
            d = cc.view.getScaleY(),
            d = cc.p(a.x * c, a.y * d);
        this._renderContext.beginPath(), this._renderContext.arc(d.x, -d.y, b * c, 0, 2 * Math.PI, !1), this._renderContext.closePath(), this._renderContext.fill()
    },
    drawPoints: function(a, b, c) {
        if (null != a) {
            c || (c = 1), b = this._renderContext;
            var d = cc.view.getScaleX(),
                e = cc.view.getScaleY();
            b.beginPath();
            for (var f = 0, g = a.length; g > f; f++) b.arc(a[f].x * d, -a[f].y * e, c * d, 0, 2 * Math.PI, !1);
            b.closePath(), b.fill()
        }
    },
    drawLine: function(a, b) {
        var c = this._renderContext,
            d = cc.view.getScaleX(),
            e = cc.view.getScaleY();
        c.beginPath(), c.moveTo(a.x * d, -a.y * e), c.lineTo(b.x * d, -b.y * e), c.closePath(), c.stroke()
    },
    drawRect: function(a, b) {
        this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y)), this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y)), this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y)), this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function(a, b, c) {
        a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)], this.drawSolidPoly(a, 4, c)
    },
    drawPoly: function(a, b, c, d) {
        if (d = d || !1, null != a) {
            if (3 > a.length) throw Error("Polygon's point must greater than 2");
            var e = a[0];
            b = this._renderContext;
            var f = cc.view.getScaleX(),
                g = cc.view.getScaleY();
            b.beginPath(), b.moveTo(e.x * f, -e.y * g);
            for (var e = 1, h = a.length; h > e; e++) b.lineTo(a[e].x * f, -a[e].y * g);
            c && b.closePath(), d ? b.fill() : b.stroke()
        }
    },
    drawSolidPoly: function(a, b, c) {
        this.setDrawColor(c.r, c.g, c.b, c.a), this.drawPoly(a, b, !0, !0)
    },
    drawCircle: function(a, b, c, d, e) {
        e = e || !1, d = this._renderContext;
        var f = cc.view.getScaleX(),
            g = cc.view.getScaleY();
        d.beginPath(), d.arc(0 | a.x * f, 0 | -(a.y * g), b * f, -c, -(c - 2 * Math.PI), !1), e && d.lineTo(0 | a.x * f, 0 | -(a.y * g)), d.stroke()
    },
    drawQuadBezier: function(a, b, c, d) {
        for (var e = this._cacheArray, f = e.length = 0, g = 0; d > g; g++) {
            var h = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * b.x + f * f * c.x,
                i = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * b.y + f * f * c.y;
            e.push(cc.p(h, i)), f += 1 / d
        }
        e.push(cc.p(c.x, c.y)), this.drawPoly(e, d + 1, !1, !1)
    },
    drawCubicBezier: function(a, b, c, d, e) {
        for (var f = this._cacheArray, g = f.length = 0, h = 0; e > h; h++) {
            var i = Math.pow(1 - g, 3) * a.x + 3 * Math.pow(1 - g, 2) * g * b.x + 3 * (1 - g) * g * g * c.x + g * g * g * d.x,
                j = Math.pow(1 - g, 3) * a.y + 3 * Math.pow(1 - g, 2) * g * b.y + 3 * (1 - g) * g * g * c.y + g * g * g * d.y;
            f.push(cc.p(i, j)), g += 1 / e
        }
        f.push(cc.p(d.x, d.y)), this.drawPoly(f, e + 1, !1, !1)
    },
    drawCatmullRom: function(a, b) {
        this.drawCardinalSpline(a, .5, b)
    },
    drawCardinalSpline: function(a, b, c) {
        cc._renderContext.strokeStyle = "rgba(255,255,255,1)";
        var d = this._cacheArray;
        d.length = 0;
        for (var e, f, g = 1 / a.length, h = 0; c + 1 > h; h++) f = h / c, 1 == f ? (e = a.length - 1, f = 1) : (e = 0 | f / g, f = (f - g * e) / g), e = cc.CardinalSplineAt(cc.getControlPointAt(a, e - 1), cc.getControlPointAt(a, e - 0), cc.getControlPointAt(a, e + 1), cc.getControlPointAt(a, e + 2), b, f), d.push(e);
        this.drawPoly(d, c + 1, !1, !1)
    },
    drawImage: function(a, b, c, d, e) {
        switch (arguments.length) {
            case 2:
                this._renderContext.drawImage(a, b.x, -(b.y + a.height));
                break;
            case 3:
                this._renderContext.drawImage(a, b.x, -(b.y + c.height), c.width, c.height);
                break;
            case 5:
                this._renderContext.drawImage(a, b.x, b.y, c.width, c.height, d.x, -(d.y + e.height), e.width, e.height);
                break;
            default:
                throw Error("Argument must be non-nil")
        }
    },
    drawStar: function(a, b, c) {
        a = a || this._renderContext, b *= cc.view.getScaleX(), c = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b), a.fillStyle = c + ",1)";
        var d = b / 10;
        a.beginPath(), a.moveTo(-b, b), a.lineTo(0, d), a.lineTo(b, b), a.lineTo(d, 0), a.lineTo(b, -b), a.lineTo(0, -d), a.lineTo(-b, -b), a.lineTo(-d, 0), a.lineTo(-b, b), a.closePath(), a.fill();
        var e = a.createRadialGradient(0, 0, d, 0, 0, b);
        e.addColorStop(0, c + ", 1)"), e.addColorStop(.3, c + ", 0.8)"), e.addColorStop(1, c + ", 0.0)"), a.fillStyle = e, a.beginPath(), a.arc(0, 0, b - d, 0, cc.PI2, !1), a.closePath(), a.fill()
    },
    drawColorBall: function(a, b, c) {
        a = a || this._renderContext, b *= cc.view.getScaleX(), c = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b);
        var d = a.createRadialGradient(0, 0, b / 10, 0, 0, b);
        d.addColorStop(0, c + ", 1)"), d.addColorStop(.3, c + ", 0.8)"), d.addColorStop(.6, c + ", 0.4)"), d.addColorStop(1, c + ", 0.0)"), a.fillStyle = d, a.beginPath(), a.arc(0, 0, b, 0, cc.PI2, !1), a.closePath(), a.fill()
    },
    fillText: function(a, b, c) {
        this._renderContext.fillText(a, b, -c)
    },
    setDrawColor: function(a, b, c, d) {
        this._renderContext.fillStyle = "rgba(" + a + "," + b + "," + c + "," + d / 255 + ")", this._renderContext.strokeStyle = "rgba(" + a + "," + b + "," + c + "," + d / 255 + ")"
    },
    setPointSize: function() {},
    setLineWidth: function(a) {
        this._renderContext.lineWidth = a * cc.view.getScaleX()
    }
}), cc.DrawingPrimitiveWebGL = cc.Class.extend({
    _renderContext: null,
    _initialized: !1,
    _shader: null,
    _colorLocation: -1,
    _colorArray: null,
    _pointSizeLocation: -1,
    _pointSize: -1,
    ctor: function(a) {
        if (null == a && (a = cc._renderContext), !a instanceof WebGLRenderingContext) throw "Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext";
        this._renderContext = a, this._colorArray = new Float32Array([1, 1, 1, 1])
    },
    lazy_init: function() {
        this._initialized || (this._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR), this._colorLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_color"), this._pointSizeLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_pointSize"), this._initialized = !0)
    },
    drawInit: function() {
        this._initialized = !1
    },
    drawPoint: function(a) {
        this.lazy_init();
        var b = this._renderContext;
        this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), b.uniform4fv(this._colorLocation, this._colorArray), this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
        var c = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, c), b.bufferData(b.ARRAY_BUFFER, new Float32Array([a.x, a.y]), b.STATIC_DRAW), b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0), b.drawArrays(b.POINTS, 0, 1), b.deleteBuffer(c), cc.incrementGLDraws(1)
    },
    drawPoints: function(a) {
        if (a && 0 != a.length) {
            this.lazy_init();
            var b = this._renderContext;
            this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), b.uniform4fv(this._colorLocation, this._colorArray), this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
            var c = b.createBuffer();
            b.bindBuffer(b.ARRAY_BUFFER, c), b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW), b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0), b.drawArrays(b.POINTS, 0, a.length), b.deleteBuffer(c), cc.incrementGLDraws(1)
        }
    },
    _pointsToTypeArray: function(a) {
        for (var b = new Float32Array(2 * a.length), c = 0; c < a.length; c++) b[2 * c] = a[c].x, b[2 * c + 1] = a[c].y;
        return b
    },
    drawLine: function(a, b) {
        this.lazy_init();
        var c = this._renderContext;
        this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), c.uniform4fv(this._colorLocation, this._colorArray);
        var d = c.createBuffer();
        c.bindBuffer(c.ARRAY_BUFFER, d), c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray([a, b]), c.STATIC_DRAW), c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0), c.drawArrays(c.LINES, 0, 2), c.deleteBuffer(d), cc.incrementGLDraws(1)
    },
    drawRect: function(a, b) {
        this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y)), this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y)), this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y)), this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function(a, b, c) {
        a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)], this.drawSolidPoly(a, 4, c)
    },
    drawPoly: function(a, b, c) {
        this.lazy_init(), b = this._renderContext, this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), b.uniform4fv(this._colorLocation, this._colorArray);
        var d = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, d), b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW), b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0), c ? b.drawArrays(b.LINE_LOOP, 0, a.length) : b.drawArrays(b.LINE_STRIP, 0, a.length), b.deleteBuffer(d), cc.incrementGLDraws(1)
    },
    drawSolidPoly: function(a, b, c) {
        this.lazy_init(), c && this.setDrawColor(c.r, c.g, c.b, c.a), b = this._renderContext, this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), b.uniform4fv(this._colorLocation, this._colorArray), c = b.createBuffer(), b.bindBuffer(b.ARRAY_BUFFER, c), b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW), b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0), b.drawArrays(b.TRIANGLE_FAN, 0, a.length), b.deleteBuffer(c), cc.incrementGLDraws(1)
    },
    drawCircle: function(a, b, c, d, e) {
        this.lazy_init();
        var f = 1;
        e && f++;
        var g = 2 * Math.PI / d;
        if (e = new Float32Array(2 * (d + 2))) {
            for (var h = 0; d >= h; h++) {
                var i = h * g,
                    j = b * Math.cos(i + c) + a.x,
                    i = b * Math.sin(i + c) + a.y;
                e[2 * h] = j, e[2 * h + 1] = i
            }
            e[2 * (d + 1)] = a.x, e[2 * (d + 1) + 1] = a.y, a = this._renderContext, this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), a.uniform4fv(this._colorLocation, this._colorArray), b = a.createBuffer(), a.bindBuffer(a.ARRAY_BUFFER, b), a.bufferData(a.ARRAY_BUFFER, e, a.STATIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0), a.drawArrays(a.LINE_STRIP, 0, d + f), a.deleteBuffer(b), cc.incrementGLDraws(1)
        }
    },
    drawQuadBezier: function(a, b, c, d) {
        this.lazy_init();
        for (var e = new Float32Array(2 * (d + 1)), f = 0, g = 0; d > g; g++) e[2 * g] = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * b.x + f * f * c.x, e[2 * g + 1] = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * b.y + f * f * c.y, f += 1 / d;
        e[2 * d] = c.x, e[2 * d + 1] = c.y, a = this._renderContext, this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), a.uniform4fv(this._colorLocation, this._colorArray), b = a.createBuffer(), a.bindBuffer(a.ARRAY_BUFFER, b), a.bufferData(a.ARRAY_BUFFER, e, a.STATIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0), a.drawArrays(a.LINE_STRIP, 0, d + 1), a.deleteBuffer(b), cc.incrementGLDraws(1)
    },
    drawCubicBezier: function(a, b, c, d, e) {
        this.lazy_init();
        for (var f = new Float32Array(2 * (e + 1)), g = 0, h = 0; e > h; h++) f[2 * h] = Math.pow(1 - g, 3) * a.x + 3 * Math.pow(1 - g, 2) * g * b.x + 3 * (1 - g) * g * g * c.x + g * g * g * d.x, f[2 * h + 1] = Math.pow(1 - g, 3) * a.y + 3 * Math.pow(1 - g, 2) * g * b.y + 3 * (1 - g) * g * g * c.y + g * g * g * d.y, g += 1 / e;
        f[2 * e] = d.x, f[2 * e + 1] = d.y, a = this._renderContext, this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), a.uniform4fv(this._colorLocation, this._colorArray), b = a.createBuffer(), a.bindBuffer(a.ARRAY_BUFFER, b), a.bufferData(a.ARRAY_BUFFER, f, a.STATIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0), a.drawArrays(a.LINE_STRIP, 0, e + 1), a.deleteBuffer(b), cc.incrementGLDraws(1)
    },
    drawCatmullRom: function(a, b) {
        this.drawCardinalSpline(a, .5, b)
    },
    drawCardinalSpline: function(a, b, c) {
        this.lazy_init();
        for (var d, e, f = new Float32Array(2 * (c + 1)), g = 1 / a.length, h = 0; c + 1 > h; h++) e = h / c, 1 == e ? (d = a.length - 1, e = 1) : (d = 0 | e / g, e = (e - g * d) / g), d = cc.CardinalSplineAt(cc.getControlPointAt(a, d - 1), cc.getControlPointAt(a, d), cc.getControlPointAt(a, d + 1), cc.getControlPointAt(a, d + 2), b, e), f[2 * h] = d.x, f[2 * h + 1] = d.y;
        a = this._renderContext, this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), a.uniform4fv(this._colorLocation, this._colorArray), b = a.createBuffer(), a.bindBuffer(a.ARRAY_BUFFER, b), a.bufferData(a.ARRAY_BUFFER, f, a.STATIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0), a.drawArrays(a.LINE_STRIP, 0, c + 1), a.deleteBuffer(b), cc.incrementGLDraws(1)
    },
    setDrawColor: function(a, b, c, d) {
        this._colorArray[0] = a / 255, this._colorArray[1] = b / 255, this._colorArray[2] = c / 255, this._colorArray[3] = d / 255
    },
    setPointSize: function(a) {
        this._pointSize = a * cc.contentScaleFactor()
    },
    setLineWidth: function(a) {
        this._renderContext.lineWidth && this._renderContext.lineWidth(a)
    }
}), cc._tmp.WebGLLabelTTF = function() {
    var a = cc.LabelTTF.prototype;
    a.setColor = cc.Sprite.prototype.setColor, a._setColorsString = function() {
        this._needUpdateTexture = !0;
        var a = this._strokeColor,
            b = this._textFillColor;
        this._shadowColorStr = "rgba(128,128,128," + this._shadowOpacity + ")", this._fillColorStr = "rgba(" + (0 | b.r) + "," + (0 | b.g) + "," + (0 | b.b) + ", 1)", this._strokeColorStr = "rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + ", 1)"
    }, a.updateDisplayedColor = cc.Sprite.prototype.updateDisplayedColor, a.setOpacity = cc.Sprite.prototype.setOpacity, a.updateDisplayedOpacity = cc.Sprite.prototype.updateDisplayedOpacity, a.initWithStringAndTextDefinition = function(a, b) {
        return cc.Sprite.prototype.init.call(this) ? (this.shaderProgram = cc.shaderCache.programForKey(cc.LabelTTF._SHADER_PROGRAM), this._updateWithTextDefinition(b, !1), this.string = a, !0) : !1
    }, a.setFontFillColor = function(a) {
        var b = this._textFillColor;
        (b.r != a.r || b.g != a.g || b.b != a.b) && (b.r = a.r, b.g = a.g, b.b = a.b, this._setColorsString(), this._needUpdateTexture = !0)
    }, a.draw = function(a) {
        if (this._string && "" != this._string) {
            a = a || cc._renderContext;
            var b = this._texture;
            if (b && b._isLoaded && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(b), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.STATIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 24, 16), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)), 1 === cc.SPRITE_DEBUG_DRAW) a = this._quad, a = [cc.p(a.tl.vertices.x, a.tl.vertices.y), cc.p(a.bl.vertices.x, a.bl.vertices.y), cc.p(a.br.vertices.x, a.br.vertices.y), cc.p(a.tr.vertices.x, a.tr.vertices.y)], cc._drawingUtil.drawPoly(a, 4, !0);
            else if (2 === cc.SPRITE_DEBUG_DRAW) {
                a = this.getTextureRect();
                var b = this.offsetX,
                    c = this.offsetY;
                a = [cc.p(b, c), cc.p(b + a.width, c), cc.p(b + a.width, c + a.height), cc.p(b, c + a.height)], cc._drawingUtil.drawPoly(a, 4, !0)
            }
            cc.g_NumberOfDraws++
        }
    }, a.setTextureRect = cc.Sprite.prototype.setTextureRect
}, cc._tmp.PrototypeLabelTTF = function() {
    var a = cc.LabelTTF.prototype;
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor), cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity), cc.defineGetterSetter(a, "string", a.getString, a.setString), cc.defineGetterSetter(a, "textAlign", a.getHorizontalAlignment, a.setHorizontalAlignment), cc.defineGetterSetter(a, "verticalAlign", a.getVerticalAlignment, a.setVerticalAlignment), cc.defineGetterSetter(a, "fontSize", a.getFontSize, a.setFontSize), cc.defineGetterSetter(a, "fontName", a.getFontName, a.setFontName), cc.defineGetterSetter(a, "font", a._getFont, a._setFont), cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a._setBoundingWidth), cc.defineGetterSetter(a, "boundingHeight", a._getBoundingHeight, a._setBoundingHeight), cc.defineGetterSetter(a, "fillStyle", a._getFillStyle, a.setFontFillColor), cc.defineGetterSetter(a, "strokeStyle", a._getStrokeStyle, a._setStrokeStyle), cc.defineGetterSetter(a, "lineWidth", a._getLineWidth, a._setLineWidth), cc.defineGetterSetter(a, "shadowOffsetX", a._getShadowOffsetX, a._setShadowOffsetX), cc.defineGetterSetter(a, "shadowOffsetY", a._getShadowOffsetY, a._setShadowOffsetY), cc.defineGetterSetter(a, "shadowOpacity", a._getShadowOpacity, a._setShadowOpacity), cc.defineGetterSetter(a, "shadowBlur", a._getShadowBlur, a._setShadowBlur)
}, cc.LabelTTF = cc.Sprite.extend({
    _dimensions: null,
    _hAlignment: cc.TEXT_ALIGNMENT_CENTER,
    _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    _fontName: null,
    _fontSize: 0,
    _string: "",
    _originalText: null,
    _isMultiLine: !1,
    _fontStyleStr: null,
    _shadowEnabled: !1,
    _shadowOffset: null,
    _shadowOpacity: 0,
    _shadowBlur: 0,
    _shadowColorStr: null,
    _strokeEnabled: !1,
    _strokeColor: null,
    _strokeSize: 0,
    _strokeColorStr: null,
    _textFillColor: null,
    _fillColorStr: null,
    _strokeShadowOffsetX: 0,
    _strokeShadowOffsetY: 0,
    _needUpdateTexture: !1,
    _labelCanvas: null,
    _labelContext: null,
    _lineWidths: null,
    _className: "LabelTTF",
    initWithString: function(a, b, c, d, e, f) {
        return a = a ? a + "" : "", c = c || 16, d = d || cc.size(0, 0), e = e || cc.TEXT_ALIGNMENT_LEFT, f = f || cc.VERTICAL_TEXT_ALIGNMENT_TOP, this._opacityModifyRGB = !1, this._dimensions = cc.size(d.width, d.height), this._fontName = b || "Arial", this._hAlignment = e, this._vAlignment = f, this._fontSize = c, this._fontStyleStr = this._fontSize + "px '" + b + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(b, this._fontSize), this.string = a, this._setColorsString(), this._updateTexture(), this._needUpdateTexture = !1, !0
    },
    ctor: function(a, b, c, d, e, f) {
        cc.Sprite.prototype.ctor.call(this), this._dimensions = cc.size(0, 0), this._hAlignment = cc.TEXT_ALIGNMENT_LEFT, this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP, this._opacityModifyRGB = !1, this._fontStyleStr = "", this._fontName = "Arial", this._shadowEnabled = this._isMultiLine = !1, this._shadowOffset = cc.p(0, 0), this._shadowBlur = this._shadowOpacity = 0, this._shadowColorStr = "rgba(128, 128, 128, 0.5)", this._strokeEnabled = !1, this._strokeColor = cc.color(255, 255, 255, 255), this._strokeSize = 0, this._strokeColorStr = "", this._textFillColor = cc.color(255, 255, 255, 255), this._fillColorStr = "rgba(255,255,255,1)", this._strokeShadowOffsetY = this._strokeShadowOffsetX = 0, this._needUpdateTexture = !1, this._lineWidths = [], this._setColorsString(), b && b instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(a, b) : cc.LabelTTF.prototype.initWithString.call(this, a, b, c, d, e, f)
    },
    init: function() {
        return this.initWithString(" ", this._fontName, this._fontSize)
    },
    _measureConfig: function() {
        this._getLabelContext().font = this._fontStyleStr
    },
    _measure: function(a) {
        return this._getLabelContext().measureText(a).width
    },
    description: function() {
        return "<cc.LabelTTF | FontName =" + this._fontName + " FontSize = " + this._fontSize.toFixed(1) + ">"
    },
    setColor: null,
    _setColorsString: null,
    updateDisplayedColor: null,
    setOpacity: null,
    updateDisplayedOpacity: null,
    updateDisplayedOpacityForCanvas: function(a) {
        cc.Node.prototype.updateDisplayedOpacity.call(this, a), this._setColorsString()
    },
    getString: function() {
        return this._string
    },
    getHorizontalAlignment: function() {
        return this._hAlignment
    },
    getVerticalAlignment: function() {
        return this._vAlignment
    },
    getDimensions: function() {
        return cc.size(this._dimensions)
    },
    getFontSize: function() {
        return this._fontSize
    },
    getFontName: function() {
        return this._fontName
    },
    initWithStringAndTextDefinition: null,
    setTextDefinition: function(a) {
        a && this._updateWithTextDefinition(a, !0)
    },
    getTextDefinition: function() {
        return this._prepareTextDefinition(!1)
    },
    enableShadow: function(a, b, c, d) {
        c = c || .5, !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        var e = this._shadowOffset;
        (e && e.x != a || e._y != b) && (e.x = a, e.y = b), this._shadowOpacity != c && (this._shadowOpacity = c), this._setColorsString(), this._shadowBlur != d && (this._shadowBlur = d), this._needUpdateTexture = !0
    },
    _getShadowOffsetX: function() {
        return this._shadowOffset.x
    },
    _setShadowOffsetX: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0), this._shadowOffset.x != a && (this._shadowOffset.x = a, this._needUpdateTexture = !0)
    },
    _getShadowOffsetY: function() {
        return this._shadowOffset._y
    },
    _setShadowOffsetY: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0), this._shadowOffset._y != a && (this._shadowOffset._y = a, this._needUpdateTexture = !0)
    },
    _getShadowOffset: function() {
        return cc.p(this._shadowOffset.x, this._shadowOffset.y)
    },
    _setShadowOffset: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0), (this._shadowOffset.x != a.x || this._shadowOffset.y != a.y) && (this._shadowOffset.x = a.x, this._shadowOffset.y = a.y, this._needUpdateTexture = !0)
    },
    _getShadowOpacity: function() {
        return this._shadowOpacity
    },
    _setShadowOpacity: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0), this._shadowOpacity != a && (this._shadowOpacity = a, this._setColorsString(), this._needUpdateTexture = !0)
    },
    _getShadowBlur: function() {
        return this._shadowBlur
    },
    _setShadowBlur: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0), this._shadowBlur != a && (this._shadowBlur = a, this._needUpdateTexture = !0)
    },
    disableShadow: function() {
        this._shadowEnabled && (this._shadowEnabled = !1, this._needUpdateTexture = !0)
    },
    enableStroke: function(a, b) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var c = this._strokeColor;
        (c.r !== a.r || c.g !== a.g || c.b !== a.b) && (c.r = a.r, c.g = a.g, c.b = a.b, this._setColorsString()), this._strokeSize !== b && (this._strokeSize = b || 0), this._needUpdateTexture = !0
    },
    _getStrokeStyle: function() {
        return this._strokeColor
    },
    _setStrokeStyle: function(a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var b = this._strokeColor;
        (b.r !== a.r || b.g !== a.g || b.b !== a.b) && (b.r = a.r, b.g = a.g, b.b = a.b, this._setColorsString(), this._needUpdateTexture = !0)
    },
    _getLineWidth: function() {
        return this._strokeSize
    },
    _setLineWidth: function(a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0), this._strokeSize !== a && (this._strokeSize = a || 0, this._needUpdateTexture = !0)
    },
    disableStroke: function() {
        this._strokeEnabled && (this._strokeEnabled = !1, this._needUpdateTexture = !0)
    },
    setFontFillColor: null,
    _getFillStyle: function() {
        return this._textFillColor
    },
    _updateWithTextDefinition: function(a, b) {
        a.fontDimensions ? (this._dimensions.width = a.boundingWidth, this._dimensions.height = a.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height = 0), this._hAlignment = a.textAlign, this._vAlignment = a.verticalAlign, this._fontName = a.fontName, this._fontSize = a.fontSize || 12, this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize), a.shadowEnabled && this.enableShadow(a.shadowOffsetX, a.shadowOffsetY, a.shadowOpacity, a.shadowBlur), a.strokeEnabled && this.enableStroke(a.strokeStyle, a.lineWidth), this.setFontFillColor(a.fillStyle), b && this._updateTexture()
    },
    _prepareTextDefinition: function(a) {
        var b = new cc.FontDefinition;
        if (a ? (b.fontSize = this._fontSize, b.boundingWidth = cc.contentScaleFactor() * this._dimensions.width, b.boundingHeight = cc.contentScaleFactor() * this._dimensions.height) : (b.fontSize = this._fontSize, b.boundingWidth = this._dimensions.width, b.boundingHeight = this._dimensions.height), b.fontName = this._fontName, b.textAlign = this._hAlignment, b.verticalAlign = this._vAlignment, this._strokeEnabled) {
            b.strokeEnabled = !0;
            var c = this._strokeColor;
            b.strokeStyle = cc.color(c.r, c.g, c.b), b.lineWidth = this._strokeSize
        } else b.strokeEnabled = !1;
        return this._shadowEnabled ? (b.shadowEnabled = !0, b.shadowBlur = this._shadowBlur, b.shadowOpacity = this._shadowOpacity, b.shadowOffsetX = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.x, b.shadowOffsetY = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.y) : b._shadowEnabled = !1, a = this._textFillColor, b.fillStyle = cc.color(a.r, a.g, a.b), b
    },
    _fontClientHeight: 18,
    setString: function(a) {
        a = String(a), this._originalText != a && (this._originalText = a + "", this._updateString(), this._needUpdateTexture = !0)
    },
    _updateString: function() {
        this._string = this._originalText
    },
    setHorizontalAlignment: function(a) {
        a !== this._hAlignment && (this._hAlignment = a, this._needUpdateTexture = !0)
    },
    setVerticalAlignment: function(a) {
        a != this._vAlignment && (this._vAlignment = a, this._needUpdateTexture = !0)
    },
    setDimensions: function(a, b) {
        var c;
        void 0 === b ? (c = a.width, b = a.height) : c = a, (c != this._dimensions.width || b != this._dimensions.height) && (this._dimensions.width = c, this._dimensions.height = b, this._updateString(), this._needUpdateTexture = !0)
    },
    _getBoundingWidth: function() {
        return this._dimensions.width
    },
    _setBoundingWidth: function(a) {
        a != this._dimensions.width && (this._dimensions.width = a, this._updateString(), this._needUpdateTexture = !0)
    },
    _getBoundingHeight: function() {
        return this._dimensions.height
    },
    _setBoundingHeight: function(a) {
        a != this._dimensions.height && (this._dimensions.height = a, this._updateString(), this._needUpdateTexture = !0)
    },
    setFontSize: function(a) {
        this._fontSize !== a && (this._fontSize = a, this._fontStyleStr = a + "px '" + this._fontName + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, a), this._needUpdateTexture = !0)
    },
    setFontName: function(a) {
        this._fontName && this._fontName != a && (this._fontName = a, this._fontStyleStr = this._fontSize + "px '" + a + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a, this._fontSize), this._needUpdateTexture = !0)
    },
    _getFont: function() {
        return this._fontStyleStr
    },
    _setFont: function(a) {
        var b = cc.LabelTTF._fontStyleRE.exec(a);
        b && (this._fontSize = parseInt(b[1]), this._fontName = b[2], this._fontStyleStr = a, this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize), this._needUpdateTexture = !0)
    },
    _drawTTFInCanvas: function(a) {
        if (a) {
            var b = this._strokeShadowOffsetX,
                c = this._strokeShadowOffsetY,
                d = this._contentSize.height - c,
                e = this._vAlignment,
                f = this._hAlignment,
                g = this._fontClientHeight,
                h = this._strokeSize;
            a.setTransform(1, 0, 0, 1, 0 + .5 * b, d + .5 * c), a.font != this._fontStyleStr && (a.font = this._fontStyleStr), a.fillStyle = this._fillColorStr;
            var i = c = 0,
                j = this._strokeEnabled;
            if (j && (a.lineWidth = 2 * h, a.strokeStyle = this._strokeColorStr), this._shadowEnabled && (h = this._shadowOffset, a.shadowColor = this._shadowColorStr, a.shadowOffsetX = h.x, a.shadowOffsetY = -h.y, a.shadowBlur = this._shadowBlur), a.textBaseline = cc.LabelTTF._textBaseline[e], a.textAlign = cc.LabelTTF._textAlign[f], b = this._contentSize.width - b, c = f === cc.TEXT_ALIGNMENT_RIGHT ? c + b : f === cc.TEXT_ALIGNMENT_CENTER ? c + b / 2 : c + 0, this._isMultiLine)
                for (f = this._strings.length, e === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? i = g + d - g * f : e === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (i = g / 2 + (d - g * f) / 2), e = 0; f > e; e++) b = this._strings[e], h = -d + g * e + i, j && a.strokeText(b, c, h), a.fillText(b, c, h);
            else e !== cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM && (i = e === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? i - d : i - .5 * d), j && a.strokeText(this._string, c, i), a.fillText(this._string, c, i)
        }
    },
    _getLabelContext: function() {
        if (this._labelContext) return this._labelContext;
        if (!this._labelCanvas) {
            var a = cc.newElement("canvas"),
                b = new cc.Texture2D;
            b.initWithElement(a), this.texture = b, this._labelCanvas = a
        }
        return this._labelContext = this._labelCanvas.getContext("2d")
    },
    _checkWarp: function(a, b, c) {
        var d = a[b],
            e = this._measure(d);
        if (e > c && 1 < d.length) {
            for (var f, g = d.length * (c / e) | 0, h = d.substr(g), i = e - this._measure(h), j = 0, k = 0; i > c && 100 > k++;) g *= c / i, g |= 0, h = d.substr(g), i = e - this._measure(h);
            for (k = 0; c > i && 100 > k++;) h && (j = (f = cc.LabelTTF._wordRex.exec(h)) ? f[0].length : 1, f = h), g += j, h = d.substr(g), i = e - this._measure(h);
            g -= j, c = d.substr(0, g), cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(f || h) && (e = cc.LabelTTF._lastWordRex.exec(c), g -= e ? e[0].length : 0, f = d.substr(g), c = d.substr(0, g)), cc.LabelTTF._firsrEnglish.test(f) && (e = cc.LabelTTF._lastEnglish.exec(c)) && c !== e[0] && (g -= e[0].length, f = d.substr(g), c = d.substr(0, g)), a[b] = f || h, a.splice(b, 0, c)
        }
    },
    _updateTTF: function() {
        var a, b, c = this._dimensions.width,
            d = this._lineWidths;
        if (d.length = 0, this._isMultiLine = !1, this._measureConfig(), 0 !== c)
            for (this._strings = this._string.split("\n"), a = 0; a < this._strings.length; a++) this._checkWarp(this._strings, a, c);
        else
            for (this._strings = this._string.split("\n"), a = 0, b = this._strings.length; b > a; a++) d.push(this._measure(this._strings[a])); if (0 < this._strings.length && (this._isMultiLine = !0), b = a = 0, this._strokeEnabled && (a = b = 2 * this._strokeSize), this._shadowEnabled) {
            var e = this._shadowOffset;
            a += 2 * Math.abs(e.x), b += 2 * Math.abs(e.y)
        }
        c = 0 === c ? this._isMultiLine ? cc.size(0 | Math.max.apply(Math, d) + a, 0 | this._fontClientHeight * this._strings.length + b) : cc.size(0 | this._measure(this._string) + a, 0 | this._fontClientHeight + b) : 0 === this._dimensions.height ? this._isMultiLine ? cc.size(0 | c + a, 0 | this._fontClientHeight * this._strings.length + b) : cc.size(0 | c + a, 0 | this._fontClientHeight + b) : cc.size(0 | c + a, 0 | this._dimensions.height + b), this.setContentSize(c), this._strokeShadowOffsetX = a, this._strokeShadowOffsetY = b, d = this._anchorPoint, this._anchorPointInPoints.x = .5 * a + (c.width - a) * d.x, this._anchorPointInPoints.y = .5 * b + (c.height - b) * d.y
    },
    getContentSize: function() {
        return this._needUpdateTexture && this._updateTTF(), cc.Sprite.prototype.getContentSize.call(this)
    },
    _getWidth: function() {
        return this._needUpdateTexture && this._updateTTF(), cc.Sprite.prototype._getWidth.call(this)
    },
    _getHeight: function() {
        return this._needUpdateTexture && this._updateTTF(), cc.Sprite.prototype._getHeight.call(this)
    },
    _updateTexture: function() {
        var a = this._getLabelContext(),
            b = this._labelCanvas,
            c = this._contentSize;
        if (0 === this._string.length) return b.width = 1, b.height = c.height || 1, this._texture && this._texture.handleLoadedTexture(), this.setTextureRect(cc.rect(0, 0, 1, c.height)), !0;
        a.font = this._fontStyleStr, this._updateTTF();
        var d = c.width,
            c = c.height,
            e = b.width == d && b.height == c;
        return b.width = d, b.height = c, e && a.clearRect(0, 0, d, c), this._drawTTFInCanvas(a), this._texture && this._texture.handleLoadedTexture(), this.setTextureRect(cc.rect(0, 0, d, c)), !0
    },
    visit: function(a) {
        this._string && "" != this._string && (this._needUpdateTexture && (this._needUpdateTexture = !1, this._updateTexture()), cc.Sprite.prototype.visit.call(this, a || cc._renderContext))
    },
    draw: null,
    _setTextureCoords: function(a) {
        var b = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (b) {
            var c, d = b.pixelsWidth,
                e = b.pixelsHeight,
                f = this._quad;
            this._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * d), d = b + (2 * a.height - 2) / (2 * d), c = (2 * a.y + 1) / (2 * e), a = c + (2 * a.width - 2) / (2 * e)) : (b = a.x / d, d = (a.x + a.height) / d, c = a.y / e, a = (a.y + a.width) / e), this._flippedX && (e = c, c = a, a = e), this._flippedY && (e = b, b = d, d = e), f.bl.texCoords.u = b, f.bl.texCoords.v = c, f.br.texCoords.u = b, f.br.texCoords.v = a, f.tl.texCoords.u = d, f.tl.texCoords.v = c, f.tr.texCoords.u = d, f.tr.texCoords.v = a) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * d), d = b + (2 * a.width - 2) / (2 * d), c = (2 * a.y + 1) / (2 * e), a = c + (2 * a.height - 2) / (2 * e)) : (b = a.x / d, d = (a.x + a.width) / d, c = a.y / e, a = (a.y + a.height) / e), this._flippedX && (e = b, b = d, d = e), this._flippedY && (e = c, c = a, a = e), f.bl.texCoords.u = b, f.bl.texCoords.v = a, f.br.texCoords.u = d, f.br.texCoords.v = a, f.tl.texCoords.u = b, f.tl.texCoords.v = c, f.tr.texCoords.u = d, f.tr.texCoords.v = c), this._quadDirty = !0
        }
    }
}), cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.LabelTTF.prototype, _p.setColor = function(a) {
    cc.Node.prototype.setColor.call(this, a), this._setColorsString()
}, _p._setColorsString = function() {
    this._needUpdateTexture = !0;
    var a = this._displayedColor,
        b = this._displayedOpacity,
        c = this._strokeColor,
        d = this._textFillColor;
    this._shadowColorStr = "rgba(" + (0 | .5 * a.r) + "," + (0 | .5 * a.g) + "," + (0 | .5 * a.b) + "," + this._shadowOpacity + ")", this._fillColorStr = "rgba(" + (0 | a.r / 255 * d.r) + "," + (0 | a.g / 255 * d.g) + "," + (0 | a.b / 255 * d.b) + ", " + b / 255 + ")", this._strokeColorStr = "rgba(" + (0 | a.r / 255 * c.r) + "," + (0 | a.g / 255 * c.g) + "," + (0 | a.b / 255 * c.b) + ", " + b / 255 + ")"
}, _p.updateDisplayedColor = function(a) {
    cc.Node.prototype.updateDisplayedColor.call(this, a), this._setColorsString()
}, _p.setOpacity = function(a) {
    this._opacity !== a && (cc.Sprite.prototype.setOpacity.call(this, a), this._setColorsString(), this._needUpdateTexture = !0)
}, _p.updateDisplayedOpacity = cc.Sprite.prototype.updateDisplayedOpacity, _p.initWithStringAndTextDefinition = function(a, b) {
    return this._updateWithTextDefinition(b, !1), this.string = a, !0
}, _p.setFontFillColor = function(a) {
    var b = this._textFillColor;
    (b.r != a.r || b.g != a.g || b.b != a.b) && (b.r = a.r, b.g = a.g, b.b = a.b, this._setColorsString(), this._needUpdateTexture = !0)
}, _p.draw = cc.Sprite.prototype.draw, _p.setTextureRect = function(a, b, c) {
    this._rectRotated = b || !1, this.setContentSize(c || a), this.setVertexRect(a), b = this._textureRect_Canvas, b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height, b.validRect = !(0 === b.width || 0 === b.height || 0 > b.x || 0 > b.y), a = this._unflippedOffsetPositionFromCenter, this._flippedX && (a.x = -a.x), this._flippedY && (a.y = -a.y), this._offsetPosition.x = a.x + (this._contentSize.width - this._rect.width) / 2, this._offsetPosition.y = a.y + (this._contentSize.height - this._rect.height) / 2, this._batchNode && (this.dirty = !0)
}, _p = null) : (cc.assert("function" == typeof cc._tmp.WebGLLabelTTF, cc._LogInfos.MissingFile, "LabelTTFWebGL.js"), cc._tmp.WebGLLabelTTF(), delete cc._tmp.WebGLLabelTTF), cc.assert("function" == typeof cc._tmp.PrototypeLabelTTF, cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js"), cc._tmp.PrototypeLabelTTF(), delete cc._tmp.PrototypeLabelTTF, cc.LabelTTF._textAlign = ["left", "center", "right"], cc.LabelTTF._textBaseline = ["top", "middle", "bottom"], cc.LabelTTF.wrapInspection = !0, cc.LabelTTF._wordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)/, cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>\u3001\u2018\u201c\u300b\uff1f\u3002\uff0c\uff01]/, cc.LabelTTF._lastWordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)$/, cc.LabelTTF._lastEnglish = /[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+$/, cc.LabelTTF._firsrEnglish = /^[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]/, cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/, cc.LabelTTF.create = function(a, b, c, d, e, f) {
    return new cc.LabelTTF(a, b, c, d, e, f)
}, cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create, cc.LabelTTF._SHADER_PROGRAM = cc.USE_LA88_LABELS ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_TEXTUREA8COLOR, cc.LabelTTF.__labelHeightDiv = cc.newElement("div"), cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial", cc.LabelTTF.__labelHeightDiv.style.position = "absolute", cc.LabelTTF.__labelHeightDiv.style.left = "-100px", cc.LabelTTF.__labelHeightDiv.style.top = "-100px", cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal", document.body ? document.body.appendChild(cc.LabelTTF.__labelHeightDiv) : cc._addEventListener(window, "load", function() {
    this.removeEventListener("load", arguments.callee, !1), document.body.appendChild(cc.LabelTTF.__labelHeightDiv)
}, !1), cc.LabelTTF.__getFontHeightByDiv = function(a, b) {
    var c = cc.LabelTTF.__fontHeightCache[a + "." + b];
    if (c > 0) return c;
    var d = cc.LabelTTF.__labelHeightDiv;
    return d.innerHTML = "ajghl~!", d.style.fontFamily = a, d.style.fontSize = b + "px", c = d.clientHeight, cc.LabelTTF.__fontHeightCache[a + "." + b] = c, d.innerHTML = "", c
}, cc.LabelTTF.__fontHeightCache = {}, cc.HashElement = cc.Class.extend({
    actions: null,
    target: null,
    actionIndex: 0,
    currentAction: null,
    currentActionSalvaged: !1,
    paused: !1,
    hh: null,
    ctor: function() {
        this.actions = [], this.target = null, this.actionIndex = 0, this.currentAction = null, this.paused = this.currentActionSalvaged = !1, this.hh = null
    }
}), cc.ActionManager = cc.Class.extend({
    _hashTargets: null,
    _arrayTargets: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _searchElementByTarget: function(a, b) {
        for (var c = 0; c < a.length; c++)
            if (b == a[c].target) return a[c];
        return null
    },
    ctor: function() {
        this._hashTargets = {}, this._arrayTargets = [], this._currentTarget = null, this._currentTargetSalvaged = !1
    },
    addAction: function(a, b, c) {
        if (!a) throw "cc.ActionManager.addAction(): action must be non-null";
        if (!b) throw "cc.ActionManager.addAction(): action must be non-null";
        var d = this._hashTargets[b.__instanceId];
        d || (d = new cc.HashElement, d.paused = c, d.target = b, this._hashTargets[b.__instanceId] = d, this._arrayTargets.push(d)), this._actionAllocWithHashElement(d), d.actions.push(a), a.startWithTarget(b)
    },
    removeAllActions: function() {
        for (var a = this._arrayTargets, b = 0; b < a.length; b++) {
            var c = a[b];
            c && this.removeAllActionsFromTarget(c.target, !0)
        }
    },
    removeAllActionsFromTarget: function(a, b) {
        if (null != a) {
            var c = this._hashTargets[a.__instanceId];
            c && (-1 !== c.actions.indexOf(c.currentAction) && !c.currentActionSalvaged && (c.currentActionSalvaged = !0), c.actions.length = 0, this._currentTarget != c || b ? this._deleteHashElement(c) : this._currentTargetSalvaged = !0)
        }
    },
    removeAction: function(a) {
        if (null != a) {
            var b = a.getOriginalTarget();
            if (b = this._hashTargets[b.__instanceId]) {
                for (var c = 0; c < b.actions.length; c++)
                    if (b.actions[c] == a) {
                        b.actions.splice(c, 1);
                        break
                    }
            } else cc.log(cc._LogInfos.ActionManager_removeAction)
        }
    },
    removeActionByTag: function(a, b) {
        a == cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_addAction), cc.assert(b, cc._LogInfos.ActionManager_addAction);
        var c = this._hashTargets[b.__instanceId];
        if (c)
            for (var d = c.actions.length, e = 0; d > e; ++e) {
                var f = c.actions[e];
                if (f && f.getTag() === a && f.getOriginalTarget() == b) {
                    this._removeActionAtIndex(e, c);
                    break
                }
            }
    },
    getActionByTag: function(a, b) {
        a == cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_getActionByTag);
        var c = this._hashTargets[b.__instanceId];
        if (c) {
            if (null != c.actions)
                for (var d = 0; d < c.actions.length; ++d) {
                    var e = c.actions[d];
                    if (e && e.getTag() === a) return e
                }
            cc.log(cc._LogInfos.ActionManager_getActionByTag_2, a)
        }
        return null
    },
    numberOfRunningActionsInTarget: function(a) {
        return (a = this._hashTargets[a.__instanceId]) && a.actions ? a.actions.length : 0
    },
    pauseTarget: function(a) {
        (a = this._hashTargets[a.__instanceId]) && (a.paused = !0)
    },
    resumeTarget: function(a) {
        (a = this._hashTargets[a.__instanceId]) && (a.paused = !1)
    },
    pauseAllRunningActions: function() {
        for (var a = [], b = this._arrayTargets, c = 0; c < b.length; c++) {
            var d = b[c];
            d && !d.paused && (d.paused = !0, a.push(d.target))
        }
        return a
    },
    resumeTargets: function(a) {
        if (a)
            for (var b = 0; b < a.length; b++) a[b] && this.resumeTarget(a[b])
    },
    purgeSharedManager: function() {
        cc.director.getScheduler().unscheduleUpdateForTarget(this)
    },
    _removeActionAtIndex: function(a, b) {
        b.actions[a] == b.currentAction && !b.currentActionSalvaged && (b.currentActionSalvaged = !0), b.actions.splice(a, 1), b.actionIndex >= a && b.actionIndex--, 0 == b.actions.length && (this._currentTarget == b ? this._currentTargetSalvaged = !0 : this._deleteHashElement(b))
    },
    _deleteHashElement: function(a) {
        a && (delete this._hashTargets[a.target.__instanceId], cc.arrayRemoveObject(this._arrayTargets, a), a.actions = null, a.target = null)
    },
    _actionAllocWithHashElement: function(a) {
        null == a.actions && (a.actions = [])
    },
    update: function(a) {
        for (var b, c = this._arrayTargets, d = 0; d < c.length; d++) {
            if (b = this._currentTarget = c[d], !b.paused)
                for (b.actionIndex = 0; b.actionIndex < b.actions.length; b.actionIndex++)
                    if (b.currentAction = b.actions[b.actionIndex], b.currentAction) {
                        if (b.currentActionSalvaged = !1, b.currentAction.step(a * (b.currentAction._speedMethod ? b.currentAction._speed : 1)), b.currentActionSalvaged) b.currentAction = null;
                        else if (b.currentAction.isDone()) {
                            b.currentAction.stop();
                            var e = b.currentAction;
                            b.currentAction = null, this.removeAction(e)
                        }
                        b.currentAction = null
                    }
            this._currentTargetSalvaged && 0 === b.actions.length && this._deleteHashElement(b)
        }
    }
}), cc.kmScalar = Number, cc.kmBool = Number, cc.kmEnum = Number, cc.KM_FALSE = 0, cc.KM_TRUE = 1, cc.kmPI = 3.141592, cc.kmPIOver180 = .017453, cc.kmPIUnder180 = 57.295779, cc.kmEpsilon = .015625, cc.kmSQR = function(a) {
    return a * a
}, cc.kmDegreesToRadians = function(a) {
    return a * cc.kmPIOver180
}, cc.kmRadiansToDegrees = function(a) {
    return a * cc.kmPIUnder180
}, cc.kmMin = function(a, b) {
    return b > a ? a : b
}, cc.kmMax = function(a, b) {
    return a > b ? a : b
}, cc.kmAlmostEqual = function(a, b) {
    return a + cc.kmEpsilon > b && a - cc.kmEpsilon < b
}, cc.kmVec2 = function(a, b) {
    this.x = a || 0, this.y = b || 0
}, cc.kmVec2Fill = function(a, b, c) {
    return a.x = b, a.y = c, a
}, cc.kmVec2Length = function(a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y))
}, cc.kmVec2LengthSq = function(a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y)
}, cc.kmVec2Normalize = function(a, b) {
    var c = 1 / cc.kmVec2Length(b),
        d = new cc.kmVec2;
    return d.x = b.x * c, d.y = b.y * c, a.x = d.x, a.y = d.y, a
}, cc.kmVec2Add = function(a, b, c) {
    return a.x = b.x + c.x, a.y = b.y + c.y, a
}, cc.kmVec2Dot = function(a, b) {
    return a.x * b.x + a.y * b.y
}, cc.kmVec2Subtract = function(a, b, c) {
    return a.x = b.x - c.x, a.y = b.y - c.y, a
}, cc.kmVec2Transform = function(a, b, c) {
    var d = new cc.kmVec2;
    return d.x = b.x * c.mat[0] + b.y * c.mat[3] + c.mat[6], d.y = b.x * c.mat[1] + b.y * c.mat[4] + c.mat[7], a.x = d.x, a.y = d.y, a
}, cc.kmVec2TransformCoord = function() {
    return null
}, cc.kmVec2Scale = function(a, b, c) {
    return a.x = b.x * c, a.y = b.y * c, a
}, cc.kmVec2AreEqual = function(a, b) {
    return a.x < b.x + cc.kmEpsilon && a.x > b.x - cc.kmEpsilon && a.y < b.y + cc.kmEpsilon && a.y > b.y - cc.kmEpsilon
}, cc.kmVec3 = function(a, b, c) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0
}, cc.kmVec3Fill = function(a, b, c, d) {
    return a ? (a.x = b, a.y = c, a.z = d, a) : new cc.kmVec3(b, c, d)
}, cc.kmVec3Length = function(a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z))
}, cc.kmVec3LengthSq = function(a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z)
}, cc.kmVec3Normalize = function(a, b) {
    var c = 1 / cc.kmVec3Length(b);
    return a.x = b.x * c, a.y = b.y * c, a.z = b.z * c, a
}, cc.kmVec3Cross = function(a, b, c) {
    return a.x = b.y * c.z - b.z * c.y, a.y = b.z * c.x - b.x * c.z, a.z = b.x * c.y - b.y * c.x, a
}, cc.kmVec3Dot = function(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z
}, cc.kmVec3Add = function(a, b, c) {
    return a.x = b.x + c.x, a.y = b.y + c.y, a.z = b.z + c.z, a
}, cc.kmVec3Subtract = function(a, b, c) {
    return a.x = b.x - c.x, a.y = b.y - c.y, a.z = b.z - c.z, a
}, cc.kmVec3Transform = function(a, b, c) {
    return a.x = b.x * c.mat[0] + b.y * c.mat[4] + b.z * c.mat[8] + c.mat[12], a.y = b.x * c.mat[1] + b.y * c.mat[5] + b.z * c.mat[9] + c.mat[13], a.z = b.x * c.mat[2] + b.y * c.mat[6] + b.z * c.mat[10] + c.mat[14], a
}, cc.kmVec3TransformNormal = function(a, b, c) {
    return a.x = b.x * c.mat[0] + b.y * c.mat[4] + b.z * c.mat[8], a.y = b.x * c.mat[1] + b.y * c.mat[5] + b.z * c.mat[9], a.z = b.x * c.mat[2] + b.y * c.mat[6] + b.z * c.mat[10], a
}, cc.kmVec3TransformCoord = function(a, b, c) {
    var d = new cc.kmVec4,
        e = new cc.kmVec4;
    return cc.kmVec4Fill(e, b.x, b.y, b.z, 1), cc.kmVec4Transform(d, e, c), a.x = d.x / d.w, a.y = d.y / d.w, a.z = d.z / d.w, a
}, cc.kmVec3Scale = function(a, b, c) {
    return a.x = b.x * c, a.y = b.y * c, a.z = b.z * c, a
}, cc.kmVec3AreEqual = function(a, b) {
    return a.x < b.x + cc.kmEpsilon && a.x > b.x - cc.kmEpsilon && a.y < b.y + cc.kmEpsilon && a.y > b.y - cc.kmEpsilon && a.z < b.z + cc.kmEpsilon && a.z > b.z - cc.kmEpsilon ? 1 : 0
}, cc.kmVec3InverseTransform = function(a, b, c) {
    return b = new cc.kmVec3(b.x - c.mat[12], b.y - c.mat[13], b.z - c.mat[14]), a.x = b.x * c.mat[0] + b.y * c.mat[1] + b.z * c.mat[2], a.y = b.x * c.mat[4] + b.y * c.mat[5] + b.z * c.mat[6], a.z = b.x * c.mat[8] + b.y * c.mat[9] + b.z * c.mat[10], a
}, cc.kmVec3InverseTransformNormal = function(a, b, c) {
    return a.x = b.x * c.mat[0] + b.y * c.mat[1] + b.z * c.mat[2], a.y = b.x * c.mat[4] + b.y * c.mat[5] + b.z * c.mat[6], a.z = b.x * c.mat[8] + b.y * c.mat[9] + b.z * c.mat[10], a
}, cc.kmVec3Assign = function(a, b) {
    return a == b ? a : (a.x = b.x, a.y = b.y, a.z = b.z, a)
}, cc.kmVec3Zero = function(a) {
    return a.x = 0, a.y = 0, a.z = 0, a
}, cc.kmVec3ToTypeArray = function(a) {
    if (!a) return null;
    var b = new Float32Array(3);
    return b[0] = a.x, b[1] = a.y, b[2] = a.z, b
}, cc.kmVec4 = function(a, b, c, d) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0, this.w = d || 0
}, cc.kmVec4Fill = function(a, b, c, d, e) {
    return a.x = b, a.y = c, a.z = d, a.w = e, a
}, cc.kmVec4Add = function(a, b, c) {
    return a.x = b.x + c.x, a.y = b.y + c.y, a.z = b.z + c.z, a.w = b.w + c.w, a
}, cc.kmVec4Dot = function(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
}, cc.kmVec4Length = function(a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z) + cc.kmSQR(a.w))
}, cc.kmVec4LengthSq = function(a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z) + cc.kmSQR(a.w)
}, cc.kmVec4Lerp = function(a) {
    return a
}, cc.kmVec4Normalize = function(a, b) {
    var c = 1 / cc.kmVec4Length(b);
    return a.x *= c, a.y *= c, a.z *= c, a.w *= c, a
}, cc.kmVec4Scale = function(a, b, c) {
    return cc.kmVec4Normalize(a, b), a.x *= c, a.y *= c, a.z *= c, a.w *= c, a
}, cc.kmVec4Subtract = function(a, b, c) {
    return a.x = b.x - c.x, a.y = b.y - c.y, a.z = b.z - c.z, a.w = b.w - c.w, a
}, cc.kmVec4Transform = function(a, b, c) {
    return a.x = b.x * c.mat[0] + b.y * c.mat[4] + b.z * c.mat[8] + b.w * c.mat[12], a.y = b.x * c.mat[1] + b.y * c.mat[5] + b.z * c.mat[9] + b.w * c.mat[13], a.z = b.x * c.mat[2] + b.y * c.mat[6] + b.z * c.mat[10] + b.w * c.mat[14], a.w = b.x * c.mat[3] + b.y * c.mat[7] + b.z * c.mat[11] + b.w * c.mat[15], a
}, cc.kmVec4TransformArray = function(a, b, c, d, e, f) {
    for (var g = 0; f > g;) cc.kmVec4Transform(a + g * b, c + g * d, e), ++g;
    return a
}, cc.kmVec4AreEqual = function(a, b) {
    return a.x < b.x + cc.kmEpsilon && a.x > b.x - cc.kmEpsilon && a.y < b.y + cc.kmEpsilon && a.y > b.y - cc.kmEpsilon && a.z < b.z + cc.kmEpsilon && a.z > b.z - cc.kmEpsilon && a.w < b.w + cc.kmEpsilon && a.w > b.w - cc.kmEpsilon
}, cc.kmVec4Assign = function(a, b) {
    return a == b ? (cc.log("destVec and srcVec are same object"), a) : (a.x = b.x, a.y = b.y, a.z = b.z, a.w = b.w, a)
}, cc.kmVec4ToTypeArray = function(a) {
    if (!a) return null;
    var b = new Float32Array(4);
    return b[0] = a.x, b[1] = a.y, b[2] = a.z, b[3] = a.w, b
}, cc.kmRay2 = function(a) {
    this.start = a || new cc.kmVec2, this.start = a || new cc.kmVec2
}, cc.kmRay2Fill = function(a, b, c, d, e) {
    a.start.x = b, a.start.y = c, a.dir.x = d, a.dir.y = e
}, cc.kmRay2IntersectLineSegment = function(a, b, c, d) {
    var e = a.start.x,
        f = a.start.y,
        g = a.start.x + a.dir.x;
    a = a.start.y + a.dir.y;
    var h = b.x,
        i = b.y,
        j = c.x,
        k = c.y,
        l = (k - i) * (g - e) - (j - h) * (a - f);
    return l > -cc.kmEpsilon && l < cc.kmEpsilon ? cc.KM_FALSE : (i = ((j - h) * (f - i) - (k - i) * (e - h)) / l, h = e + i * (g - e), i = f + i * (a - f), h < cc.kmMin(b.x, c.x) - cc.kmEpsilon || h > cc.kmMax(b.x, c.x) + cc.kmEpsilon || i < cc.kmMin(b.y, c.y) - cc.kmEpsilon || i > cc.kmMax(b.y, c.y) + cc.kmEpsilon || h < cc.kmMin(e, g) - cc.kmEpsilon || h > cc.kmMax(e, g) + cc.kmEpsilon || i < cc.kmMin(f, a) - cc.kmEpsilon || i > cc.kmMax(f, a) + cc.kmEpsilon ? cc.KM_FALSE : (d.x = h, d.y = i, cc.KM_TRUE))
}, cc.calculate_line_normal = function(a, b, c) {
    var d = new cc.kmVec2;
    cc.kmVec2Subtract(d, b, a), c.x = -d.y, c.y = d.x, cc.kmVec2Normalize(c, c)
}, cc.kmRay2IntersectTriangle = function(a, b, c, d, e, f) {
    var g, h = new cc.kmVec2,
        i = new cc.kmVec2,
        j = new cc.kmVec2,
        k = 1e4,
        l = cc.KM_FALSE;
    return cc.kmRay2IntersectLineSegment(a, b, c, h) && (g = new cc.kmVec2, l = cc.KM_TRUE, g = cc.kmVec2Length(cc.kmVec2Subtract(g, h, a.start)), k > g && (i.x = h.x, i.y = h.y, k = g, cc.calculate_line_normal(b, c, j))), cc.kmRay2IntersectLineSegment(a, c, d, h) && (g = new cc.kmVec2, l = cc.KM_TRUE, g = cc.kmVec2Length(cc.kmVec2Subtract(g, h, a.start)), k > g && (i.x = h.x, i.y = h.y, k = g, cc.calculate_line_normal(c, d, j))), cc.kmRay2IntersectLineSegment(a, d, b, h) && (g = new cc.kmVec2, l = cc.KM_TRUE, g = cc.kmVec2Length(cc.kmVec2Subtract(g, h, a.start)), k > g && (i.x = h.x, i.y = h.y, cc.calculate_line_normal(d, b, j))), l && (e.x = i.x, e.y = i.y, f && (f.x = j.x, f.y = j.y)), l
}, cc.kmRay2IntersectCircle = function() {
    cc.log("cc.kmRay2IntersectCircle() has not been implemented.")
};
var Float32Array = Float32Array || Array;
if (cc.kmMat3 = function() {
    this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0])
}, cc.kmMat3Fill = function(a, b) {
    for (var c = 0; 9 > c; c++) a.mat[c] = b;
    return a
}, cc.kmMat3Adjugate = function(a, b) {
    return a.mat[0] = b.mat[4] * b.mat[8] - b.mat[5] * b.mat[7], a.mat[1] = b.mat[2] * b.mat[7] - b.mat[1] * b.mat[8], a.mat[2] = b.mat[1] * b.mat[5] - b.mat[2] * b.mat[4], a.mat[3] = b.mat[5] * b.mat[6] - b.mat[3] * b.mat[8], a.mat[4] = b.mat[0] * b.mat[8] - b.mat[2] * b.mat[6], a.mat[5] = b.mat[2] * b.mat[3] - b.mat[0] * b.mat[5], a.mat[6] = b.mat[3] * b.mat[7] - b.mat[4] * b.mat[6], a.mat[8] = b.mat[0] * b.mat[4] - b.mat[1] * b.mat[3], a
}, cc.kmMat3Identity = function(a) {
    return a.mat[1] = a.mat[2] = a.mat[3] = a.mat[5] = a.mat[6] = a.mat[7] = 0, a.mat[0] = a.mat[4] = a.mat[8] = 1, a
}, cc.kmMat3Inverse = function(a, b, c) {
    var d = new cc.kmMat3;
    return 0 === b ? null : (b = 1 / b, cc.kmMat3Adjugate(d, c), cc.kmMat3ScalarMultiply(a, d, b), a)
}, cc.kmMat3._identity = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), cc.kmMat3IsIdentity = function(a) {
    for (var b = 0; 9 > b; b++)
        if (cc.kmMat3._identity[b] !== a.mat[b]) return !1;
    return !0
}, cc.kmMat3Transpose = function(a, b) {
    var c, d;
    for (c = 0; 3 > c; ++c)
        for (d = 0; 3 > d; ++d) a.mat[3 * c + d] = b.mat[3 * d + c];
    return a
}, cc.kmMat3Determinant = function(a) {
    var b;
    return b = a.mat[0] * a.mat[4] * a.mat[8] + a.mat[1] * a.mat[5] * a.mat[6] + a.mat[2] * a.mat[3] * a.mat[7], b -= a.mat[2] * a.mat[4] * a.mat[6] + a.mat[0] * a.mat[5] * a.mat[7] + a.mat[1] * a.mat[3] * a.mat[8]
}, cc.kmMat3Multiply = function(a, b, c) {
    return b = b.mat, c = c.mat, a.mat[0] = b[0] * c[0] + b[3] * c[1] + b[6] * c[2], a.mat[1] = b[1] * c[0] + b[4] * c[1] + b[7] * c[2], a.mat[2] = b[2] * c[0] + b[5] * c[1] + b[8] * c[2], a.mat[3] = b[0] * c[3] + b[3] * c[4] + b[6] * c[5], a.mat[4] = b[1] * c[3] + b[4] * c[4] + b[7] * c[5], a.mat[5] = b[2] * c[3] + b[5] * c[4] + b[8] * c[5], a.mat[6] = b[0] * c[6] + b[3] * c[7] + b[6] * c[8], a.mat[7] = b[1] * c[6] + b[4] * c[7] + b[7] * c[8], a.mat[8] = b[2] * c[6] + b[5] * c[7] + b[8] * c[8], a
}, cc.kmMat3ScalarMultiply = function(a, b, c) {
    for (var d = 0; 9 > d; d++) a.mat[d] = b.mat[d] * c;
    return a
}, cc.kmMat3RotationAxisAngle = function(a, b, c) {
    var d = Math.cos(c);
    return c = Math.sin(c), a.mat[0] = d + b.x * b.x * (1 - d), a.mat[1] = b.z * c + b.y * b.x * (1 - d), a.mat[2] = -b.y * c + b.z * b.x * (1 - d), a.mat[3] = -b.z * c + b.x * b.y * (1 - d), a.mat[4] = d + b.y * b.y * (1 - d), a.mat[5] = b.x * c + b.z * b.y * (1 - d), a.mat[6] = b.y * c + b.x * b.z * (1 - d), a.mat[7] = -b.x * c + b.y * b.z * (1 - d), a.mat[8] = d + b.z * b.z * (1 - d), a
}, cc.kmMat3Assign = function(a, b) {
    if (a == b) return cc.log("cc.kmMat3Assign(): pOut equals pIn"), a;
    for (var c = 0; 9 > c; c++) a.mat[c] = b.mat[c];
    return a
}, cc.kmMat3AreEqual = function(a, b) {
    if (a == b) return !0;
    for (var c = 0; 9 > c; ++c)
        if (!(a.mat[c] + cc.kmEpsilon > b.mat[c] && a.mat[c] - cc.kmEpsilon < b.mat[c])) return !1;
    return !0
}, cc.kmMat3RotationX = function(a, b) {
    return a.mat[0] = 1, a.mat[1] = 0, a.mat[2] = 0, a.mat[3] = 0, a.mat[4] = Math.cos(b), a.mat[5] = Math.sin(b), a.mat[6] = 0, a.mat[7] = -Math.sin(b), a.mat[8] = Math.cos(b), a
}, cc.kmMat3RotationY = function(a, b) {
    return a.mat[0] = Math.cos(b), a.mat[1] = 0, a.mat[2] = -Math.sin(b), a.mat[3] = 0, a.mat[4] = 1, a.mat[5] = 0, a.mat[6] = Math.sin(b), a.mat[7] = 0, a.mat[8] = Math.cos(b), a
}, cc.kmMat3RotationZ = function(a, b) {
    return a.mat[0] = Math.cos(b), a.mat[1] = -Math.sin(b), a.mat[2] = 0, a.mat[3] = Math.sin(b), a.mat[4] = Math.cos(b), a.mat[5] = 0, a.mat[6] = 0, a.mat[7] = 0, a.mat[8] = 1, a
}, cc.kmMat3Rotation = function(a, b) {
    return a.mat[0] = Math.cos(b), a.mat[1] = Math.sin(b), a.mat[2] = 0, a.mat[3] = -Math.sin(b), a.mat[4] = Math.cos(b), a.mat[5] = 0, a.mat[6] = 0, a.mat[7] = 0, a.mat[8] = 1, a
}, cc.kmMat3Scaling = function(a, b, c) {
    return cc.kmMat3Identity(a), a.mat[0] = b, a.mat[4] = c, a
}, cc.kmMat3Translation = function(a, b, c) {
    return cc.kmMat3Identity(a), a.mat[6] = b, a.mat[7] = c, a
}, cc.kmMat3RotationQuaternion = function(a, b) {
    return b && a ? (a.mat[0] = 1 - 2 * (b.y * b.y + b.z * b.z), a.mat[1] = 2 * (b.x * b.y - b.w * b.z), a.mat[2] = 2 * (b.x * b.z + b.w * b.y), a.mat[3] = 2 * (b.x * b.y + b.w * b.z), a.mat[4] = 1 - 2 * (b.x * b.x + b.z * b.z), a.mat[5] = 2 * (b.y * b.z - b.w * b.x), a.mat[6] = 2 * (b.x * b.z - b.w * b.y), a.mat[7] = 2 * (b.y * b.z + b.w * b.x), a.mat[8] = 1 - 2 * (b.x * b.x + b.y * b.y), a) : null
}, cc.kmMat3RotationToAxisAngle = function(a, b, c) {
    return cc.kmQuaternionRotationMatrix(void 0, c), cc.kmQuaternionToAxisAngle(void 0, a, b), a
}, cc.kmMat4 = function() {
    this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
}, cc.kmMat4Fill = function(a, b) {
    a.mat[0] = a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[5] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[10] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = a.mat[15] = b
}, cc.kmMat4Identity = function(a) {
    return a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = 0, a.mat[0] = a.mat[5] = a.mat[10] = a.mat[15] = 1, a
}, cc.kmMat4._get = function(a, b, c) {
    return a.mat[b + 4 * c]
}, cc.kmMat4._set = function(a, b, c, d) {
    a.mat[b + 4 * c] = d
}, cc.kmMat4._swap = function(a, b, c, d, e) {
    var f = cc.kmMat4._get(a, b, c);
    cc.kmMat4._set(a, b, c, cc.kmMat4._get(a, d, e)), cc.kmMat4._set(a, d, e, f)
}, cc.kmMat4._gaussj = function(a, b) {
    var c, d, e, f, g = 0,
        h = 0,
        i = [0, 0, 0, 0],
        j = [0, 0, 0, 0],
        k = [0, 0, 0, 0];
    for (c = 0; 4 > c; c++) {
        for (d = f = 0; 4 > d; d++)
            if (1 != k[d])
                for (e = 0; 4 > e; e++) 0 == k[e] && Math.abs(cc.kmMat4._get(a, d, e)) >= f && (f = Math.abs(cc.kmMat4._get(a, d, e)), h = d, g = e);
        if (++k[g], h != g) {
            for (d = 0; 4 > d; d++) cc.kmMat4._swap(a, h, d, g, d);
            for (d = 0; 4 > d; d++) cc.kmMat4._swap(b, h, d, g, d)
        }
        if (j[c] = h, i[c] = g, 0 == cc.kmMat4._get(a, g, g)) return cc.KM_FALSE;
        for (e = 1 / cc.kmMat4._get(a, g, g), cc.kmMat4._set(a, g, g, 1), d = 0; 4 > d; d++) cc.kmMat4._set(a, g, d, cc.kmMat4._get(a, g, d) * e);
        for (d = 0; 4 > d; d++) cc.kmMat4._set(b, g, d, cc.kmMat4._get(b, g, d) * e);
        for (e = 0; 4 > e; e++)
            if (e != g) {
                for (f = cc.kmMat4._get(a, e, g), cc.kmMat4._set(a, e, g, 0), d = 0; 4 > d; d++) cc.kmMat4._set(a, e, d, cc.kmMat4._get(a, e, d) - cc.kmMat4._get(a, g, d) * f);
                for (d = 0; 4 > d; d++) cc.kmMat4._set(b, e, d, cc.kmMat4._get(a, e, d) - cc.kmMat4._get(b, g, d) * f)
            }
    }
    for (d = 3; d >= 0; d--)
        if (j[d] != i[d])
            for (e = 0; 4 > e; e++) cc.kmMat4._swap(a, e, j[d], e, i[d]);
    return cc.KM_TRUE
}, cc.kmMat4._identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), cc.kmMat4Inverse = function(a, b) {
    var c = new cc.kmMat4,
        d = new cc.kmMat4;
    return cc.kmMat4Assign(c, b), cc.kmMat4Identity(d), cc.kmMat4._gaussj(c, d) == cc.KM_FALSE ? null : (cc.kmMat4Assign(a, c), a)
}, cc.kmMat4IsIdentity = function(a) {
    for (var b = 0; 16 > b; b++)
        if (cc.kmMat4._identity[b] != a.mat[b]) return !1;
    return !0
}, cc.kmMat4Transpose = function(a, b) {
    var c, d, e = a.mat,
        f = b.mat;
    for (d = 0; 4 > d; ++d)
        for (c = 0; 4 > c; ++c) e[4 * d + c] = f[4 * c + d];
    return a
}, cc.kmMat4Multiply = function(a, b, c) {
    var d = a.mat,
        e = b.mat[0],
        f = b.mat[1],
        g = b.mat[2],
        h = b.mat[3],
        i = b.mat[4],
        j = b.mat[5],
        k = b.mat[6],
        l = b.mat[7],
        m = b.mat[8],
        n = b.mat[9],
        o = b.mat[10],
        p = b.mat[11],
        q = b.mat[12],
        r = b.mat[13],
        s = b.mat[14];
    b = b.mat[15];
    var t = c.mat[0],
        u = c.mat[1],
        v = c.mat[2],
        w = c.mat[3],
        x = c.mat[4],
        y = c.mat[5],
        z = c.mat[6],
        A = c.mat[7],
        B = c.mat[8],
        C = c.mat[9],
        D = c.mat[10],
        E = c.mat[11],
        F = c.mat[12],
        G = c.mat[13],
        H = c.mat[14];
    return c = c.mat[15], d[0] = t * e + u * i + v * m + w * q, d[1] = t * f + u * j + v * n + w * r, d[2] = t * g + u * k + v * o + w * s, d[3] = t * h + u * l + v * p + w * b, d[4] = x * e + y * i + z * m + A * q, d[5] = x * f + y * j + z * n + A * r, d[6] = x * g + y * k + z * o + A * s, d[7] = x * h + y * l + z * p + A * b, d[8] = B * e + C * i + D * m + E * q, d[9] = B * f + C * j + D * n + E * r, d[10] = B * g + C * k + D * o + E * s, d[11] = B * h + C * l + D * p + E * b, d[12] = F * e + G * i + H * m + c * q, d[13] = F * f + G * j + H * n + c * r, d[14] = F * g + G * k + H * o + c * s, d[15] = F * h + G * l + H * p + c * b, a
}, cc.getMat4MultiplyValue = function(a, b) {
    var c = a.mat,
        d = b.mat,
        e = new Float32Array(16);
    return e[0] = c[0] * d[0] + c[4] * d[1] + c[8] * d[2] + c[12] * d[3], e[1] = c[1] * d[0] + c[5] * d[1] + c[9] * d[2] + c[13] * d[3], e[2] = c[2] * d[0] + c[6] * d[1] + c[10] * d[2] + c[14] * d[3], e[3] = c[3] * d[0] + c[7] * d[1] + c[11] * d[2] + c[15] * d[3], e[4] = c[0] * d[4] + c[4] * d[5] + c[8] * d[6] + c[12] * d[7], e[5] = c[1] * d[4] + c[5] * d[5] + c[9] * d[6] + c[13] * d[7], e[6] = c[2] * d[4] + c[6] * d[5] + c[10] * d[6] + c[14] * d[7], e[7] = c[3] * d[4] + c[7] * d[5] + c[11] * d[6] + c[15] * d[7], e[8] = c[0] * d[8] + c[4] * d[9] + c[8] * d[10] + c[12] * d[11], e[9] = c[1] * d[8] + c[5] * d[9] + c[9] * d[10] + c[13] * d[11], e[10] = c[2] * d[8] + c[6] * d[9] + c[10] * d[10] + c[14] * d[11], e[11] = c[3] * d[8] + c[7] * d[9] + c[11] * d[10] + c[15] * d[11], e[12] = c[0] * d[12] + c[4] * d[13] + c[8] * d[14] + c[12] * d[15], e[13] = c[1] * d[12] + c[5] * d[13] + c[9] * d[14] + c[13] * d[15], e[14] = c[2] * d[12] + c[6] * d[13] + c[10] * d[14] + c[14] * d[15], e[15] = c[3] * d[12] + c[7] * d[13] + c[11] * d[14] + c[15] * d[15], e
}, cc.getMat4MultiplyWithMat4 = function(a, b, c) {
    a = a.mat, b = b.mat;
    var d = c.mat;
    return d[0] = a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], d[1] = a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], d[2] = a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], d[3] = a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], d[4] = a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], d[5] = a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], d[6] = a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], d[7] = a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], d[8] = a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], d[9] = a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], d[10] = a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], d[11] = a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], d[12] = a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], d[13] = a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], d[14] = a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], d[15] = a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15], c.mat
}, cc.kmMat4Assign = function(a, b) {
    if (a == b) return cc.log("cc.kmMat4Assign(): pOut equals pIn"), a;
    var c = a.mat,
        d = b.mat;
    return c[0] = d[0], c[1] = d[1], c[2] = d[2], c[3] = d[3], c[4] = d[4], c[5] = d[5], c[6] = d[6], c[7] = d[7], c[8] = d[8], c[9] = d[9], c[10] = d[10], c[11] = d[11], c[12] = d[12], c[13] = d[13], c[14] = d[14], c[15] = d[15], a

}, cc.kmMat4AreEqual = function(a, b) {
    if (a == b) return cc.log("cc.kmMat4AreEqual(): pMat1 and pMat2 are same object."), !0;
    for (var c = 0; 16 > c; c++)
        if (!(a.mat[c] + cc.kmEpsilon > b.mat[c] && a.mat[c] - cc.kmEpsilon < b.mat[c])) return !1;
    return !0
}, cc.kmMat4RotationX = function(a, b) {
    return a.mat[0] = 1, a.mat[1] = 0, a.mat[2] = 0, a.mat[3] = 0, a.mat[4] = 0, a.mat[5] = Math.cos(b), a.mat[6] = Math.sin(b), a.mat[7] = 0, a.mat[8] = 0, a.mat[9] = -Math.sin(b), a.mat[10] = Math.cos(b), a.mat[11] = 0, a.mat[12] = 0, a.mat[13] = 0, a.mat[14] = 0, a.mat[15] = 1, a
}, cc.kmMat4RotationY = function(a, b) {
    return a.mat[0] = Math.cos(b), a.mat[1] = 0, a.mat[2] = -Math.sin(b), a.mat[3] = 0, a.mat[4] = 0, a.mat[5] = 1, a.mat[6] = 0, a.mat[7] = 0, a.mat[8] = Math.sin(b), a.mat[9] = 0, a.mat[10] = Math.cos(b), a.mat[11] = 0, a.mat[12] = 0, a.mat[13] = 0, a.mat[14] = 0, a.mat[15] = 1, a
}, cc.kmMat4RotationZ = function(a, b) {
    return a.mat[0] = Math.cos(b), a.mat[1] = Math.sin(b), a.mat[2] = 0, a.mat[3] = 0, a.mat[4] = -Math.sin(b), a.mat[5] = Math.cos(b), a.mat[6] = 0, a.mat[7] = 0, a.mat[8] = 0, a.mat[9] = 0, a.mat[10] = 1, a.mat[11] = 0, a.mat[12] = 0, a.mat[13] = 0, a.mat[14] = 0, a.mat[15] = 1, a
}, cc.kmMat4RotationPitchYawRoll = function(a, b, c, d) {
    var e = Math.cos(b);
    b = Math.sin(b);
    var f = Math.cos(c);
    c = Math.sin(c);
    var g = Math.cos(d);
    d = Math.sin(d);
    var h = b * c,
        i = e * c;
    return a.mat[0] = f * g, a.mat[4] = f * d, a.mat[8] = -c, a.mat[1] = h * g - e * d, a.mat[5] = h * d + e * g, a.mat[9] = b * f, a.mat[2] = i * g + b * d, a.mat[6] = i * d - b * g, a.mat[10] = e * f, a.mat[3] = a.mat[7] = a.mat[11] = 0, a.mat[15] = 1, a
}, cc.kmMat4RotationQuaternion = function(a, b) {
    return a.mat[0] = 1 - 2 * (b.y * b.y + b.z * b.z), a.mat[1] = 2 * (b.x * b.y + b.z * b.w), a.mat[2] = 2 * (b.x * b.z - b.y * b.w), a.mat[3] = 0, a.mat[4] = 2 * (b.x * b.y - b.z * b.w), a.mat[5] = 1 - 2 * (b.x * b.x + b.z * b.z), a.mat[6] = 2 * (b.z * b.y + b.x * b.w), a.mat[7] = 0, a.mat[8] = 2 * (b.x * b.z + b.y * b.w), a.mat[9] = 2 * (b.y * b.z - b.x * b.w), a.mat[10] = 1 - 2 * (b.x * b.x + b.y * b.y), a.mat[11] = 0, a.mat[12] = 0, a.mat[13] = 0, a.mat[14] = 0, a.mat[15] = 1, a
}, cc.kmMat4RotationTranslation = function(a, b, c) {
    return a.mat[0] = b.mat[0], a.mat[1] = b.mat[1], a.mat[2] = b.mat[2], a.mat[3] = 0, a.mat[4] = b.mat[3], a.mat[5] = b.mat[4], a.mat[6] = b.mat[5], a.mat[7] = 0, a.mat[8] = b.mat[6], a.mat[9] = b.mat[7], a.mat[10] = b.mat[8], a.mat[11] = 0, a.mat[12] = c.x, a.mat[13] = c.y, a.mat[14] = c.z, a.mat[15] = 1, a
}, cc.kmMat4Scaling = function(a, b, c, d) {
    return a.mat[0] = b, a.mat[5] = c, a.mat[10] = d, a.mat[15] = 1, a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = 0, a
}, cc.kmMat4Translation = function(a, b, c, d) {
    return a.mat[0] = a.mat[5] = a.mat[10] = a.mat[15] = 1, a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = 0, a.mat[12] = b, a.mat[13] = c, a.mat[14] = d, a
}, cc.kmMat4GetUpVec3 = function(a, b) {
    return a.x = b.mat[4], a.y = b.mat[5], a.z = b.mat[6], cc.kmVec3Normalize(a, a), a
}, cc.kmMat4GetRightVec3 = function(a, b) {
    return a.x = b.mat[0], a.y = b.mat[1], a.z = b.mat[2], cc.kmVec3Normalize(a, a), a
}, cc.kmMat4GetForwardVec3 = function(a, b) {
    return a.x = b.mat[8], a.y = b.mat[9], a.z = b.mat[10], cc.kmVec3Normalize(a, a), a
}, cc.kmMat4PerspectiveProjection = function(a, b, c, d, e) {
    var f = cc.kmDegreesToRadians(b / 2);
    b = e - d;
    var g = Math.sin(f);
    return 0 == b || 0 == g || 0 == c ? null : (f = Math.cos(f) / g, cc.kmMat4Identity(a), a.mat[0] = f / c, a.mat[5] = f, a.mat[10] = -(e + d) / b, a.mat[11] = -1, a.mat[14] = -2 * d * e / b, a.mat[15] = 0, a)
}, cc.kmMat4OrthographicProjection = function(a, b, c, d, e, f, g) {
    return cc.kmMat4Identity(a), a.mat[0] = 2 / (c - b), a.mat[5] = 2 / (e - d), a.mat[10] = -2 / (g - f), a.mat[12] = -((c + b) / (c - b)), a.mat[13] = -((e + d) / (e - d)), a.mat[14] = -((g + f) / (g - f)), a
}, cc.kmMat4LookAt = function(a, b, c, d) {
    var e = new cc.kmVec3,
        f = new cc.kmVec3,
        g = new cc.kmVec3,
        h = new cc.kmVec3,
        i = new cc.kmMat4;
    return cc.kmVec3Subtract(e, c, b), cc.kmVec3Normalize(e, e), cc.kmVec3Assign(f, d), cc.kmVec3Normalize(f, f), cc.kmVec3Cross(g, e, f), cc.kmVec3Normalize(g, g), cc.kmVec3Cross(h, g, e), cc.kmVec3Normalize(g, g), cc.kmMat4Identity(a), a.mat[0] = g.x, a.mat[4] = g.y, a.mat[8] = g.z, a.mat[1] = h.x, a.mat[5] = h.y, a.mat[9] = h.z, a.mat[2] = -e.x, a.mat[6] = -e.y, a.mat[10] = -e.z, cc.kmMat4Translation(i, -b.x, -b.y, -b.z), cc.kmMat4Multiply(a, a, i), a
}, cc.kmMat4RotationAxisAngle = function(a, b, c) {
    var d = Math.cos(c);
    c = Math.sin(c);
    var e = new cc.kmVec3;
    return cc.kmVec3Normalize(e, b), a.mat[0] = d + e.x * e.x * (1 - d), a.mat[1] = e.z * c + e.y * e.x * (1 - d), a.mat[2] = -e.y * c + e.z * e.x * (1 - d), a.mat[3] = 0, a.mat[4] = -e.z * c + e.x * e.y * (1 - d), a.mat[5] = d + e.y * e.y * (1 - d), a.mat[6] = e.x * c + e.z * e.y * (1 - d), a.mat[7] = 0, a.mat[8] = e.y * c + e.x * e.z * (1 - d), a.mat[9] = -e.x * c + e.y * e.z * (1 - d), a.mat[10] = d + e.z * e.z * (1 - d), a.mat[11] = 0, a.mat[12] = 0, a.mat[13] = 0, a.mat[14] = 0, a.mat[15] = 1, a
}, cc.kmMat4ExtractRotation = function(a, b) {
    return a.mat[0] = b.mat[0], a.mat[1] = b.mat[1], a.mat[2] = b.mat[2], a.mat[3] = b.mat[4], a.mat[4] = b.mat[5], a.mat[5] = b.mat[6], a.mat[6] = b.mat[8], a.mat[7] = b.mat[9], a.mat[8] = b.mat[10], a
}, cc.kmMat4ExtractPlane = function(a, b, c) {
    switch (c) {
        case cc.KM_PLANE_RIGHT:
            a.a = b.mat[3] - b.mat[0], a.b = b.mat[7] - b.mat[4], a.c = b.mat[11] - b.mat[8], a.d = b.mat[15] - b.mat[12];
            break;
        case cc.KM_PLANE_LEFT:
            a.a = b.mat[3] + b.mat[0], a.b = b.mat[7] + b.mat[4], a.c = b.mat[11] + b.mat[8], a.d = b.mat[15] + b.mat[12];
            break;
        case cc.KM_PLANE_BOTTOM:
            a.a = b.mat[3] + b.mat[1], a.b = b.mat[7] + b.mat[5], a.c = b.mat[11] + b.mat[9], a.d = b.mat[15] + b.mat[13];
            break;
        case cc.KM_PLANE_TOP:
            a.a = b.mat[3] - b.mat[1], a.b = b.mat[7] - b.mat[5], a.c = b.mat[11] - b.mat[9], a.d = b.mat[15] - b.mat[13];
            break;
        case cc.KM_PLANE_FAR:
            a.a = b.mat[3] - b.mat[2], a.b = b.mat[7] - b.mat[6], a.c = b.mat[11] - b.mat[10], a.d = b.mat[15] - b.mat[14];
            break;
        case cc.KM_PLANE_NEAR:
            a.a = b.mat[3] + b.mat[2], a.b = b.mat[7] + b.mat[6], a.c = b.mat[11] + b.mat[10], a.d = b.mat[15] + b.mat[14];
            break;
        default:
            cc.log("cc.kmMat4ExtractPlane(): Invalid plane index")
    }
    return b = Math.sqrt(a.a * a.a + a.b * a.b + a.c * a.c), a.a /= b, a.b /= b, a.c /= b, a.d /= b, a
}, cc.kmMat4RotationToAxisAngle = function(a, b, c) {
    var d = new cc.kmQuaternion,
        e = new cc.kmMat3;
    return cc.kmMat4ExtractRotation(e, c), cc.kmQuaternionRotationMatrix(d, e), cc.kmQuaternionToAxisAngle(d, a, b), a
}, cc.KM_PLANE_LEFT = 0, cc.KM_PLANE_RIGHT = 1, cc.KM_PLANE_BOTTOM = 2, cc.KM_PLANE_TOP = 3, cc.KM_PLANE_NEAR = 4, cc.KM_PLANE_FAR = 5, cc.kmPlane = function(a, b, c, d) {
    this.a = a || 0, this.b = b || 0, this.c = c || 0, this.d = d || 0
}, cc.POINT_INFRONT_OF_PLANE = 0, cc.POINT_BEHIND_PLANE = 1, cc.POINT_ON_PLANE = 2, cc.kmPlaneDot = function(a, b) {
    return a.a * b.x + a.b * b.y + a.c * b.z + a.d * b.w
}, cc.kmPlaneDotCoord = function(a, b) {
    return a.a * b.x + a.b * b.y + a.c * b.z + a.d
}, cc.kmPlaneDotNormal = function(a, b) {
    return a.a * b.x + a.b * b.y + a.c * b.z
}, cc.kmPlaneFromPointNormal = function(a, b, c) {
    return a.a = c.x, a.b = c.y, a.c = c.z, a.d = -cc.kmVec3Dot(c, b), a
}, cc.kmPlaneFromPoints = function(a, b, c, d) {
    var e = new cc.kmVec3,
        f = new cc.kmVec3,
        g = new cc.kmVec3;
    return cc.kmVec3Subtract(f, c, b), cc.kmVec3Subtract(g, d, b), cc.kmVec3Cross(e, f, g), cc.kmVec3Normalize(e, e), a.a = e.x, a.b = e.y, a.c = e.z, a.d = cc.kmVec3Dot(cc.kmVec3Scale(e, e, -1), b), a
}, cc.kmPlaneIntersectLine = function() {
    throw "cc.kmPlaneIntersectLine() hasn't been implemented."
}, cc.kmPlaneNormalize = function(a, b) {
    var c = new cc.kmVec3;
    c.x = b.a, c.y = b.b, c.z = b.c;
    var d = 1 / cc.kmVec3Length(c);
    return cc.kmVec3Normalize(c, c), a.a = c.x, a.b = c.y, a.c = c.z, a.d = b.d * d, a
}, cc.kmPlaneScale = function() {
    cc.log("cc.kmPlaneScale() has not been implemented.")
}, cc.kmPlaneClassifyPoint = function(a, b) {
    var c = a.a * b.x + a.b * b.y + a.c * b.z + a.d;
    return c > .001 ? cc.POINT_INFRONT_OF_PLANE : -.001 > c ? cc.POINT_BEHIND_PLANE : cc.POINT_ON_PLANE
}, cc.kmQuaternion = function(a, b, c, d) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0, this.w = d || 0
}, cc.kmQuaternionConjugate = function(a, b) {
    return a.x = -b.x, a.y = -b.y, a.z = -b.z, a.w = b.w, a
}, cc.kmQuaternionDot = function(a, b) {
    return a.w * b.w + a.x * b.x + a.y * b.y + a.z * b.z
}, cc.kmQuaternionExp = function(a) {
    return a
}, cc.kmQuaternionIdentity = function(a) {
    return a.x = 0, a.y = 0, a.z = 0, a.w = 1, a
}, cc.kmQuaternionInverse = function(a, b) {
    var c = cc.kmQuaternionLength(b),
        d = new cc.kmQuaternion;
    return Math.abs(c) > cc.kmEpsilon ? (a.x = 0, a.y = 0, a.z = 0, a.w = 0, a) : (cc.kmQuaternionScale(a, cc.kmQuaternionConjugate(d, b), 1 / c), a)
}, cc.kmQuaternionIsIdentity = function(a) {
    return 0 == a.x && 0 == a.y && 0 == a.z && 1 == a.w
}, cc.kmQuaternionLength = function(a) {
    return Math.sqrt(cc.kmQuaternionLengthSq(a))
}, cc.kmQuaternionLengthSq = function(a) {
    return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w
}, cc.kmQuaternionLn = function(a) {
    return a
}, cc.kmQuaternionMultiply = function(a, b, c) {
    return a.w = b.w * c.w - b.x * c.x - b.y * c.y - b.z * c.z, a.x = b.w * c.x + b.x * c.w + b.y * c.z - b.z * c.y, a.y = b.w * c.y + b.y * c.w + b.z * c.x - b.x * c.z, a.z = b.w * c.z + b.z * c.w + b.x * c.y - b.y * c.x, a
}, cc.kmQuaternionNormalize = function(a, b) {
    var c = cc.kmQuaternionLength(b);
    if (Math.abs(c) <= cc.kmEpsilon) throw "cc.kmQuaternionNormalize(): pIn is an invalid value";
    return cc.kmQuaternionScale(a, b, 1 / c), a
}, cc.kmQuaternionRotationAxis = function(a, b, c) {
    c *= .5;
    var d = Math.sin(c);
    return a.w = Math.cos(c), a.x = b.x * d, a.y = b.y * d, a.z = b.z * d, a
}, cc.kmQuaternionRotationMatrix = function(a, b) {
    var c, d, e, f;
    if (c = [], d = f = 0, !b) return null;
    c[0] = b.mat[0], c[1] = b.mat[3], c[2] = b.mat[6], c[4] = b.mat[1], c[5] = b.mat[4], c[6] = b.mat[7], c[8] = b.mat[2], c[9] = b.mat[5], c[10] = b.mat[8], c[15] = 1;
    var g = c[0];
    return d = g[0] + g[5] + g[10] + 1, d > cc.kmEpsilon ? (f = 2 * Math.sqrt(d), c = (g[9] - g[6]) / f, d = (g[2] - g[8]) / f, e = (g[4] - g[1]) / f, f *= .25) : g[0] > g[5] && g[0] > g[10] ? (f = 2 * Math.sqrt(1 + g[0] - g[5] - g[10]), c = .25 * f, d = (g[4] + g[1]) / f, e = (g[2] + g[8]) / f, f = (g[9] - g[6]) / f) : g[5] > g[10] ? (f = 2 * Math.sqrt(1 + g[5] - g[0] - g[10]), c = (g[4] + g[1]) / f, d = .25 * f, e = (g[9] + g[6]) / f, f = (g[2] - g[8]) / f) : (f = 2 * Math.sqrt(1 + g[10] - g[0] - g[5]), c = (g[2] + g[8]) / f, d = (g[9] + g[6]) / f, e = .25 * f, f = (g[4] - g[1]) / f), a.x = c, a.y = d, a.z = e, a.w = f, a
}, cc.kmQuaternionRotationYawPitchRoll = function(a, b, c, d) {
    var e, f, g, h, i;
    return e = cc.kmDegreesToRadians(c) / 2, f = cc.kmDegreesToRadians(b) / 2, g = cc.kmDegreesToRadians(d) / 2, d = Math.cos(e), b = Math.cos(f), c = Math.cos(g), e = Math.sin(e), f = Math.sin(f), g = Math.sin(g), h = b * c, i = f * g, a.w = d * h + e * i, a.x = e * h - d * i, a.y = d * f * c + e * b * g, a.z = d * b * g - e * f * c, cc.kmQuaternionNormalize(a, a), a
}, cc.kmQuaternionSlerp = function(a, b, c, d) {
    if (b.x == c.x && b.y == c.y && b.z == c.z && b.w == c.w) return a.x = b.x, a.y = b.y, a.z = b.z, a.w = b.w, a;
    var e = cc.kmQuaternionDot(b, c),
        f = Math.acos(e),
        g = Math.sqrt(1 - cc.kmSQR(e)),
        e = Math.sin(d * f) / g;
    return d = Math.sin((1 - d) * f) / g, f = new cc.kmQuaternion, g = new cc.kmQuaternion, cc.kmQuaternionScale(f, b, d), cc.kmQuaternionScale(g, c, e), cc.kmQuaternionAdd(a, f, g), a
}, cc.kmQuaternionToAxisAngle = function(a, b, c) {
    Math.acos(a.w), c = Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z)), c > -cc.kmEpsilon && c < cc.kmEpsilon || c < 2 * cc.kmPI + cc.kmEpsilon && c > 2 * cc.kmPI - cc.kmEpsilon ? (b.x = 0, b.y = 0, b.z = 1) : (b.x = a.x / c, b.y = a.y / c, b.z = a.z / c, cc.kmVec3Normalize(b, b))
}, cc.kmQuaternionScale = function(a, b, c) {
    return a.x = b.x * c, a.y = b.y * c, a.z = b.z * c, a.w = b.w * c, a
}, cc.kmQuaternionAssign = function(a, b) {
    return a.x = b.x, a.y = b.y, a.z = b.z, a.w = b.w, a
}, cc.kmQuaternionAdd = function(a, b, c) {
    return a.x = b.x + c.x, a.y = b.y + c.y, a.z = b.z + c.z, a.w = b.w + c.w, a
}, cc.kmQuaternionRotationBetweenVec3 = function(a, b, c, d) {
    var e = new cc.kmVec3,
        f = new cc.kmVec3;
    return cc.kmVec3Assign(e, b), cc.kmVec3Assign(f, c), cc.kmVec3Normalize(e, e), cc.kmVec3Normalize(f, f), c = cc.kmVec3Dot(e, f), c >= 1 ? (cc.kmQuaternionIdentity(a), a) : (-.999999 > c ? Math.abs(cc.kmVec3LengthSq(d)) < cc.kmEpsilon ? cc.kmQuaternionRotationAxis(a, d, cc.kmPI) : (e = new cc.kmVec3, f = new cc.kmVec3, f.x = 1, f.y = 0, f.z = 0, cc.kmVec3Cross(e, f, b), Math.abs(cc.kmVec3LengthSq(e)) < cc.kmEpsilon && (f = new cc.kmVec3, f.x = 0, f.y = 1, f.z = 0, cc.kmVec3Cross(e, f, b)), cc.kmVec3Normalize(e, e), cc.kmQuaternionRotationAxis(a, e, cc.kmPI)) : (b = Math.sqrt(2 * (1 + c)), d = 1 / b, c = new cc.kmVec3, cc.kmVec3Cross(c, e, f), a.x = c.x * d, a.y = c.y * d, a.z = c.z * d, a.w = .5 * b, cc.kmQuaternionNormalize(a, a)), a)
}, cc.kmQuaternionMultiplyVec3 = function(a, b, c) {
    var d = new cc.kmVec3,
        e = new cc.kmVec3,
        f = new cc.kmVec3;
    return f.x = b.x, f.y = b.y, f.z = b.z, cc.kmVec3Cross(d, f, c), cc.kmVec3Cross(e, f, d), cc.kmVec3Scale(d, d, 2 * b.w), cc.kmVec3Scale(e, e, 2), cc.kmVec3Add(a, c, d), cc.kmVec3Add(a, a, e), a
}, cc.kmAABB = function(a, b) {
    this.min = a || new cc.kmVec3, this.max = b || new cc.kmVec3
}, cc.kmAABBContainsPoint = function(a, b) {
    return a.x >= b.min.x && a.x <= b.max.x && a.y >= b.min.y && a.y <= b.max.y && a.z >= b.min.z && a.z <= b.max.z ? cc.KM_TRUE : cc.KM_FALSE
}, cc.kmAABBAssign = function(a, b) {
    return cc.kmVec3Assign(a.min, b.min), cc.kmVec3Assign(a.max, b.max), a
}, cc.kmAABBScale = function() {
    cc.log("cc.kmAABBScale hasn't been supported.")
}, cc.km_mat4_stack = function(a, b, c, d) {
    this.top = c, this.stack = d
}, cc.km_mat4_stack.INITIAL_SIZE = 30, cc.km_mat4_stack_initialize = function(a) {
    a.stack = [], a.top = null
}, cc.km_mat4_stack_push = function(a, b) {
    a.stack.push(a.top), a.top = new cc.kmMat4, cc.kmMat4Assign(a.top, b)
}, cc.km_mat4_stack_pop = function(a) {
    a.top = a.stack.pop()
}, cc.km_mat4_stack_release = function(a) {
    a.stack = null, a.top = null
}, cc.KM_GL_MODELVIEW = 5888, cc.KM_GL_PROJECTION = 5889, cc.KM_GL_TEXTURE = 5890, cc.modelview_matrix_stack = new cc.km_mat4_stack, cc.projection_matrix_stack = new cc.km_mat4_stack, cc.texture_matrix_stack = new cc.km_mat4_stack, cc.current_stack = null, cc.initialized = !1, cc.lazyInitialize = function() {
    if (!cc.initialized) {
        var a = new cc.kmMat4;
        cc.km_mat4_stack_initialize(cc.modelview_matrix_stack), cc.km_mat4_stack_initialize(cc.projection_matrix_stack), cc.km_mat4_stack_initialize(cc.texture_matrix_stack), cc.current_stack = cc.modelview_matrix_stack, cc.initialized = !0, cc.kmMat4Identity(a), cc.km_mat4_stack_push(cc.modelview_matrix_stack, a), cc.km_mat4_stack_push(cc.projection_matrix_stack, a), cc.km_mat4_stack_push(cc.texture_matrix_stack, a)
    }
}, cc.lazyInitialize(), cc.kmGLFreeAll = function() {
    cc.km_mat4_stack_release(cc.modelview_matrix_stack), cc.km_mat4_stack_release(cc.projection_matrix_stack), cc.km_mat4_stack_release(cc.texture_matrix_stack), cc.initialized = !1, cc.current_stack = null
}, cc.kmGLPushMatrix = function() {
    cc.km_mat4_stack_push(cc.current_stack, cc.current_stack.top)
}, cc.kmGLPushMatrixWitMat4 = function(a) {
    cc.current_stack.stack.push(cc.current_stack.top), cc.kmMat4Assign(a, cc.current_stack.top), cc.current_stack.top = a
}, cc.kmGLPopMatrix = function() {
    cc.current_stack.top = cc.current_stack.stack.pop()
}, cc.kmGLMatrixMode = function(a) {
    switch (a) {
        case cc.KM_GL_MODELVIEW:
            cc.current_stack = cc.modelview_matrix_stack;
            break;
        case cc.KM_GL_PROJECTION:
            cc.current_stack = cc.projection_matrix_stack;
            break;
        case cc.KM_GL_TEXTURE:
            cc.current_stack = cc.texture_matrix_stack;
            break;
        default:
            throw "Invalid matrix mode specified"
    }
}, cc.kmGLLoadIdentity = function() {
    cc.kmMat4Identity(cc.current_stack.top)
}, cc.kmGLLoadMatrix = function(a) {
    cc.kmMat4Assign(cc.current_stack.top, a)
}, cc.kmGLMultMatrix = function(a) {
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, a)
}, cc.kmGLTranslatef = function(a, b, c) {
    var d = new cc.kmMat4;
    cc.kmMat4Translation(d, a, b, c), cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, d)
}, cc.kmGLRotatef = function(a, b, c, d) {
    b = new cc.kmVec3(b, c, d), c = new cc.kmMat4, cc.kmMat4RotationAxisAngle(c, b, cc.kmDegreesToRadians(a)), cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, c)
}, cc.kmGLScalef = function(a, b, c) {
    var d = new cc.kmMat4;
    cc.kmMat4Scaling(d, a, b, c), cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, d)
}, cc.kmGLGetMatrix = function(a, b) {
    switch (a) {
        case cc.KM_GL_MODELVIEW:
            cc.kmMat4Assign(b, cc.modelview_matrix_stack.top);
            break;
        case cc.KM_GL_PROJECTION:
            cc.kmMat4Assign(b, cc.projection_matrix_stack.top);
            break;
        case cc.KM_GL_TEXTURE:
            cc.kmMat4Assign(b, cc.texture_matrix_stack.top);
            break;
        default:
            throw "Invalid matrix mode specified"
    }
}, cc.SHADER_POSITION_UCOLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()                              \n{ \n    gl_FragColor = v_fragmentColor;      \n}\n", cc.SHADER_POSITION_UCOLOR_VERT = "attribute vec4 a_position;\nuniform    vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor; \nvoid main(void)   \n{\n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    gl_PointSize = u_pointSize;          \n    v_fragmentColor = u_color;           \n}", cc.SHADER_POSITION_COLOR_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvoid main() \n{ \n     gl_FragColor = v_fragmentColor; \n} ", cc.SHADER_POSITION_COLOR_VERT = "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color;             \n}", cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "// #extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()	\n{ \n// #if defined GL_OES_standard_derivatives	\n// gl_FragColor = v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n// #else	\ngl_FragColor = v_color * step(0.0, 1.0 - length(v_texcoord)); \n// #endif \n}", cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "attribute mediump vec4 a_position; \nattribute mediump vec2 a_texcoord; \nattribute mediump vec4 a_color;	\nvarying mediump vec4 v_color; \nvarying mediump vec2 v_texcoord;	\nvoid main() \n{ \n     v_color = a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n     v_texcoord = a_texcoord; \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n}", cc.SHADER_POSITION_TEXTURE_FRAG = "precision lowp float;   \nvarying vec2 v_texCoord;  \nuniform sampler2D CC_Texture0; \nvoid main() \n{  \n    gl_FragColor =  texture2D(CC_Texture0, v_texCoord);   \n}", cc.SHADER_POSITION_TEXTURE_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord = a_texCoord;               \n}", cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "precision lowp float;  \nuniform vec4 u_color; \nvarying vec2 v_texCoord; \nuniform sampler2D CC_Texture0;  \nvoid main() \n{  \n    gl_FragColor =  texture2D(CC_Texture0, v_texCoord) * u_color;    \n}", cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "attribute vec4 a_position;\nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord = a_texCoord;                 \n}", cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "precision lowp float;  \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D CC_Texture0; \nvoid main() \n{ \n    gl_FragColor = vec4( v_fragmentColor.rgb,         \n        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n    ); \n}", cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color; \n    v_texCoord = a_texCoord; \n}", cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D CC_Texture0; \nvoid main() \n{ \n    gl_FragColor = v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n}", cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color; \n    v_texCoord = a_texCoord; \n}", cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "precision lowp float;   \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord;   \nuniform sampler2D CC_Texture0; \nuniform float CC_alpha_value; \nvoid main() \n{  \n    vec4 texColor = texture2D(CC_Texture0, v_texCoord);  \n    // mimic: glAlphaFunc(GL_GREATER)           \n    //pass if ( incoming_pixel >= CC_alpha_value ) => fail if incoming_pixel < CC_alpha_value   \n    if ( texColor.a <= CC_alpha_value )          \n        discard; \n    gl_FragColor = texColor * v_fragmentColor;  \n}", cc.SHADEREX_SWITCHMASK_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D u_texture;  \nuniform sampler2D   u_mask;   \nvoid main()  \n{  \n    vec4 texColor   = texture2D(u_texture, v_texCoord);  \n    vec4 maskColor  = texture2D(u_mask, v_texCoord); \n    vec4 finalColor = vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n    gl_FragColor    = v_fragmentColor * finalColor; \n}", cc.shaderCache = {
    TYPE_POSITION_TEXTURECOLOR: 0,
    TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
    TYPE_POSITION_COLOR: 2,
    TYPE_POSITION_TEXTURE: 3,
    TYPE_POSITION_TEXTURE_UCOLOR: 4,
    TYPE_POSITION_TEXTURE_A8COLOR: 5,
    TYPE_POSITION_UCOLOR: 6,
    TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
    TYPE_MAX: 8,
    _programs: {},
    _init: function() {
        return this.loadDefaultShaders(), !0
    },
    _loadDefaultShader: function(a, b) {
        switch (b) {
            case this.TYPE_POSITION_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG), a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR), a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG), a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR), a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG), a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            case this.TYPE_POSITION_TEXTURE:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG), a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURE_UCOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG), a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURE_A8COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT, cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG), a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR), a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_UCOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG), a.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
                break;
            case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT, cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG), a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS), a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            default:
                return void cc.log("cocos2d: cc.shaderCache._loadDefaultShader, error shader type")
        }
        a.link(), a.updateUniforms()
    },
    loadDefaultShaders: function() {
        var a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR), this._programs[cc.SHADER_POSITION_TEXTURECOLOR] = a, this._programs.ShaderPositionTextureColor = a, a = new cc.GLProgram, this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST), this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = a, this._programs.ShaderPositionTextureColorAlphaTest = a, a = new cc.GLProgram, this._loadDefaultShader(a, this.TYPE_POSITION_COLOR), this._programs[cc.SHADER_POSITION_COLOR] = a, this._programs.ShaderPositionColor = a, a = new cc.GLProgram, this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE), this._programs[cc.SHADER_POSITION_TEXTURE] = a, this._programs.ShaderPositionTexture = a, a = new cc.GLProgram, this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR), this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = a, this._programs.ShaderPositionTextureUColor = a, a = new cc.GLProgram, this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR), this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = a, this._programs.ShaderPositionTextureA8Color = a, a = new cc.GLProgram, this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR), this._programs[cc.SHADER_POSITION_UCOLOR] = a, this._programs.ShaderPositionUColor = a, a = new cc.GLProgram, this._loadDefaultShader(a, this.TYPE_POSITION_LENGTH_TEXTURECOLOR), this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = a, this._programs.ShaderPositionLengthTextureColor = a
    },
    reloadDefaultShaders: function() {
        var a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        a.reset(), this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR), a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), a.reset(), this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST), a = this.programForKey(cc.SHADER_POSITION_COLOR), a.reset(), this._loadDefaultShader(a, this.TYPE_POSITION_COLOR), a = this.programForKey(cc.SHADER_POSITION_TEXTURE), a.reset(), this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE), a = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR), a.reset(), this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR), a = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR), a.reset(), this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR), a = this.programForKey(cc.SHADER_POSITION_UCOLOR), a.reset(), this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR)
    },
    programForKey: function(a) {
        return this._programs[a]
    },
    getProgram: function(a) {
        return this._programs[a]
    },
    addProgram: function(a, b) {
        this._programs[b] = a
    }
}, cc.HashUniformEntry = function(a, b, c) {
    this.value = a, this.location = b, this.hh = c || {}
}, cc.GLProgram = cc.Class.extend({
    _glContext: null,
    _programObj: null,
    _vertShader: null,
    _fragShader: null,
    _uniforms: null,
    _hashForUniforms: null,
    _usesTime: !1,
    _updateUniformLocation: function(a, b, c) {
        if (null == a) return !1;
        c = !0;
        for (var d = null, e = 0; e < this._hashForUniforms.length; e++) this._hashForUniforms[e].location == a && (d = this._hashForUniforms[e]);
        return d ? d.value == b ? c = !1 : d.value = b : (d = new cc.HashUniformEntry, d.location = a, d.value = b, this._hashForUniforms.push(d)), c
    },
    _description: function() {
        return "<CCGLProgram = " + this.toString() + " | Program = " + this._programObj.toString() + ", VertexShader = " + this._vertShader.toString() + ", FragmentShader = " + this._fragShader.toString() + ">"
    },
    _compileShader: function(a, b, c) {
        return c && a ? (this._glContext.shaderSource(a, "precision highp float;        \nuniform mat4 CC_PMatrix;         \nuniform mat4 CC_MVMatrix;        \nuniform mat4 CC_MVPMatrix;       \nuniform vec4 CC_Time;            \nuniform vec4 CC_SinTime;         \nuniform vec4 CC_CosTime;         \nuniform vec4 CC_Random01;        \n//CC INCLUDES END                \n" + c), this._glContext.compileShader(a), c = this._glContext.getShaderParameter(a, this._glContext.COMPILE_STATUS), c || (cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(a)), cc.log(b == this._glContext.VERTEX_SHADER ? "cocos2d: \n" + this.vertexShaderLog() : "cocos2d: \n" + this.fragmentShaderLog())), 1 == c) : !1
    },
    ctor: function(a, b, c) {
        this._uniforms = [], this._hashForUniforms = [], this._glContext = c || cc._renderContext, a && b && this.init(a, b)
    },
    destroyProgram: function() {
        this._hashForUniforms = this._uniforms = this._fragShader = this._vertShader = null, this._glContext.deleteProgram(this._programObj)
    },
    initWithVertexShaderByteArray: function(a, b) {
        var c = this._glContext;
        return this._programObj = c.createProgram(), this._fragShader = this._vertShader = null, a && (this._vertShader = c.createShader(c.VERTEX_SHADER), this._compileShader(this._vertShader, c.VERTEX_SHADER, a) || cc.log("cocos2d: ERROR: Failed to compile vertex shader")), b && (this._fragShader = c.createShader(c.FRAGMENT_SHADER), this._compileShader(this._fragShader, c.FRAGMENT_SHADER, b) || cc.log("cocos2d: ERROR: Failed to compile fragment shader")), this._vertShader && c.attachShader(this._programObj, this._vertShader), cc.checkGLErrorDebug(), this._fragShader && c.attachShader(this._programObj, this._fragShader), this._hashForUniforms.length = 0, cc.checkGLErrorDebug(), !0
    },
    initWithString: function(a, b) {
        return this.initWithVertexShaderByteArray(a, b)
    },
    initWithVertexShaderFilename: function(a, b) {
        var c = cc.loader.getRes(a);
        if (!c) throw "Please load the resource firset : " + a;
        var d = cc.loader.getRes(b);
        if (!d) throw "Please load the resource firset : " + b;
        return this.initWithVertexShaderByteArray(c, d)
    },
    init: function(a, b) {
        return this.initWithVertexShaderFilename(a, b)
    },
    addAttribute: function(a, b) {
        this._glContext.bindAttribLocation(this._programObj, b, a)
    },
    link: function() {
        return this._programObj ? (this._glContext.linkProgram(this._programObj), this._vertShader && this._glContext.deleteShader(this._vertShader), this._fragShader && this._glContext.deleteShader(this._fragShader), this._fragShader = this._vertShader = null, cc.game.config[cc.game.CONFIG_KEY.debugMode] && !this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS) ? (cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj)), cc.glDeleteProgram(this._programObj), this._programObj = null, !1) : !0) : (cc.log("cc.GLProgram.link(): Cannot link invalid program"), !1)
    },
    use: function() {
        cc.glUseProgram(this._programObj)
    },
    updateUniforms: function() {
        this._uniforms[cc.UNIFORM_PMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S), this._uniforms[cc.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S), this._uniforms[cc.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S), this._uniforms[cc.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S), this._uniforms[cc.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S), this._uniforms[cc.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S), this._usesTime = null != this._uniforms[cc.UNIFORM_TIME] || null != this._uniforms[cc.UNIFORM_SINTIME] || null != this._uniforms[cc.UNIFORM_COSTIME], this._uniforms[cc.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S), this._uniforms[cc.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S), this.use(), this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER], 0)
    },
    getUniformLocationForName: function(a) {
        if (!a) throw "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null";
        if (!this._programObj) throw "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized";
        return this._glContext.getUniformLocation(this._programObj, a)
    },
    getUniformMVPMatrix: function() {
        return this._uniforms[cc.UNIFORM_MVPMATRIX]
    },
    getUniformSampler: function() {
        return this._uniforms[cc.UNIFORM_SAMPLER]
    },
    setUniformLocationWith1i: function(a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform1i(a, b)
    },
    setUniformLocationWith2i: function(a, b, c) {
        this._updateUniformLocation(a, [b, c]) && this._glContext.uniform2i(a, b, c)
    },
    setUniformLocationWith3i: function(a, b, c, d) {
        this._updateUniformLocation(a, [b, c, d]) && this._glContext.uniform3i(a, b, c, d)
    },
    setUniformLocationWith4i: function(a, b, c, d, e) {
        this._updateUniformLocation(a, [b, c, d, e]) && this._glContext.uniform4i(a, b, c, d, e)
    },
    setUniformLocationWith2iv: function(a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform2iv(a, b)
    },
    setUniformLocationWith3iv: function(a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform3iv(a, b)
    },
    setUniformLocationWith4iv: function(a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform4iv(a, b)
    },
    setUniformLocationI32: function(a, b) {
        this.setUniformLocationWith1i(a, b)
    },
    setUniformLocationWith1f: function(a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform1f(a, b)
    },
    setUniformLocationWith2f: function(a, b, c) {
        this._updateUniformLocation(a, [b, c]) && this._glContext.uniform2f(a, b, c)
    },
    setUniformLocationWith3f: function(a, b, c, d) {
        this._updateUniformLocation(a, [b, c, d]) && this._glContext.uniform3f(a, b, c, d)
    },
    setUniformLocationWith4f: function(a, b, c, d, e) {
        this._updateUniformLocation(a, [b, c, d, e]) && this._glContext.uniform4f(a, b, c, d, e)
    },
    setUniformLocationWith2fv: function(a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform2fv(a, b)
    },
    setUniformLocationWith3fv: function(a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform3fv(a, b)
    },
    setUniformLocationWith4fv: function(a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform4fv(a, b)
    },
    setUniformLocationWithMatrix4fv: function(a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniformMatrix4fv(a, !1, b)
    },
    setUniformLocationF32: function() {
        if (!(2 > arguments.length)) switch (arguments.length) {
            case 2:
                this.setUniformLocationWith1f(arguments[0], arguments[1]);
                break;
            case 3:
                this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
                break;
            case 4:
                this.setUniformLocationWith3f(arguments[0], arguments[1], arguments[2], arguments[3]);
                break;
            case 5:
                this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4])
        }
    },
    setUniformsForBuiltins: function() {
        var a = new cc.kmMat4,
            b = new cc.kmMat4,
            c = new cc.kmMat4;
        cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, a), cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, b), cc.kmMat4Multiply(c, a, b), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], a.mat, 1), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], b.mat, 1), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], c.mat, 1), this._usesTime && (a = cc.director, a = a.getTotalFrames() * a.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], a / 10, a, 2 * a, 4 * a), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], a / 8, a / 4, a / 2, Math.sin(a)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], a / 8, a / 4, a / 2, Math.cos(a))), -1 != this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
    },
    setUniformForModelViewProjectionMatrix: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top))
    },
    setUniformForModelViewProjectionMatrixWithMat4: function(a) {
        cc.kmMat4Multiply(a, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top), this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, a.mat)
    },
    setUniformForModelViewAndProjectionMatrixWithMat4: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, cc.modelview_matrix_stack.top.mat), this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
    },
    vertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getVertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getFragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    fragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._fragShader)
    },
    programLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    getProgramLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    reset: function() {
        this._fragShader = this._vertShader = null, this._uniforms.length = 0, this._glContext.deleteProgram(this._programObj), this._programObj = null;
        for (var a = 0; a < this._hashForUniforms.length; a++) this._hashForUniforms[a].value = null, this._hashForUniforms[a] = null;
        this._hashForUniforms.length = 0
    },
    getProgram: function() {
        return this._programObj
    },
    retain: function() {},
    release: function() {}
}), cc.GLProgram.create = function(a, b) {
    return new cc.GLProgram(a, b)
}, cc._currentProjectionMatrix = -1, cc._vertexAttribPosition = !1, cc._vertexAttribColor = !1, cc._vertexAttribTexCoords = !1, cc.ENABLE_GL_STATE_CACHE && (cc.MAX_ACTIVETEXTURE = 16, cc._currentShaderProgram = -1, cc._currentBoundTexture = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], cc._blendingSource = -1, cc._blendingDest = -1, cc._GLServerState = 0, cc.TEXTURE_ATLAS_USE_VAO && (cc._uVAO = 0)), cc.glInvalidateStateCache = function() {
    if (cc.kmGLFreeAll(), cc._currentProjectionMatrix = -1, cc._vertexAttribPosition = !1, cc._vertexAttribColor = !1, cc._vertexAttribTexCoords = !1, cc.ENABLE_GL_STATE_CACHE) {
        cc._currentShaderProgram = -1;
        for (var a = 0; a < cc.MAX_ACTIVETEXTURE; a++) cc._currentBoundTexture[a] = -1;
        cc._blendingSource = -1, cc._blendingDest = -1, cc._GLServerState = 0
    }
}, cc.glUseProgram = function(a) {
    a !== cc._currentShaderProgram && (cc._currentShaderProgram = a, cc._renderContext.useProgram(a))
}, cc.ENABLE_GL_STATE_CACHE || (cc.glUseProgram = function(a) {
    cc._renderContext.useProgram(a)
}), cc.glDeleteProgram = function(a) {
    cc.ENABLE_GL_STATE_CACHE && a === cc._currentShaderProgram && (cc._currentShaderProgram = -1), gl.deleteProgram(a)
}, cc.glBlendFunc = function(a, b) {
    (a !== cc._blendingSource || b !== cc._blendingDest) && (cc._blendingSource = a, cc._blendingDest = b, cc.setBlending(a, b))
}, cc.setBlending = function(a, b) {
    var c = cc._renderContext;
    a === c.ONE && b === c.ZERO ? c.disable(c.BLEND) : (c.enable(c.BLEND), cc._renderContext.blendFunc(a, b))
}, cc.glBlendFuncForParticle = function(a, b) {
    if (a !== cc._blendingSource || b !== cc._blendingDest) {
        cc._blendingSource = a, cc._blendingDest = b;
        var c = cc._renderContext;
        a === c.ONE && b === c.ZERO ? c.disable(c.BLEND) : (c.enable(c.BLEND), c.blendFuncSeparate(c.SRC_ALPHA, b, a, b))
    }
}, cc.ENABLE_GL_STATE_CACHE || (cc.glBlendFunc = cc.setBlending), cc.glBlendResetToCache = function() {
    var a = cc._renderContext;
    a.blendEquation(a.FUNC_ADD), cc.ENABLE_GL_STATE_CACHE ? cc.setBlending(cc._blendingSource, cc._blendingDest) : cc.setBlending(a.BLEND_SRC, a.BLEND_DST)
}, cc.setProjectionMatrixDirty = function() {
    cc._currentProjectionMatrix = -1
}, cc.glEnableVertexAttribs = function(a) {
    var b = cc._renderContext,
        c = a & cc.VERTEX_ATTRIB_FLAG_POSITION;
    c !== cc._vertexAttribPosition && (c ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), cc._vertexAttribPosition = c), c = a & cc.VERTEX_ATTRIB_FLAG_COLOR, c !== cc._vertexAttribColor && (c ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), cc._vertexAttribColor = c), a &= cc.VERTEX_ATTRIB_FLAG_TEX_COORDS, a !== cc._vertexAttribTexCoords && (a ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), cc._vertexAttribTexCoords = a)
}, cc.glBindTexture2D = function(a) {
    cc.glBindTexture2DN(0, a)
}, cc.glBindTexture2DN = function(a, b) {
    if (cc._currentBoundTexture[a] != b) {
        cc._currentBoundTexture[a] = b;
        var c = cc._renderContext;
        c.activeTexture(c.TEXTURE0 + a), b ? c.bindTexture(c.TEXTURE_2D, b._webTextureObj) : c.bindTexture(c.TEXTURE_2D, null)
    }
}, cc.ENABLE_GL_STATE_CACHE || (cc.glBindTexture2DN = function(a, b) {
    var c = cc._renderContext;
    c.activeTexture(c.TEXTURE0 + a), b ? c.bindTexture(c.TEXTURE_2D, b._webTextureObj) : c.bindTexture(c.TEXTURE_2D, null)
}), cc.glDeleteTexture = function(a) {
    cc.glDeleteTextureN(0, a)
}, cc.glDeleteTextureN = function(a, b) {
    cc.ENABLE_GL_STATE_CACHE && b == cc._currentBoundTexture[a] && (cc._currentBoundTexture[a] = -1), cc._renderContext.deleteTexture(b)
}, cc.glBindVAO = function(a) {
    cc.TEXTURE_ATLAS_USE_VAO && cc.ENABLE_GL_STATE_CACHE && cc._uVAO != a && (cc._uVAO = a)
}, cc.glEnable = function() {}, cc.IMAGE_FORMAT_JPEG = 0, cc.IMAGE_FORMAT_PNG = 1, cc.IMAGE_FORMAT_RAWDATA = 9, cc.NextPOT = function(a) {
    return a -= 1, a |= a >> 1, a |= a >> 2, a |= a >> 4, a |= a >> 8, (a | a >> 16) + 1
}, cc.RenderTexture = cc.Node.extend({
    sprite: null,
    clearFlags: 0,
    clearDepthVal: 0,
    autoDraw: !1,
    _cacheCanvas: null,
    _cacheContext: null,
    _fBO: 0,
    _depthRenderBuffer: 0,
    _oldFBO: 0,
    _texture: null,
    _textureCopy: null,
    _uITextureImage: null,
    _pixelFormat: cc.Texture2D.PIXEL_FORMAT_RGBA8888,
    _clearColor: null,
    clearStencilVal: 0,
    _clearColorStr: null,
    _className: "RenderTexture",
    ctor: null,
    _ctorForCanvas: function(a, b, c, d) {
        cc.Node.prototype.ctor.call(this), this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0, this._clearColor = cc.color(255, 255, 255, 255), this._clearColorStr = "rgba(255,255,255,1)", this._cacheCanvas = cc.newElement("canvas"), this._cacheContext = this._cacheCanvas.getContext("2d"), this.anchorY = this.anchorX = 0, void 0 !== a && void 0 !== b && (c = c || cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.initWithWidthAndHeight(a, b, c, d || 0))
    },
    _ctorForWebGL: function(a, b, c, d) {
        cc.Node.prototype.ctor.call(this), this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0, this._clearColor = cc.color(0, 0, 0, 0), void 0 !== a && void 0 !== b && (c = c || cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.initWithWidthAndHeight(a, b, c, d || 0))
    },
    cleanup: null,
    _cleanupForCanvas: function() {
        cc.Node.prototype.onExit.call(this), this._cacheCanvas = this._cacheContext = null
    },
    _cleanupForWebGL: function() {
        cc.Node.prototype.onExit.call(this), this._textureCopy = null;
        var a = cc._renderContext;
        a.deleteFramebuffer(this._fBO), this._depthRenderBuffer && a.deleteRenderbuffer(this._depthRenderBuffer), this._uITextureImage = null
    },
    getSprite: function() {
        return this.sprite
    },
    setSprite: function(a) {
        this.sprite = a
    },
    initWithWidthAndHeight: null,
    _initWithWidthAndHeightForCanvas: function(a, b, c, d) {
        return c = this._cacheCanvas, d = cc.contentScaleFactor(), c.width = 0 | a * d, c.height = 0 | b * d, this._cacheContext.translate(0, c.height), a = new cc.Texture2D, a.initWithElement(c), a.handleLoadedTexture(), a = this.sprite = cc.Sprite.create(a), a.setBlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA), this.autoDraw = !1, this.addChild(a), !0
    },
    _initWithWidthAndHeightForWebGL: function(a, b, c, d) {
        c == cc.Texture2D.PIXEL_FORMAT_A8 && cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
        var e = cc._renderContext,
            f = cc.contentScaleFactor();
        a = 0 | a * f, b = 0 | b * f, this._oldFBO = e.getParameter(e.FRAMEBUFFER_BINDING);
        var g;
        cc.configuration.supportsNPOT() ? (f = a, g = b) : (f = cc.NextPOT(a), g = cc.NextPOT(b));
        for (var h = new Uint8Array(4 * f * g), i = 0; 4 * f * g > i; i++) h[i] = 0;
        if (this._pixelFormat = c, this._texture = new cc.Texture2D, !this._texture) return !1;
        if (i = this._texture, i.initWithData(h, this._pixelFormat, f, g, cc.size(a, b)), c = e.getParameter(e.RENDERBUFFER_BINDING), cc.configuration.checkForGLExtension("GL_QCOM")) {
            if (this._textureCopy = new cc.Texture2D, !this._textureCopy) return !1;
            this._textureCopy.initWithData(h, this._pixelFormat, f, g, cc.size(a, b))
        }
        return this._fBO = e.createFramebuffer(), e.bindFramebuffer(e.FRAMEBUFFER, this._fBO), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, i._webTextureObj, 0), 0 != d && (this._depthRenderBuffer = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, this._depthRenderBuffer), e.renderbufferStorage(e.RENDERBUFFER, d, f, g), d == e.DEPTH_STENCIL ? e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, this._depthRenderBuffer) : d == e.STENCIL_INDEX || d == e.STENCIL_INDEX8 ? e.framebufferRenderbuffer(e.FRAMEBUFFER, e.STENCIL_ATTACHMENT, e.RENDERBUFFER, this._depthRenderBuffer) : d == e.DEPTH_COMPONENT16 && e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, this._depthRenderBuffer)), e.checkFramebufferStatus(e.FRAMEBUFFER) !== e.FRAMEBUFFER_COMPLETE && cc.log("Could not attach texture to the framebuffer"), i.setAliasTexParameters(), a = this.sprite = cc.Sprite.create(i), a.scaleY = -1, a.setBlendFunc(e.ONE, e.ONE_MINUS_SRC_ALPHA), e.bindRenderbuffer(e.RENDERBUFFER, c), e.bindFramebuffer(e.FRAMEBUFFER, this._oldFBO), this.autoDraw = !1, this.addChild(a), !0
    },
    begin: null,
    _beginForCanvas: function() {
        cc._renderContext = this._cacheContext, cc.view._setScaleXYForRenderTexture()
    },
    _beginForWebGL: function() {
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLPushMatrix(), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPushMatrix();
        var a = cc.director;
        a.setProjection(a.getProjection());
        var b = this._texture.getContentSizeInPixels(),
            c = cc.director.getWinSizeInPixels(),
            a = c.width / b.width,
            c = c.height / b.height,
            d = cc._renderContext;
        d.viewport(0, 0, b.width, b.height), b = new cc.kmMat4, cc.kmMat4OrthographicProjection(b, -1 / a, 1 / a, -1 / c, 1 / c, -1, 1), cc.kmGLMultMatrix(b), this._oldFBO = d.getParameter(d.FRAMEBUFFER_BINDING), d.bindFramebuffer(d.FRAMEBUFFER, this._fBO), cc.configuration.checkForGLExtension("GL_QCOM") && (d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, this._textureCopy._webTextureObj, 0), d.clear(d.COLOR_BUFFER_BIT | d.DEPTH_BUFFER_BIT), d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, this._texture._webTextureObj, 0))
    },
    beginWithClear: function(a, b, c, d, e, f) {
        var g = cc._renderContext;
        e = e || g.COLOR_BUFFER_BIT, f = f || g.COLOR_BUFFER_BIT | g.DEPTH_BUFFER_BIT, this._beginWithClear(a, b, c, d, e, f, g.COLOR_BUFFER_BIT | g.DEPTH_BUFFER_BIT | g.STENCIL_BUFFER_BIT)
    },
    _beginWithClear: null,
    _beginWithClearForCanvas: function(a, b, c, d, e, f) {
        this.begin(), a = a || 0, b = b || 0, c = c || 0, d = isNaN(d) ? 1 : d, e = this._cacheContext, f = this._cacheCanvas, e.save(), e.fillStyle = "rgba(" + (0 | a) + "," + (0 | b) + "," + (0 | c) + "," + d / 255 + ")", e.clearRect(0, 0, f.width, -f.height), e.fillRect(0, 0, f.width, -f.height), e.restore()
    },
    _beginWithClearForWebGL: function(a, b, c, d, e, f, g) {
        a /= 255, b /= 255, c /= 255, d /= 255, this.begin();
        var h = cc._renderContext,
            i = [0, 0, 0, 0],
            j = 0,
            k = 0;
        g & h.COLOR_BUFFER_BIT && (i = h.getParameter(h.COLOR_CLEAR_VALUE), h.clearColor(a, b, c, d)), g & h.DEPTH_BUFFER_BIT && (j = h.getParameter(h.DEPTH_CLEAR_VALUE), h.clearDepth(e)), g & h.STENCIL_BUFFER_BIT && (k = h.getParameter(h.STENCIL_CLEAR_VALUE), h.clearStencil(f)), h.clear(g), g & h.COLOR_BUFFER_BIT && h.clearColor(i[0], i[1], i[2], i[3]), g & h.DEPTH_BUFFER_BIT && h.clearDepth(j), g & h.STENCIL_BUFFER_BIT && h.clearStencil(k)
    },
    end: null,
    _endForCanvas: function() {
        cc._renderContext = cc._mainRenderContextBackup, cc.view._resetScale()
    },
    _endForWebGL: function() {
        var a = cc._renderContext,
            b = cc.director;
        a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO), b.setViewport(), cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLPopMatrix(), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPopMatrix()
    },
    clear: function(a, b, c, d) {
        this.beginWithClear(a, b, c, d), this.end()
    },
    clearRect: null,
    _clearRectForCanvas: function(a, b, c, d) {
        this._cacheContext.clearRect(a, b, c, -d)
    },
    _clearRectForWebGL: function() {},
    clearDepth: null,
    _clearDepthForCanvas: function() {
        cc.log("clearDepth isn't supported on Cocos2d-Html5")
    },
    _clearDepthForWebGL: function(a) {
        this.begin();
        var b = cc._renderContext,
            c = b.getParameter(b.DEPTH_CLEAR_VALUE);
        b.clearDepth(a), b.clear(b.DEPTH_BUFFER_BIT), b.clearDepth(c), this.end()
    },
    clearStencil: null,
    _clearStencilForCanvas: function() {
        cc.log("clearDepth isn't supported on Cocos2d-Html5")
    },
    _clearStencilForWebGL: function(a) {
        var b = cc._renderContext,
            c = b.getParameter(b.STENCIL_CLEAR_VALUE);
        b.clearStencil(a), b.clear(b.STENCIL_BUFFER_BIT), b.clearStencil(c)
    },
    visit: null,
    _visitForCanvas: function(a) {
        this._visible && (a = a || cc._renderContext, a.save(), this.draw(a), this.transform(a), this.sprite.visit(), a.restore(), this.arrivalOrder = 0)
    },
    _visitForWebGL: function(a) {
        if (this._visible) {
            cc.kmGLPushMatrix();
            var b = this.grid;
            b && b.isActive() && (b.beforeDraw(), this.transformAncestors()), this.transform(a), this.sprite.visit(), this.draw(a), b && b.isActive() && b.afterDraw(this), cc.kmGLPopMatrix(), this.arrivalOrder = 0
        }
    },
    draw: null,
    _drawForCanvas: function(a) {
        if (a = a || cc._renderContext, this.autoDraw) {
            if (this.begin(), this.clearFlags) {
                var b = this._cacheCanvas;
                a.save(), a.fillStyle = this._clearColorStr, a.clearRect(0, 0, b.width, -b.height), a.fillRect(0, 0, b.width, -b.height), a.restore()
            }
            this.sortAllChildren(), a = this._children;
            for (var b = a.length, c = this.sprite, d = 0; b > d; d++) {
                var e = a[d];
                e != c && e.visit()
            }
            this.end()
        }
    },
    _drawForWebGL: function(a) {
        if (a = cc._renderContext, this.autoDraw) {
            this.begin();
            var b = this.clearFlags;
            if (b) {
                var c = [0, 0, 0, 0],
                    d = 0,
                    e = 0;
                b & a.COLOR_BUFFER_BIT && (c = a.getParameter(a.COLOR_CLEAR_VALUE), a.clearColor(this._clearColor.r / 255, this._clearColor.g / 255, this._clearColor.b / 255, this._clearColor.a / 255)), b & a.DEPTH_BUFFER_BIT && (d = a.getParameter(a.DEPTH_CLEAR_VALUE), a.clearDepth(this.clearDepthVal)), b & a.STENCIL_BUFFER_BIT && (e = a.getParameter(a.STENCIL_CLEAR_VALUE), a.clearStencil(this.clearStencilVal)), a.clear(b), b & a.COLOR_BUFFER_BIT && a.clearColor(c[0], c[1], c[2], c[3]), b & a.DEPTH_BUFFER_BIT && a.clearDepth(d), b & a.STENCIL_BUFFER_BIT && a.clearStencil(e)
            }
            for (this.sortAllChildren(), a = this._children, b = 0; b < a.length; b++) c = a[b], c != this.sprite && c.visit();
            this.end()
        }
    },
    newCCImage: function() {
        return cc.log("saveToFile isn't supported on cocos2d-html5"), null
    },
    _memcpy: function(a, b, c, d, e) {
        for (var f = 0; e > f; f++) a[b + f] = c[d + f]
    },
    saveToFile: function() {
        cc.log("saveToFile isn't supported on Cocos2d-Html5")
    },
    listenToBackground: function() {
        cc.log("listenToBackground isn't supported on Cocos2d-Html5")
    },
    listenToForeground: function() {
        cc.log("listenToForeground isn't supported on Cocos2d-Html5")
    },
    getClearFlags: function() {
        return this.clearFlags
    },
    setClearFlags: function(a) {
        this.clearFlags = a
    },
    getClearColor: function() {
        return this._clearColor
    },
    setClearColor: null,
    _setClearColorForCanvas: function(a) {
        var b = this._clearColor;
        b.r = a.r, b.g = a.g, b.b = a.b, b.a = a.a, this._clearColorStr = "rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + "," + a.a / 255 + ")"
    },
    _setClearColorForWebGL: function(a) {
        var b = this._clearColor;
        b.r = a.r, b.g = a.g, b.b = a.b, b.a = a.a
    },
    getClearDepth: function() {
        return this.clearDepthVal
    },
    setClearDepth: function(a) {
        this.clearDepthVal = a
    },
    getClearStencil: function() {
        return this.clearStencilVal
    },
    setClearStencil: function(a) {
        this.clearStencilVal = a
    },
    isAutoDraw: function() {
        return this.autoDraw
    },
    setAutoDraw: function(a) {
        this.autoDraw = a
    }
}), _p = cc.RenderTexture.prototype, cc._renderType == cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.cleanup = _p._cleanupForWebGL, _p.initWithWidthAndHeight = _p._initWithWidthAndHeightForWebGL, _p.begin = _p._beginForWebGL, _p._beginWithClear = _p._beginWithClearForWebGL, _p.end = _p._endForWebGL, _p.clearRect = _p._clearRectForWebGL, _p.clearDepth = _p._clearDepthForWebGL, _p.clearStencil = _p._clearStencilForWebGL, _p.visit = _p._visitForWebGL, _p.draw = _p._drawForWebGL, _p.setClearColor = _p._setClearColorForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.cleanup = _p._cleanupForCanvas, _p.initWithWidthAndHeight = _p._initWithWidthAndHeightForCanvas, _p.begin = _p._beginForCanvas, _p._beginWithClear = _p._beginWithClearForCanvas, _p.end = _p._endForCanvas, _p.clearRect = _p._clearRectForCanvas, _p.clearDepth = _p._clearDepthForCanvas, _p.clearStencil = _p._clearStencilForCanvas, _p.visit = _p._visitForCanvas, _p.draw = _p._drawForCanvas, _p.setClearColor = _p._setClearColorForCanvas), cc.defineGetterSetter(_p, "clearColorVal", _p.getClearColor, _p.setClearColor), cc.RenderTexture.create = function(a, b, c, d) {
    return new cc.RenderTexture(a, b, c, d)
}, cc.LabelAtlas = cc.AtlasNode.extend({
    _string: null,
    _mapStartChar: null,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _className: "LabelAtlas",
    ctor: function(a, b, c, d, e) {
        cc.AtlasNode.prototype.ctor.call(this), b && cc.LabelAtlas.prototype.initWithString.call(this, a, b, c, d, e)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this._loadedEventListeners || (this._loadedEventListeners = []), this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: b
        })
    },
    _callLoadedEventCallbacks: function() {
        if (this._loadedEventListeners) {
            this._textureLoaded = !0;
            for (var a = this._loadedEventListeners, b = 0, c = a.length; c > b; b++) {
                var d = a[b];
                d.eventCallback.call(d.eventTarget, this)
            }
            a.length = 0
        }
    },
    initWithString: function(a, b, c, d, e) {
        var f, g, h = a + "";
        if (void 0 === c) {
            if (c = cc.loader.getRes(b), 1 !== parseInt(c.version, 10)) return cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version"), !1;
            b = cc.path.changeBasename(b, c.textureFilename), d = cc.contentScaleFactor(), f = parseInt(c.itemWidth, 10) / d, g = parseInt(c.itemHeight, 10) / d, c = String.fromCharCode(parseInt(c.firstChar, 10))
        } else f = c || 0, g = d || 0, c = e || " ";
        var i = null,
            i = b instanceof cc.Texture2D ? b : cc.textureCache.addImage(b);
        return (this._textureLoaded = b = i.isLoaded()) || i.addLoadedEventListener(function() {
            this.initWithTexture(i, f, g, h.length), this.string = h, this._callLoadedEventCallbacks()
        }, this), this.initWithTexture(i, f, g, h.length) ? (this._mapStartChar = c, this.string = h, !0) : !1
    },
    setColor: function(a) {
        cc.AtlasNode.prototype.setColor.call(this, a), this.updateAtlasValues()
    },
    getString: function() {
        return this._string
    },
    draw: function(a) {
        cc.AtlasNode.prototype.draw.call(this, a), cc.LABELATLAS_DEBUG_DRAW && (a = this.size, a = [cc.p(0, 0), cc.p(a.width, 0), cc.p(a.width, a.height), cc.p(0, a.height)], cc._drawingUtil.drawPoly(a, 4, !0))
    },
    _addChildForCanvas: function(a, b, c) {
        a._lateChild = !0, cc.Node.prototype.addChild.call(this, a, b, c)
    },
    updateAtlasValues: null,
    _updateAtlasValuesForCanvas: function() {
        for (var a = this._string || "", b = a.length, c = this.texture, d = this._itemWidth, e = this._itemHeight, f = 0; b > f; f++) {
            var g = a.charCodeAt(f) - this._mapStartChar.charCodeAt(0),
                h = parseInt(g % this._itemsPerRow, 10),
                g = parseInt(g / this._itemsPerRow, 10),
                h = cc.rect(h * d, g * e, d, e),
                g = a.charCodeAt(f),
                i = this.getChildByTag(f);
            i ? 32 == g ? (i.init(), i.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : (i.initWithTexture(c, h), i.visible = !0, i.opacity = this._displayedOpacity) : (i = new cc.Sprite, 32 == g ? (i.init(), i.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : i.initWithTexture(c, h), cc.Node.prototype.addChild.call(this, i, 0, f)), i.setPosition(f * d + d / 2, e / 2)
        }
    },
    _updateAtlasValuesForWebGL: function() {
        var a = this._string,
            b = a.length,
            c = this.textureAtlas,
            d = c.texture,
            e = d.pixelsWidth,
            d = d.pixelsHeight,
            f = this._itemWidth,
            g = this._itemHeight;
        this._ignoreContentScaleFactor || (f = this._itemWidth * cc.contentScaleFactor(), g = this._itemHeight * cc.contentScaleFactor()), b > c.getCapacity() && cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
        for (var h = c.quads, i = this._displayedColor, i = {
                r: i.r,
                g: i.g,
                b: i.b,
                a: this._displayedOpacity
            }, j = this._itemWidth, k = 0; b > k; k++) {
            var l, m = a.charCodeAt(k) - this._mapStartChar.charCodeAt(0),
                n = m % this._itemsPerRow,
                o = 0 | m / this._itemsPerRow;
            cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (n = (2 * n * f + 1) / (2 * e), m = n + (2 * f - 2) / (2 * e), o = (2 * o * g + 1) / (2 * d), l = o + (2 * g - 2) / (2 * d)) : (n = n * f / e, m = n + f / e, o = o * g / d, l = o + g / d);
            var p = h[k],
                q = p.tl,
                r = p.tr,
                s = p.bl,
                p = p.br;
            q.texCoords.u = n, q.texCoords.v = o, r.texCoords.u = m, r.texCoords.v = o, s.texCoords.u = n, s.texCoords.v = l, p.texCoords.u = m, p.texCoords.v = l, s.vertices.x = k * j, s.vertices.y = 0, s.vertices.z = 0, p.vertices.x = k * j + j, p.vertices.y = 0, p.vertices.z = 0, q.vertices.x = k * j, q.vertices.y = this._itemHeight, q.vertices.z = 0, r.vertices.x = k * j + j, r.vertices.y = this._itemHeight, r.vertices.z = 0, q.colors = i, r.colors = i, s.colors = i, p.colors = i
        }
        b > 0 && (c.dirty = !0, a = c.totalQuads, b > a && c.increaseTotalQuadsWith(b - a))
    },
    setString: null,
    _setStringForCanvas: function(a) {
        a = String(a);
        var b = a.length;
        if (this._string = a, this.width = b * this._itemWidth, this.height = this._itemHeight, this._children) {
            a = this._children;
            for (var b = a.length, c = 0; b > c; c++) {
                var d = a[c];
                d && !d._lateChild && (d.visible = !1)
            }
        }
        this.updateAtlasValues(), this.quadsToDraw = b
    },
    _setStringForWebGL: function(a) {
        a = String(a);
        var b = a.length;
        b > this.textureAtlas.totalQuads && this.textureAtlas.resizeCapacity(b), this._string = a, this.width = b * this._itemWidth, this.height = this._itemHeight, this.updateAtlasValues(), this.quadsToDraw = b
    },
    setOpacity: null,
    _setOpacityForCanvas: function(a) {
        if (this._displayedOpacity !== a) {
            cc.AtlasNode.prototype.setOpacity.call(this, a);
            for (var b = this._children, c = 0, d = b.length; d > c; c++) b[c] && (b[c].opacity = a)
        }
    },
    _setOpacityForWebGL: function(a) {
        this._opacity !== a && cc.AtlasNode.prototype.setOpacity.call(this, a)
    }
}), _p = cc.LabelAtlas.prototype, cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.updateAtlasValues = _p._updateAtlasValuesForWebGL, _p.setString = _p._setStringForWebGL, _p.setOpacity = _p._setOpacityForWebGL) : (_p.updateAtlasValues = _p._updateAtlasValuesForCanvas, _p.setString = _p._setStringForCanvas, _p.setOpacity = _p._setOpacityForCanvas, _p.addChild = _p._addChildForCanvas), cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity), cc.defineGetterSetter(_p, "string", _p.getString, _p.setString), cc.LabelAtlas.create = function(a, b, c, d, e) {
    return new cc.LabelAtlas(a, b, c, d, e)
}, cc.LABEL_AUTOMATIC_WIDTH = -1, cc.LabelBMFont = cc.SpriteBatchNode.extend({
    _opacityModifyRGB: !1,
    _string: "",
    _config: null,
    _fntFile: "",
    _initialString: "",
    _alignment: cc.TEXT_ALIGNMENT_CENTER,
    _width: -1,
    _lineBreakWithoutSpaces: !1,
    _imageOffset: null,
    _reusedChar: null,
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeColorEnabled: !0,
    _cascadeOpacityEnabled: !0,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _className: "LabelBMFont",
    _setString: function(a, b) {
        b ? this._initialString = a : this._string = a;
        var c = this._children;
        if (c)
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                e && e.setVisible(!1)
            }
        this._textureLoaded && (this.createFontChars(), b && this.updateLabel())
    },
    ctor: function(a, b, c, d, e) {
        cc.SpriteBatchNode.prototype.ctor.call(this), this._imageOffset = cc.p(0, 0), this._displayedColor = cc.color(255, 255, 255, 255), this._realColor = cc.color(255, 255, 255, 255), this._reusedChar = [], this.initWithString(a, b, c, d, e)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this._loadedEventListeners || (this._loadedEventListeners = []), this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: b
        })
    },
    _callLoadedEventCallbacks: function() {
        if (this._loadedEventListeners) {
            for (var a = this._loadedEventListeners, b = 0, c = a.length; c > b; b++) {
                var d = a[b];
                d.eventCallback.call(d.eventTarget, this)
            }
            a.length = 0
        }
    },
    draw: function(a) {
        if (cc.SpriteBatchNode.prototype.draw.call(this, a), cc.LABELBMFONT_DEBUG_DRAW) {
            a = this.getContentSize();
            var b = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
            a = [cc.p(b.x, b.y), cc.p(b.x + a.width, b.y), cc.p(b.x + a.width, b.y + a.height), cc.p(b.x, b.y + a.height)], cc._drawingUtil.setDrawColor(0, 255, 0, 255), cc._drawingUtil.drawPoly(a, 4, !0)
        }
    },
    setColor: function(a) {
        var b = this._displayedColor,
            c = this._realColor;
        c.r == a.r && c.g == a.g && c.b == a.b && c.a == a.a || (b.r = c.r = a.r, b.g = c.g = a.g, b.b = c.b = a.b, this._textureLoaded && this._cascadeColorEnabled && (a = cc.color.WHITE, (b = this._parent) && b.cascadeColor && (a = b.getDisplayedColor()), this.updateDisplayedColor(a)))
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function(a) {
        if (this._opacityModifyRGB = a, a = this._children)
            for (var b = 0; b < a.length; b++) {
                var c = a[b];
                c && (c.opacityModifyRGB = this._opacityModifyRGB)
            }
    },
    getOpacity: function() {
        return this._realOpacity
    },
    getDisplayedOpacity: function() {
        return this._displayedOpacity
    },
    setOpacity: function(a) {
        if (this._displayedOpacity = this._realOpacity = a, this._cascadeOpacityEnabled) {
            var b = 255,
                c = this._parent;
            c && c.cascadeOpacity && (b = c.getDisplayedOpacity()), this.updateDisplayedOpacity(b)
        }
        this._displayedColor.a = this._realColor.a = a
    },
    updateDisplayedOpacity: function(a) {
        this._displayedOpacity = this._realOpacity * a / 255, a = this._children;
        for (var b = 0; b < a.length; b++) {
            var c = a[b];
            cc._renderType == cc._RENDER_TYPE_WEBGL ? c.updateDisplayedOpacity(this._displayedOpacity) : (cc.Node.prototype.updateDisplayedOpacity.call(c, this._displayedOpacity), c.setNodeDirty())
        }
        this._changeTextureColor()
    },
    isCascadeOpacityEnabled: function() {
        return !1
    },
    setCascadeOpacityEnabled: function(a) {
        this._cascadeOpacityEnabled = a
    },
    getColor: function() {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedColor: function() {
        var a = this._displayedColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    updateDisplayedColor: function(a) {
        var b = this._displayedColor,
            c = this._realColor;
        for (b.r = c.r * a.r / 255, b.g = c.g * a.g / 255, b.b = c.b * a.b / 255, a = this._children, b = 0; b < a.length; b++) c = a[b], cc._renderType == cc._RENDER_TYPE_WEBGL ? c.updateDisplayedColor(this._displayedColor) : (cc.Node.prototype.updateDisplayedColor.call(c, this._displayedColor), c.setNodeDirty());
        this._changeTextureColor()
    },
    _changeTextureColor: function() {
        if (cc._renderType != cc._RENDER_TYPE_WEBGL) {
            var a = this.getTexture();
            if (a && 0 < a.getContentSize().width) {
                var b = this._originalTexture.getHtmlElementObj();
                if (b) {
                    var c = a.getHtmlElementObj(),
                        d = cc.rect(0, 0, b.width, b.height);
                    c instanceof HTMLCanvasElement && !this._rectRotated ? cc.generateTintImageWithMultiply(b, this._displayedColor, d, c) : (c = cc.generateTintImageWithMultiply(b, this._displayedColor, d), a = new cc.Texture2D, a.initWithElement(c), a.handleLoadedTexture()), this.setTexture(a)
                }
            }
        }
    },
    isCascadeColorEnabled: function() {
        return !1
    },
    setCascadeColorEnabled: function(a) {
        this._cascadeColorEnabled = a
    },
    init: function() {
        return this.initWithString(null, null, null, null, null)
    },
    initWithString: function(a, b, c, d, e) {
        if (a = a || "", this._config && cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported"), b) {
            var f = cc.loader.getRes(b);
            if (!f) return cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file"), !1;
            this._config = f, this._fntFile = b, b = cc.textureCache.addImage(f.atlasName), (this._textureLoaded = f = b.isLoaded()) || b.addLoadedEventListener(function(a) {
                this._textureLoaded = !0, this.initWithTexture(a, this._initialString.length), this.setString(this._initialString, !0), this._callLoadedEventCallbacks()
            }, this)
        } else b = new cc.Texture2D, f = new Image, b.initWithElement(f), this._textureLoaded = !1;
        return this.initWithTexture(b, a.length) ? (this._alignment = d || cc.TEXT_ALIGNMENT_LEFT, this._imageOffset = e || cc.p(0, 0), this._width = null == c ? -1 : c, this._displayedOpacity = this._realOpacity = 255, this._displayedColor = cc.color(255, 255, 255, 255), this._realColor = cc.color(255, 255, 255, 255), this._cascadeColorEnabled = this._cascadeOpacityEnabled = !0, this._contentSize.width = 0, this._contentSize.height = 0, this.setAnchorPoint(.5, .5), cc._renderType === cc._RENDER_TYPE_WEBGL && (c = this.textureAtlas.texture, this._opacityModifyRGB = c.hasPremultipliedAlpha(), d = this._reusedChar = new cc.Sprite, d.initWithTexture(c, cc.rect(0, 0, 0, 0), !1), d.batchNode = this), this.setString(a, !0), !0) : !1
    },
    createFontChars: function() {
        var a = cc._renderType,
            b = a === cc._RENDER_TYPE_CANVAS ? this.texture : this.textureAtlas.texture,
            c = 0,
            d = cc.size(0, 0),
            e = 0,
            f = 1,
            g = this._string,
            h = g ? g.length : 0;
        if (0 !== h) {
            var i, j = this._config,
                k = j.kerningDict,
                l = j.commonHeight,
                m = j.fontDefDictionary;
            for (i = 0; h - 1 > i; i++) 10 == g.charCodeAt(i) && f++;
            var n = l * f,
                f = -(l - l * f),
                o = -1;
            for (i = 0; h > i; i++)
                if (l = g.charCodeAt(i), 0 != l)
                    if (10 === l) c = 0, f -= j.commonHeight;
                    else {
                        var p = k[o << 16 | 65535 & l] || 0,
                            q = m[l];
                        if (q) {
                            var r = cc.rect(q.rect.x, q.rect.y, q.rect.width, q.rect.height),
                                r = cc.rectPixelsToPoints(r);
                            r.x += this._imageOffset.x, r.y += this._imageOffset.y, (o = this.getChildByTag(i)) ? 32 === l && a === cc._RENDER_TYPE_CANVAS ? o.setTextureRect(r, !1, cc.size(0, 0)) : (o.setTextureRect(r, !1), o.visible = !0) : (o = new cc.Sprite, 32 === l && a === cc._RENDER_TYPE_CANVAS && (r = cc.rect(0, 0, 0, 0)), o.initWithTexture(b, r, !1), o._newTextureWhenChangeColor = !0, this.addChild(o, 0, i)), o.opacityModifyRGB = this._opacityModifyRGB, cc._renderType == cc._RENDER_TYPE_WEBGL ? (o.updateDisplayedColor(this._displayedColor), o.updateDisplayedOpacity(this._displayedOpacity)) : (cc.Node.prototype.updateDisplayedColor.call(o, this._displayedColor), cc.Node.prototype.updateDisplayedOpacity.call(o, this._displayedOpacity), o.setNodeDirty()), r = cc.p(c + q.xOffset + .5 * q.rect.width + p, f + (j.commonHeight - q.yOffset) - .5 * r.height * cc.contentScaleFactor()), o.setPosition(cc.pointPixelsToPoints(r)), c += q.xAdvance + p, o = l, c > e && (e = c)
                        } else cc.log("cocos2d: LabelBMFont: character not found " + g[i])
                    }
            d.width = e, d.height = n, this.setContentSize(cc.sizePixelsToPoints(d))
        }
    },
    updateString: function(a) {
        var b = this._children;
        if (b)
            for (var c = 0, d = b.length; d > c; c++) {
                var e = b[c];
                e && (e.visible = !1)
            }
        this._config && this.createFontChars(), a || this.updateLabel()
    },
    getString: function() {
        return this._initialString
    },
    setString: function(a, b) {
        a = String(a), null == b && (b = !0), (null == a || "string" != typeof a) && (a += ""), this._initialString = a, this._setString(a, b)
    },
    _setStringForSetter: function(a) {
        this.setString(a, !1)
    },
    setCString: function(a) {
        this.setString(a, !0)
    },
    updateLabel: function() {
        if (this.string = this._initialString, 0 < this._width) {
            for (var a, b = this._string.length, c = [], d = [], e = 1, f = 0, g = !1, h = !1, i = -1, j = -1, k = 0, l = 0, m = this._children.length; m > l; l++) {
                for (var n = 0; !(a = this.getChildByTag(l + k + n));) n++;
                if (k += n, f >= b) break;
                var o = this._string[f];
                if (h || (j = this._getLetterPosXLeft(a), h = !0), g || (i = j, g = !0), 10 == o.charCodeAt(0)) {
                    if (d.push("\n"), c = c.concat(d), d.length = 0, g = h = !1, i = j = -1, l--, k -= n, e++, f >= b) break;
                    j || (j = this._getLetterPosXLeft(a), h = !0), i || (i = j, g = !0), f++
                } else if (this._isspace_unicode(o)) d.push(o), c = c.concat(d), d.length = 0, h = !1, j = -1, f++;
                else if (this._getLetterPosXRight(a) - i > this._width)
                    if (this._lineBreakWithoutSpaces) {
                        if (this._utf8_trim_ws(d), d.push("\n"), c = c.concat(d), d.length = 0, g = h = !1, i = j = -1, e++, f >= b) break;
                        j || (j = this._getLetterPosXLeft(a), h = !0), i || (i = j, g = !0), l--
                    } else d.push(o), -1 != c.lastIndexOf(" ") ? this._utf8_trim_ws(c) : c = [], 0 < c.length && c.push("\n"), e++, g = !1, i = -1, f++;
                    else d.push(o), f++
            }
            for (c = c.concat(d), l = c.length, a = "", f = 0; l > f; ++f) a += c[f];
            a += String.fromCharCode(0), this._setString(a, !1)
        }
        if (this._alignment != cc.TEXT_ALIGNMENT_LEFT)
            for (c = f = 0, b = this._string.length, d = [], e = 0; b > e; e++)
                if (10 == this._string[e].charCodeAt(0) || 0 == this._string[e].charCodeAt(0)) {
                    if (l = 0, g = d.length, 0 == g) c++;
                    else if (a = f + g - 1 + c, !(0 > a) && (l = this.getChildByTag(a), null != l)) {
                        switch (l = l.getPositionX() + l._getWidth() / 2, h = 0, this._alignment) {
                            case cc.TEXT_ALIGNMENT_CENTER:
                                h = this.width / 2 - l / 2;
                                break;
                            case cc.TEXT_ALIGNMENT_RIGHT:
                                h = this.width - l
                        }
                        if (0 != h)
                            for (l = 0; g > l; l++) a = f + l + c, 0 > a || !(a = this.getChildByTag(a)) || (a.x += h);
                        f += g, c++, d.length = 0
                    }
                } else d.push(this._string[f])
    },
    setAlignment: function(a) {
        this._alignment = a, this.updateLabel()
    },
    _getAlignment: function() {
        return this._alignment
    },
    setBoundingWidth: function(a) {
        this._width = a, this.updateLabel()
    },
    _getBoundingWidth: function() {
        return this._width
    },
    setLineBreakWithoutSpace: function(a) {
        this._lineBreakWithoutSpaces = a, this.updateLabel()
    },
    setScale: function(a, b) {
        cc.Node.prototype.setScale.call(this, a, b), this.updateLabel()
    },
    setScaleX: function(a) {
        cc.Node.prototype.setScaleX.call(this, a), this.updateLabel()
    },
    setScaleY: function(a) {
        cc.Node.prototype.setScaleY.call(this, a), this.updateLabel()
    },
    setFntFile: function(a) {
        if (null != a && a != this._fntFile) {
            var b = cc.loader.getRes(a);
            b ? (this._fntFile = a, this._config = b, a = cc.textureCache.addImage(b.atlasName), this._textureLoaded = b = a.isLoaded(), this.texture = a, cc._renderType === cc._RENDER_TYPE_CANVAS && (this._originalTexture = this.texture), b ? this.createFontChars() : a.addLoadedEventListener(function(a) {
                this._textureLoaded = !0, this.texture = a, this.createFontChars(), this._changeTextureColor(), this.updateLabel(), this._callLoadedEventCallbacks()
            }, this)) : cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file")
        }
    },
    getFntFile: function() {
        return this._fntFile
    },
    setAnchorPoint: function(a, b) {
        cc.Node.prototype.setAnchorPoint.call(this, a, b), this.updateLabel()
    },
    _setAnchor: function(a) {
        cc.Node.prototype._setAnchor.call(this, a), this.updateLabel()
    },
    _setAnchorX: function(a) {
        cc.Node.prototype._setAnchorX.call(this, a), this.updateLabel()
    },
    _setAnchorY: function(a) {
        cc.Node.prototype._setAnchorY.call(this, a), this.updateLabel()
    },
    _atlasNameFromFntFile: function() {},
    _kerningAmountForFirst: function(a, b) {
        var c = 0;
        if (this._configuration.kerningDictionary) {
            var d = this._configuration.kerningDictionary[(a << 16 | 65535 & b).toString()];
            d && (c = d.amount)
        }
        return c
    },
    _getLetterPosXLeft: function(a) {
        return a.getPositionX() * this._scaleX - a._getWidth() * this._scaleX * a._getAnchorX()
    },
    _getLetterPosXRight: function(a) {
        return a.getPositionX() * this._scaleX + a._getWidth() * this._scaleX * a._getAnchorX()
    },
    _isspace_unicode: function(a) {
        return a = a.charCodeAt(0), a >= 9 && 13 >= a || 32 == a || 133 == a || 160 == a || 5760 == a || a >= 8192 && 8202 >= a || 8232 == a || 8233 == a || 8239 == a || 8287 == a || 12288 == a
    },
    _utf8_trim_ws: function(a) {
        var b = a.length;
        if (!(0 >= b) && (b -= 1, this._isspace_unicode(a[b]))) {
            for (var c = b - 1; c >= 0 && this._isspace_unicode(a[c]); --c) b = c;
            this._utf8_trim_from(a, b)
        }
    },
    _utf8_trim_from: function(a, b) {
        var c = a.length;
        b >= c || 0 > b || a.splice(b, c)
    }
}), _p = cc.LabelBMFont.prototype, cc._renderType === cc._RENDER_TYPE_CANVAS && !cc.sys._supportCanvasNewBlendModes && (_p._changeTextureColor = function() {
    if (cc._renderType != cc._RENDER_TYPE_WEBGL) {
        var a, b = this.getTexture();
        b && 0 < b.getContentSize().width && (a = b.getHtmlElementObj()) && (b = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj())) && (a instanceof HTMLCanvasElement && !this._rectRotated ? cc.generateTintImage(a, b, this._displayedColor, null, a) : (a = cc.generateTintImage(a, b, this._displayedColor), b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.setTexture(b)))
    }
}), cc.defineGetterSetter(_p, "string", _p.getString, _p._setStringForSetter), cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p.setBoundingWidth), cc.defineGetterSetter(_p, "textAlign", _p._getAlignment, _p.setAlignment), cc.LabelBMFont.create = function(a, b, c, d, e) {
    return new cc.LabelBMFont(a, b, c, d, e)
}, cc._fntLoader = {
    INFO_EXP: /info [^\n]*(\n|$)/gi,
    COMMON_EXP: /common [^\n]*(\n|$)/gi,
    PAGE_EXP: /page [^\n]*(\n|$)/gi,
    CHAR_EXP: /char [^\n]*(\n|$)/gi,
    KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
    ITEM_EXP: /\w+=[^ \r\n]+/gi,
    INT_EXP: /^[\-]?\d+$/,
    _parseStrToObj: function(a) {
        a = a.match(this.ITEM_EXP);
        var b = {};
        if (a)
            for (var c = 0, d = a.length; d > c; c++) {
                var e = a[c],
                    f = e.indexOf("="),
                    g = e.substring(0, f),
                    e = e.substring(f + 1);
                e.match(this.INT_EXP) ? e = parseInt(e) : '"' == e[0] && (e = e.substring(1, e.length - 1)), b[g] = e
            }
        return b
    },
    parseFnt: function(a, b) {
        var c = {}, d = this._parseStrToObj(a.match(this.INFO_EXP)[0]).padding.split(",");
        if (parseInt(d[0]), parseInt(d[1]), parseInt(d[2]), parseInt(d[3]), d = this._parseStrToObj(a.match(this.COMMON_EXP)[0]), c.commonHeight = d.lineHeight, cc._renderType === cc._RENDER_TYPE_WEBGL) {
            var e = cc.configuration.getMaxTextureSize();
            (d.scaleW > e.width || d.scaleH > e.height) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported")
        }
        1 !== d.pages && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page"), d = this._parseStrToObj(a.match(this.PAGE_EXP)[0]), 0 !== d.id && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found"), c.atlasName = cc.path.changeBasename(b, d.file);
        for (var f = a.match(this.CHAR_EXP), g = c.fontDefDictionary = {}, d = 0, e = f.length; e > d; d++) {
            var h = this._parseStrToObj(f[d]);
            g[h.id] = {
                rect: {
                    x: h.x,
                    y: h.y,
                    width: h.width,
                    height: h.height
                },
                xOffset: h.xoffset,
                yOffset: h.yoffset,
                xAdvance: h.xadvance
            }
        }
        if (f = c.kerningDict = {}, g = a.match(this.KERNING_EXP))
            for (d = 0, e = g.length; e > d; d++) h = this._parseStrToObj(g[d]), f[h.first << 16 | 65535 & h.second] = h.amount;
        return c
    },
    load: function(a, b, c, d) {
        var e = this;
        cc.loader.loadTxt(a, function(a, c) {
            return a ? d(a) : void d(null, e.parseFnt(c, b))
        })
    }
}, cc.loader.register(["fnt"], cc._fntLoader), cc.MotionStreak = cc.Node.extend({
    texture: null,
    fastMode: !1,
    startingPositionInitialized: !1,
    _blendFunc: null,
    _stroke: 0,
    _fadeDelta: 0,
    _minSeg: 0,
    _maxPoints: 0,
    _nuPoints: 0,
    _previousNuPoints: 0,
    _pointVertexes: null,
    _pointState: null,
    _vertices: null,
    _colorPointer: null,
    _texCoords: null,
    _verticesBuffer: null,
    _colorPointerBuffer: null,
    _texCoordsBuffer: null,
    _className: "MotionStreak",
    ctor: function(a, b, c, d, e) {
        cc.Node.prototype.ctor.call(this), this._positionR = cc.p(0, 0), this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA), this._vertexWebGLBuffer = cc._renderContext.createBuffer(), this.startingPositionInitialized = this.fastMode = !1, this.texture = null, this._previousNuPoints = this._nuPoints = this._maxPoints = this._minSeg = this._fadeDelta = this._stroke = 0, this._texCoordsBuffer = this._colorPointerBuffer = this._verticesBuffer = this._texCoords = this._colorPointer = this._vertices = this._pointState = this._pointVertexes = null, void 0 !== e && this.initWithFade(a, b, c, d, e)
    },
    getTexture: function() {
        return this.texture
    },
    setTexture: function(a) {
        this.texture != a && (this.texture = a)
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        void 0 === b ? this._blendFunc = a : (this._blendFunc.src = a, this._blendFunc.dst = b)
    },
    getOpacity: function() {
        return cc.log("cc.MotionStreak.getOpacity has not been supported."), 0
    },
    setOpacity: function() {
        cc.log("cc.MotionStreak.setOpacity has not been supported.")
    },
    setOpacityModifyRGB: function() {},
    isOpacityModifyRGB: function() {
        return !1
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this), this._verticesBuffer && cc._renderContext.deleteBuffer(this._verticesBuffer), this._texCoordsBuffer && cc._renderContext.deleteBuffer(this._texCoordsBuffer), this._colorPointerBuffer && cc._renderContext.deleteBuffer(this._colorPointerBuffer)
    },
    isFastMode: function() {
        return this.fastMode
    },
    setFastMode: function(a) {
        this.fastMode = a
    },
    isStartingPositionInitialized: function() {
        return this.startingPositionInitialized
    },
    setStartingPositionInitialized: function(a) {
        this.startingPositionInitialized = a
    },
    initWithFade: function(a, b, c, d, e) {
        if (!e) throw "cc.MotionStreak.initWithFade(): Invalid filename or texture";
        return "string" == typeof e && (e = cc.textureCache.addImage(e)), cc.Node.prototype.setPosition.call(this, cc.p(0, 0)), this.anchorY = this.anchorX = 0, this.ignoreAnchor = !0, this.startingPositionInitialized = !1, this.fastMode = !0, this._minSeg = -1 == b ? c / 5 : b, this._minSeg *= this._minSeg, this._stroke = c, this._fadeDelta = 1 / a, a = (0 | 60 * a) + 2, this._nuPoints = 0, this._pointState = new Float32Array(a), this._pointVertexes = new Float32Array(2 * a), this._vertices = new Float32Array(4 * a), this._texCoords = new Float32Array(4 * a), this._colorPointer = new Uint8Array(8 * a), this._maxPoints = a, a = cc._renderContext, this._verticesBuffer = a.createBuffer(), this._texCoordsBuffer = a.createBuffer(), this._colorPointerBuffer = a.createBuffer(), this._blendFunc.src = a.SRC_ALPHA, this._blendFunc.dst = a.ONE_MINUS_SRC_ALPHA, this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR), this.texture = e, this.color = d, this.scheduleUpdate(), a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer), a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW), a.bindBuffer(a.ARRAY_BUFFER, this._texCoordsBuffer), a.bufferData(a.ARRAY_BUFFER, this._texCoords, a.DYNAMIC_DRAW), a.bindBuffer(a.ARRAY_BUFFER, this._colorPointerBuffer), a.bufferData(a.ARRAY_BUFFER, this._colorPointer, a.DYNAMIC_DRAW), !0
    },
    tintWithColor: function(a) {
        this.color = a;
        for (var b = this._colorPointer, c = 0, d = 2 * this._nuPoints; d > c; c++) b[4 * c] = a.r, b[4 * c + 1] = a.g, b[4 * c + 2] = a.b
    },
    reset: function() {
        this._nuPoints = 0
    },
    setPosition: function(a, b) {
        this.startingPositionInitialized = !0, void 0 === b ? (this._positionR.x = a.x, this._positionR.y = a.y) : (this._positionR.x = a, this._positionR.y = b)
    },
    getPositionX: function() {
        return this._positionR.x
    },
    setPositionX: function(a) {
        this._positionR.x = a, this.startingPositionInitialized || (this.startingPositionInitialized = !0)
    },
    getPositionY: function() {
        return this._positionR.y
    },
    setPositionY: function(a) {
        this._positionR.y = a, this.startingPositionInitialized || (this.startingPositionInitialized = !0)
    },
    draw: function(a) {
        !(1 >= this._nuPoints) && this.texture && this.texture.isLoaded() && (a = a || cc._renderContext, cc.nodeDrawSetup(this), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(this.texture), a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer), a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, this._texCoordsBuffer), a.bufferData(a.ARRAY_BUFFER, this._texCoords, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, this._colorPointerBuffer), a.bufferData(a.ARRAY_BUFFER, this._colorPointer, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0), a.drawArrays(a.TRIANGLE_STRIP, 0, 2 * this._nuPoints), cc.g_NumberOfDraws++)
    },
    update: function(a) {
        if (this.startingPositionInitialized) {
            a *= this._fadeDelta;
            var b, c, d, e, f = 0,
                g = this._nuPoints,
                h = this._pointState,
                i = this._pointVertexes,
                j = this._vertices,
                k = this._colorPointer;
            for (d = 0; g > d; d++) h[d] -= a, 0 >= h[d] ? f++ : (b = d - f, f > 0 ? (h[b] = h[d], i[2 * b] = i[2 * d], i[2 * b + 1] = i[2 * d + 1], e = 2 * d, c = 2 * b, j[2 * c] = j[2 * e], j[2 * c + 1] = j[2 * e + 1], j[2 * (c + 1)] = j[2 * (e + 1)], j[2 * (c + 1) + 1] = j[2 * (e + 1) + 1], e *= 4, c *= 4, k[c + 0] = k[e + 0], k[c + 1] = k[e + 1], k[c + 2] = k[e + 2], k[c + 4] = k[e + 4], k[c + 5] = k[e + 5], k[c + 6] = k[e + 6]) : c = 8 * b, b = 255 * h[b], k[c + 3] = b, k[c + 7] = b);
            if (g -= f, d = !0, g >= this._maxPoints ? d = !1 : g > 0 && (a = cc.pDistanceSQ(cc.p(i[2 * (g - 1)], i[2 * (g - 1) + 1]), this._positionR) < this._minSeg, c = 1 == g ? !1 : cc.pDistanceSQ(cc.p(i[2 * (g - 2)], i[2 * (g - 2) + 1]), this._positionR) < 2 * this._minSeg, a || c) && (d = !1), d && (i[2 * g] = this._positionR.x, i[2 * g + 1] = this._positionR.y, h[g] = 1, h = 8 * g, d = this._displayedColor, k[h] = d.r, k[h + 1] = d.g, k[h + 2] = d.b, k[h + 4] = d.r, k[h + 5] = d.g, k[h + 6] = d.b, k[h + 3] = 255, k[h + 7] = 255, g > 0 && this.fastMode && (g > 1 ? cc.vertexLineToPolygon(i, this._stroke, this._vertices, g, 1) : cc.vertexLineToPolygon(i, this._stroke, this._vertices, 0, 2)), g++), this.fastMode || cc.vertexLineToPolygon(i, this._stroke, this._vertices, 0, g), g && this._previousNuPoints != g) {
                for (i = 1 / g, k = this._texCoords, d = 0; g > d; d++) k[4 * d] = 0, k[4 * d + 1] = i * d, k[2 * (2 * d + 1)] = 1, k[2 * (2 * d + 1) + 1] = i * d;
                this._previousNuPoints = g
            }
            this._nuPoints = g
        }
    }
}), cc.MotionStreak.create = function(a, b, c, d, e) {
    return new cc.MotionStreak(a, b, c, d, e)
}, cc.NodeGrid = cc.Node.extend({
    grid: null,
    _target: null,
    getGrid: function() {
        return this.grid
    },
    setGrid: function(a) {
        this.grid = a
    },
    setTarget: function(a) {
        this._target = a
    },
    addChild: function(a, b, c) {
        cc.Node.prototype.addChild.call(this, a, b, c), a && !this._target && (this._target = a)
    },
    visit: function() {
        if (this._visible) {
            var a = cc._renderType == cc._RENDER_TYPE_WEBGL,
                b = this.grid;
            a && b && b._active && b.beforeDraw(), this.transform();
            var c = this._children;
            if (c && 0 < c.length) {
                var d = c.length;
                for (this.sortAllChildren(), i = 0; d > i; i++) {
                    var e = c[i];
                    e && e.visit()
                }
            }
            a && b && b._active && b.afterDraw(this._target)
        }
    },
    _transformForWebGL: function() {
        var a = this._transform4x4,
            b = cc.current_stack.top,
            c = this.nodeToParentTransform(),
            d = a.mat;
        d[0] = c.a, d[4] = c.c, d[12] = c.tx, d[1] = c.b, d[5] = c.d, d[13] = c.ty, d[14] = this._vertexZ, cc.kmMat4Multiply(b, b, a), null == this._camera || this.grid && this.grid.isActive() || (a = this._anchorPointInPoints.x, b = this._anchorPointInPoints.y, 0 !== a || 0 !== b ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (a |= 0, b |= 0), cc.kmGLTranslatef(a, b, 0), this._camera.locate(), cc.kmGLTranslatef(-a, -b, 0)) : this._camera.locate())
    }
}), _p = cc.NodeGrid.prototype, cc._renderType === cc._RENDER_TYPE_WEBGL && (_p.transform = _p._transformForWebGL), cc.defineGetterSetter(_p, "target", null, _p.setTarget), cc.NodeGrid.create = function() {
    return new cc.NodeGrid
}, cc.v2fzero = function() {
    return {
        x: 0,
        y: 0
    }
}, cc.v2f = function(a, b) {
    return {
        x: a,
        y: b
    }
}, cc.v2fadd = function(a, b) {
    return cc.v2f(a.x + b.x, a.y + b.y)
}, cc.v2fsub = function(a, b) {
    return cc.v2f(a.x - b.x, a.y - b.y)
}, cc.v2fmult = function(a, b) {
    return cc.v2f(a.x * b, a.y * b)
}, cc.v2fperp = function(a) {
    return cc.v2f(-a.y, a.x)
}, cc.v2fneg = function(a) {
    return cc.v2f(-a.x, -a.y)
}, cc.v2fdot = function(a, b) {
    return a.x * b.x + a.y * b.y
}, cc.v2fforangle = function(a) {
    return cc.v2f(Math.cos(a), Math.sin(a))
}, cc.v2fnormalize = function(a) {
    return a = cc.pNormalize(cc.p(a.x, a.y)), cc.v2f(a.x, a.y)
}, cc.__v2f = function(a) {
    return cc.v2f(a.x, a.y)
}, cc.__t = function(a) {
    return {
        u: a.x,
        v: a.y
    }
}, cc.DrawNodeCanvas = cc.Node.extend({
    _buffer: null,
    _blendFunc: null,
    _lineWidth: 1,
    _drawColor: null,
    _className: "DrawNodeCanvas",
    ctor: function() {
        cc.Node.prototype.ctor.call(this), this._buffer = [], this._drawColor = cc.color(255, 255, 255, 255), this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), this.init()
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = b)
    },
    setLineWidth: function(a) {
        this._lineWidth = a
    },
    getLineWidth: function() {
        return this._lineWidth
    },
    setDrawColor: function(a) {
        var b = this._drawColor;
        b.r = a.r, b.g = a.g, b.b = a.b, b.a = null == a.a ? 255 : a.a
    },
    getDrawColor: function() {
        return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
    },
    drawRect: function(a, b, c, d, e) {
        d = d || this._lineWidth, e = e || this.getDrawColor(), null == e.a && (e.a = 255), a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)], b = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY), b.verts = a, b.lineWidth = d, b.lineColor = e, b.isClosePolygon = !0, b.isStroke = !0, b.lineCap = "butt", (b.fillColor = c) && (null == c.a && (c.a = 255), b.isFill = !0), this._buffer.push(b)
    },
    drawCircle: function(a, b, c, d, e, f, g) {
        f = f || this._lineWidth, g = g || this.getDrawColor(), null == g.a && (g.a = 255);
        for (var h = 2 * Math.PI / d, i = [], j = 0; d >= j; j++) {
            var k = j * h,
                l = b * Math.cos(k + c) + a.x,
                k = b * Math.sin(k + c) + a.y;
            i.push(cc.p(l, k))
        }
        e && i.push(cc.p(a.x, a.y)), a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY), a.verts = i, a.lineWidth = f, a.lineColor = g, a.isClosePolygon = !0, a.isStroke = !0, this._buffer.push(a)
    },
    drawQuadBezier: function(a, b, c, d, e, f) {
        e = e || this._lineWidth, f = f || this.getDrawColor(), null == f.a && (f.a = 255);
        for (var g = [], h = 0, i = 0; d > i; i++) {
            var j = Math.pow(1 - h, 2) * a.x + 2 * (1 - h) * h * b.x + h * h * c.x,
                k = Math.pow(1 - h, 2) * a.y + 2 * (1 - h) * h * b.y + h * h * c.y;
            g.push(cc.p(j, k)), h += 1 / d
        }
        g.push(cc.p(c.x, c.y)), a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY), a.verts = g, a.lineWidth = e, a.lineColor = f, a.isStroke = !0, a.lineCap = "round", this._buffer.push(a)
    },
    drawCubicBezier: function(a, b, c, d, e, f, g) {
        f = f || this._lineWidth, g = g || this.getDrawColor(), null == g.a && (g.a = 255);
        for (var h = [], i = 0, j = 0; e > j; j++) {
            var k = Math.pow(1 - i, 3) * a.x + 3 * Math.pow(1 - i, 2) * i * b.x + 3 * (1 - i) * i * i * c.x + i * i * i * d.x,
                l = Math.pow(1 - i, 3) * a.y + 3 * Math.pow(1 - i, 2) * i * b.y + 3 * (1 - i) * i * i * c.y + i * i * i * d.y;
            h.push(cc.p(k, l)), i += 1 / e
        }
        h.push(cc.p(d.x, d.y)), a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY), a.verts = h, a.lineWidth = f, a.lineColor = g, a.isStroke = !0, a.lineCap = "round", this._buffer.push(a)
    },
    drawCatmullRom: function(a, b, c, d) {
        this.drawCardinalSpline(a, .5, b, c, d)
    },
    drawCardinalSpline: function(a, b, c, d, e) {
        d = d || this._lineWidth, e = e || this.getDrawColor(), null == e.a && (e.a = 255);
        for (var f, g, h = [], i = 1 / a.length, j = 0; c + 1 > j; j++) g = j / c, 1 == g ? (f = a.length - 1, g = 1) : (f = 0 | g / i, g = (g - i * f) / i), f = cc.cardinalSplineAt(cc.getControlPointAt(a, f - 1), cc.getControlPointAt(a, f - 0), cc.getControlPointAt(a, f + 1), cc.getControlPointAt(a, f + 2), b, g), h.push(f);
        a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY), a.verts = h, a.lineWidth = d, a.lineColor = e, a.isStroke = !0, a.lineCap = "round", this._buffer.push(a)
    },
    drawDot: function(a, b, c) {
        c = c || this.getDrawColor(), null == c.a && (c.a = 255);
        var d = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
        d.verts = [a], d.lineWidth = b, d.fillColor = c, this._buffer.push(d)
    },
    drawDots: function(a, b, c) {
        if (a && 0 != a.length) {
            c = c || this.getDrawColor(), null == c.a && (c.a = 255);
            for (var d = 0, e = a.length; e > d; d++) this.drawDot(a[d], b, c)
        }
    },
    drawSegment: function(a, b, c, d) {
        c = c || this._lineWidth, d = d || this.getDrawColor(), null == d.a && (d.a = 255);
        var e = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        e.verts = [a, b], e.lineWidth = 2 * c, e.lineColor = d, e.isStroke = !0, e.lineCap = "round", this._buffer.push(e)
    },
    drawPoly_: function(a, b, c, d) {
        c = c || this._lineWidth, d = d || this.getDrawColor(), null == d.a && (d.a = 255);
        var e = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        e.verts = a, e.fillColor = b, e.lineWidth = c, e.lineColor = d, e.isClosePolygon = !0, e.isStroke = !0, e.lineCap = "round", b && (e.isFill = !0), this._buffer.push(e)
    },
    drawPoly: function(a, b, c, d) {
        for (var e = [], f = 0; f < a.length; f++) e.push(cc.p(a[f].x, a[f].y));
        return this.drawPoly_(e, b, c, d)
    },
    draw: function(a) {
        a = a || cc._renderContext, this._blendFunc && this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst == cc.ONE && (a.globalCompositeOperation = "lighter");
        for (var b = 0; b < this._buffer.length; b++) {
            var c = this._buffer[b];
            switch (c.type) {
                case cc.DrawNode.TYPE_DOT:
                    this._drawDot(a, c);
                    break;
                case cc.DrawNode.TYPE_SEGMENT:
                    this._drawSegment(a, c);
                    break;
                case cc.DrawNode.TYPE_POLY:
                    this._drawPoly(a, c)
            }
        }
    },
    _drawDot: function(a, b) {
        var c = b.fillColor,
            d = b.verts[0],
            e = b.lineWidth,
            f = cc.view.getScaleX(),
            g = cc.view.getScaleY();
        a.fillStyle = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + "," + c.a / 255 + ")", a.beginPath(), a.arc(d.x * f, -d.y * g, e * f, 0, 2 * Math.PI, !1), a.closePath(), a.fill()
    },
    _drawSegment: function(a, b) {
        var c = b.lineColor,
            d = b.verts[0],
            e = b.verts[1],
            f = b.lineWidth,
            g = b.lineCap,
            h = cc.view.getScaleX(),
            i = cc.view.getScaleY();
        a.strokeStyle = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + "," + c.a / 255 + ")", a.lineWidth = f * h, a.beginPath(), a.lineCap = g, a.moveTo(d.x * h, -d.y * i), a.lineTo(e.x * h, -e.y * i), a.stroke()
    },
    _drawPoly: function(a, b) {
        var c = b.verts,
            d = b.lineCap,
            e = b.fillColor,
            f = b.lineWidth,
            g = b.lineColor,
            h = b.isClosePolygon,
            i = b.isFill,
            j = b.isStroke;
        if (null != c) {
            var k = c[0],
                l = cc.view.getScaleX(),
                m = cc.view.getScaleY();
            for (a.lineCap = d, e && (a.fillStyle = "rgba(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + "," + e.a / 255 + ")"), f && (a.lineWidth = f * l), g && (a.strokeStyle = "rgba(" + (0 | g.r) + "," + (0 | g.g) + "," + (0 | g.b) + "," + g.a / 255 + ")"), a.beginPath(), a.moveTo(k.x * l, -k.y * m), d = 1, e = c.length; e > d; d++) a.lineTo(c[d].x * l, -c[d].y * m);
            h && a.closePath(), i && a.fill(), j && a.stroke()
        }
    },
    clear: function() {
        this._buffer.length = 0
    }
}), cc.DrawNodeWebGL = cc.Node.extend({
    _bufferCapacity: 0,
    _buffer: null,
    _trianglesArrayBuffer: null,
    _trianglesWebBuffer: null,
    _trianglesReader: null,
    _lineWidth: 1,
    _drawColor: null,
    _blendFunc: null,
    _dirty: !1,
    _className: "DrawNodeWebGL",
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = b)
    },
    ctor: function() {
        cc.Node.prototype.ctor.call(this), this._buffer = [], this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), this._drawColor = cc.color(255, 255, 255, 255), this.init()
    },
    init: function() {
        return cc.Node.prototype.init.call(this) ? (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR), this._ensureCapacity(64), this._trianglesWebBuffer = cc._renderContext.createBuffer(), this._dirty = !0) : !1
    },
    setLineWidth: function(a) {
        this._lineWidth = a
    },
    getLineWidth: function() {
        return this._lineWidth
    },
    setDrawColor: function(a) {
        var b = this._drawColor;
        b.r = a.r, b.g = a.g, b.b = a.b, b.a = a.a
    },
    getDrawColor: function() {
        return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
    },
    drawRect: function(a, b, c, d, e) {
        d = d || this._lineWidth, e = e || this.getDrawColor(), null == e.a && (e.a = 255), a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)], null == c ? this._drawSegments(a, d, e, !0) : this.drawPoly(a, c, d, e)
    },
    drawCircle: function(a, b, c, d, e, f, g) {
        f = f || this._lineWidth, g = g || this.getDrawColor(), null == g.a && (g.a = 255);
        var h, i = 2 * Math.PI / d,
            j = [];
        for (h = 0; d >= h; h++) {
            var k = h * i,
                l = b * Math.cos(k + c) + a.x,
                k = b * Math.sin(k + c) + a.y;
            j.push(cc.p(l, k))
        }
        for (e && j.push(cc.p(a.x, a.y)), f *= .5, h = 0, a = j.length; a - 1 > h; h++) this.drawSegment(j[h], j[h + 1], f, g)
    },
    drawQuadBezier: function(a, b, c, d, e, f) {
        e = e || this._lineWidth, f = f || this.getDrawColor(), null == f.a && (f.a = 255);
        for (var g = [], h = 0, i = 0; d > i; i++) {
            var j = Math.pow(1 - h, 2) * a.x + 2 * (1 - h) * h * b.x + h * h * c.x,
                k = Math.pow(1 - h, 2) * a.y + 2 * (1 - h) * h * b.y + h * h * c.y;
            g.push(cc.p(j, k)), h += 1 / d
        }
        g.push(cc.p(c.x, c.y)), this._drawSegments(g, e, f, !1)
    },
    drawCubicBezier: function(a, b, c, d, e, f, g) {
        f = f || this._lineWidth, g = g || this.getDrawColor(), null == g.a && (g.a = 255);
        for (var h = [], i = 0, j = 0; e > j; j++) {
            var k = Math.pow(1 - i, 3) * a.x + 3 * Math.pow(1 - i, 2) * i * b.x + 3 * (1 - i) * i * i * c.x + i * i * i * d.x,
                l = Math.pow(1 - i, 3) * a.y + 3 * Math.pow(1 - i, 2) * i * b.y + 3 * (1 - i) * i * i * c.y + i * i * i * d.y;
            h.push(cc.p(k, l)), i += 1 / e
        }
        h.push(cc.p(d.x, d.y)), this._drawSegments(h, f, g, !1)
    },
    drawCatmullRom: function(a, b, c, d) {
        this.drawCardinalSpline(a, .5, b, c, d)
    },
    drawCardinalSpline: function(a, b, c, d, e) {
        d = d || this._lineWidth, e = e || this.getDrawColor(), null == e.a && (e.a = 255);
        for (var f, g, h = [], i = 1 / a.length, j = 0; c + 1 > j; j++) g = j / c, 1 == g ? (f = a.length - 1, g = 1) : (f = 0 | g / i, g = (g - i * f) / i), f = cc.cardinalSplineAt(cc.getControlPointAt(a, f - 1), cc.getControlPointAt(a, f - 0), cc.getControlPointAt(a, f + 1), cc.getControlPointAt(a, f + 2), b, g), h.push(f);
        for (d *= .5, a = 0, b = h.length; b - 1 > a; a++) this.drawSegment(h[a], h[a + 1], d, e)
    },
    _render: function() {
        var a = cc._renderContext;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._trianglesWebBuffer), this._dirty && (a.bufferData(a.ARRAY_BUFFER, this._trianglesArrayBuffer, a.STREAM_DRAW), this._dirty = !1);
        var b = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, b, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, b, 8), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, b, 12), a.drawArrays(a.TRIANGLES, 0, 3 * this._buffer.length), cc.incrementGLDraws(1)
    },
    _ensureCapacity: function(a) {
        var b = this._buffer;
        if (b.length + a > this._bufferCapacity) {
            var c = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
            if (this._bufferCapacity += Math.max(this._bufferCapacity, a), null == b || 0 === b.length) this._buffer = [], this._trianglesArrayBuffer = new ArrayBuffer(c * this._bufferCapacity), this._trianglesReader = new Uint8Array(this._trianglesArrayBuffer);
            else {
                a = [];
                for (var d = new ArrayBuffer(c * this._bufferCapacity), e = 0; e < b.length; e++) a[e] = new cc.V2F_C4B_T2F_Triangle(b[e].a, b[e].b, b[e].c, d, e * c);
                this._trianglesReader = new Uint8Array(d), this._trianglesArrayBuffer = d, this._buffer = a
            }
        }
    },
    draw: function() {
        cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), this._shaderProgram.use(), this._shaderProgram.setUniformsForBuiltins(), this._render()
    },
    drawDot: function(a, b, c) {
        c = c || this.getDrawColor(), null == c.a && (c.a = 255);
        var d = {
            r: 0 | c.r,
            g: 0 | c.g,
            b: 0 | c.b,
            a: 0 | c.a
        };
        c = {
            vertices: {
                x: a.x - b,
                y: a.y - b
            },
            colors: d,
            texCoords: {
                u: -1,
                v: -1
            }
        };
        var e = {
            vertices: {
                x: a.x - b,
                y: a.y + b
            },
            colors: d,
            texCoords: {
                u: -1,
                v: 1
            }
        }, f = {
                vertices: {
                    x: a.x + b,
                    y: a.y + b
                },
                colors: d,
                texCoords: {
                    u: 1,
                    v: 1
                }
            };
        a = {
            vertices: {
                x: a.x + b,
                y: a.y - b
            },
            colors: d,
            texCoords: {
                u: 1,
                v: -1
            }
        }, this._ensureCapacity(6), this._buffer.push(new cc.V2F_C4B_T2F_Triangle(c, e, f, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT)), this._buffer.push(new cc.V2F_C4B_T2F_Triangle(c, f, a, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT)), this._dirty = !0
    },
    drawDots: function(a, b, c) {
        if (a && 0 != a.length) {
            c = c || this.getDrawColor(), null == c.a && (c.a = 255);
            for (var d = 0, e = a.length; e > d; d++) this.drawDot(a[d], b, c)
        }
    },
    drawSegment: function(a, b, c, d) {
        d = d || this.getDrawColor(), null == d.a && (d.a = 255), c = c || .5 * this._lineWidth, this._ensureCapacity(18), d = {
            r: 0 | d.r,
            g: 0 | d.g,
            b: 0 | d.b,
            a: 0 | d.a
        };
        var e = cc.__v2f(a),
            f = cc.__v2f(b);
        b = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(f, e))), a = cc.v2fperp(b);
        var g = cc.v2fmult(b, c),
            h = cc.v2fmult(a, c);
        c = cc.v2fsub(f, cc.v2fadd(g, h));
        var i = cc.v2fadd(f, cc.v2fsub(g, h)),
            j = cc.v2fsub(f, g),
            f = cc.v2fadd(f, g),
            k = cc.v2fsub(e, g),
            l = cc.v2fadd(e, g),
            m = cc.v2fsub(e, cc.v2fsub(g, h)),
            e = cc.v2fadd(e, cc.v2fadd(g, h)),
            g = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
            h = this._trianglesArrayBuffer,
            n = this._buffer;
        n.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: c,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(cc.v2fadd(b, a)))
        }, {
            vertices: i,
            colors: d,
            texCoords: cc.__t(cc.v2fsub(b, a))
        }, {
            vertices: j,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, h, n.length * g)), n.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: f,
            colors: d,
            texCoords: cc.__t(b)
        }, {
            vertices: i,
            colors: d,
            texCoords: cc.__t(cc.v2fsub(b, a))
        }, {
            vertices: j,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, h, n.length * g)), n.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: f,
            colors: d,
            texCoords: cc.__t(b)
        }, {
            vertices: k,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, {
            vertices: j,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, h, n.length * g)), n.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: f,
            colors: d,
            texCoords: cc.__t(b)
        }, {
            vertices: k,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, {
            vertices: l,
            colors: d,
            texCoords: cc.__t(b)
        }, h, n.length * g)), n.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: m,
            colors: d,
            texCoords: cc.__t(cc.v2fsub(a, b))
        }, {
            vertices: k,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, {
            vertices: l,
            colors: d,
            texCoords: cc.__t(b)
        }, h, n.length * g)), n.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: m,
            colors: d,
            texCoords: cc.__t(cc.v2fsub(a, b))
        }, {
            vertices: e,
            colors: d,
            texCoords: cc.__t(cc.v2fadd(b, a))
        }, {
            vertices: l,
            colors: d,
            texCoords: cc.__t(b)
        }, h, n.length * g)), this._dirty = !0
    },
    drawPoly: function(a, b, c, d) {
        if (null == b) this._drawSegments(a, c, d, !0);
        else {
            null == b.a && (b.a = 255), null == d.a && (d.a = 255), c = c || this._lineWidth, c *= .5, b = {
                r: 0 | b.r,
                g: 0 | b.g,
                b: 0 | b.b,
                a: 0 | b.a
            }, d = {
                r: 0 | d.r,
                g: 0 | d.g,
                b: 0 | d.b,
                a: 0 | d.a
            };
            var e, f, g, h, i = [],
                j = a.length;
            for (e = 0; j > e; e++) {
                f = cc.__v2f(a[(e - 1 + j) % j]), g = cc.__v2f(a[e]), h = cc.__v2f(a[(e + 1) % j]);
                var k = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(g, f)));
                g = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(h, g))), k = cc.v2fmult(cc.v2fadd(k, g), 1 / (cc.v2fdot(k, g) + 1)), i[e] = {
                    offset: k,
                    n: g
                }
            }
            k = c > 0, this._ensureCapacity(3 * (3 * j - 2));
            var l = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
                m = this._trianglesArrayBuffer,
                n = this._buffer,
                o = 0 == k ? .5 : 0;
            for (e = 0; j - 2 > e; e++) f = cc.v2fsub(cc.__v2f(a[0]), cc.v2fmult(i[0].offset, o)), g = cc.v2fsub(cc.__v2f(a[e + 1]), cc.v2fmult(i[e + 1].offset, o)), h = cc.v2fsub(cc.__v2f(a[e + 2]), cc.v2fmult(i[e + 2].offset, o)), n.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: f,
                colors: b,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: g,
                colors: b,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: h,
                colors: b,
                texCoords: cc.__t(cc.v2fzero())
            }, m, n.length * l));
            for (e = 0; j > e; e++) {
                o = (e + 1) % j, f = cc.__v2f(a[e]), g = cc.__v2f(a[o]), h = i[e].n;
                var p = i[e].offset,
                    q = i[o].offset,
                    o = k ? cc.v2fsub(f, cc.v2fmult(p, c)) : cc.v2fsub(f, cc.v2fmult(p, .5)),
                    r = k ? cc.v2fsub(g, cc.v2fmult(q, c)) : cc.v2fsub(g, cc.v2fmult(q, .5));
                f = k ? cc.v2fadd(f, cc.v2fmult(p, c)) : cc.v2fadd(f, cc.v2fmult(p, .5)), g = k ? cc.v2fadd(g, cc.v2fmult(q, c)) : cc.v2fadd(g, cc.v2fmult(q, .5)), k ? (n.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: o,
                    colors: d,
                    texCoords: cc.__t(cc.v2fneg(h))
                }, {
                    vertices: r,
                    colors: d,
                    texCoords: cc.__t(cc.v2fneg(h))
                }, {
                    vertices: g,
                    colors: d,
                    texCoords: cc.__t(h)
                }, m, n.length * l)), n.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: o,
                    colors: d,
                    texCoords: cc.__t(cc.v2fneg(h))
                }, {
                    vertices: f,
                    colors: d,
                    texCoords: cc.__t(h)
                }, {
                    vertices: g,
                    colors: d,
                    texCoords: cc.__t(h)
                }, m, n.length * l))) : (n.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: o,
                    colors: b,
                    texCoords: cc.__t(cc.v2fzero())
                }, {
                    vertices: r,
                    colors: b,
                    texCoords: cc.__t(cc.v2fzero())
                }, {
                    vertices: g,
                    colors: b,
                    texCoords: cc.__t(h)
                }, m, n.length * l)), n.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: o,
                    colors: b,
                    texCoords: cc.__t(cc.v2fzero())
                }, {
                    vertices: f,
                    colors: b,
                    texCoords: cc.__t(h)
                }, {
                    vertices: g,
                    colors: b,
                    texCoords: cc.__t(h)
                }, m, n.length * l)))
            }
            this._dirty = !0
        }
    },
    _drawSegments: function(a, b, c, d) {
        if (b = b || this._lineWidth, c = c || this._drawColor, null == c.a && (c.a = 255), b *= .5, !(0 >= b)) {
            c = {
                r: 0 | c.r,
                g: 0 | c.g,
                b: 0 | c.b,
                a: 0 | c.a
            };
            var e, f, g, h, i = [],
                j = a.length;
            for (e = 0; j > e; e++) {
                f = cc.__v2f(a[(e - 1 + j) % j]), g = cc.__v2f(a[e]), h = cc.__v2f(a[(e + 1) % j]);
                var k = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(g, f)));
                g = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(h, g))), h = cc.v2fmult(cc.v2fadd(k, g), 1 / (cc.v2fdot(k, g) + 1)), i[e] = {
                    offset: h,
                    n: g
                }
            }
            this._ensureCapacity(3 * (3 * j - 2)), h = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
            var k = this._trianglesArrayBuffer,
                l = this._buffer;
            for (d = d ? j : j - 1, e = 0; d > e; e++) {
                var m = (e + 1) % j;
                f = cc.__v2f(a[e]), g = cc.__v2f(a[m]);
                var n = i[e].n,
                    o = i[e].offset,
                    p = i[m].offset,
                    m = cc.v2fsub(f, cc.v2fmult(o, b)),
                    q = cc.v2fsub(g, cc.v2fmult(p, b));
                f = cc.v2fadd(f, cc.v2fmult(o, b)), g = cc.v2fadd(g, cc.v2fmult(p, b)), l.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: m,
                    colors: c,
                    texCoords: cc.__t(cc.v2fneg(n))
                }, {
                    vertices: q,
                    colors: c,
                    texCoords: cc.__t(cc.v2fneg(n))
                }, {
                    vertices: g,
                    colors: c,
                    texCoords: cc.__t(n)
                }, k, l.length * h)), l.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: m,
                    colors: c,
                    texCoords: cc.__t(cc.v2fneg(n))
                }, {
                    vertices: f,
                    colors: c,
                    texCoords: cc.__t(n)
                }, {
                    vertices: g,
                    colors: c,
                    texCoords: cc.__t(n)
                }, k, l.length * h))
            }
            this._dirty = !0
        }
    },
    clear: function() {
        this._buffer.length = 0, this._dirty = !0
    }
}), cc.DrawNode = cc._renderType == cc._RENDER_TYPE_WEBGL ? cc.DrawNodeWebGL : cc.DrawNodeCanvas, cc.DrawNode.create = function() {
    return new cc.DrawNode
}, cc._DrawNodeElement = function(a, b, c, d, e, f, g, h, i) {
    this.type = a, this.verts = b || null, this.fillColor = c || null, this.lineWidth = d || 0, this.lineColor = e || null, this.lineCap = f || "butt", this.isClosePolygon = g || !1, this.isFill = h || !1, this.isStroke = i || !1
}, cc.DrawNode.TYPE_DOT = 0, cc.DrawNode.TYPE_SEGMENT = 1, cc.DrawNode.TYPE_POLY = 2, cc.stencilBits = -1, cc.setProgram = function(a, b) {
    a.shaderProgram = b;
    var c = a.children;
    if (c)
        for (var d = 0; d < c.length; d++) cc.setProgram(c[d], b)
}, cc.ClippingNode = cc.Node.extend({
    alphaThreshold: 0,
    inverted: !1,
    _stencil: null,
    _godhelpme: !1,
    ctor: function(a) {
        cc.Node.prototype.ctor.call(this), this._stencil = null, this.alphaThreshold = 0, this.inverted = !1, cc.ClippingNode.prototype.init.call(this, a || null)
    },
    init: null,
    _className: "ClippingNode",
    _initForWebGL: function(a) {
        return this._stencil = a, this.alphaThreshold = 1, this.inverted = !1, cc.ClippingNode._init_once = !0, cc.ClippingNode._init_once && (cc.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS), 0 >= cc.stencilBits && cc.log("Stencil buffer is not enabled."), cc.ClippingNode._init_once = !1), !0
    },
    _initForCanvas: function(a) {
        this._stencil = a, this.alphaThreshold = 1, this.inverted = !1
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this), this._stencil.onEnter()
    },
    onEnterTransitionDidFinish: function() {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this), this._stencil.onEnterTransitionDidFinish()
    },
    onExitTransitionDidStart: function() {
        this._stencil.onExitTransitionDidStart(), cc.Node.prototype.onExitTransitionDidStart.call(this)
    },
    onExit: function() {
        this._stencil.onExit(), cc.Node.prototype.onExit.call(this)
    },
    visit: null,
    _visitForWebGL: function(a) {
        var b = a || cc._renderContext;
        if (1 > cc.stencilBits) cc.Node.prototype.visit.call(this, a);
        else if (this._stencil && this._stencil.visible)
            if (cc.ClippingNode._layer + 1 == cc.stencilBits) cc.ClippingNode._visit_once = !0, cc.ClippingNode._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs."), cc.ClippingNode._visit_once = !1), cc.Node.prototype.visit.call(this, a);
            else {
                cc.ClippingNode._layer++;
                var c = 1 << cc.ClippingNode._layer,
                    d = c | c - 1,
                    e = b.isEnabled(b.STENCIL_TEST),
                    f = b.getParameter(b.STENCIL_WRITEMASK),
                    g = b.getParameter(b.STENCIL_FUNC),
                    h = b.getParameter(b.STENCIL_REF),
                    i = b.getParameter(b.STENCIL_VALUE_MASK),
                    j = b.getParameter(b.STENCIL_FAIL),
                    k = b.getParameter(b.STENCIL_PASS_DEPTH_FAIL),
                    l = b.getParameter(b.STENCIL_PASS_DEPTH_PASS);
                b.enable(b.STENCIL_TEST), b.stencilMask(c);
                var m = b.getParameter(b.DEPTH_WRITEMASK);
                if (b.depthMask(!1), b.stencilFunc(b.NEVER, c, c), b.stencilOp(this.inverted ? b.REPLACE : b.ZERO, b.KEEP, b.KEEP), cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLPushMatrix(), cc.kmGLLoadIdentity(), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPushMatrix(), cc.kmGLLoadIdentity(), cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255)), cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLPopMatrix(), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPopMatrix(), b.stencilFunc(b.NEVER, c, c), b.stencilOp(this.inverted ? b.ZERO : b.REPLACE, b.KEEP, b.KEEP), 1 > this.alphaThreshold) {
                    var c = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST),
                        n = b.getUniformLocation(c.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S);
                    cc.glUseProgram(c.getProgram()), c.setUniformLocationWith1f(n, this.alphaThreshold), cc.setProgram(this._stencil, c)
                }
                cc.kmGLPushMatrix(), this.transform(), this._stencil.visit(), cc.kmGLPopMatrix(), b.depthMask(m), b.stencilFunc(b.EQUAL, d, d), b.stencilOp(b.KEEP, b.KEEP, b.KEEP), cc.Node.prototype.visit.call(this, a), b.stencilFunc(g, h, i), b.stencilOp(j, k, l), b.stencilMask(f), e || b.disable(b.STENCIL_TEST), cc.ClippingNode._layer--
            } else this.inverted && cc.Node.prototype.visit.call(this, a)
    },
    _visitForCanvas: function(a) {
        if (this._stencil && this._stencil.visible) {
            a = a || cc._renderContext;
            var b = a.canvas;
            if (this._cangodhelpme() || this._stencil instanceof cc.Sprite) {
                var c = cc.ClippingNode._getSharedCache();
                c.width = b.width, c.height = b.height, c.getContext("2d").drawImage(b, 0, 0), a.save(), cc.Node.prototype.visit.call(this, a), a.globalCompositeOperation = this.inverted ? "destination-out" : "destination-in", this.transform(a), this._stencil.visit(), a.restore(), a.save(), a.setTransform(1, 0, 0, 1, 0, 0), a.globalCompositeOperation = "destination-over", a.drawImage(c, 0, 0)
            } else {
                var d, c = this._children;
                a.save(), this.transform(a), this._stencil.visit(a), this.inverted && (a.save(), a.setTransform(1, 0, 0, 1, 0, 0), a.moveTo(0, 0), a.lineTo(0, b.height), a.lineTo(b.width, b.height), a.lineTo(b.width, 0), a.lineTo(0, 0), a.restore()), a.clip(), this._cangodhelpme(!0);
                var e = c.length;
                if (e > 0) {
                    for (this.sortAllChildren(), b = 0; e > b && (d = c[b], 0 > d._localZOrder); b++) d.visit(a);
                    for (this.draw(a); e > b; b++) c[b].visit(a)
                } else this.draw(a);
                this._cangodhelpme(!1)
            }
            a.restore()
        } else this.inverted && cc.Node.prototype.visit.call(this, a)
    },
    getStencil: function() {
        return this._stencil
    },
    setStencil: null,
    _setStencilForWebGL: function(a) {
        this._stencil = a
    },
    _setStencilForCanvas: function(a) {
        this._stencil = a;
        var b = cc._renderContext;
        !(a instanceof cc.Sprite) && a instanceof cc.DrawNode && (a.draw = function() {
            var c = cc.view.getScaleX(),
                d = cc.view.getScaleY();
            b.beginPath();
            for (var e = 0; e < a._buffer.length; e++) {
                var f = a._buffer[e].verts,
                    g = f[0];
                b.moveTo(g.x * c, -g.y * d);
                for (var g = 1, h = f.length; h > g; g++) b.lineTo(f[g].x * c, -f[g].y * d)
            }
        })
    },
    getAlphaThreshold: function() {
        return this.alphaThreshold
    },
    setAlphaThreshold: function(a) {
        this.alphaThreshold = a
    },
    isInverted: function() {
        return this.inverted
    },
    setInverted: function(a) {
        this.inverted = a
    },
    _cangodhelpme: function(a) {
        return (!0 === a || !1 === a) && (cc.ClippingNode.prototype._godhelpme = a), cc.ClippingNode.prototype._godhelpme
    }
}), _p = cc.ClippingNode.prototype, cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.init = _p._initForWebGL, _p.visit = _p._visitForWebGL, _p.setStencil = _p._setStencilForWebGL) : (_p.init = _p._initForCanvas, _p.visit = _p._visitForCanvas, _p.setStencil = _p._setStencilForCanvas), cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil), cc.ClippingNode._init_once = null, cc.ClippingNode._visit_once = null, cc.ClippingNode._layer = -1, cc.ClippingNode._sharedCache = null, cc.ClippingNode._getSharedCache = function() {
    return cc.ClippingNode._sharedCache || (cc.ClippingNode._sharedCache = document.createElement("canvas"))
}, cc.ClippingNode.create = function(a) {
    return new cc.ClippingNode(a)
}, cc.GridBase = cc.Class.extend({
    _active: !1,
    _reuseGrid: 0,
    _gridSize: null,
    _texture: null,
    _step: null,
    _grabber: null,
    _isTextureFlipped: !1,
    _shaderProgram: null,
    _directorProjection: 0,
    _dirty: !1,
    ctor: function(a, b, c) {
        cc._checkWebGLRenderMode(), this._active = !1, this._reuseGrid = 0, this._texture = this._gridSize = null, this._step = cc.p(0, 0), this._grabber = null, this._isTextureFlipped = !1, this._shaderProgram = null, this._directorProjection = 0, this._dirty = !1, void 0 !== a && this.initWithSize(a, b, c)
    },
    isActive: function() {
        return this._active
    },
    setActive: function(a) {
        if (this._active = a, !a) {
            a = cc.director;
            var b = a.getProjection();
            a.setProjection(b)
        }
    },
    getReuseGrid: function() {
        return this._reuseGrid
    },
    setReuseGrid: function(a) {
        this._reuseGrid = a
    },
    getGridSize: function() {
        return cc.size(this._gridSize.width, this._gridSize.height)
    },
    setGridSize: function(a) {
        this._gridSize.width = parseInt(a.width), this._gridSize.height = parseInt(a.height)
    },
    getStep: function() {
        return cc.p(this._step.x, this._step.y)
    },
    setStep: function(a) {
        this._step.x = a.x, this._step.y = a.y
    },
    isTextureFlipped: function() {
        return this._isTextureFlipped
    },
    setTextureFlipped: function(a) {
        this._isTextureFlipped != a && (this._isTextureFlipped = a, this.calculateVertexPoints())
    },
    initWithSize: function(a, b, c) {
        if (!b) {
            var d = cc.director.getWinSizeInPixels(),
                e = cc.NextPOT(d.width),
                f = cc.NextPOT(d.height),
                g = new Uint8Array(4 * e * f);
            if (!g) return cc.log("cocos2d: CCGrid: not enough memory."), !1;
            if (b = new cc.Texture2D, b.initWithData(g, cc.Texture2D.PIXEL_FORMAT_RGBA8888, e, f, d), !b) return cc.log("cocos2d: CCGrid: error creating texture"), !1
        }
        return this._active = !1, this._reuseGrid = 0, this._gridSize = a, this._texture = b, this._isTextureFlipped = c || !1, this._step.x = this._texture.width / a.width, this._step.y = this._texture.height / a.height, this._grabber = new cc.Grabber, this._grabber ? (this._grabber.grab(this._texture), this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), this.calculateVertexPoints(), !0) : !1
    },
    beforeDraw: function() {
        this._directorProjection = cc.director.getProjection(), this.set2DProjection(), this._grabber.beforeRender(this._texture)
    },
    afterDraw: function(a) {
        if (this._grabber.afterRender(this._texture), cc.director.setProjection(this._directorProjection), a.getCamera().isDirty()) {
            var b = a.getAnchorPointInPoints();
            cc.kmGLTranslatef(b.x, b.y, 0), a.getCamera().locate(), cc.kmGLTranslatef(-b.x, -b.y, 0)
        }
        cc.glBindTexture2D(this._texture), this.blit()
    },
    blit: function() {
        cc.log("cc.GridBase.blit(): Shall be overridden in subclass.")
    },
    reuse: function() {
        cc.log("cc.GridBase.reuse(): Shall be overridden in subclass.")
    },
    calculateVertexPoints: function() {
        cc.log("cc.GridBase.calculateVertexPoints(): Shall be overridden in subclass.")
    },
    set2DProjection: function() {
        var a = cc.director.getWinSizeInPixels();
        cc._renderContext.viewport(0, 0, a.width, a.height), cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLLoadIdentity();
        var b = new cc.kmMat4;
        cc.kmMat4OrthographicProjection(b, 0, a.width, 0, a.height, -1, 1), cc.kmGLMultMatrix(b), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLLoadIdentity(), cc.setProjectionMatrixDirty()
    }
}), cc.GridBase.create = function(a, b, c) {
    return new cc.GridBase(a, b, c)
}, cc.Grid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function(a, b, c) {
        cc.GridBase.prototype.ctor.call(this), this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null, void 0 !== a && this.initWithSize(a, b, c)
    },
    vertex: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.vertex() : Numbers must be integers"), a = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y);
        var b = this._vertices;
        return new cc.Vertex3F(b[a], b[a + 1], b[a + 2])
    },
    originalVertex: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.originalVertex() : Numbers must be integers"), a = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y);
        var b = this._originalVertices;
        return new cc.Vertex3F(b[a], b[a + 1], b[a + 2])
    },
    setVertex: function(a, b) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.setVertex() : Numbers must be integers");
        var c = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y),
            d = this._vertices;
        d[c] = b.x, d[c + 1] = b.y, d[c + 2] = b.z, this._dirty = !0
    },
    blit: function() {
        var a = this._gridSize.width * this._gridSize.height;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS), this._shaderProgram.use(), this._shaderProgram.setUniformsForBuiltins();
        var b = cc._renderContext,
            c = this._dirty;
        b.bindBuffer(b.ARRAY_BUFFER, this._verticesBuffer), c && b.bufferData(b.ARRAY_BUFFER, this._vertices, b.DYNAMIC_DRAW), b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, b.FLOAT, !1, 0, 0), b.bindBuffer(b.ARRAY_BUFFER, this._texCoordinateBuffer), c && b.bufferData(b.ARRAY_BUFFER, this._texCoordinates, b.DYNAMIC_DRAW), b.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, b.FLOAT, !1, 0, 0), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indicesBuffer), c && b.bufferData(b.ELEMENT_ARRAY_BUFFER, this._indices, b.STATIC_DRAW), b.drawElements(b.TRIANGLES, 6 * a, b.UNSIGNED_SHORT, 0), c && (this._dirty = !1), cc.incrementGLDraws(1)
    },
    reuse: function() {
        if (0 < this._reuseGrid) {
            for (var a = this._originalVertices, b = this._vertices, c = 0, d = this._vertices.length; d > c; c++) a[c] = b[c];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function() {
        var a = cc._renderContext,
            b = this._texture.pixelsWidth,
            c = this._texture.pixelsHeight,
            d = this._texture.getContentSizeInPixels().height,
            e = this._gridSize,
            f = (e.width + 1) * (e.height + 1);
        this._vertices = new Float32Array(3 * f), this._texCoordinates = new Float32Array(2 * f), this._indices = new Uint16Array(6 * e.width * e.height), this._verticesBuffer && a.deleteBuffer(this._verticesBuffer), this._verticesBuffer = a.createBuffer(), this._texCoordinateBuffer && a.deleteBuffer(this._texCoordinateBuffer), this._texCoordinateBuffer = a.createBuffer(), this._indicesBuffer && a.deleteBuffer(this._indicesBuffer), this._indicesBuffer = a.createBuffer();
        for (var g, h, i = this._indices, j = this._texCoordinates, k = this._isTextureFlipped, l = this._vertices, f = 0; f < e.width; ++f)
            for (g = 0; g < e.height; ++g) {
                var m = g * e.width + f;
                h = f * this._step.x;
                var n = h + this._step.x,
                    o = g * this._step.y,
                    p = o + this._step.y,
                    q = f * (e.height + 1) + g,
                    r = (f + 1) * (e.height + 1) + g,
                    s = (f + 1) * (e.height + 1) + (g + 1),
                    t = f * (e.height + 1) + (g + 1);
                i[6 * m] = q, i[6 * m + 1] = r, i[6 * m + 2] = t, i[6 * m + 3] = r, i[6 * m + 4] = s, i[6 * m + 5] = t;
                var m = [3 * q, 3 * r, 3 * s, 3 * t],
                    u = [{
                        x: h,
                        y: o,
                        z: 0
                    }, {
                        x: n,
                        y: o,
                        z: 0
                    }, {
                        x: n,
                        y: p,
                        z: 0
                    }, {
                        x: h,
                        y: p,
                        z: 0
                    }],
                    q = [2 * q, 2 * r, 2 * s, 2 * t],
                    n = [cc.p(h, o), cc.p(n, o), cc.p(n, p), cc.p(h, p)];
                for (h = 0; 4 > h; ++h) l[m[h]] = u[h].x, l[m[h] + 1] = u[h].y, l[m[h] + 2] = u[h].z, j[q[h]] = n[h].x / b, j[q[h] + 1] = k ? (d - n[h].y) / c : n[h].y / c
            }
        this._originalVertices = new Float32Array(this._vertices), a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer), a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW), a.bindBuffer(a.ARRAY_BUFFER, this._texCoordinateBuffer), a.bufferData(a.ARRAY_BUFFER, this._texCoordinates, a.DYNAMIC_DRAW), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indicesBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW), this._dirty = !0
    }
}), cc.Grid3D.create = function(a, b, c) {
    return new cc.Grid3D(a, b, c)
}, cc.TiledGrid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function(a, b, c) {
        cc.GridBase.prototype.ctor.call(this), this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null, void 0 !== a && this.initWithSize(a, b, c)
    },
    tile: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.tile() : Numbers must be integers"), a = 12 * (this._gridSize.height * a.x + a.y);
        var b = this._vertices;
        return new cc.Quad3(new cc.Vertex3F(b[a], b[a + 1], b[a + 2]), new cc.Vertex3F(b[a + 3], b[a + 4], b[a + 5]), new cc.Vertex3F(b[a + 6], b[a + 7], b[a + 8]), new cc.Vertex3F(b[a + 9], b[a + 10], b[a + 11]))
    },
    originalTile: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.originalTile() : Numbers must be integers"), a = 12 * (this._gridSize.height * a.x + a.y);
        var b = this._originalVertices;
        return new cc.Quad3(new cc.Vertex3F(b[a], b[a + 1], b[a + 2]), new cc.Vertex3F(b[a + 3], b[a + 4], b[a + 5]), new cc.Vertex3F(b[a + 6], b[a + 7], b[a + 8]), new cc.Vertex3F(b[a + 9], b[a + 10], b[a + 11]))
    },
    setTile: function(a, b) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.setTile() : Numbers must be integers");
        var c = 12 * (this._gridSize.height * a.x + a.y),
            d = this._vertices;
        d[c] = b.bl.x, d[c + 1] = b.bl.y, d[c + 2] = b.bl.z, d[c + 3] = b.br.x, d[c + 4] = b.br.y, d[c + 5] = b.br.z, d[c + 6] = b.tl.x, d[c + 7] = b.tl.y, d[c + 8] = b.tl.z, d[c + 9] = b.tr.x, d[c + 10] = b.tr.y, d[c + 11] = b.tr.z, this._dirty = !0
    },
    blit: function() {
        var a = this._gridSize.width * this._gridSize.height;
        this._shaderProgram.use(), this._shaderProgram.setUniformsForBuiltins();
        var b = cc._renderContext,
            c = this._dirty;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS), b.bindBuffer(b.ARRAY_BUFFER, this._verticesBuffer), c && b.bufferData(b.ARRAY_BUFFER, this._vertices, b.DYNAMIC_DRAW), b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, b.FLOAT, !1, 0, this._vertices), b.bindBuffer(b.ARRAY_BUFFER, this._texCoordinateBuffer), c && b.bufferData(b.ARRAY_BUFFER, this._texCoordinates, b.DYNAMIC_DRAW), b.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, b.FLOAT, !1, 0, this._texCoordinates), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indicesBuffer), c && b.bufferData(b.ELEMENT_ARRAY_BUFFER, this._indices, b.STATIC_DRAW), b.drawElements(b.TRIANGLES, 6 * a, b.UNSIGNED_SHORT, 0), c && (this._dirty = !1), cc.incrementGLDraws(1)
    },
    reuse: function() {
        if (0 < this._reuseGrid) {
            for (var a = this._vertices, b = this._originalVertices, c = 0; c < a.length; c++) b[c] = a[c];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function() {
        var a = this._texture.pixelsWidth,
            b = this._texture.pixelsHeight,
            c = this._texture.getContentSizeInPixels().height,
            d = this._gridSize,
            e = d.width * d.height;
        this._vertices = new Float32Array(12 * e), this._texCoordinates = new Float32Array(8 * e), this._indices = new Uint16Array(6 * e);
        var f = cc._renderContext;
        this._verticesBuffer && f.deleteBuffer(this._verticesBuffer), this._verticesBuffer = f.createBuffer(), this._texCoordinateBuffer && f.deleteBuffer(this._texCoordinateBuffer), this._texCoordinateBuffer = f.createBuffer(), this._indicesBuffer && f.deleteBuffer(this._indicesBuffer), this._indicesBuffer = f.createBuffer();
        var g, h, i = 0,
            j = this._step,
            k = this._vertices,
            l = this._texCoordinates,
            m = this._isTextureFlipped;
        for (g = 0; g < d.width; g++)
            for (h = 0; h < d.height; h++) {
                var n = g * j.x,
                    o = n + j.x,
                    p = h * j.y,
                    q = p + j.y;
                k[12 * i] = n, k[12 * i + 1] = p, k[12 * i + 2] = 0, k[12 * i + 3] = o, k[12 * i + 4] = p, k[12 * i + 5] = 0, k[12 * i + 6] = n, k[12 * i + 7] = q, k[12 * i + 8] = 0, k[12 * i + 9] = o, k[12 * i + 10] = q, k[12 * i + 11] = 0;
                var r = p,
                    s = q;
                m && (r = c - p, s = c - q), l[8 * i] = n / a, l[8 * i + 1] = r / b, l[8 * i + 2] = o / a, l[8 * i + 3] = r / b, l[8 * i + 4] = n / a, l[8 * i + 5] = s / b, l[8 * i + 6] = o / a, l[8 * i + 7] = s / b, i++
            }
        for (a = this._indices, g = 0; e > g; g++) a[6 * g + 0] = 4 * g + 0, a[6 * g + 1] = 4 * g + 1, a[6 * g + 2] = 4 * g + 2, a[6 * g + 3] = 4 * g + 1, a[6 * g + 4] = 4 * g + 2, a[6 * g + 5] = 4 * g + 3;
        this._originalVertices = new Float32Array(this._vertices), f.bindBuffer(f.ARRAY_BUFFER, this._verticesBuffer), f.bufferData(f.ARRAY_BUFFER, this._vertices, f.DYNAMIC_DRAW), f.bindBuffer(f.ARRAY_BUFFER, this._texCoordinateBuffer), f.bufferData(f.ARRAY_BUFFER, this._texCoordinates, f.DYNAMIC_DRAW), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this._indicesBuffer), f.bufferData(f.ELEMENT_ARRAY_BUFFER, this._indices, f.DYNAMIC_DRAW), this._dirty = !0
    }
}), cc.TiledGrid3D.create = function(a, b, c) {
    return new cc.TiledGrid3D(a, b, c)
}, cc.Grabber = cc.Class.extend({
    _FBO: null,
    _oldFBO: null,
    _oldClearColor: null,
    _gl: null,
    ctor: function() {
        cc._checkWebGLRenderMode(), this._gl = cc._renderContext, this._oldClearColor = [0, 0, 0, 0], this._oldFBO = null, this._FBO = this._gl.createFramebuffer()
    },
    grab: function(a) {
        var b = this._gl;
        this._oldFBO = b.getParameter(b.FRAMEBUFFER_BINDING), b.bindFramebuffer(b.FRAMEBUFFER, this._FBO), b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, a._webTextureObj, 0), b.checkFramebufferStatus(b.FRAMEBUFFER) != b.FRAMEBUFFER_COMPLETE && cc.log("Frame Grabber: could not attach texture to frmaebuffer"), b.bindFramebuffer(b.FRAMEBUFFER, this._oldFBO)
    },
    beforeRender: function(a) {
        a = this._gl, this._oldFBO = a.getParameter(a.FRAMEBUFFER_BINDING), a.bindFramebuffer(a.FRAMEBUFFER, this._FBO), this._oldClearColor = a.getParameter(a.COLOR_CLEAR_VALUE), a.clearColor(0, 0, 0, 0), a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
    },
    afterRender: function(a) {
        a = this._gl, a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO), a.colorMask(!0, !0, !0, !0)
    },
    destroy: function() {
        this._gl.deleteFramebuffer(this._FBO)
    }
}), cc.ACTION_TAG_INVALID = -1, cc.Action = cc.Class.extend({
    originalTarget: null,
    target: null,
    tag: cc.ACTION_TAG_INVALID,
    ctor: function() {
        this.target = this.originalTarget = null, this.tag = cc.ACTION_TAG_INVALID
    },
    copy: function() {
        return cc.log("copy is deprecated. Please use clone instead."), this.clone()
    },
    clone: function() {
        var a = new cc.Action;
        return a.originalTarget = null, a.target = null, a.tag = this.tag, a
    },
    isDone: function() {
        return !0
    },
    startWithTarget: function(a) {
        this.target = this.originalTarget = a
    },
    stop: function() {
        this.target = null
    },
    step: function() {
        cc.log("[Action step]. override me")
    },
    update: function() {
        cc.log("[Action update]. override me")
    },
    getTarget: function() {
        return this.target
    },
    setTarget: function(a) {
        this.target = a
    },
    getOriginalTarget: function() {
        return this.originalTarget
    },
    setOriginalTarget: function(a) {
        this.originalTarget = a
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(a) {
        this.tag = a
    },
    retain: function() {},
    release: function() {}
}), cc.action = function() {
    return new cc.Action
}, cc.Action.create = cc.action, cc.FiniteTimeAction = cc.Action.extend({
    _duration: 0,
    ctor: function() {
        cc.Action.prototype.ctor.call(this), this._duration = 0
    },
    getDuration: function() {
        return this._duration * (this._times || 1)
    },
    setDuration: function(a) {
        this._duration = a
    },
    reverse: function() {
        return cc.log("cocos2d: FiniteTimeAction#reverse: Implement me"), null
    },
    clone: function() {
        return new cc.FiniteTimeAction
    }
}), cc.Speed = cc.Action.extend({
    _speed: 0,
    _innerAction: null,
    ctor: function(a, b) {
        cc.Action.prototype.ctor.call(this), this._speed = 0, this._innerAction = null, a && this.initWithAction(a, b)
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(a) {
        this._speed = a
    },
    initWithAction: function(a, b) {
        if (!a) throw "cc.Speed.initWithAction(): action must be non nil";
        return this._innerAction = a, this._speed = b, !0
    },
    clone: function() {
        var a = new cc.Speed;
        return a.initWithAction(this._innerAction.clone(), this._speed), a
    },
    startWithTarget: function(a) {
        cc.Action.prototype.startWithTarget.call(this, a), this._innerAction.startWithTarget(a)
    },
    stop: function() {
        this._innerAction.stop(), cc.Action.prototype.stop.call(this)
    },
    step: function(a) {
        this._innerAction.step(a * this._speed)
    },
    isDone: function() {
        return this._innerAction.isDone()
    },
    reverse: function() {
        return new cc.Speed(this._innerAction.reverse(), this._speed)
    },
    setInnerAction: function(a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
}), cc.speed = function(a, b) {
    return new cc.Speed(a, b)
}, cc.Speed.create = cc.speed, cc.Follow = cc.Action.extend({
    _followedNode: null,
    _boundarySet: !1,
    _boundaryFullyCovered: !1,
    _halfScreenSize: null,
    _fullScreenSize: null,
    _worldRect: null,
    leftBoundary: 0,
    rightBoundary: 0,
    topBoundary: 0,
    bottomBoundary: 0,
    ctor: function(a, b) {
        cc.Action.prototype.ctor.call(this), this._followedNode = null, this._boundaryFullyCovered = this._boundarySet = !1, this._fullScreenSize = this._halfScreenSize = null, this.bottomBoundary = this.topBoundary = this.rightBoundary = this.leftBoundary = 0, this._worldRect = cc.rect(0, 0, 0, 0), a && (b ? this.initWithTarget(a, b) : this.initWithTarget(a))
    },
    clone: function() {
        var a = new cc.Follow,
            b = this._worldRect,
            b = new cc.Rect(b.x, b.y, b.width, b.height);
        return a.initWithTarget(this._followedNode, b), a
    },
    isBoundarySet: function() {
        return this._boundarySet
    },
    setBoudarySet: function(a) {
        this._boundarySet = a
    },
    initWithTarget: function(a, b) {
        if (!a) throw "cc.Follow.initWithAction(): followedNode must be non nil";
        b = b || cc.rect(0, 0, 0, 0), this._followedNode = a, this._worldRect = b, this._boundarySet = !cc._rectEqualToZero(b), this._boundaryFullyCovered = !1;
        var c = cc.director.getWinSize();
        return this._fullScreenSize = cc.p(c.width, c.height), this._halfScreenSize = cc.pMult(this._fullScreenSize, .5), this._boundarySet && (this.leftBoundary = -(b.x + b.width - this._fullScreenSize.x), this.rightBoundary = -b.x, this.topBoundary = -b.y, this.bottomBoundary = -(b.y + b.height - this._fullScreenSize.y), this.rightBoundary < this.leftBoundary && (this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2), this.topBoundary < this.bottomBoundary && (this.topBoundary = this.bottomBoundary = (this.topBoundary + this.bottomBoundary) / 2), this.topBoundary == this.bottomBoundary && this.leftBoundary == this.rightBoundary && (this._boundaryFullyCovered = !0)), !0
    },
    step: function(a) {
        a = this._followedNode.x;
        var b = this._followedNode.y;
        a = this._halfScreenSize.x - a, b = this._halfScreenSize.y - b, this._boundarySet ? this._boundaryFullyCovered || this.target.setPosition(cc.clampf(a, this.leftBoundary, this.rightBoundary), cc.clampf(b, this.bottomBoundary, this.topBoundary)) : this.target.setPosition(a, b)
    },
    isDone: function() {
        return !this._followedNode.running
    },
    stop: function() {
        this.target = null, cc.Action.prototype.stop.call(this)
    }
}), cc.follow = function(a, b) {
    return new cc.Follow(a, b)
}, cc.Follow.create = cc.follow, cc.ActionInterval = cc.FiniteTimeAction.extend({
    _elapsed: 0,
    _firstTick: !1,
    _easeList: null,
    _times: 1,
    _repeatForever: !1,
    _repeatMethod: !1,
    _speed: 1,
    _speedMethod: !1,
    ctor: function(a) {
        this._times = this._speed = 1, this._repeatForever = !1, this.MAX_VALUE = 2, this._speedMethod = this._repeatMethod = !1, cc.FiniteTimeAction.prototype.ctor.call(this), void 0 !== a && this.initWithDuration(a)
    },
    getElapsed: function() {
        return this._elapsed
    },
    initWithDuration: function(a) {
        return this._duration = 0 === a ? cc.FLT_EPSILON : a, this._elapsed = 0, this._firstTick = !0
    },
    isDone: function() {
        return this._elapsed >= this._duration
    },
    _cloneDecoration: function(a) {
        a._repeatForever = this._repeatForever, a._speed = this._speed, a._times = this._times, a._easeList = this._easeList, a._speedMethod = this._speedMethod, a._repeatMethod = this._repeatMethod
    },
    _reverseEaseList: function(a) {
        if (this._easeList) {
            a._easeList = [];
            for (var b = 0; b < this._easeList.length; b++) a._easeList.push(this._easeList[b].reverse())
        }
    },
    clone: function() {
        var a = new cc.ActionInterval(this._duration);
        return this._cloneDecoration(a), a
    },
    easing: function() {
        this._easeList ? this._easeList.length = 0 : this._easeList = [];
        for (var a = 0; a < arguments.length; a++) this._easeList.push(arguments[a]);
        return this
    },
    _computeEaseTime: function(a) {
        var b = this._easeList;
        if (!b || 0 === b.length) return a;
        for (var c = 0, d = b.length; d > c; c++) a = b[c].easing(a);
        return a
    },
    step: function(a) {
        this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += a, a = this._elapsed / (1.192092896e-7 < this._duration ? this._duration : 1.192092896e-7), a = 1 > a ? a : 1, this.update(a > 0 ? a : 0), this._repeatMethod && 1 < this._times && this.isDone() && (this._repeatForever || this._times--, this.startWithTarget(this.target), this.step(this._elapsed - this._duration))
    },
    startWithTarget: function(a) {
        cc.Action.prototype.startWithTarget.call(this, a), this._elapsed = 0, this._firstTick = !0
    },
    reverse: function() {
        return cc.log("cc.IntervalAction: reverse not implemented."), null
    },
    setAmplitudeRate: function() {
        cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.")
    },
    getAmplitudeRate: function() {
        return cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass."), 0
    },
    speed: function(a) {
        return 0 >= a ? (cc.log("The speed parameter error"), this) : (this._speedMethod = !0, this._speed *= a, this)
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(a) {
        return this._speed = a, this
    },
    repeat: function(a) {
        return a = Math.round(a), isNaN(a) || 1 > a ? (cc.log("The repeat parameter error"), this) : (this._repeatMethod = !0, this._times *= a, this)
    },
    repeatForever: function() {
        return this._repeatMethod = !0, this._times = this.MAX_VALUE, this._repeatForever = !0, this
    }
}), cc.actionInterval = function(a) {
    return new cc.ActionInterval(a)
}, cc.ActionInterval.create = cc.actionInterval, cc.Sequence = cc.ActionInterval.extend({
    _actions: null,
    _split: null,
    _last: 0,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this), this._actions = [];
        var b = a instanceof Array ? a : arguments,
            c = b.length - 1;
        if (c >= 0 && null == b[c] && cc.log("parameters should not be ending with null in Javascript"), c >= 0) {
            for (var d = b[0], e = 1; c > e; e++) b[e] && (d = cc.Sequence._actionOneTwo(d, b[e]));
            this.initWithTwoActions(d, b[c])
        }
    },
    initWithTwoActions: function(a, b) {
        if (!a || !b) throw "cc.Sequence.initWithTwoActions(): arguments must all be non nil";
        return this.initWithDuration(a._duration + b._duration), this._actions[0] = a, this._actions[1] = b, !0
    },
    clone: function() {
        var a = new cc.Sequence;
        return this._cloneDecoration(a), a.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone()), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._split = this._actions[0]._duration / this._duration, this._last = -1
    },
    stop: function() {
        -1 !== this._last && this._actions[this._last].stop(), cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = 0,
            c = this._split,
            d = this._actions,
            e = this._last;
        c > a ? (a = 0 !== c ? a / c : 1, 0 === b && 1 === e && (d[1].update(0), d[1].stop())) : (b = 1, a = 1 === c ? 1 : (a - c) / (1 - c), -1 === e && (d[0].startWithTarget(this.target), d[0].update(1), d[0].stop()), e || (d[0].update(1), d[0].stop())), e === b && d[b].isDone() || (e !== b && d[b].startWithTarget(this.target), d[b].update(a), this._last = b)
    },
    reverse: function() {
        var a = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.sequence = function(a) {
    var b = a instanceof Array ? a : arguments;
    0 < b.length && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var c = b[0], d = 1; d < b.length; d++) b[d] && (c = cc.Sequence._actionOneTwo(c, b[d]));
    return c
}, cc.Sequence.create = cc.sequence, cc.Sequence._actionOneTwo = function(a, b) {
    var c = new cc.Sequence;
    return c.initWithTwoActions(a, b), c
}, cc.Repeat = cc.ActionInterval.extend({
    _times: 0,
    _total: 0,
    _nextDt: 0,
    _actionInstant: !1,
    _innerAction: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== b && this.initWithAction(a, b)
    },
    initWithAction: function(a, b) {
        return this.initWithDuration(a._duration * b) ? (this._times = b, this._innerAction = a, a instanceof cc.ActionInstant && (this._actionInstant = !0, this._times -= 1), this._total = 0, !0) : !1
    },
    clone: function() {
        var a = new cc.Repeat;
        return this._cloneDecoration(a), a.initWithAction(this._innerAction.clone(), this._times), a
    },
    startWithTarget: function(a) {
        this._total = 0, this._nextDt = this._innerAction._duration / this._duration, cc.ActionInterval.prototype.startWithTarget.call(this, a), this._innerAction.startWithTarget(a)
    },
    stop: function() {
        this._innerAction.stop(), cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = this._innerAction,
            c = this._duration,
            d = this._times,
            e = this._nextDt;
        if (a >= e) {
            for (; a > e && this._total < d;) b.update(1), this._total++, b.stop(), b.startWithTarget(this.target), this._nextDt = e += b._duration / c;
            a >= 1 && this._total < d && this._total++, this._actionInstant || (this._total === d ? (b.update(1), b.stop()) : b.update(a - (e - b._duration / c)))
        } else b.update(a * d % 1)
    },
    isDone: function() {
        return this._total == this._times
    },
    reverse: function() {
        var a = new cc.Repeat(this._innerAction.reverse(), this._times);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    },
    setInnerAction: function(a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
}), cc.repeat = function(a, b) {
    return new cc.Repeat(a, b)
}, cc.Repeat.create = cc.repeat, cc.RepeatForever = cc.ActionInterval.extend({
    _innerAction: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this), this._innerAction = null, a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw "cc.RepeatForever.initWithAction(): action must be non null";
        return this._innerAction = a, !0
    },
    clone: function() {
        var a = new cc.RepeatForever;
        return this._cloneDecoration(a), a.initWithAction(this._innerAction.clone()), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._innerAction.startWithTarget(a)
    },
    step: function(a) {
        var b = this._innerAction;
        b.step(a), b.isDone() && (b.startWithTarget(this.target), b.step(b.getElapsed() - b._duration))
    },
    isDone: function() {
        return !1
    },
    reverse: function() {
        var a = new cc.RepeatForever(this._innerAction.reverse());
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    },
    setInnerAction: function(a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
}), cc.repeatForever = function(a) {
    return new cc.RepeatForever(a)
}, cc.RepeatForever.create = cc.repeatForever, cc.Spawn = cc.ActionInterval.extend({
    _one: null,
    _two: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this), this._two = this._one = null;
        var b = a instanceof Array ? a : arguments,
            c = b.length - 1;
        if (c >= 0 && null == b[c] && cc.log("parameters should not be ending with null in Javascript"), c >= 0) {
            for (var d = b[0], e = 1; c > e; e++) b[e] && (d = cc.Spawn._actionOneTwo(d, b[e]));
            this.initWithTwoActions(d, b[c])
        }
    },
    initWithTwoActions: function(a, b) {
        if (!a || !b) throw "cc.Spawn.initWithTwoActions(): arguments must all be non null";
        var c = !1,
            d = a._duration,
            e = b._duration;
        return this.initWithDuration(Math.max(d, e)) && (this._one = a, this._two = b, d > e ? this._two = cc.Sequence._actionOneTwo(b, cc.delayTime(d - e)) : e > d && (this._one = cc.Sequence._actionOneTwo(a, cc.delayTime(e - d))), c = !0), c
    },
    clone: function() {
        var a = new cc.Spawn;
        return this._cloneDecoration(a), a.initWithTwoActions(this._one.clone(), this._two.clone()), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._one.startWithTarget(a), this._two.startWithTarget(a)
    },
    stop: function() {
        this._one.stop(), this._two.stop(), cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a = this._computeEaseTime(a), this._one && this._one.update(a), this._two && this._two.update(a)
    },
    reverse: function() {
        var a = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.spawn = function(a) {
    var b = a instanceof Array ? a : arguments;
    0 < b.length && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var c = b[0], d = 1; d < b.length; d++) null != b[d] && (c = cc.Spawn._actionOneTwo(c, b[d]));
    return c
}, cc.Spawn.create = cc.spawn, cc.Spawn._actionOneTwo = function(a, b) {
    var c = new cc.Spawn;
    return c.initWithTwoActions(a, b), c
}, cc.RotateTo = cc.ActionInterval.extend({
    _dstAngleX: 0,
    _startAngleX: 0,
    _diffAngleX: 0,
    _dstAngleY: 0,
    _startAngleY: 0,
    _diffAngleY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._dstAngleX = b || 0, this._dstAngleY = c || this._dstAngleX, !0) : !1
    },
    clone: function() {
        var a = new cc.RotateTo;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.rotationX % 360,
            c = this._dstAngleX - b;
        c > 180 && (c -= 360), -180 > c && (c += 360), this._startAngleX = b, this._diffAngleX = c, this._startAngleY = a.rotationY % 360, a = this._dstAngleY - this._startAngleY, a > 180 && (a -= 360), -180 > a && (a += 360), this._diffAngleY = a
    },
    reverse: function() {
        cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.")
    },
    update: function(a) {
        a = this._computeEaseTime(a), this.target && (this.target.rotationX = this._startAngleX + this._diffAngleX * a, this.target.rotationY = this._startAngleY + this._diffAngleY * a)
    }
}), cc.rotateTo = function(a, b, c) {
    return new cc.RotateTo(a, b, c)
}, cc.RotateTo.create = cc.rotateTo, cc.RotateBy = cc.ActionInterval.extend({
    _angleX: 0,
    _startAngleX: 0,
    _angleY: 0,
    _startAngleY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._angleX = b || 0, this._angleY = c || this._angleX, !0) : !1
    },
    clone: function() {
        var a = new cc.RotateBy;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._angleX, this._angleY), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._startAngleX = a.rotationX, this._startAngleY = a.rotationY
    },
    update: function(a) {
        a = this._computeEaseTime(a), this.target && (this.target.rotationX = this._startAngleX + this._angleX * a, this.target.rotationY = this._startAngleY + this._angleY * a)
    },
    reverse: function() {
        var a = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.rotateBy = function(a, b, c) {
    return new cc.RotateBy(a, b, c)
}, cc.RotateBy.create = cc.rotateBy, cc.MoveBy = cc.ActionInterval.extend({
    _positionDelta: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this), this._positionDelta = cc.p(0, 0), this._startPosition = cc.p(0, 0), this._previousPosition = cc.p(0, 0), void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 !== b.x && (c = b.y, b = b.x), this._positionDelta.x = b, this._positionDelta.y = c, !0) : !1
    },
    clone: function() {
        var a = new cc.MoveBy;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._positionDelta), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY(), this._previousPosition.x = b, this._previousPosition.y = a, this._startPosition.x = b, this._startPosition.y = a
    },
    update: function(a) {
        if (a = this._computeEaseTime(a), this.target) {
            var b = this._positionDelta.x * a;
            a *= this._positionDelta.y;
            var c = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var d = this.target.getPositionX(),
                    e = this.target.getPositionY(),
                    f = this._previousPosition;
                c.x = c.x + d - f.x, c.y = c.y + e - f.y, b += c.x, a += c.y, f.x = b, f.y = a, this.target.setPosition(b, a)
            } else this.target.setPosition(c.x + b, c.y + a)
        }
    },
    reverse: function() {
        var a = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.moveBy = function(a, b, c) {
    return new cc.MoveBy(a, b, c)
}, cc.MoveBy.create = cc.moveBy, cc.MoveTo = cc.MoveBy.extend({
    _endPosition: null,
    ctor: function(a, b, c) {
        cc.MoveBy.prototype.ctor.call(this), this._endPosition = cc.p(0, 0), void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.MoveBy.prototype.initWithDuration.call(this, a, b, c) ? (void 0 !== b.x && (c = b.y, b = b.x), this._endPosition.x = b, this._endPosition.y = c, !0) : !1
    },
    clone: function() {
        var a = new cc.MoveTo;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._endPosition), a
    },
    startWithTarget: function(a) {
        cc.MoveBy.prototype.startWithTarget.call(this, a), this._positionDelta.x = this._endPosition.x - a.getPositionX(), this._positionDelta.y = this._endPosition.y - a.getPositionY()
    }
}), cc.moveTo = function(a, b, c) {
    return new cc.MoveTo(a, b, c)
}, cc.MoveTo.create = cc.moveTo, cc.SkewTo = cc.ActionInterval.extend({
    _skewX: 0,
    _skewY: 0,
    _startSkewX: 0,
    _startSkewY: 0,
    _endSkewX: 0,
    _endSkewY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        var d = !1;
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) && (this._endSkewX = b, this._endSkewY = c, d = !0), d
    },
    clone: function() {
        var a = new cc.SkewTo;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._endSkewX, this._endSkewY), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._startSkewX = a.skewX % 180, this._deltaX = this._endSkewX - this._startSkewX, 180 < this._deltaX && (this._deltaX -= 360), -180 > this._deltaX && (this._deltaX += 360), this._startSkewY = a.skewY % 360, this._deltaY = this._endSkewY - this._startSkewY, 180 < this._deltaY && (this._deltaY -= 360), -180 > this._deltaY && (this._deltaY += 360)
    },
    update: function(a) {
        a = this._computeEaseTime(a), this.target.skewX = this._startSkewX + this._deltaX * a, this.target.skewY = this._startSkewY + this._deltaY * a
    }
}), cc.skewTo = function(a, b, c) {
    return new cc.SkewTo(a, b, c)
}, cc.SkewTo.create = cc.skewTo, cc.SkewBy = cc.SkewTo.extend({
    ctor: function(a, b, c) {
        cc.SkewTo.prototype.ctor.call(this), void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        var d = !1;
        return cc.SkewTo.prototype.initWithDuration.call(this, a, b, c) && (this._skewX = b, this._skewY = c, d = !0), d
    },
    clone: function() {
        var a = new cc.SkewBy;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._skewX, this._skewY), a
    },
    startWithTarget: function(a) {
        cc.SkewTo.prototype.startWithTarget.call(this, a), this._deltaX = this._skewX, this._deltaY = this._skewY, this._endSkewX = this._startSkewX + this._deltaX, this._endSkewY = this._startSkewY + this._deltaY
    },
    reverse: function() {
        var a = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.skewBy = function(a, b, c) {
    return new cc.SkewBy(a, b, c)
}, cc.SkewBy.create = cc.skewBy, cc.JumpBy = cc.ActionInterval.extend({
    _startPosition: null,
    _delta: null,
    _height: 0,
    _jumps: 0,
    _previousPosition: null,
    ctor: function(a, b, c, d, e) {
        cc.ActionInterval.prototype.ctor.call(this), this._startPosition = cc.p(0, 0), this._previousPosition = cc.p(0, 0), this._delta = cc.p(0, 0), void 0 !== d && this.initWithDuration(a, b, c, d, e)
    },
    initWithDuration: function(a, b, c, d, e) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 === e && (e = d, d = c, c = b.y, b = b.x), this._delta.x = b, this._delta.y = c, this._height = d, this._jumps = e, !0) : !1
    },
    clone: function() {
        var a = new cc.JumpBy;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._delta, this._height, this._jumps), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY(), this._previousPosition.x = b, this._previousPosition.y = a, this._startPosition.x = b, this._startPosition.y = a
    },
    update: function(a) {
        if (a = this._computeEaseTime(a), this.target) {
            var b = a * this._jumps % 1,
                b = 4 * this._height * b * (1 - b),
                b = b + this._delta.y * a;
            a *= this._delta.x;
            var c = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var d = this.target.getPositionX(),
                    e = this.target.getPositionY(),
                    f = this._previousPosition;
                c.x = c.x + d - f.x, c.y = c.y + e - f.y, a += c.x, b += c.y, f.x = a, f.y = b, this.target.setPosition(a, b)
            } else this.target.setPosition(c.x + a, c.y + b)
        }
    },
    reverse: function() {
        var a = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.jumpBy = function(a, b, c, d, e) {
    return new cc.JumpBy(a, b, c, d, e)
}, cc.JumpBy.create = cc.jumpBy, cc.JumpTo = cc.JumpBy.extend({
    _endPosition: null,
    ctor: function(a, b, c, d, e) {
        cc.JumpBy.prototype.ctor.call(this), this._endPosition = cc.p(0, 0), void 0 !== d && this.initWithDuration(a, b, c, d, e)
    },
    initWithDuration: function(a, b, c, d, e) {
        return cc.JumpBy.prototype.initWithDuration.call(this, a, b, c, d, e) ? (void 0 === e && (c = b.y, b = b.x), this._endPosition.x = b, this._endPosition.y = c, !0) : !1
    },
    startWithTarget: function(a) {
        cc.JumpBy.prototype.startWithTarget.call(this, a), this._delta.x = this._endPosition.x - this._startPosition.x, this._delta.y = this._endPosition.y - this._startPosition.y
    },
    clone: function() {
        var a = new cc.JumpTo;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._endPosition, this._height, this._jumps), a
    }
}), cc.jumpTo = function(a, b, c, d, e) {
    return new cc.JumpTo(a, b, c, d, e)
}, cc.JumpTo.create = cc.jumpTo, cc.bezierAt = function(a, b, c, d, e) {
    return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
}, cc.BezierBy = cc.ActionInterval.extend({
    _config: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this), this._config = [], this._startPosition = cc.p(0, 0), this._previousPosition = cc.p(0, 0), b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._config = b, !0) : !1
    },
    clone: function() {
        var a = new cc.BezierBy;
        this._cloneDecoration(a);
        for (var b = [], c = 0; c < this._config.length; c++) {
            var d = this._config[c];
            b.push(cc.p(d.x, d.y))
        }
        return a.initWithDuration(this._duration, b), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY(), this._previousPosition.x = b, this._previousPosition.y = a, this._startPosition.x = b, this._startPosition.y = a
    },
    update: function(a) {
        if (a = this._computeEaseTime(a), this.target) {
            var b = this._config,
                c = b[0].y,
                d = b[1].y,
                e = b[2].y,
                b = cc.bezierAt(0, b[0].x, b[1].x, b[2].x, a);
            if (a = cc.bezierAt(0, c, d, e, a), c = this._startPosition, cc.ENABLE_STACKABLE_ACTIONS) {
                var d = this.target.getPositionX(),
                    e = this.target.getPositionY(),
                    f = this._previousPosition;
                c.x = c.x + d - f.x, c.y = c.y + e - f.y, b += c.x, a += c.y, f.x = b, f.y = a, this.target.setPosition(b, a)
            } else this.target.setPosition(c.x + b, c.y + a)
        }
    },
    reverse: function() {
        var a = this._config,
            a = [cc.pAdd(a[1], cc.pNeg(a[2])), cc.pAdd(a[0], cc.pNeg(a[2])), cc.pNeg(a[2])],
            a = new cc.BezierBy(this._duration, a);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.bezierBy = function(a, b) {
    return new cc.BezierBy(a, b)
}, cc.BezierBy.create = cc.bezierBy, cc.BezierTo = cc.BezierBy.extend({
    _toConfig: null,
    ctor: function(a, b) {
        cc.BezierBy.prototype.ctor.call(this), this._toConfig = [], b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toConfig = b, !0) : !1
    },
    clone: function() {
        var a = new cc.BezierTo;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._toConfig), a
    },
    startWithTarget: function(a) {
        cc.BezierBy.prototype.startWithTarget.call(this, a), a = this._startPosition;
        var b = this._toConfig,
            c = this._config;
        c[0] = cc.pSub(b[0], a), c[1] = cc.pSub(b[1], a), c[2] = cc.pSub(b[2], a)
    }
}), cc.bezierTo = function(a, b) {
    return new cc.BezierTo(a, b)
}, cc.BezierTo.create = cc.bezierTo, cc.ScaleTo = cc.ActionInterval.extend({
    _scaleX: 1,
    _scaleY: 1,
    _startScaleX: 1,
    _startScaleY: 1,
    _endScaleX: 0,
    _endScaleY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._endScaleX = b, this._endScaleY = null != c ? c : b, !0) : !1
    },
    clone: function() {
        var a = new cc.ScaleTo;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._endScaleX, this._endScaleY), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._startScaleX = a.scaleX, this._startScaleY = a.scaleY, this._deltaX = this._endScaleX - this._startScaleX, this._deltaY = this._endScaleY - this._startScaleY
    },
    update: function(a) {
        a = this._computeEaseTime(a), this.target && (this.target.scaleX = this._startScaleX + this._deltaX * a, this.target.scaleY = this._startScaleY + this._deltaY * a)
    }
}), cc.scaleTo = function(a, b, c) {
    return new cc.ScaleTo(a, b, c)
}, cc.ScaleTo.create = cc.scaleTo, cc.ScaleBy = cc.ScaleTo.extend({
    startWithTarget: function(a) {
        cc.ScaleTo.prototype.startWithTarget.call(this, a), this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX, this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
    },
    reverse: function() {
        var a = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    },
    clone: function() {
        var a = new cc.ScaleBy;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._endScaleX, this._endScaleY), a
    }
}), cc.scaleBy = function(a, b, c) {
    return new cc.ScaleBy(a, b, c)
}, cc.ScaleBy.create = cc.scaleBy, cc.Blink = cc.ActionInterval.extend({
    _times: 0,
    _originalState: !1,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._times = b, !0) : !1
    },
    clone: function() {
        var a = new cc.Blink;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._times), a
    },
    update: function(a) {
        if (a = this._computeEaseTime(a), this.target && !this.isDone()) {
            var b = 1 / this._times;
            this.target.visible = a % b > b / 2
        }
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._originalState = a.visible
    },
    stop: function() {
        this.target.visible = this._originalState, cc.ActionInterval.prototype.stop.call(this)
    },
    reverse: function() {
        var a = new cc.Blink(this._duration, this._times);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.blink = function(a, b) {
    return new cc.Blink(a, b)
}, cc.Blink.create = cc.blink, cc.FadeTo = cc.ActionInterval.extend({
    _toOpacity: 0,
    _fromOpacity: 0,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toOpacity = b, !0) : !1
    },
    clone: function() {
        var a = new cc.FadeTo;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._toOpacity), a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = void 0 !== this._fromOpacity ? this._fromOpacity : 255;
        this.target.opacity = b + (this._toOpacity - b) * a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._fromOpacity = a.opacity
    }
}), cc.fadeTo = function(a, b) {
    return new cc.FadeTo(a, b)
}, cc.FadeTo.create = cc.fadeTo, cc.FadeIn = cc.FadeTo.extend({
    _reverseAction: null,
    ctor: function(a) {
        cc.FadeTo.prototype.ctor.call(this), a && this.initWithDuration(a, 255)
    },
    reverse: function() {
        var a = new cc.FadeOut;
        return a.initWithDuration(this._duration, 0), this._cloneDecoration(a), this._reverseEaseList(a), a
    },
    clone: function() {
        var a = new cc.FadeIn;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._toOpacity), a
    },
    startWithTarget: function(a) {
        this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity), cc.FadeTo.prototype.startWithTarget.call(this, a)
    }
}), cc.fadeIn = function(a) {
    return new cc.FadeIn(a)
}, cc.FadeIn.create = cc.fadeIn, cc.FadeOut = cc.FadeTo.extend({
    ctor: function(a) {
        cc.FadeTo.prototype.ctor.call(this), a && this.initWithDuration(a, 0)
    },
    reverse: function() {
        var a = new cc.FadeIn;
        return a._reverseAction = this, a.initWithDuration(this._duration, 255), this._cloneDecoration(a), this._reverseEaseList(a), a
    },
    clone: function() {
        var a = new cc.FadeOut;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._toOpacity), a
    }
}), cc.fadeOut = function(a) {
    return new cc.FadeOut(a)
}, cc.FadeOut.create = cc.fadeOut, cc.TintTo = cc.ActionInterval.extend({
    _to: null,
    _from: null,
    ctor: function(a, b, c, d) {
        cc.ActionInterval.prototype.ctor.call(this), this._to = cc.color(0, 0, 0), this._from = cc.color(0, 0, 0), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = cc.color(b, c, d), !0) : !1
    },
    clone: function() {
        var a = new cc.TintTo;
        this._cloneDecoration(a);
        var b = this._to;
        return a.initWithDuration(this._duration, b.r, b.g, b.b), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._from = this.target.color
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = this._from,
            c = this._to;
        b && (this.target.color = cc.color(b.r + (c.r - b.r) * a, b.g + (c.g - b.g) * a, b.b + (c.b - b.b) * a))
    }
}), cc.tintTo = function(a, b, c, d) {
    return new cc.TintTo(a, b, c, d)
}, cc.TintTo.create = cc.tintTo, cc.TintBy = cc.ActionInterval.extend({
    _deltaR: 0,
    _deltaG: 0,
    _deltaB: 0,
    _fromR: 0,
    _fromG: 0,
    _fromB: 0,
    ctor: function(a, b, c, d) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._deltaR = b, this._deltaG = c, this._deltaB = d, !0) : !1
    },
    clone: function() {
        var a = new cc.TintBy;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), a = a.color, this._fromR = a.r, this._fromG = a.g, this._fromB = a.b
    },
    update: function(a) {
        a = this._computeEaseTime(a), this.target.color = cc.color(this._fromR + this._deltaR * a, this._fromG + this._deltaG * a, this._fromB + this._deltaB * a)
    },
    reverse: function() {
        var a = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.tintBy = function(a, b, c, d) {
    return new cc.TintBy(a, b, c, d)
}, cc.TintBy.create = cc.tintBy, cc.DelayTime = cc.ActionInterval.extend({
    update: function() {},
    reverse: function() {
        var a = new cc.DelayTime(this._duration);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    },
    clone: function() {
        var a = new cc.DelayTime;
        return this._cloneDecoration(a), a.initWithDuration(this._duration), a
    }
}), cc.delayTime = function(a) {
    return new cc.DelayTime(a)
}, cc.DelayTime.create = cc.delayTime, cc.ReverseTime = cc.ActionInterval.extend({
    _other: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this), this._other = null, a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw "cc.ReverseTime.initWithAction(): action must be non null";
        if (a == this._other) throw "cc.ReverseTime.initWithAction(): the action was already passed in.";
        return cc.ActionInterval.prototype.initWithDuration.call(this, a._duration) ? (this._other = a, !0) : !1
    },
    clone: function() {
        var a = new cc.ReverseTime;
        return this._cloneDecoration(a), a.initWithAction(this._other.clone()), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._other.startWithTarget(a)
    },
    update: function(a) {
        a = this._computeEaseTime(a), this._other && this._other.update(1 - a)
    },
    reverse: function() {
        return this._other.clone()
    },
    stop: function() {
        this._other.stop(), cc.Action.prototype.stop.call(this)
    }
}), cc.reverseTime = function(a) {
    return new cc.ReverseTime(a)
}, cc.ReverseTime.create = cc.reverseTime, cc.Animate = cc.ActionInterval.extend({
    _animation: null,
    _nextFrame: 0,
    _origFrame: null,
    _executedLoops: 0,
    _splitTimes: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this), this._splitTimes = [], a && this.initWithAnimation(a)
    },
    getAnimation: function() {
        return this._animation
    },
    setAnimation: function(a) {
        this._animation = a
    },
    initWithAnimation: function(a) {
        if (!a) throw "cc.Animate.initWithAnimation(): animation must be non-NULL";
        var b = a.getDuration();
        if (this.initWithDuration(b * a.getLoops())) {
            this._nextFrame = 0, this.setAnimation(a), this._origFrame = null, this._executedLoops = 0;
            var c = this._splitTimes,
                d = c.length = 0,
                e = b / a.getTotalDelayUnits();
            a = a.getFrames(), cc.arrayVerifyType(a, cc.AnimationFrame);
            for (var f = 0; f < a.length; f++) {
                var g = d * e / b,
                    d = d + a[f].getDelayUnits();
                c.push(g)
            }
            return !0
        }
        return !1
    },
    clone: function() {
        var a = new cc.Animate;
        return this._cloneDecoration(a), a.initWithAnimation(this._animation.clone()), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._animation.getRestoreOriginalFrame() && (this._origFrame = a.displayFrame()), this._executedLoops = this._nextFrame = 0
    },
    update: function(a) {
        a = this._computeEaseTime(a), 1 > a && (a *= this._animation.getLoops(), (0 | a) > this._executedLoops && (this._nextFrame = 0, this._executedLoops++), a %= 1);
        for (var b = this._animation.getFrames(), c = b.length, d = this._splitTimes, e = this._nextFrame; c > e && d[e] <= a; e++) this.target.setSpriteFrame(b[e].getSpriteFrame()), this._nextFrame = e + 1
    },
    reverse: function() {
        var a = this._animation,
            b = a.getFrames(),
            c = [];
        if (cc.arrayVerifyType(b, cc.AnimationFrame), 0 < b.length)
            for (var d = b.length - 1; d >= 0; d--) {
                var e = b[d];
                if (!e) break;
                c.push(e.clone())
            }
        return b = new cc.Animation(c, a.getDelayPerUnit(), a.getLoops()), b.setRestoreOriginalFrame(a.getRestoreOriginalFrame()), a = new cc.Animate(b), this._cloneDecoration(a), this._reverseEaseList(a), a
    },
    stop: function() {
        this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame), cc.Action.prototype.stop.call(this)
    }
}), cc.animate = function(a) {
    return new cc.Animate(a)
}, cc.Animate.create = cc.animate, cc.TargetedAction = cc.ActionInterval.extend({
    _action: null,
    _forcedTarget: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this), b && this.initWithTarget(a, b)
    },
    initWithTarget: function(a, b) {
        return this.initWithDuration(b._duration) ? (this._forcedTarget = a, this._action = b, !0) : !1
    },
    clone: function() {
        var a = new cc.TargetedAction;
        return this._cloneDecoration(a), a.initWithTarget(this._forcedTarget, this._action.clone()), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._action.startWithTarget(this._forcedTarget)
    },
    stop: function() {
        this._action.stop()
    },
    update: function(a) {
        a = this._computeEaseTime(a), this._action.update(a)
    },
    getForcedTarget: function() {
        return this._forcedTarget
    },
    setForcedTarget: function(a) {
        this._forcedTarget != a && (this._forcedTarget = a)
    }
}), cc.targetedAction = function(a, b) {
    return new cc.TargetedAction(a, b)
}, cc.TargetedAction.create = cc.targetedAction, cc.ActionInstant = cc.FiniteTimeAction.extend({
    isDone: function() {
        return !0
    },
    step: function() {
        this.update(1)
    },
    update: function() {},
    reverse: function() {
        return this.clone()
    },
    clone: function() {
        return new cc.ActionInstant
    }
}), cc.Show = cc.ActionInstant.extend({
    update: function() {
        this.target.visible = !0
    },
    reverse: function() {
        return new cc.Hide
    },
    clone: function() {
        return new cc.Show
    }
}), cc.show = function() {
    return new cc.Show
}, cc.Show.create = cc.show, cc.Hide = cc.ActionInstant.extend({
    update: function() {
        this.target.visible = !1
    },
    reverse: function() {
        return new cc.Show
    },
    clone: function() {
        return new cc.Hide
    }
}), cc.hide = function() {
    return new cc.Hide
}, cc.Hide.create = cc.hide, cc.ToggleVisibility = cc.ActionInstant.extend({
    update: function() {
        this.target.visible = !this.target.visible
    },
    reverse: function() {
        return new cc.ToggleVisibility
    },
    clone: function() {
        return new cc.ToggleVisibility
    }
}), cc.toggleVisibility = function() {
    return new cc.ToggleVisibility
}, cc.ToggleVisibility.create = cc.toggleVisibility, cc.RemoveSelf = cc.ActionInstant.extend({
    _isNeedCleanUp: !0,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this), void 0 !== a && this.init(a)
    },
    update: function() {
        this.target.removeFromParent(this._isNeedCleanUp)
    },
    init: function(a) {
        return this._isNeedCleanUp = a, !0
    },
    reverse: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    },
    clone: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    }
}), cc.removeSelf = function(a) {
    return new cc.RemoveSelf(a)
}, cc.RemoveSelf.create = cc.removeSelf, cc.FlipX = cc.ActionInstant.extend({
    _flippedX: !1,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this), this._flippedX = !1, void 0 !== a && this.initWithFlipX(a)
    },
    initWithFlipX: function(a) {
        return this._flippedX = a, !0
    },
    update: function() {
        this.target.flippedX = this._flippedX
    },
    reverse: function() {
        return new cc.FlipX(!this._flippedX)
    },
    clone: function() {
        var a = new cc.FlipX;
        return a.initWithFlipX(this._flippedX), a
    }
}), cc.flipX = function(a) {
    return new cc.FlipX(a)
}, cc.FlipX.create = cc.flipX, cc.FlipY = cc.ActionInstant.extend({
    _flippedY: !1,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this), this._flippedY = !1, void 0 !== a && this.initWithFlipY(a)
    },
    initWithFlipY: function(a) {
        return this._flippedY = a, !0
    },
    update: function() {
        this.target.flippedY = this._flippedY
    },
    reverse: function() {
        return new cc.FlipY(!this._flippedY)
    },
    clone: function() {
        var a = new cc.FlipY;
        return a.initWithFlipY(this._flippedY), a
    }
}), cc.flipY = function(a) {
    return new cc.FlipY(a)
}, cc.FlipY.create = cc.flipY, cc.Place = cc.ActionInstant.extend({
    _x: 0,
    _y: 0,
    ctor: function(a, b) {
        cc.FiniteTimeAction.prototype.ctor.call(this), this._y = this._x = 0, void 0 !== a && (void 0 !== a.x && (b = a.y, a = a.x), this.initWithPosition(a, b))
    },
    initWithPosition: function(a, b) {
        return this._x = a, this._y = b, !0
    },
    update: function() {
        this.target.setPosition(this._x, this._y)
    },
    clone: function() {
        var a = new cc.Place;
        return a.initWithPosition(this._x, this._y), a
    }
}), cc.place = function(a, b) {
    return new cc.Place(a, b)
}, cc.Place.create = cc.place, cc.CallFunc = cc.ActionInstant.extend({
    _selectorTarget: null,
    _callFunc: null,
    _function: null,
    _data: null,
    ctor: function(a, b, c) {
        cc.FiniteTimeAction.prototype.ctor.call(this), void 0 !== a && (void 0 === b ? this.initWithFunction(a) : this.initWithFunction(a, b, c))
    },
    initWithFunction: function(a, b, c) {
        return b ? (this._data = c, this._callFunc = a, this._selectorTarget = b) : a && (this._function = a), !0
    },
    execute: function() {
        null != this._callFunc ? this._callFunc.call(this._selectorTarget, this.target, this._data) : this._function && this._function.call(null, this.target)
    },
    update: function() {
        this.execute()
    },
    getTargetCallback: function() {
        return this._selectorTarget
    },
    setTargetCallback: function(a) {
        a != this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = a)
    },
    clone: function() {
        var a = new cc.CallFunc;
        return this._selectorTarget ? a.initWithFunction(this._callFunc, this._selectorTarget, this._data) : this._function && a.initWithFunction(this._function), a
    }
}), cc.callFunc = function(a, b, c) {
    return new cc.CallFunc(a, b, c)
}, cc.CallFunc.create = cc.callFunc, cc.ActionCamera = cc.ActionInterval.extend({
    _centerXOrig: 0,
    _centerYOrig: 0,
    _centerZOrig: 0,
    _eyeXOrig: 0,
    _eyeYOrig: 0,
    _eyeZOrig: 0,
    _upXOrig: 0,
    _upYOrig: 0,
    _upZOrig: 0,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this), this._upZOrig = this._upYOrig = this._upXOrig = this._eyeZOrig = this._eyeYOrig = this._eyeXOrig = this._centerZOrig = this._centerYOrig = this._centerXOrig = 0
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), a = a.getCamera();
        var b = a.getCenter();
        this._centerXOrig = b.x, this._centerYOrig = b.y, this._centerZOrig = b.z, b = a.getEye(), this._eyeXOrig = b.x, this._eyeYOrig = b.y, this._eyeZOrig = b.z, a = a.getUp(), this._upXOrig = a.x, this._upYOrig = a.y, this._upZOrig = a.z
    },
    clone: function() {
        return new cc.ActionCamera
    },
    reverse: function() {
        return new cc.ReverseTime(this)
    }
}), cc.OrbitCamera = cc.ActionCamera.extend({
    _radius: 0,
    _deltaRadius: 0,
    _angleZ: 0,
    _deltaAngleZ: 0,
    _angleX: 0,
    _deltaAngleX: 0,
    _radZ: 0,
    _radDeltaZ: 0,
    _radX: 0,
    _radDeltaX: 0,
    ctor: function(a, b, c, d, e, f, g) {
        cc.ActionCamera.prototype.ctor.call(this), void 0 !== g && this.initWithDuration(a, b, c, d, e, f, g)
    },
    initWithDuration: function(a, b, c, d, e, f, g) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._radius = b, this._deltaRadius = c, this._angleZ = d, this._deltaAngleZ = e, this._angleX = f, this._deltaAngleX = g, this._radDeltaZ = cc.degreesToRadians(e), this._radDeltaX = cc.degreesToRadians(g), !0) : !1
    },
    sphericalRadius: function() {
        var a, b;
        b = this.target.getCamera();
        var c = b.getEye();
        a = b.getCenter(), b = c.x - a.x;
        var d = c.y - a.y;
        a = c.z - a.z;
        var c = Math.sqrt(Math.pow(b, 2) + Math.pow(d, 2) + Math.pow(a, 2)),
            e = Math.sqrt(Math.pow(b, 2) + Math.pow(d, 2));
        return 0 === e && (e = cc.FLT_EPSILON), 0 === c && (c = cc.FLT_EPSILON), a = Math.acos(a / c), b = 0 > b ? Math.PI - Math.asin(d / e) : Math.asin(d / e), {
            newRadius: c / cc.Camera.getZEye(),
            zenith: a,
            azimuth: b
        }
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), a = this.sphericalRadius(), isNaN(this._radius) && (this._radius = a.newRadius), isNaN(this._angleZ) && (this._angleZ = cc.radiansToDegrees(a.zenith)), isNaN(this._angleX) && (this._angleX = cc.radiansToDegrees(a.azimuth)), this._radZ = cc.degreesToRadians(this._angleZ), this._radX = cc.degreesToRadians(this._angleX)
    },
    clone: function() {
        var a = new cc.OrbitCamera;
        return a.initWithDuration(this._duration, this._radius, this._deltaRadius, this._angleZ, this._deltaAngleZ, this._angleX, this._deltaAngleX), a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = (this._radius + this._deltaRadius * a) * cc.Camera.getZEye(),
            c = this._radZ + this._radDeltaZ * a,
            d = this._radX + this._radDeltaX * a;
        a = Math.sin(c) * Math.cos(d) * b + this._centerXOrig, d = Math.sin(c) * Math.sin(d) * b + this._centerYOrig, b = Math.cos(c) * b + this._centerZOrig, this.target.getCamera().setEye(a, d, b)
    }
}), cc.orbitCamera = function(a, b, c, d, e, f, g) {
    return new cc.OrbitCamera(a, b, c, d, e, f, g)
}, cc.OrbitCamera.create = cc.orbitCamera, cc.ActionEase = cc.ActionInterval.extend({
    _inner: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this), a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw "cc.ActionEase.initWithAction(): action must be non nil";
        return this.initWithDuration(a.getDuration()) ? (this._inner = a, !0) : !1
    },
    clone: function() {
        var a = new cc.ActionEase;
        return a.initWithAction(this._inner.clone()), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._inner.startWithTarget(this.target)
    },
    stop: function() {
        this._inner.stop(), cc.ActionInterval.prototype.stop.call(this)
    },
    update: function(a) {
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.ActionEase(this._inner.reverse())
    },
    getInnerAction: function() {
        return this._inner
    }
}), cc.actionEase = function(a) {
    return new cc.ActionEase(a)
}, cc.ActionEase.create = cc.actionEase, cc.EaseRateAction = cc.ActionEase.extend({
    _rate: 0,
    ctor: function(a, b) {
        cc.ActionEase.prototype.ctor.call(this), void 0 !== b && this.initWithAction(a, b)
    },
    setRate: function(a) {
        this._rate = a
    },
    getRate: function() {
        return this._rate
    },
    initWithAction: function(a, b) {
        return cc.ActionEase.prototype.initWithAction.call(this, a) ? (this._rate = b, !0) : !1
    },
    clone: function() {
        var a = new cc.EaseRateAction;
        return a.initWithAction(this._inner.clone(), this._rate), a
    },
    reverse: function() {
        return new cc.EaseRateAction(this._inner.reverse(), 1 / this._rate)
    }
}), cc.easeRateAction = function(a, b) {
    return new cc.EaseRateAction(a, b)
}, cc.EaseRateAction.create = cc.easeRateAction, cc.EaseIn = cc.EaseRateAction.extend({
    update: function(a) {
        this._inner.update(Math.pow(a, this._rate))
    },
    reverse: function() {
        return new cc.EaseIn(this._inner.reverse(), 1 / this._rate)
    },
    clone: function() {
        var a = new cc.EaseIn;
        return a.initWithAction(this._inner.clone(), this._rate), a
    }
}), cc.EaseIn.create = function(a, b) {
    return new cc.EaseIn(a, b)
}, cc.easeIn = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            return Math.pow(a, this._rate)
        },
        reverse: function() {
            return cc.easeIn(1 / this._rate)
        }
    }
}, cc.EaseOut = cc.EaseRateAction.extend({
    update: function(a) {
        this._inner.update(Math.pow(a, 1 / this._rate))
    },
    reverse: function() {
        return new cc.EaseOut(this._inner.reverse(), 1 / this._rate)
    },
    clone: function() {
        var a = new cc.EaseOut;
        return a.initWithAction(this._inner.clone(), this._rate), a
    }
}), cc.EaseOut.create = function(a, b) {
    return new cc.EaseOut(a, b)
}, cc.easeOut = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            return Math.pow(a, 1 / this._rate)
        },
        reverse: function() {
            return cc.easeOut(1 / this._rate)
        }
    }
}, cc.EaseInOut = cc.EaseRateAction.extend({
    update: function(a) {
        a *= 2, this._inner.update(1 > a ? .5 * Math.pow(a, this._rate) : 1 - .5 * Math.pow(2 - a, this._rate))
    },
    clone: function() {
        var a = new cc.EaseInOut;
        return a.initWithAction(this._inner.clone(), this._rate), a
    },
    reverse: function() {
        return new cc.EaseInOut(this._inner.reverse(), this._rate)
    }
}), cc.EaseInOut.create = function(a, b) {
    return new cc.EaseInOut(a, b)
}, cc.easeInOut = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            return a *= 2, 1 > a ? .5 * Math.pow(a, this._rate) : 1 - .5 * Math.pow(2 - a, this._rate)
        },
        reverse: function() {
            return cc.easeInOut(this._rate)
        }
    }
}, cc.EaseExponentialIn = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(0 === a ? 0 : Math.pow(2, 10 * (a - 1)))
    },
    reverse: function() {
        return new cc.EaseExponentialOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialIn;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseExponentialIn.create = function(a) {
    return new cc.EaseExponentialIn(a)
}, cc._easeExponentialInObj = {
    easing: function(a) {
        return 0 === a ? 0 : Math.pow(2, 10 * (a - 1))
    },
    reverse: function() {
        return cc._easeExponentialOutObj
    }
}, cc.easeExponentialIn = function() {
    return cc._easeExponentialInObj
}, cc.EaseExponentialOut = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(1 == a ? 1 : -Math.pow(2, -10 * a) + 1)
    },
    reverse: function() {
        return new cc.EaseExponentialIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialOut;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseExponentialOut.create = function(a) {
    return new cc.EaseExponentialOut(a)
}, cc._easeExponentialOutObj = {
    easing: function(a) {
        return 1 == a ? 1 : -Math.pow(2, -10 * a) + 1
    },
    reverse: function() {
        return cc._easeExponentialInObj
    }
}, cc.easeExponentialOut = function() {
    return cc._easeExponentialOutObj
}, cc.EaseExponentialInOut = cc.ActionEase.extend({
    update: function(a) {
        1 != a && 0 !== a && (a *= 2, a = 1 > a ? .5 * Math.pow(2, 10 * (a - 1)) : .5 * (-Math.pow(2, -10 * (a - 1)) + 2)), this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseExponentialInOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialInOut;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseExponentialInOut.create = function(a) {
    return new cc.EaseExponentialInOut(a)
}, cc._easeExponentialInOutObj = {
    easing: function(a) {
        return 1 !== a && 0 !== a ? (a *= 2, 1 > a ? .5 * Math.pow(2, 10 * (a - 1)) : .5 * (-Math.pow(2, -10 * (a - 1)) + 2)) : a
    },
    reverse: function() {
        return cc._easeExponentialInOutObj
    }
}, cc.easeExponentialInOut = function() {
    return cc._easeExponentialInOutObj
}, cc.EaseSineIn = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1, this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseSineOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseSineIn;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseSineIn.create = function(a) {
    return new cc.EaseSineIn(a)
}, cc._easeSineInObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1
    },
    reverse: function() {
        return cc._easeSineOutObj
    }
}, cc.easeSineIn = function() {
    return cc._easeSineInObj
}, cc.EaseSineOut = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : Math.sin(a * Math.PI / 2), this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseSineIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseSineOut;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseSineOut.create = function(a) {
    return new cc.EaseSineOut(a)
}, cc._easeSineOutObj = {
    easing: function(a) {
        return 0 === a || 1 == a ? a : Math.sin(a * Math.PI / 2)
    },
    reverse: function() {
        return cc._easeSineInObj
    }
}, cc.easeSineOut = function() {
    return cc._easeSineOutObj
}, cc.EaseSineInOut = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : -.5 * (Math.cos(Math.PI * a) - 1), this._inner.update(a)
    },
    clone: function() {
        var a = new cc.EaseSineInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseSineInOut(this._inner.reverse())
    }
}), cc.EaseSineInOut.create = function(a) {
    return new cc.EaseSineInOut(a)
}, cc._easeSineInOutObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : -.5 * (Math.cos(Math.PI * a) - 1)
    },
    reverse: function() {
        return cc._easeSineInOutObj
    }
}, cc.easeSineInOut = function() {
    return cc._easeSineInOutObj
}, cc.EaseElastic = cc.ActionEase.extend({
    _period: .3,
    ctor: function(a, b) {
        cc.ActionEase.prototype.ctor.call(this), a && this.initWithAction(a, b)
    },
    getPeriod: function() {
        return this._period
    },
    setPeriod: function(a) {
        this._period = a
    },
    initWithAction: function(a, b) {
        return cc.ActionEase.prototype.initWithAction.call(this, a), this._period = null == b ? .3 : b, !0
    },
    reverse: function() {
        return cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass."), null
    },
    clone: function() {
        var a = new cc.EaseElastic;
        return a.initWithAction(this._inner.clone(), this._period), a
    }
}), cc.EaseElastic.create = function(a, b) {
    return new cc.EaseElastic(a, b)
}, cc.EaseElasticIn = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0;
        0 === a || 1 === a ? b = a : (b = this._period / 4, a -= 1, b = -Math.pow(2, 10 * a) * Math.sin(2 * (a - b) * Math.PI / this._period)), this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticOut(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticIn;
        return a.initWithAction(this._inner.clone(), this._period), a
    }
}), cc.EaseElasticIn.create = function(a, b) {
    return new cc.EaseElasticIn(a, b)
}, cc._easeElasticInObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : (a -= 1, -Math.pow(2, 10 * a) * Math.sin(2 * (a - .075) * Math.PI / .3))
    },
    reverse: function() {
        return cc._easeElasticOutObj
    }
}, cc.easeElasticIn = function(a) {
    return a && .3 !== a ? {
        _period: a,
        easing: function(a) {
            return 0 === a || 1 === a ? a : (a -= 1, -Math.pow(2, 10 * a) * Math.sin(2 * (a - this._period / 4) * Math.PI / this._period))
        },
        reverse: function() {
            return cc.easeElasticOut(this._period)
        }
    } : cc._easeElasticInObj
}, cc.EaseElasticOut = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0;
        0 === a || 1 == a ? b = a : (b = this._period / 4, b = Math.pow(2, -10 * a) * Math.sin(2 * (a - b) * Math.PI / this._period) + 1), this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticIn(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticOut;
        return a.initWithAction(this._inner.clone(), this._period), a
    }
}), cc.EaseElasticOut.create = function(a, b) {
    return new cc.EaseElasticOut(a, b)
}, cc._easeElasticOutObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin(2 * (a - .075) * Math.PI / .3) + 1
    },
    reverse: function() {
        return cc._easeElasticInObj
    }
}, cc.easeElasticOut = function(a) {
    return a && .3 !== a ? {
        _period: a,
        easing: function(a) {
            return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin(2 * (a - this._period / 4) * Math.PI / this._period) + 1
        },
        reverse: function() {
            return cc.easeElasticIn(this._period)
        }
    } : cc._easeElasticOutObj
}, cc.EaseElasticInOut = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0,
            b = this._period;
        if (0 === a || 1 == a) b = a;
        else {
            b || (b = this._period = .3 * 1.5);
            var c = b / 4;
            a = 2 * a - 1, b = 0 > a ? -.5 * Math.pow(2, 10 * a) * Math.sin(2 * (a - c) * Math.PI / b) : .5 * Math.pow(2, -10 * a) * Math.sin(2 * (a - c) * Math.PI / b) + 1
        }
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticInOut(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticInOut;
        return a.initWithAction(this._inner.clone(), this._period), a
    }
}), cc.EaseElasticInOut.create = function(a, b) {
    return new cc.EaseElasticInOut(a, b)
}, cc.easeElasticInOut = function(a) {
    return {
        _period: a || .3,
        easing: function(a) {
            var b = 0,
                b = this._period;
            if (0 === a || 1 === a) b = a;
            else {
                b || (b = this._period = .3 * 1.5);
                var c = b / 4;
                a = 2 * a - 1, b = 0 > a ? -.5 * Math.pow(2, 10 * a) * Math.sin(2 * (a - c) * Math.PI / b) : .5 * Math.pow(2, -10 * a) * Math.sin(2 * (a - c) * Math.PI / b) + 1
            }
            return b
        },
        reverse: function() {
            return cc.easeElasticInOut(this._period)
        }
    }
}, cc.EaseBounce = cc.ActionEase.extend({
    bounceTime: function(a) {
        return 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? (a -= 1.5 / 2.75, 7.5625 * a * a + .75) : 2.5 / 2.75 > a ? (a -= 2.25 / 2.75, 7.5625 * a * a + .9375) : (a -= 2.625 / 2.75, 7.5625 * a * a + .984375)
    },
    clone: function() {
        var a = new cc.EaseBounce;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseBounce(this._inner.reverse())
    }
}), cc.EaseBounce.create = function(a) {
    return new cc.EaseBounce(a)
}, cc.EaseBounceIn = cc.EaseBounce.extend({
    update: function(a) {
        a = 1 - this.bounceTime(1 - a), this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseBounceOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBounceIn;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseBounceIn.create = function(a) {
    return new cc.EaseBounceIn(a)
}, cc._bounceTime = function(a) {
    return 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? (a -= 1.5 / 2.75, 7.5625 * a * a + .75) : 2.5 / 2.75 > a ? (a -= 2.25 / 2.75, 7.5625 * a * a + .9375) : (a -= 2.625 / 2.75, 7.5625 * a * a + .984375)
}, cc._easeBounceInObj = {
    easing: function(a) {
        return 1 - cc._bounceTime(1 - a)
    },
    reverse: function() {
        return cc._easeBounceOutObj
    }
}, cc.easeBounceIn = function() {
    return cc._easeBounceInObj
}, cc.EaseBounceOut = cc.EaseBounce.extend({
    update: function(a) {
        a = this.bounceTime(a), this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseBounceIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBounceOut;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseBounceOut.create = function(a) {
    return new cc.EaseBounceOut(a)
}, cc._easeBounceOutObj = {
    easing: function(a) {
        return cc._bounceTime(a)
    },
    reverse: function() {
        return cc._easeBounceInObj
    }
}, cc.easeBounceOut = function() {
    return cc._easeBounceOutObj
}, cc.EaseBounceInOut = cc.EaseBounce.extend({
    update: function(a) {
        var b = 0,
            b = .5 > a ? .5 * (1 - this.bounceTime(1 - 2 * a)) : .5 * this.bounceTime(2 * a - 1) + .5;
        this._inner.update(b)
    },
    clone: function() {
        var a = new cc.EaseBounceInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseBounceInOut(this._inner.reverse())
    }
}), cc.EaseBounceInOut.create = function(a) {
    return new cc.EaseBounceInOut(a)
}, cc._easeBounceInOutObj = {
    easing: function(a) {
        return a = .5 > a ? .5 * (1 - cc._bounceTime(1 - 2 * a)) : .5 * cc._bounceTime(2 * a - 1) + .5
    },
    reverse: function() {
        return cc._easeBounceInOutObj
    }
}, cc.easeBounceInOut = function() {
    return cc._easeBounceInOutObj
}, cc.EaseBackIn = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(0 === a || 1 == a ? a : a * a * (2.70158 * a - 1.70158))
    },
    reverse: function() {
        return new cc.EaseBackOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBackIn;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseBackIn.create = function(a) {
    return new cc.EaseBackIn(a)
}, cc._easeBackInObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : a * a * (2.70158 * a - 1.70158)
    },
    reverse: function() {
        return cc._easeBackOutObj
    }
}, cc.easeBackIn = function() {
    return cc._easeBackInObj
}, cc.EaseBackOut = cc.ActionEase.extend({
    update: function(a) {
        a -= 1, this._inner.update(a * a * (2.70158 * a + 1.70158) + 1)
    },
    reverse: function() {
        return new cc.EaseBackIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBackOut;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseBackOut.create = function(a) {
    return new cc.EaseBackOut(a)
}, cc._easeBackOutObj = {
    easing: function(a) {
        return a -= 1, a * a * (2.70158 * a + 1.70158) + 1
    },
    reverse: function() {
        return cc._easeBackInObj
    }
}, cc.easeBackOut = function() {
    return cc._easeBackOutObj
}, cc.EaseBackInOut = cc.ActionEase.extend({
    update: function(a) {
        a *= 2, 1 > a ? this._inner.update(a * a * (3.5949095 * a - 2.5949095) / 2) : (a -= 2, this._inner.update(a * a * (3.5949095 * a + 2.5949095) / 2 + 1))
    },
    clone: function() {
        var a = new cc.EaseBackInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseBackInOut(this._inner.reverse())
    }
}), cc.EaseBackInOut.create = function(a) {
    return new cc.EaseBackInOut(a)
}, cc._easeBackInOutObj = {
    easing: function(a) {
        return a *= 2, 1 > a ? a * a * (3.5949095 * a - 2.5949095) / 2 : (a -= 2, a * a * (3.5949095 * a + 2.5949095) / 2 + 1)
    },
    reverse: function() {
        return cc._easeBackInOutObj
    }
}, cc.easeBackInOut = function() {
    return cc._easeBackInOutObj
}, cc.EaseBezierAction = cc.ActionEase.extend({
    _p0: null,
    _p1: null,
    _p2: null,
    _p3: null,
    ctor: function(a) {
        cc.ActionEase.prototype.ctor.call(this, a)
    },
    _updateTime: function(a, b, c, d, e) {
        return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
    },
    update: function(a) {
        a = this._updateTime(this._p0, this._p1, this._p2, this._p3, a), this._inner.update(a)
    },
    clone: function() {
        var a = new cc.EaseBezierAction;
        return a.initWithAction(this._inner.clone()), a.setBezierParamer(this._p0, this._p1, this._p2, this._p3), a
    },
    reverse: function() {
        var a = new cc.EaseBezierAction(this._inner.reverse());
        return a.setBezierParamer(this._p3, this._p2, this._p1, this._p0), a
    },
    setBezierParamer: function(a, b, c, d) {
        this._p0 = a || 0, this._p1 = b || 0, this._p2 = c || 0, this._p3 = d || 0
    }
}), cc.EaseBezierAction.create = function(a) {
    return new cc.EaseBezierAction(a)
}, cc.easeBezierAction = function(a, b, c, d) {
    return {
        easing: function(e) {
            return cc.EaseBezierAction.prototype._updateTime(a, b, c, d, e)
        },
        reverse: function() {
            return cc.easeBezierAction(d, c, b, a)
        }
    }
}, cc.EaseQuadraticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return Math.pow(a, 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionIn;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionIn(this._inner.reverse())
    }
}), cc.EaseQuadraticActionIn.create = function(a) {
    return new cc.EaseQuadraticActionIn(a)
}, cc._easeQuadraticActionIn = {
    easing: cc.EaseQuadraticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionIn
    }
}, cc.easeQuadraticActionIn = function() {
    return cc._easeQuadraticActionIn
}, cc.EaseQuadraticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return -a * (a - 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionOut;
        return a.initWithAction(), a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionOut(this._inner.reverse())
    }
}), cc.EaseQuadraticActionOut.create = function(a) {
    return new cc.EaseQuadraticActionOut(a)
}, cc._easeQuadraticActionOut = {
    easing: cc.EaseQuadraticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionOut
    }
}, cc.easeQuadraticActionOut = function() {
    return cc._easeQuadraticActionOut
}, cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        var b = a;
        return a *= 2, 1 > a ? b = .5 * a * a : (--a, b = -.5 * (a * (a - 2) - 1)), b
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionInOut(this._inner.reverse())
    }
}), cc.EaseQuadraticActionInOut.create = function(a) {
    return new cc.EaseQuadraticActionInOut(a)
}, cc._easeQuadraticActionInOut = {
    easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionInOut
    }
}, cc.easeQuadraticActionInOut = function() {
    return cc._easeQuadraticActionInOut
}, cc.EaseQuarticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionIn;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuarticActionIn(this._inner.reverse())
    }
}), cc.EaseQuarticActionIn.create = function(a) {
    return new cc.EaseQuarticActionIn(a)
}, cc._easeQuarticActionIn = {
    easing: cc.EaseQuarticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionIn
    }
}, cc.easeQuarticActionIn = function() {
    return cc._easeQuarticActionIn
}, cc.EaseQuarticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a -= 1, -(a * a * a * a - 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuarticActionOut(this._inner.reverse())
    }
}), cc.EaseQuarticActionOut.create = function(a) {
    return new cc.EaseQuarticActionOut(a)
}, cc._easeQuarticActionOut = {
    easing: cc.EaseQuarticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionOut
    }
}, cc.easeQuarticActionOut = function() {
    return cc._easeQuarticActionOut
}, cc.EaseQuarticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a *= 2, 1 > a ? .5 * a * a * a * a : (a -= 2, -.5 * (a * a * a * a - 2))
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuarticActionInOut(this._inner.reverse())
    }
}), cc.EaseQuarticActionInOut.create = function(a) {
    return new cc.EaseQuarticActionInOut(a)
}, cc._easeQuarticActionInOut = {
    easing: cc.EaseQuarticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionInOut
    }
}, cc.easeQuarticActionInOut = function() {
    return cc._easeQuarticActionInOut
}, cc.EaseQuinticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionIn;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuinticActionIn(this._inner.reverse())
    }
}), cc.EaseQuinticActionIn.create = function(a) {
    return new cc.EaseQuinticActionIn(a)
}, cc._easeQuinticActionIn = {
    easing: cc.EaseQuinticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionIn
    }
}, cc.easeQuinticActionIn = function() {
    return cc._easeQuinticActionIn
}, cc.EaseQuinticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a -= 1, a * a * a * a * a + 1
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuinticActionOut(this._inner.reverse())
    }
}), cc.EaseQuinticActionOut.create = function(a) {
    return new cc.EaseQuinticActionOut(a)
}, cc._easeQuinticActionOut = {
    easing: cc.EaseQuinticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionOut
    }
}, cc.easeQuinticActionOut = function() {
    return cc._easeQuinticActionOut
}, cc.EaseQuinticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a *= 2, 1 > a ? .5 * a * a * a * a * a : (a -= 2, .5 * (a * a * a * a * a + 2))
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuinticActionInOut(this._inner.reverse())
    }
}), cc.EaseQuinticActionInOut.create = function(a) {
    return new cc.EaseQuinticActionInOut(a)
}, cc._easeQuinticActionInOut = {
    easing: cc.EaseQuinticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionInOut
    }
}, cc.easeQuinticActionInOut = function() {
    return cc._easeQuinticActionInOut
}, cc.EaseCircleActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return -1 * (Math.sqrt(1 - a * a) - 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionIn;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseCircleActionIn(this._inner.reverse())
    }
}), cc.EaseCircleActionIn.create = function(a) {
    return new cc.EaseCircleActionIn(a)
}, cc._easeCircleActionIn = {
    easing: cc.EaseCircleActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionIn
    }
}, cc.easeCircleActionIn = function() {
    return cc._easeCircleActionIn
}, cc.EaseCircleActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a -= 1, Math.sqrt(1 - a * a)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseCircleActionOut(this._inner.reverse())
    }
}), cc.EaseCircleActionOut.create = function(a) {
    return new cc.EaseCircleActionOut(a)
}, cc._easeCircleActionOut = {
    easing: cc.EaseCircleActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionOut
    }
}, cc.easeCircleActionOut = function() {
    return cc._easeCircleActionOut
}, cc.EaseCircleActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a *= 2, 1 > a ? -.5 * (Math.sqrt(1 - a * a) - 1) : (a -= 2, .5 * (Math.sqrt(1 - a * a) + 1))
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseCircleActionInOut(this._inner.reverse())
    }
}), cc.EaseCircleActionInOut.create = function(a) {
    return new cc.EaseCircleActionInOut(a)
}, cc._easeCircleActionInOut = {
    easing: cc.EaseCircleActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionInOut
    }
}, cc.easeCircleActionInOut = function() {
    return cc._easeCircleActionInOut
}, cc.EaseCubicActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionIn;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseCubicActionIn(this._inner.reverse())
    }
}), cc.EaseCubicActionIn.create = function(a) {
    return new cc.EaseCubicActionIn(a)
}, cc._easeCubicActionIn = {
    easing: cc.EaseCubicActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionIn
    }
}, cc.easeCubicActionIn = function() {
    return cc._easeCubicActionIn
}, cc.EaseCubicActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a -= 1, a * a * a + 1
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseCubicActionOut(this._inner.reverse())
    }
}), cc.EaseCubicActionOut.create = function(a) {
    return new cc.EaseCubicActionOut(a)
}, cc._easeCubicActionOut = {
    easing: cc.EaseCubicActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionOut
    }
}, cc.easeCubicActionOut = function() {
    return cc._easeCubicActionOut
}, cc.EaseCubicActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a *= 2, 1 > a ? .5 * a * a * a : (a -= 2, .5 * (a * a * a + 2))
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseCubicActionInOut(this._inner.reverse())
    }
}), cc.EaseCubicActionInOut.create = function(a) {
    return new cc.EaseCubicActionInOut(a)
}, cc._easeCubicActionInOut = {
    easing: cc.EaseCubicActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionInOut
    }
}, cc.easeCubicActionInOut = function() {
    return cc._easeCubicActionInOut
}, cc.cardinalSplineAt = function(a, b, c, d, e, f) {
    var g = f * f,
        h = g * f,
        i = (1 - e) / 2;
    e = i * (-h + 2 * g - f);
    var j = i * (-h + g) + (2 * h - 3 * g + 1);
    return f = i * (h - 2 * g + f) + (-2 * h + 3 * g), g = i * (h - g), cc.p(a.x * e + b.x * j + c.x * f + d.x * g, a.y * e + b.y * j + c.y * f + d.y * g)
}, cc.reverseControlPoints = function(a) {
    for (var b = [], c = a.length - 1; c >= 0; c--) b.push(cc.p(a[c].x, a[c].y));
    return b
}, cc.cloneControlPoints = function(a) {
    for (var b = [], c = 0; c < a.length; c++) b.push(cc.p(a[c].x, a[c].y));
    return b
}, cc.copyControlPoints = cc.cloneControlPoints, cc.getControlPointAt = function(a, b) {
    var c = Math.min(a.length - 1, Math.max(b, 0));
    return a[c]
}, cc.reverseControlPointsInline = function(a) {
    for (var b = a.length, c = 0 | b / 2, d = 0; c > d; ++d) {
        var e = a[d];
        a[d] = a[b - d - 1], a[b - d - 1] = e
    }
}, cc.CardinalSplineTo = cc.ActionInterval.extend({
    _points: null,
    _deltaT: 0,
    _tension: 0,
    _previousPosition: null,
    _accumulatedDiff: null,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this), this._points = [], void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        if (!b || 0 == b.length) throw "Invalid configuration. It must at least have one control point";
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.setPoints(b), this._tension = c, !0) : !1
    },
    clone: function() {
        var a = new cc.CardinalSplineTo;
        return a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._deltaT = 1 / (this._points.length - 1), this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY()), this._accumulatedDiff = cc.p(0, 0)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b, c = this._points;
        if (1 == a) b = c.length - 1, a = 1;
        else {
            var d = this._deltaT;
            b = 0 | a / d, a = (a - d * b) / d
        }
        b = cc.cardinalSplineAt(cc.getControlPointAt(c, b - 1), cc.getControlPointAt(c, b - 0), cc.getControlPointAt(c, b + 1), cc.getControlPointAt(c, b + 2), this._tension, a), cc.ENABLE_STACKABLE_ACTIONS && (c = this.target.getPositionX() - this._previousPosition.x, a = this.target.getPositionY() - this._previousPosition.y, 0 != c || 0 != a) && (d = this._accumulatedDiff, c = d.x + c, a = d.y + a, d.x = c, d.y = a, b.x += c, b.y += a), this.updatePosition(b)
    },
    reverse: function() {
        var a = cc.reverseControlPoints(this._points);
        return cc.cardinalSplineTo(this._duration, a, this._tension)
    },
    updatePosition: function(a) {
        this.target.setPosition(a), this._previousPosition = a
    },
    getPoints: function() {
        return this._points
    },
    setPoints: function(a) {
        this._points = a
    }
}), cc.cardinalSplineTo = function(a, b, c) {
    return new cc.CardinalSplineTo(a, b, c)
}, cc.CardinalSplineTo.create = cc.cardinalSplineTo, cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
    _startPosition: null,
    ctor: function(a, b, c) {
        cc.CardinalSplineTo.prototype.ctor.call(this), this._startPosition = cc.p(0, 0), void 0 !== c && this.initWithDuration(a, b, c)
    },
    startWithTarget: function(a) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, a), this._startPosition.x = a.getPositionX(), this._startPosition.y = a.getPositionY()
    },
    reverse: function() {
        for (var a, b = this._points.slice(), c = b[0], d = 1; d < b.length; ++d) a = b[d], b[d] = cc.pSub(a, c), c = a;
        for (b = cc.reverseControlPoints(b), c = b[b.length - 1], b.pop(), c.x = -c.x, c.y = -c.y, b.unshift(c), d = 1; d < b.length; ++d) a = b[d], a.x = -a.x, a.y = -a.y, a.x += c.x, a.y += c.y, c = b[d] = a;
        return cc.cardinalSplineBy(this._duration, b, this._tension)
    },
    updatePosition: function(a) {
        var b = this._startPosition,
            c = a.x + b.x;
        a = a.y + b.y, this._previousPosition.x = c, this._previousPosition.y = a, this.target.setPosition(c, a)
    },
    clone: function() {
        var a = new cc.CardinalSplineBy;
        return a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension), a
    }
}), cc.cardinalSplineBy = function(a, b, c) {
    return new cc.CardinalSplineBy(a, b, c)
}, cc.CardinalSplineBy.create = cc.cardinalSplineBy, cc.CatmullRomTo = cc.CardinalSplineTo.extend({
    ctor: function(a, b) {
        b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, .5)
    },
    clone: function() {
        var a = new cc.CatmullRomTo;
        return a.initWithDuration(this._duration, cc.copyControlPoints(this._points)), a
    }
}), cc.catmullRomTo = function(a, b) {
    return new cc.CatmullRomTo(a, b)
}, cc.CatmullRomTo.create = cc.catmullRomTo, cc.CatmullRomBy = cc.CardinalSplineBy.extend({
    ctor: function(a, b) {
        cc.CardinalSplineBy.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, .5)
    },
    clone: function() {
        var a = new cc.CatmullRomBy;
        return a.initWithDuration(this._duration, cc.copyControlPoints(this._points)), a
    }
}), cc.catmullRomBy = function(a, b) {
    return new cc.CatmullRomBy(a, b)
}, cc.CatmullRomBy.create = cc.catmullRomBy, cc.ActionTweenDelegate = cc.Class.extend({
    updateTweenAction: function() {}
}), cc.ActionTween = cc.ActionInterval.extend({
    key: "",
    from: 0,
    to: 0,
    delta: 0,
    ctor: function(a, b, c, d) {
        cc.ActionInterval.prototype.ctor.call(this), this.key = "", void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.key = b, this.to = d, this.from = c, !0) : !1
    },
    startWithTarget: function(a) {
        if (!a || !a.updateTweenAction) throw "cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function";
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this.delta = this.to - this.from
    },
    update: function(a) {
        this.target.updateTweenAction(this.to - this.delta * (1 - a), this.key)
    },
    reverse: function() {
        return new cc.ActionTween(this.duration, this.key, this.to, this.from)
    },
    clone: function() {
        var a = new cc.ActionTween;
        return a.initWithDuration(this._duration, this.key, this.from, this.to), a
    }
}), cc.actionTween = function(a, b, c, d) {
    return new cc.ActionTween(a, b, c, d)
}, cc.ActionTween.create = cc.actionTween, cc.GridAction = cc.ActionInterval.extend({
    _gridSize: null,
    ctor: function(a, b) {
        cc._checkWebGLRenderMode(), cc.ActionInterval.prototype.ctor.call(this), this._gridSize = cc.size(0, 0), b && this.initWithDuration(a, b)
    },
    clone: function() {
        var a = new cc.GridAction,
            b = this._gridSize;
        return a.initWithDuration(this._duration, cc.size(b.width, b.height)), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = this.getGrid(),
            c = this.target;
        (a = c.grid) && 0 < a.getReuseGrid() ? (b = a.getGridSize(), a.isActive() && b.width == this._gridSize.width && b.height == this._gridSize.height && a.reuse()) : (a && a.isActive() && a.setActive(!1), c.grid = b, c.grid.setActive(!0))
    },
    reverse: function() {
        return new cc.ReverseTime(this)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._gridSize.width = b.width, this._gridSize.height = b.height, !0) : !1
    },
    getGrid: function() {
        cc.log("cc.GridAction.getGrid(): it should be overridden in subclass.")
    }
}), cc.gridAction = function(a, b) {
    return new cc.GridAction(a, b)
}, cc.GridAction.create = cc.gridAction, cc.Grid3DAction = cc.GridAction.extend({
    getGrid: function() {
        return new cc.Grid3D(this._gridSize)
    },
    vertex: function(a) {
        return this.target.grid.vertex(a)
    },
    originalVertex: function(a) {
        return this.target.grid.originalVertex(a)
    },
    setVertex: function(a, b) {
        this.target.grid.setVertex(a, b)
    }
}), cc.grid3DAction = function(a, b) {
    return new cc.Grid3DAction(a, b)
}, cc.Grid3DAction.create = cc.grid3DAction, cc.TiledGrid3DAction = cc.GridAction.extend({
    tile: function(a) {
        return this.target.grid.tile(a)
    },
    originalTile: function(a) {
        return this.target.grid.originalTile(a)
    },
    setTile: function(a, b) {
        this.target.grid.setTile(a, b)
    },
    getGrid: function() {
        return new cc.TiledGrid3D(this._gridSize)
    }
}), cc.tiledGrid3DAction = function(a, b) {
    return new cc.TiledGrid3DAction(a, b)
}, cc.TiledGrid3DAction.create = cc.tiledGrid3DAction, cc.StopGrid = cc.ActionInstant.extend({
    startWithTarget: function(a) {
        cc.ActionInstant.prototype.startWithTarget.call(this, a), (a = this.target.grid) && a.isActive() && a.setActive(!1)
    }
}), cc.stopGrid = function() {
    return new cc.StopGrid
}, cc.StopGrid.create = cc.stopGrid, cc.ReuseGrid = cc.ActionInstant.extend({
    _times: null,
    ctor: function(a) {
        cc.ActionInstant.prototype.ctor.call(this), void 0 !== a && this.initWithTimes(a)
    },
    initWithTimes: function(a) {
        return this._times = a, !0
    },
    startWithTarget: function(a) {
        cc.ActionInstant.prototype.startWithTarget.call(this, a), this.target.grid && this.target.grid.isActive() && this.target.grid.setReuseGrid(this.target.grid.getReuseGrid() + this._times)
    }
}), cc.reuseGrid = function(a) {
    return new cc.ReuseGrid(a)
}, cc.ReuseGrid.create = cc.reuseGrid, cc.Waves3D = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b = this._gridSize, c = this._amplitude, d = cc.p(0, 0), e = this._amplitudeRate, f = this._waves, g = 0; g < b.width + 1; ++g)
            for (var h = 0; h < b.height + 1; ++h) {
                d.x = g, d.y = h;
                var i = this.originalVertex(d);
                i.z += Math.sin(2 * Math.PI * a * f + .01 * (i.y + i.x)) * c * e, this.setVertex(d, i)
            }
    }
}), cc.waves3D = function(a, b, c, d) {
    return new cc.Waves3D(a, b, c, d)
}, cc.Waves3D.create = cc.waves3D, cc.FlipX3D = cc.Grid3DAction.extend({
    ctor: function(a) {
        void 0 !== a ? cc.GridAction.prototype.ctor.call(this, a, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
    },
    initWithDuration: function(a) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, cc.size(1, 1))
    },
    initWithSize: function(a, b) {
        return 1 != a.width || 1 != a.height ? (cc.log("Grid size must be (1,1)"), !1) : cc.Grid3DAction.prototype.initWithDuration.call(this, b, a)
    },
    update: function(a) {
        var b = Math.PI * a;
        a = Math.sin(b);
        var c = Math.cos(b / 2),
            b = new cc.Vertex3F,
            d = cc.p(0, 0);
        d.x = d.y = 1;
        var e = this.originalVertex(d);
        d.x = d.y = 0;
        var f, g, d = this.originalVertex(d),
            h = e.x,
            i = d.x;
        h > i ? (e = cc.p(0, 0), d = cc.p(0, 1), f = cc.p(1, 0), g = cc.p(1, 1)) : (f = cc.p(0, 0), g = cc.p(0, 1), e = cc.p(1, 0), d = cc.p(1, 1), h = i), b.x = h - h * c, b.z = Math.abs(parseFloat(h * a / 4)), a = this.originalVertex(e), a.x = b.x, a.z += b.z, this.setVertex(e, a), a = this.originalVertex(d), a.x = b.x, a.z += b.z, this.setVertex(d, a), a = this.originalVertex(f), a.x -= b.x, a.z -= b.z, this.setVertex(f, a), a = this.originalVertex(g), a.x -= b.x, a.z -= b.z, this.setVertex(g, a)
    }
}), cc.flipX3D = function(a) {
    return new cc.FlipX3D(a)
}, cc.FlipX3D.create = cc.flipX3D, cc.FlipY3D = cc.FlipX3D.extend({
    ctor: function(a) {
        void 0 !== a ? cc.GridAction.prototype.ctor.call(this, a, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
    },
    update: function(a) {
        var b = Math.PI * a;
        a = Math.sin(b);
        var c = Math.cos(b / 2),
            b = new cc.Vertex3F,
            d = cc.p(0, 0);
        d.x = d.y = 1;
        var e = this.originalVertex(d);
        d.x = d.y = 0;
        var f, g, d = this.originalVertex(d),
            h = e.y,
            i = d.y;
        h > i ? (e = cc.p(0, 0), d = cc.p(0, 1), f = cc.p(1, 0), g = cc.p(1, 1)) : (d = cc.p(0, 0), e = cc.p(0, 1), g = cc.p(1, 0), f = cc.p(1, 1), h = i), b.y = h - h * c, b.z = Math.abs(parseFloat(h * a) / 4), a = this.originalVertex(e), a.y = b.y, a.z += b.z, this.setVertex(e, a), a = this.originalVertex(d), a.y -= b.y, a.z -= b.z, this.setVertex(d, a), a = this.originalVertex(f), a.y = b.y, a.z += b.z, this.setVertex(f, a), a = this.originalVertex(g), a.y -= b.y, a.z -= b.z, this.setVertex(g, a)
    }
}), cc.flipY3D = function(a) {
    return new cc.FlipY3D(a)
}, cc.FlipY3D.create = cc.flipY3D, cc.Lens3D = cc.Grid3DAction.extend({
    _position: null,
    _radius: 0,
    _lensEffect: 0,
    _concave: !1,
    _dirty: !1,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), this._position = cc.p(0, 0), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getLensEffect: function() {
        return this._lensEffect
    },
    setLensEffect: function(a) {
        this._lensEffect = a
    },
    setConcave: function(a) {
        this._concave = a
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(a) {
        cc.pointEqualToPoint(a, this._position) || (this._position.x = a.x, this._position.y = a.y, this._dirty = !0)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._radius = d, this._lensEffect = .7, this._dirty = !0) : !1
    },
    update: function(a) {
        if (this._dirty) {
            a = this._gridSize.width;
            for (var b, c, d, e = this._gridSize.height, f = this._radius, g = this._lensEffect, h = cc.p(0, 0), i = cc.p(0, 0), j = 0; a + 1 > j; ++j)
                for (var k = 0; e + 1 > k; ++k) h.x = j, h.y = k, b = this.originalVertex(h), i.x = this._position.x - b.x, i.y = this._position.y - b.y, c = cc.pLength(i), f > c && (c = f - c, c /= f, 0 == c && (c = .001), c = Math.log(c) * g, d = Math.exp(c) * f, c = cc.pLength(i), c > 0 && (i.x /= c, i.y /= c, i.x *= d, i.y *= d, b.z += cc.pLength(i) * g)), this.setVertex(h, b);
            this._dirty = !1
        }
    }
}), cc.lens3D = function(a, b, c, d) {
    return new cc.Lens3D(a, b, c, d)
}, cc.Lens3D.create = cc.lens3D, cc.Ripple3D = cc.Grid3DAction.extend({
    _position: null,
    _radius: 0,
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d, e, f) {
        cc.GridAction.prototype.ctor.call(this), this._position = cc.p(0, 0), void 0 !== f && this.initWithDuration(a, b, c, d, e, f)
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(a) {
        this._position.x = a.x, this._position.y = a.y
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d, e, f) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._radius = d, this._waves = e, this._amplitude = f, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b, c, d = this._gridSize.width, e = this._gridSize.height, f = cc.p(0, 0), g = this._radius, h = this._waves, i = this._amplitude, j = this._amplitudeRate, k = cc.p(0, 0), l = 0; d + 1 > l; ++l)
            for (var m = 0; e + 1 > m; ++m) {
                if (f.x = l, f.y = m, b = this.originalVertex(f), k.x = this._position.x - b.x, k.y = this._position.y - b.y, c = cc.pLength(k), g > c) {
                    c = g - c;
                    var n = Math.pow(c / g, 2);
                    b.z += Math.sin(2 * a * Math.PI * h + .1 * c) * i * j * n
                }
                this.setVertex(f, b)
            }
    }
}), cc.ripple3D = function(a, b, c, d, e, f) {
    return new cc.Ripple3D(a, b, c, d, e, f)
}, cc.Ripple3D.create = cc.ripple3D, cc.Shaky3D = cc.Grid3DAction.extend({
    _randRange: 0,
    _shakeZ: !1,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._randRange = c, this._shakeZ = d, !0) : !1
    },
    update: function(a) {
        a = this._gridSize.width;
        for (var b, c = this._gridSize.height, d = this._randRange, e = this._shakeZ, f = cc.p(0, 0), g = 0; a + 1 > g; ++g)
            for (var h = 0; c + 1 > h; ++h) f.x = g, f.y = h, b = this.originalVertex(f), b.x += cc.rand() % (2 * d) - d, b.y += cc.rand() % (2 * d) - d, e && (b.z += cc.rand() % (2 * d) - d), this.setVertex(f, b)
    }
}), cc.shaky3D = function(a, b, c, d) {
    return new cc.Shaky3D(a, b, c, d)
}, cc.Shaky3D.create = cc.shaky3D, cc.Liquid = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b, c = this._gridSize.width, d = this._gridSize.height, e = cc.p(0, 0), f = this._waves, g = this._amplitude, h = this._amplitudeRate, i = 1; c > i; ++i)
            for (var j = 1; d > j; ++j) e.x = i, e.y = j, b = this.originalVertex(e), b.x += Math.sin(2 * a * Math.PI * f + .01 * b.x) * g * h, b.y += Math.sin(2 * a * Math.PI * f + .01 * b.y) * g * h, this.setVertex(e, b)
    }
}), cc.liquid = function(a, b, c, d) {
    return new cc.Liquid(a, b, c, d)
}, cc.Liquid.create = cc.liquid, cc.Waves = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    _vertical: !1,
    _horizontal: !1,
    ctor: function(a, b, c, d, e, f) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== f && this.initWithDuration(a, b, c, d, e, f)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d, e, f) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = c, this._amplitude = d, this._amplitudeRate = 1, this._horizontal = e, this._vertical = f, !0) : !1
    },
    update: function(a) {
        for (var b, c = this._gridSize.width, d = this._gridSize.height, e = cc.p(0, 0), f = this._vertical, g = this._horizontal, h = this._waves, i = this._amplitude, j = this._amplitudeRate, k = 0; c + 1 > k; ++k)
            for (var l = 0; d + 1 > l; ++l) e.x = k, e.y = l, b = this.originalVertex(e), f && (b.x += Math.sin(2 * a * Math.PI * h + .01 * b.y) * i * j), g && (b.y += Math.sin(2 * a * Math.PI * h + .01 * b.x) * i * j), this.setVertex(e, b)
    }
}), cc.waves = function(a, b, c, d, e, f) {
    return new cc.Waves(a, b, c, d, e, f)
}, cc.Waves.create = cc.waves, cc.Twirl = cc.Grid3DAction.extend({
    _position: null,
    _twirls: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d, e) {
        cc.GridAction.prototype.ctor.call(this), this._position = cc.p(0, 0), void 0 !== e && this.initWithDuration(a, b, c, d, e)
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(a) {
        this._position.x = a.x, this._position.y = a.y
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d, e) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._twirls = d, this._amplitude = e, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b, c, d, e = this._position, f = this._gridSize.width, g = this._gridSize.height, h = cc.p(0, 0), i = .1 * this._amplitude * this._amplitudeRate, j = this._twirls, k = cc.p(0, 0), l = 0; f + 1 > l; ++l)
            for (var m = 0; g + 1 > m; ++m) h.x = l, h.y = m, b = this.originalVertex(h), k.x = l - f / 2, k.y = m - g / 2, c = cc.pLength(k) * Math.cos(Math.PI / 2 + 2 * a * Math.PI * j) * i, d = Math.sin(c) * (b.y - e.y) + Math.cos(c) * (b.x - e.x), c = Math.cos(c) * (b.y - e.y) - Math.sin(c) * (b.x - e.x), b.x = e.x + d, b.y = e.y + c, this.setVertex(h, b)
    }
}), cc.twirl = function(a, b, c, d, e) {
    return new cc.Twirl(a, b, c, d, e)
}, cc.Twirl.create = cc.twirl, cc.ShakyTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0,
    _shakeZ: !1,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._randRange = c, this._shakeZ = d, !0) : !1
    },
    update: function(a) {
        a = this._gridSize;
        for (var b = this._randRange, c = cc.p(0, 0), d = 0; d < a.width; ++d)
            for (var e = 0; e < a.height; ++e) {
                c.x = d, c.y = e;
                var f = this.originalTile(c);
                f.bl.x += cc.rand() % (2 * b) - b, f.br.x += cc.rand() % (2 * b) - b, f.tl.x += cc.rand() % (2 * b) - b, f.tr.x += cc.rand() % (2 * b) - b, f.bl.y += cc.rand() % (2 * b) - b, f.br.y += cc.rand() % (2 * b) - b, f.tl.y += cc.rand() % (2 * b) - b, f.tr.y += cc.rand() % (2 * b) - b, this._shakeZ && (f.bl.z += cc.rand() % (2 * b) - b, f.br.z += cc.rand() % (2 * b) - b, f.tl.z += cc.rand() % (2 * b) - b, f.tr.z += cc.rand() % (2 * b) - b), this.setTile(c, f)
            }
    }
}), cc.shakyTiles3D = function(a, b, c, d) {
    return new cc.ShakyTiles3D(a, b, c, d)
}, cc.ShakyTiles3D.create = cc.shakyTiles3D, cc.ShatteredTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0,
    _once: !1,
    _shatterZ: !1,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._once = !1, this._randRange = c, this._shatterZ = d, !0) : !1
    },
    update: function(a) {
        if (!1 === this._once) {
            a = this._gridSize;
            for (var b, c = this._randRange, d = cc.p(0, 0), e = 0; e < a.width; ++e)
                for (var f = 0; f < a.height; ++f) d.x = e, d.y = f, b = this.originalTile(d), b.bl.x += cc.rand() % (2 * c) - c, b.br.x += cc.rand() % (2 * c) - c, b.tl.x += cc.rand() % (2 * c) - c, b.tr.x += cc.rand() % (2 * c) - c, b.bl.y += cc.rand() % (2 * c) - c, b.br.y += cc.rand() % (2 * c) - c, b.tl.y += cc.rand() % (2 * c) - c, b.tr.y += cc.rand() % (2 * c) - c, this._shatterZ && (b.bl.z += cc.rand() % (2 * c) - c, b.br.z += cc.rand() % (2 * c) - c, b.tl.z += cc.rand() % (2 * c) - c, b.tr.z += cc.rand() % (2 * c) - c), this.setTile(d, b);
            this._once = !0
        }
    }
}), cc.shatteredTiles3D = function(a, b, c, d) {
    return new cc.ShatteredTiles3D(a, b, c, d)
}, cc.ShatteredTiles3D.create = cc.shatteredTiles3D, cc.Tile = function(a, b, c) {
    this.position = a || cc.p(0, 0), this.startPosition = b || cc.p(0, 0), this.delta = c || cc.p(0, 0)
}, cc.ShuffleTiles = cc.TiledGrid3DAction.extend({
    _seed: 0,
    _tilesCount: 0,
    _tilesOrder: null,
    _tiles: null,
    ctor: function(a, b, c) {
        cc.GridAction.prototype.ctor.call(this), this._tilesOrder = [], this._tiles = [], void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._seed = c, this._tilesOrder.length = 0, this._tiles.length = 0, !0) : !1
    },
    shuffle: function(a, b) {
        for (var c = b - 1; c >= 0; c--) {
            var d = 0 | cc.rand() % (c + 1),
                e = a[c];
            a[c] = a[d], a[d] = e
        }
    },
    getDelta: function(a) {
        var b = this._gridSize,
            c = a.width * b.height + a.height;
        return cc.size(this._tilesOrder[c] / b.height - a.width, this._tilesOrder[c] % b.height - a.height)
    },
    placeTile: function(a, b) {
        var c = this.originalTile(a),
            d = this.target.grid.getStep(),
            e = b.position;
        c.bl.x += e.x * d.x, c.bl.y += e.y * d.y, c.br.x += e.x * d.x, c.br.y += e.y * d.y, c.tl.x += e.x * d.x, c.tl.y += e.y * d.y, c.tr.x += e.x * d.x, c.tr.y += e.y * d.y, this.setTile(a, c)
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a), a = this._gridSize, this._tilesCount = a.width * a.height;
        for (var b = this._tilesOrder, c = b.length = 0; c < this._tilesCount; ++c) b[c] = c;
        this.shuffle(b, this._tilesCount);
        for (var b = this._tiles, c = b.length = 0, d = cc.size(0, 0), e = 0; e < a.width; ++e)
            for (var f = 0; f < a.height; ++f) b[c] = new cc.Tile, b[c].position = cc.p(e, f), b[c].startPosition = cc.p(e, f), d.width = e, d.height = f, b[c].delta = this.getDelta(d), ++c
    },
    update: function(a) {
        for (var b, c = 0, d = this._gridSize, e = this._tiles, f = cc.p(0, 0), g = 0; g < d.width; ++g)
            for (var h = 0; h < d.height; ++h) f.x = g, f.y = h, b = e[c], b.position.x = b.delta.width * a, b.position.y = b.delta.height * a, this.placeTile(f, b), ++c
    }
}), cc.shuffleTiles = function(a, b, c) {
    return new cc.ShuffleTiles(a, b, c)
}, cc.ShuffleTiles.create = cc.shuffleTiles, cc.FadeOutTRTiles = cc.TiledGrid3DAction.extend({
    testFunc: function(a, b) {
        var c = this._gridSize.width * b,
            d = this._gridSize.height * b;
        return 0 == c + d ? 1 : Math.pow((a.width + a.height) / (c + d), 6)
    },
    turnOnTile: function(a) {
        this.setTile(a, this.originalTile(a))
    },
    turnOffTile: function(a) {
        this.setTile(a, new cc.Quad3)
    },
    transformTile: function(a, b) {
        var c = this.originalTile(a),
            d = this.target.grid.getStep();
        c.bl.x += d.x / 2 * (1 - b), c.bl.y += d.y / 2 * (1 - b), c.br.x -= d.x / 2 * (1 - b), c.br.y += d.y / 2 * (1 - b), c.tl.x += d.x / 2 * (1 - b), c.tl.y -= d.y / 2 * (1 - b), c.tr.x -= d.x / 2 * (1 - b), c.tr.y -= d.y / 2 * (1 - b), this.setTile(a, c)
    },
    update: function(a) {
        for (var b, c = this._gridSize, d = cc.p(0, 0), e = cc.size(0, 0), f = 0; f < c.width; ++f)
            for (var g = 0; g < c.height; ++g) d.x = f, d.y = g, e.width = f, e.height = g, b = this.testFunc(e, a), 0 == b ? this.turnOffTile(d) : 1 > b ? this.transformTile(d, b) : this.turnOnTile(d)
    }
}), cc.fadeOutTRTiles = function(a, b) {
    return new cc.FadeOutTRTiles(a, b)
}, cc.FadeOutTRTiles.create = cc.fadeOutTRTiles, cc.FadeOutBLTiles = cc.FadeOutTRTiles.extend({
    testFunc: function(a, b) {
        return 0 == a.width + a.height ? 1 : Math.pow((this._gridSize.width * (1 - b) + this._gridSize.height * (1 - b)) / (a.width + a.height), 6)
    }
}), cc.fadeOutBLTiles = function(a, b) {
    return new cc.FadeOutBLTiles(a, b)
}, cc.FadeOutBLTiles.create = cc.fadeOutBLTiles, cc.FadeOutUpTiles = cc.FadeOutTRTiles.extend({
    testFunc: function(a, b) {
        var c = this._gridSize.height * b;
        return 0 == c ? 1 : Math.pow(a.height / c, 6)
    },
    transformTile: function(a, b) {
        var c = this.originalTile(a),
            d = this.target.grid.getStep();
        c.bl.y += d.y / 2 * (1 - b), c.br.y += d.y / 2 * (1 - b), c.tl.y -= d.y / 2 * (1 - b), c.tr.y -= d.y / 2 * (1 - b), this.setTile(a, c)
    }
}), cc.fadeOutUpTiles = function(a, b) {
    return new cc.FadeOutUpTiles(a, b)
}, cc.FadeOutUpTiles.create = cc.fadeOutUpTiles, cc.FadeOutDownTiles = cc.FadeOutUpTiles.extend({
    testFunc: function(a, b) {
        return 0 == a.height ? 1 : Math.pow(this._gridSize.height * (1 - b) / a.height, 6)
    }
}), cc.fadeOutDownTiles = function(a, b) {
    return new cc.FadeOutDownTiles(a, b)
}, cc.FadeOutDownTiles.create = cc.fadeOutDownTiles, cc.TurnOffTiles = cc.TiledGrid3DAction.extend({
    _seed: null,
    _tilesCount: 0,
    _tilesOrder: null,
    ctor: function(a, b, c) {
        cc.GridAction.prototype.ctor.call(this), this._tilesOrder = [], void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._seed = c || 0, this._tilesOrder.length = 0, !0) : !1
    },
    shuffle: function(a, b) {
        for (var c = b - 1; c >= 0; c--) {
            var d = 0 | cc.rand() % (c + 1),
                e = a[c];
            a[c] = a[d], a[d] = e
        }
    },
    turnOnTile: function(a) {
        this.setTile(a, this.originalTile(a))
    },
    turnOffTile: function(a) {
        this.setTile(a, new cc.Quad3)
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a), this._tilesCount = this._gridSize.width * this._gridSize.height, a = this._tilesOrder;
        for (var b = a.length = 0; b < this._tilesCount; ++b) a[b] = b;
        this.shuffle(a, this._tilesCount)
    },
    update: function(a) {
        a = 0 | a * this._tilesCount;
        for (var b, c = this._gridSize, d = cc.p(0, 0), e = this._tilesOrder, f = 0; f < this._tilesCount; f++) b = e[f], d.x = 0 | b / c.height, d.y = b % (0 | c.height), a > f ? this.turnOffTile(d) : this.turnOnTile(d)
    }
}), cc.turnOffTiles = function(a, b, c) {
    return new cc.TurnOffTiles(a, b, c)
}, cc.TurnOffTiles.create = cc.turnOffTiles, cc.WavesTiles3D = cc.TiledGrid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b, c = this._gridSize, d = this._waves, e = this._amplitude, f = this._amplitudeRate, g = cc.p(0, 0), h = 0; h < c.width; h++)
            for (var i = 0; i < c.height; i++) g.x = h, g.y = i, b = this.originalTile(g), b.bl.z = Math.sin(2 * a * Math.PI * d + .01 * (b.bl.y + b.bl.x)) * e * f, b.br.z = b.bl.z, b.tl.z = b.bl.z, b.tr.z = b.bl.z, this.setTile(g, b)
    }
}), cc.wavesTiles3D = function(a, b, c, d) {
    return new cc.WavesTiles3D(a, b, c, d)
}, cc.WavesTiles3D.create = cc.wavesTiles3D, cc.JumpTiles3D = cc.TiledGrid3DAction.extend({
    _jumps: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._jumps = c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        var b = Math.sin(2 * Math.PI * a * this._jumps) * this._amplitude * this._amplitudeRate;
        a = Math.sin(Math.PI * (2 * a * this._jumps + 1)) * this._amplitude * this._amplitudeRate;
        for (var c, d = this._gridSize, e = this.target.grid, f = cc.p(0, 0), g = 0; g < d.width; g++)
            for (var h = 0; h < d.height; h++) f.x = g, f.y = h, c = e.originalTile(f), 0 == (g + h) % 2 ? (c.bl.z += b, c.br.z += b, c.tl.z += b, c.tr.z += b) : (c.bl.z += a, c.br.z += a, c.tl.z += a, c.tr.z += a), e.setTile(f, c)
    }
}), cc.jumpTiles3D = function(a, b, c, d) {
    return new cc.JumpTiles3D(a, b, c, d)
}, cc.JumpTiles3D.create = cc.jumpTiles3D, cc.SplitRows = cc.TiledGrid3DAction.extend({
    _rows: 0,
    _winSize: null,
    ctor: function(a, b) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return this._rows = b, cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, cc.size(1, b))
    },
    update: function(a) {
        for (var b, c, d = this._gridSize, e = this._winSize.width, f = cc.p(0, 0), g = 0; g < d.height; ++g) f.y = g, b = this.originalTile(f), c = 1, 0 == g % 2 && (c = -1), b.bl.x += c * e * a, b.br.x += c * e * a, b.tl.x += c * e * a, b.tr.x += c * e * a, this.setTile(f, b)
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a), this._winSize = cc.director.getWinSizeInPixels()
    }
}), cc.splitRows = function(a, b) {
    return new cc.SplitRows(a, b)
}, cc.SplitRows.create = cc.splitRows, cc.SplitCols = cc.TiledGrid3DAction.extend({
    _cols: 0,
    _winSize: null,
    ctor: function(a, b) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return this._cols = b, cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, cc.size(b, 1))
    },
    update: function(a) {
        for (var b, c, d = this._gridSize.width, e = this._winSize.height, f = cc.p(0, 0), g = 0; d > g; ++g) f.x = g, b = this.originalTile(f), c = 1, 0 == g % 2 && (c = -1), b.bl.y += c * e * a, b.br.y += c * e * a, b.tl.y += c * e * a, b.tr.y += c * e * a, this.setTile(f, b)
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a), this._winSize = cc.director.getWinSizeInPixels()
    }
}), cc.splitCols = function(a, b) {
    return new cc.SplitCols(a, b)
}, cc.SplitCols.create = cc.splitCols, cc.PageTurn3D = cc.Grid3DAction.extend({
    update: function(a) {
        var b = Math.max(0, a - .25),
            b = -100 - 500 * b * b;
        a = -Math.PI / 2 * Math.sqrt(a);
        var c = +Math.PI / 2 + a;
        a = Math.sin(c);
        for (var c = Math.cos(c), d = this._gridSize, e = cc.p(0, 0), f = 0; f <= d.width; ++f)
            for (var g = 0; g <= d.height; ++g) {
                e.x = f, e.y = g;
                var h = this.originalVertex(e),
                    i = Math.sqrt(h.x * h.x + (h.y - b) * (h.y - b)),
                    j = i * a,
                    k = Math.asin(h.x / i) / a,
                    l = Math.cos(k);
                h.x = k <= Math.PI ? j * Math.sin(k) : 0, h.y = i + b - j * (1 - l) * a, h.z = j * (1 - l) * c / 7, .5 > h.z && (h.z = .5), this.setVertex(e, h)
            }
    }
}), cc.pageTurn3D = function(a, b) {
    return new cc.PageTurn3D(a, b)
}, cc.PageTurn3D.create = cc.pageTurn3D, cc.ProgressTimer = cc.Node.extend({
    _type: null,
    _percentage: 0,
    _sprite: null,
    _midPoint: null,
    _barChangeRate: null,
    _reverseDirection: !1,
    _className: "ProgressTimer",
    getMidpoint: function() {
        return cc.p(this._midPoint.x, this._midPoint.y)
    },
    setMidpoint: function(a) {
        this._midPoint = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
    },
    getBarChangeRate: function() {
        return cc.p(this._barChangeRate.x, this._barChangeRate.y)
    },
    setBarChangeRate: function(a) {
        this._barChangeRate = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
    },
    getType: function() {
        return this._type
    },
    getPercentage: function() {
        return this._percentage
    },
    getSprite: function() {
        return this._sprite
    },
    setPercentage: function(a) {
        this._percentage != a && (this._percentage = cc.clampf(a, 0, 100), this._updateProgress())
    },
    setOpacityModifyRGB: function() {},
    isOpacityModifyRGB: function() {
        return !1
    },
    isReverseDirection: function() {
        return this._reverseDirection
    },
    _boundaryTexCoord: function(a) {
        if (a < cc.ProgressTimer.TEXTURE_COORDS_COUNT) {
            var b = cc.ProgressTimer.TEXTURE_COORDS;
            return this._reverseDirection ? cc.p(b >> 7 - (a << 1) & 1, b >> 7 - ((a << 1) + 1) & 1) : cc.p(b >> (a << 1) + 1 & 1, b >> (a << 1) & 1)
        }
        return cc.p(0, 0)
    },
    _origin: null,
    _startAngle: 270,
    _endAngle: 270,
    _radius: 0,
    _counterClockWise: !1,
    _barRect: null,
    _vertexDataCount: 0,
    _vertexData: null,
    _vertexArrayBuffer: null,
    _vertexWebGLBuffer: null,
    _vertexDataDirty: !1,
    ctor: null,
    _ctorForCanvas: function(a) {
        cc.Node.prototype.ctor.call(this), this._type = cc.ProgressTimer.TYPE_RADIAL, this._percentage = 0, this._midPoint = cc.p(0, 0), this._barChangeRate = cc.p(0, 0), this._reverseDirection = !1, this._sprite = null, this._origin = cc.p(0, 0), this._endAngle = this._startAngle = 270, this._radius = 0, this._counterClockWise = !1, this._barRect = cc.rect(0, 0, 0, 0), a && this._initWithSpriteForCanvas(a)
    },
    _ctorForWebGL: function(a) {
        cc.Node.prototype.ctor.call(this), this._type = cc.ProgressTimer.TYPE_RADIAL, this._percentage = 0, this._midPoint = cc.p(0, 0), this._barChangeRate = cc.p(0, 0), this._reverseDirection = !1, this._sprite = null, this._vertexWebGLBuffer = cc._renderContext.createBuffer(), this._vertexDataCount = 0, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataDirty = !1, a && this._initWithSpriteForWebGL(a)
    },
    setColor: function(a) {
        this._sprite.color = a, this._updateColor()
    },
    setOpacity: function(a) {
        this._sprite.opacity = a, this._updateColor()
    },
    getColor: function() {
        return this._sprite.color
    },
    getOpacity: function() {
        return this._sprite.opacity
    },
    setReverseProgress: null,
    _setReverseProgressForCanvas: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a)
    },
    _setReverseProgressForWebGL: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0)
    },
    setSprite: null,
    _setSpriteForCanvas: function(a) {
        this._sprite != a && (this._sprite = a, this.width = this._sprite.width, this.height = this._sprite.height)
    },
    _setSpriteForWebGL: function(a) {
        a && this._sprite != a && (this._sprite = a, this.width = a.width, this.height = a.height, this._vertexData && (this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0))
    },
    setType: null,
    _setTypeForCanvas: function(a) {
        a !== this._type && (this._type = a)
    },
    _setTypeForWebGL: function(a) {
        a !== this._type && (this._vertexData && (this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0), this._type = a)
    },
    setReverseDirection: null,
    _setReverseDirectionForCanvas: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a)
    },
    _setReverseDirectionForWebGL: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0)
    },
    _textureCoordFromAlphaPoint: function(a) {
        var b = this._sprite;
        if (!b) return {
            u: 0,
            v: 0
        };
        var c = b.quad,
            d = cc.p(c.bl.texCoords.u, c.bl.texCoords.v),
            c = cc.p(c.tr.texCoords.u, c.tr.texCoords.v);
        return b.textureRectRotated && (b = a.x, a.x = a.y, a.y = b), {
            u: d.x * (1 - a.x) + c.x * a.x,
            v: d.y * (1 - a.y) + c.y * a.y
        }
    },
    _vertexFromAlphaPoint: function(a) {
        if (!this._sprite) return {
            x: 0,
            y: 0
        };
        var b = this._sprite.quad,
            c = cc.p(b.bl.vertices.x, b.bl.vertices.y),
            b = cc.p(b.tr.vertices.x, b.tr.vertices.y);
        return {
            x: c.x * (1 - a.x) + b.x * a.x,
            y: c.y * (1 - a.y) + b.y * a.y
        }
    },
    initWithSprite: null,
    _initWithSpriteForCanvas: function(a) {
        return this.percentage = 0, this.anchorY = this.anchorX = .5, this._type = cc.ProgressTimer.TYPE_RADIAL, this._reverseDirection = !1, this.midPoint = cc.p(.5, .5), this.barChangeRate = cc.p(1, 1), this.sprite = a, !0
    },
    _initWithSpriteForWebGL: function(a) {
        return this.percentage = 0, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0, this.anchorY = this.anchorX = .5, this._type = cc.ProgressTimer.TYPE_RADIAL, this._reverseDirection = !1, this.midPoint = cc.p(.5, .5), this.barChangeRate = cc.p(1, 1), this.sprite = a, this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR), !0
    },
    draw: null,
    _drawForCanvas: function(a) {
        a = a || cc._renderContext;
        var b = this._sprite;
        "source" != b._blendFuncStr && (a.globalCompositeOperation = b._blendFuncStr);
        var c = cc.view.getScaleX(),
            d = cc.view.getScaleY();
        a.globalAlpha = b._displayedOpacity / 255;
        var e = b._rect,
            f = b._contentSize,
            g = b._offsetPosition,
            h = b._drawSize_Canvas,
            i = 0 | g.x,
            j = -g.y - e.height,
            k = b._textureRect_Canvas;
        h.width = e.width * c, h.height = e.height * d, a.save(), b._flippedX && (i = -g.x - e.width, a.scale(-1, 1)), b._flippedY && (j = g.y, a.scale(1, -1)), i *= c, j *= d, this._type == cc.ProgressTimer.TYPE_BAR ? (e = this._barRect, a.beginPath(), a.rect(e.x * c, e.y * d, e.width * c, e.height * d), a.clip(), a.closePath()) : this._type == cc.ProgressTimer.TYPE_RADIAL && (e = this._origin.x * c, g = this._origin.y * d, a.beginPath(), a.arc(e, g, this._radius * d, Math.PI / 180 * this._startAngle, Math.PI / 180 * this._endAngle, this._counterClockWise), a.lineTo(e, g), a.clip(), a.closePath()), b._texture && k.validRect ? (c = b._texture.getHtmlElementObj(), b._colorized ? a.drawImage(c, 0, 0, k.width, k.height, i, j, h.width, h.height) : a.drawImage(c, k.x, k.y, k.width, k.height, i, j, h.width, h.height)) : 0 !== f.width && (b = this.color, a.fillStyle = "rgba(" + b.r + "," + b.g + "," + b.b + ",1)", a.fillRect(i, j, f.width * c, f.height * d)), a.restore(), cc.incrementGLDraws(1)
    },
    _drawForWebGL: function(a) {
        if (a = a || cc._renderContext, this._vertexData && this._sprite) {
            cc.nodeDrawSetup(this);
            var b = this._sprite.getBlendFunc();
            cc.glBlendFunc(b.src, b.dst), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), cc.glBindTexture2D(this._sprite.texture), a.bindBuffer(a.ARRAY_BUFFER, this._vertexWebGLBuffer), this._vertexDataDirty && (a.bufferData(a.ARRAY_BUFFER, this._vertexArrayBuffer, a.DYNAMIC_DRAW), this._vertexDataDirty = !1), b = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT, a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, b, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, b, 8), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, b, 12), this._type === cc.ProgressTimer.TYPE_RADIAL ? a.drawArrays(a.TRIANGLE_FAN, 0, this._vertexDataCount) : this._type == cc.ProgressTimer.TYPE_BAR && (this._reverseDirection ? (a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount / 2), a.drawArrays(a.TRIANGLE_STRIP, 4, this._vertexDataCount / 2), cc.g_NumberOfDraws++) : a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount)), cc.g_NumberOfDraws++
        }
    },
    _updateRadial: function() {
        if (this._sprite) {
            var a, b = this._midPoint;
            a = this._percentage / 100;
            var c = 2 * cc.PI * (this._reverseDirection ? a : 1 - a),
                d = cc.p(b.x, 1),
                e = cc.pRotateByAngle(d, b, c),
                c = 0;
            if (0 == a) e = d, c = 0;
            else if (1 == a) e = d, c = 4;
            else {
                var f = cc.FLT_MAX,
                    g = cc.ProgressTimer.TEXTURE_COORDS_COUNT;
                for (a = 0; g >= a; ++a) {
                    var h = (a + (g - 1)) % g,
                        i = this._boundaryTexCoord(a % g),
                        h = this._boundaryTexCoord(h);
                    0 == a ? h = cc.pLerp(i, h, 1 - b.x) : 4 == a && (i = cc.pLerp(i, h, 1 - b.x));
                    var j = cc.p(0, 0);
                    cc.pLineIntersect(i, h, b, e, j) && (0 != a && 4 != a || 0 <= j.x && 1 >= j.x) && 0 <= j.y && j.y < f && (f = j.y, c = a)
                }
                e = cc.pAdd(b, cc.pMult(cc.pSub(e, b), f))
            } if (f = !0, this._vertexDataCount != c + 3 && (f = !1, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0), !this._vertexData) {
                for (g = this._vertexDataCount = c + 3, i = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT, this._vertexArrayBuffer = new ArrayBuffer(g * i), h = [], a = 0; g > a; a++) h[a] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, a * i);
                if (this._vertexData = h, !this._vertexData) return void cc.log("cc.ProgressTimer._updateRadial() : Not enough memory")
            }
            if (this._updateColor(), g = this._vertexData, !f)
                for (g[0].texCoords = this._textureCoordFromAlphaPoint(b), g[0].vertices = this._vertexFromAlphaPoint(b), g[1].texCoords = this._textureCoordFromAlphaPoint(d), g[1].vertices = this._vertexFromAlphaPoint(d), a = 0; c > a; a++) b = this._boundaryTexCoord(a), g[a + 2].texCoords = this._textureCoordFromAlphaPoint(b), g[a + 2].vertices = this._vertexFromAlphaPoint(b);
            g[this._vertexDataCount - 1].texCoords = this._textureCoordFromAlphaPoint(e), g[this._vertexDataCount - 1].vertices = this._vertexFromAlphaPoint(e)
        }
    },
    _updateBar: function() {
        if (this._sprite) {
            var a, b = this._percentage / 100,
                c = this._barChangeRate,
                c = cc.pMult(cc.p(1 - c.x + b * c.x, 1 - c.y + b * c.y), .5),
                b = cc.pSub(this._midPoint, c),
                c = cc.pAdd(this._midPoint, c);
            if (0 > b.x && (c.x += -b.x, b.x = 0), 1 < c.x && (b.x -= c.x - 1, c.x = 1), 0 > b.y && (c.y += -b.y, b.y = 0), 1 < c.y && (b.y -= c.y - 1, c.y = 1), this._reverseDirection) {
                if (!this._vertexData) {
                    this._vertexDataCount = 8;
                    var d = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                    this._vertexArrayBuffer = new ArrayBuffer(8 * d);
                    var e = [];
                    for (a = 0; 8 > a; a++) e[a] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, a * d);
                    e[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 1)), e[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1)), e[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0)), e[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0)), e[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1)), e[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1)), e[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 0)), e[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0)), this._vertexData = e
                }
                a = this._vertexData, a[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(b.x, c.y)), a[2].vertices = this._vertexFromAlphaPoint(cc.p(b.x, c.y)), a[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(b.x, b.y)), a[3].vertices = this._vertexFromAlphaPoint(cc.p(b.x, b.y)), a[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, c.y)), a[4].vertices = this._vertexFromAlphaPoint(cc.p(c.x, c.y)), a[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, b.y)), a[5].vertices = this._vertexFromAlphaPoint(cc.p(c.x, b.y))
            } else {
                if (!this._vertexData)
                    for (this._vertexDataCount = 4, d = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT, this._vertexArrayBuffer = new ArrayBuffer(4 * d), this._vertexData = [], a = 0; 4 > a; a++) this._vertexData[a] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, a * d);
                a = this._vertexData, a[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(b.x, c.y)), a[0].vertices = this._vertexFromAlphaPoint(cc.p(b.x, c.y)), a[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(b.x, b.y)), a[1].vertices = this._vertexFromAlphaPoint(cc.p(b.x, b.y)), a[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, c.y)), a[2].vertices = this._vertexFromAlphaPoint(cc.p(c.x, c.y)), a[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, b.y)), a[3].vertices = this._vertexFromAlphaPoint(cc.p(c.x, b.y))
            }
            this._updateColor()
        }
    },
    _updateColor: function() {
        if (this._sprite && this._vertexData) {
            for (var a = this._sprite.quad.tl.colors, b = this._vertexData, c = 0, d = this._vertexDataCount; d > c; ++c) b[c].colors = a;
            this._vertexDataDirty = !0
        }
    },
    _updateProgress: null,
    _updateProgressForCanvas: function() {
        var a = this._sprite,
            b = a.width,
            c = a.height,
            d = this._midPoint;
        if (this._type == cc.ProgressTimer.TYPE_RADIAL) {
            this._radius = Math.round(Math.sqrt(b * b + c * c));
            var e, f = !1,
                g = this._origin;
            g.x = b * d.x, g.y = -c * d.y, this._reverseDirection ? (e = 270, d = 270 - 3.6 * this._percentage) : (d = -90, e = -90 + 3.6 * this._percentage), a._flippedX && (g.x -= 2 * b * this._midPoint.x, d = -d - 180, e = -e - 180, f = !f), a._flippedY && (g.y += 2 * c * this._midPoint.y, f = !f, d = -d, e = -e), this._startAngle = d, this._endAngle = e, this._counterClockWise = f
        } else {
            e = this._barChangeRate, g = this._percentage / 100, f = this._barRect, e = cc.size(b * (1 - e.x), c * (1 - e.y));
            var g = cc.size((b - e.width) * g, (c - e.height) * g),
                g = cc.size(e.width + g.width, e.height + g.height),
                h = cc.p(b * d.x, c * d.y);
            e = h.x - g.width / 2, .5 < d.x && g.width / 2 >= b - h.x && (e = b - g.width), b = h.y - g.height / 2, .5 < d.y && g.height / 2 >= c - h.y && (b = c - g.height), f.x = 0, c = 1, a._flippedX && (f.x -= g.width, c = -1), e > 0 && (f.x += e * c), f.y = 0, c = 1, a._flippedY && (f.y += g.height, c = -1), b > 0 && (f.y -= b * c), f.width = g.width, f.height = -g.height
        }
    },
    _updateProgressForWebGL: function() {
        var a = this._type;
        a === cc.ProgressTimer.TYPE_RADIAL ? this._updateRadial() : a === cc.ProgressTimer.TYPE_BAR && this._updateBar(), this._vertexDataDirty = !0
    }
}), _p = cc.ProgressTimer.prototype, cc._renderType == cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.setReverseProgress = _p._setReverseProgressForWebGL, _p.setSprite = _p._setSpriteForWebGL, _p.setType = _p._setTypeForWebGL, _p.setReverseDirection = _p._setReverseDirectionForWebGL, _p.initWithSprite = _p._initWithSpriteForWebGL, _p.draw = _p._drawForWebGL, _p._updateProgress = _p._updateProgressForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.setReverseProgress = _p._setReverseProgressForCanvas, _p.setSprite = _p._setSpriteForCanvas, _p.setType = _p._setTypeForCanvas, _p.setReverseDirection = _p._setReverseDirectionForCanvas, _p.initWithSprite = _p._initWithSpriteForCanvas, _p.draw = _p._drawForCanvas, _p._updateProgress = cc.ProgressTimer.prototype._updateProgressForCanvas), cc.defineGetterSetter(_p, "midPoint", _p.getMidpoint, _p.setMidpoint), cc.defineGetterSetter(_p, "barChangeRate", _p.getBarChangeRate, _p.setBarChangeRate), cc.defineGetterSetter(_p, "type", _p.getType, _p.setType), cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage), cc.defineGetterSetter(_p, "sprite", _p.getSprite, _p.setSprite), cc.defineGetterSetter(_p, "reverseDir", _p.isReverseDirection, _p.setReverseDirection), cc.ProgressTimer.create = function(a) {
    return new cc.ProgressTimer(a)
}, cc.ProgressTimer.TEXTURE_COORDS_COUNT = 4, cc.ProgressTimer.TEXTURE_COORDS = 75, cc.ProgressTimer.TYPE_RADIAL = 0, cc.ProgressTimer.TYPE_BAR = 1, cc.ProgressTo = cc.ActionInterval.extend({
    _to: 0,
    _from: 0,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this), this._from = this._to = 0, void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = b, !0) : !1
    },
    clone: function() {
        var a = new cc.ProgressTo;
        return a.initWithDuration(this._duration, this._to), a
    },
    reverse: function() {
        return cc.log("cc.ProgressTo.reverse(): reverse hasn't been supported."), null
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._from = a.percentage, 100 == this._from && (this._from = 0)
    },
    update: function(a) {
        this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
    }
}), cc.progressTo = function(a, b) {
    return new cc.ProgressTo(a, b)
}, cc.ProgressTo.create = cc.progressTo, cc.ProgressFromTo = cc.ActionInterval.extend({
    _to: 0,
    _from: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this), this._from = this._to = 0, void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = c, this._from = b, !0) : !1
    },
    clone: function() {
        var a = new cc.ProgressFromTo;
        return a.initWithDuration(this._duration, this._from, this._to), a
    },
    reverse: function() {
        return cc.progressFromTo(this._duration, this._to, this._from)
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a)
    },
    update: function(a) {
        this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
    }
}), cc.progressFromTo = function(a, b, c) {
    return new cc.ProgressFromTo(a, b, c)
}, cc.ProgressFromTo.create = cc.progressFromTo, cc.SCENE_FADE = 4208917214, cc.TRANSITION_ORIENTATION_LEFT_OVER = 0, cc.TRANSITION_ORIENTATION_RIGHT_OVER = 1, cc.TRANSITION_ORIENTATION_UP_OVER = 0, cc.TRANSITION_ORIENTATION_DOWN_OVER = 1, cc.TransitionScene = cc.Scene.extend({
    _inScene: null,
    _outScene: null,
    _duration: null,
    _isInSceneOnTop: !1,
    _isSendCleanupToScene: !1,
    _className: "TransitionScene",
    ctor: function(a, b) {
        cc.Scene.prototype.ctor.call(this), void 0 !== a && void 0 !== b && this.initWithDuration(a, b)
    },
    _setNewScene: function(a) {
        this.unschedule(this._setNewScene), a = cc.director, this._isSendCleanupToScene = a.isSendCleanupToScene(), a.runScene(this._inScene), cc.eventManager.setEnabled(!0), this._outScene.visible = !0
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    draw: function() {
        this._isInSceneOnTop ? (this._outScene.visit(), this._inScene.visit()) : (this._inScene.visit(), this._outScene.visit())
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this), cc.eventManager.setEnabled(!1), this._outScene.onExitTransitionDidStart(), this._inScene.onEnter()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this), cc.eventManager.setEnabled(!0), this._outScene.onExit(), this._inScene.onEnterTransitionDidFinish()
    },
    cleanup: function() {
        cc.Node.prototype.cleanup.call(this), this._isSendCleanupToScene && this._outScene.cleanup()
    },
    initWithDuration: function(a, b) {
        if (!b) throw "cc.TransitionScene.initWithDuration(): Argument scene must be non-nil";
        if (this.init()) {
            if (this._duration = a, this.attr({
                x: 0,
                y: 0,
                anchorX: 0,
                anchorY: 0
            }), this._inScene = b, this._outScene = cc.director.getRunningScene(), this._outScene || (this._outScene = cc.Scene.create(), this._outScene.init()), this._inScene == this._outScene) throw "cc.TransitionScene.initWithDuration(): Incoming scene must be different from the outgoing scene";
            return this._sceneOrder(), !0
        }
        return !1
    },
    finish: function() {
        this._inScene.attr({
            visible: !0,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        }), cc._renderType === cc._RENDER_TYPE_WEBGL && this._inScene.getCamera().restore(), this._outScene.attr({
            visible: !1,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        }), cc._renderType === cc._RENDER_TYPE_WEBGL && this._outScene.getCamera().restore(), this.schedule(this._setNewScene, 0)
    },
    hideOutShowIn: function() {
        this._inScene.visible = !0, this._outScene.visible = !1
    }
}), cc.TransitionScene.create = function(a, b) {
    return new cc.TransitionScene(a, b)
}, cc.TransitionSceneOriented = cc.TransitionScene.extend({
    _orientation: 0,
    ctor: function(a, b, c) {
        cc.TransitionScene.prototype.ctor.call(this), void 0 != c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.TransitionScene.prototype.initWithDuration.call(this, a, b) && (this._orientation = c), !0
    }
}), cc.TransitionSceneOriented.create = function(a, b, c) {
    return new cc.TransitionSceneOriented(a, b, c)
}, cc.TransitionRotoZoom = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this), this._inScene.attr({
            scale: .001,
            anchorX: .5,
            anchorY: .5
        }), this._outScene.attr({
            scale: 1,
            anchorX: .5,
            anchorY: .5
        });
        var a = cc.sequence(cc.spawn(cc.scaleBy(this._duration / 2, .001), cc.rotateBy(this._duration / 2, 720)), cc.delayTime(this._duration / 2));
        this._outScene.runAction(a), this._inScene.runAction(cc.sequence(a.reverse(), cc.callFunc(this.finish, this)))
    }
}), cc.TransitionRotoZoom.create = function(a, b) {
    return new cc.TransitionRotoZoom(a, b)
}, cc.TransitionJumpZoom = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize();
        this._inScene.attr({
            scale: .5,
            x: a.width,
            y: 0,
            anchorX: .5,
            anchorY: .5
        }), this._outScene.anchorX = .5, this._outScene.anchorY = .5;
        var b = cc.jumpBy(this._duration / 4, cc.p(-a.width, 0), a.width / 4, 2),
            c = cc.scaleTo(this._duration / 4, 1),
            a = cc.scaleTo(this._duration / 4, .5),
            a = cc.sequence(a, b),
            b = cc.sequence(b, c),
            c = cc.delayTime(this._duration / 2);
        this._outScene.runAction(a), this._inScene.runAction(cc.sequence(c, b, cc.callFunc(this.finish, this)))
    }
}), cc.TransitionJumpZoom.create = function(a, b) {
    return new cc.TransitionJumpZoom(a, b)
}, cc.TransitionMoveInL = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this), this.initScenes();
        var a = this.action();
        this._inScene.runAction(cc.sequence(this.easeActionWithAction(a), cc.callFunc(this.finish, this)))
    },
    initScenes: function() {
        this._inScene.setPosition(-cc.director.getWinSize().width, 0)
    },
    action: function() {
        return cc.moveTo(this._duration, cc.p(0, 0))
    },
    easeActionWithAction: function(a) {
        return new cc.EaseOut(a, 2)
    }
}), cc.TransitionMoveInL.create = function(a, b) {
    return new cc.TransitionMoveInL(a, b)
}, cc.TransitionMoveInR = cc.TransitionMoveInL.extend({
    ctor: function(a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    initScenes: function() {
        this._inScene.setPosition(cc.director.getWinSize().width, 0)
    }
}), cc.TransitionMoveInR.create = function(a, b) {
    return new cc.TransitionMoveInR(a, b)
}, cc.TransitionMoveInT = cc.TransitionMoveInL.extend({
    ctor: function(a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    initScenes: function() {
        this._inScene.setPosition(0, cc.director.getWinSize().height)
    }
}), cc.TransitionMoveInT.create = function(a, b) {
    return new cc.TransitionMoveInT(a, b)
}, cc.TransitionMoveInB = cc.TransitionMoveInL.extend({
    ctor: function(a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    initScenes: function() {
        this._inScene.setPosition(0, -cc.director.getWinSize().height)
    }
}), cc.TransitionMoveInB.create = function(a, b) {
    return new cc.TransitionMoveInB(a, b)
}, cc.ADJUST_FACTOR = .5, cc.TransitionSlideInL = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this), this.initScenes();
        var a = this.action(),
            b = this.action(),
            a = this.easeActionWithAction(a),
            b = cc.sequence(this.easeActionWithAction(b), cc.callFunc(this.finish, this));
        this._inScene.runAction(a), this._outScene.runAction(b)
    },
    initScenes: function() {
        this._inScene.setPosition(-cc.director.getWinSize().width + cc.ADJUST_FACTOR, 0)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0))
    },
    easeActionWithAction: function(a) {
        return new cc.EaseInOut(a, 2)
    }
}), cc.TransitionSlideInL.create = function(a, b) {
    return new cc.TransitionSlideInL(a, b)
}, cc.TransitionSlideInR = cc.TransitionSlideInL.extend({
    ctor: function(a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    initScenes: function() {
        this._inScene.setPosition(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(-(cc.director.getWinSize().width - cc.ADJUST_FACTOR), 0))
    }
}), cc.TransitionSlideInR.create = function(a, b) {
    return new cc.TransitionSlideInR(a, b)
}, cc.TransitionSlideInB = cc.TransitionSlideInL.extend({
    ctor: function(a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    initScenes: function() {
        this._inScene.setPosition(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    }
}), cc.TransitionSlideInB.create = function(a, b) {
    return new cc.TransitionSlideInB(a, b)
}, cc.TransitionSlideInT = cc.TransitionSlideInL.extend({
    ctor: function(a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    initScenes: function() {
        this._inScene.setPosition(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR)))
    }
}), cc.TransitionSlideInT.create = function(a, b) {
    return new cc.TransitionSlideInT(a, b)
}, cc.TransitionShrinkGrow = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this), this._inScene.attr({
            scale: .001,
            anchorX: 2 / 3,
            anchorY: .5
        }), this._outScene.attr({
            scale: 1,
            anchorX: 1 / 3,
            anchorY: .5
        });
        var a = cc.scaleTo(this._duration, .01),
            b = cc.scaleTo(this._duration, 1);
        this._inScene.runAction(this.easeActionWithAction(b)), this._outScene.runAction(cc.sequence(this.easeActionWithAction(a), cc.callFunc(this.finish, this)))
    },
    easeActionWithAction: function(a) {
        return new cc.EaseOut(a, 2)
    }
}), cc.TransitionShrinkGrow.create = function(a, b) {
    return new cc.TransitionShrinkGrow(a, b)
}, cc.TransitionFlipX = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this), c = c || cc.TRANSITION_ORIENTATION_RIGHT_OVER, b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90), a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, c, a, 0, 0), cc.callFunc(this.finish, this)), b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 0, 0), cc.hide(), cc.delayTime(this._duration / 2)), this._inScene.runAction(a), this._outScene.runAction(b)
    }
}), cc.TransitionFlipX.create = function(a, b, c) {
    return new cc.TransitionFlipX(a, b, c)
}, cc.TransitionFlipY = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this), c = c || cc.TRANSITION_ORIENTATION_UP_OVER, b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation == cc.TRANSITION_ORIENTATION_UP_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90), a = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Show.create(), cc.OrbitCamera.create(this._duration / 2, 1, 0, c, a, 90, 0), cc.CallFunc.create(this.finish, this)), b = cc.Sequence.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, 0, b, 90, 0), cc.Hide.create(), cc.DelayTime.create(this._duration / 2)), this._inScene.runAction(a), this._outScene.runAction(b)
    }
}), cc.TransitionFlipY.create = function(a, b, c) {
    return new cc.TransitionFlipY(a, b, c)
}, cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this), c = c || cc.TRANSITION_ORIENTATION_RIGHT_OVER, b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90), a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, c, a, -45, 0), cc.callFunc(this.finish, this)), b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 45, 0), cc.hide(), cc.delayTime(this._duration / 2)), this._inScene.runAction(a), this._outScene.runAction(b)
    }
}), cc.TransitionFlipAngular.create = function(a, b, c) {
    return new cc.TransitionFlipAngular(a, b, c)
}, cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this), c = c || cc.TRANSITION_ORIENTATION_RIGHT_OVER, b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90), a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, c, a, 0, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this)), b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 0, 0), cc.scaleTo(this._duration / 2, .5)), cc.hide(), cc.delayTime(this._duration / 2)), this._inScene.scale = .5, this._inScene.runAction(a), this._outScene.runAction(b)
    }
}), cc.TransitionZoomFlipX.create = function(a, b, c) {
    return new cc.TransitionZoomFlipX(a, b, c)
}, cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this), c = c || cc.TRANSITION_ORIENTATION_UP_OVER, b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90), a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, c, a, 90, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this)), b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 90, 0), cc.scaleTo(this._duration / 2, .5)), cc.hide(), cc.delayTime(this._duration / 2)), this._inScene.scale = .5, this._inScene.runAction(a), this._outScene.runAction(b)
    }
}), cc.TransitionZoomFlipY.create = function(a, b, c) {
    return new cc.TransitionZoomFlipY(a, b, c)
}, cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this), c = c || cc.TRANSITION_ORIENTATION_RIGHT_OVER, b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90), a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, c, a, -45, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.show(), cc.callFunc(this.finish, this)), b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 45, 0), cc.scaleTo(this._duration / 2, .5)), cc.hide(), cc.delayTime(this._duration / 2)), this._inScene.scale = .5, this._inScene.runAction(a), this._outScene.runAction(b)
    }
}), cc.TransitionZoomFlipAngular.create = function(a, b, c) {
    return new cc.TransitionZoomFlipAngular(a, b, c)
}, cc.TransitionFade = cc.TransitionScene.extend({
    _color: null,
    ctor: function(a, b, c) {
        cc.TransitionScene.prototype.ctor.call(this), this._color = cc.color(), b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = new cc.LayerColor(this._color);
        this._inScene.visible = !1, this.addChild(a, 2, cc.SCENE_FADE);
        var a = this.getChildByTag(cc.SCENE_FADE),
            b = cc.sequence(cc.fadeIn(this._duration / 2), cc.callFunc(this.hideOutShowIn, this), cc.fadeOut(this._duration / 2), cc.callFunc(this.finish, this));
        a.runAction(b)
    },
    onExit: function() {
        cc.TransitionScene.prototype.onExit.call(this), this.removeChildByTag(cc.SCENE_FADE, !1)
    },
    initWithDuration: function(a, b, c) {
        return c = c || cc.color.BLACK, cc.TransitionScene.prototype.initWithDuration.call(this, a, b) && (this._color.r = c.r, this._color.g = c.g, this._color.b = c.b, this._color.a = 0), !0
    }
}), cc.TransitionFade.create = function(a, b, c) {
    return new cc.TransitionFade(a, b, c)
}, cc.TransitionCrossFade = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.color(0, 0, 0, 0),
            b = cc.director.getWinSize(),
            a = cc.LayerColor.create(a),
            c = cc.RenderTexture.create(b.width, b.height);
        if (null != c) {
            c.sprite.anchorX = .5, c.sprite.anchorY = .5, c.attr({
                x: b.width / 2,
                y: b.height / 2,
                anchorX: .5,
                anchorY: .5
            }), c.begin(), this._inScene.visit(), c.end();
            var d = cc.RenderTexture.create(b.width, b.height);
            d.setPosition(b.width / 2, b.height / 2), d.sprite.anchorX = d.anchorX = .5, d.sprite.anchorY = d.anchorY = .5, d.begin(), this._outScene.visit(), d.end(), c.sprite.setBlendFunc(cc.ONE, cc.ONE), d.sprite.setBlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA), a.addChild(c), a.addChild(d), c.sprite.opacity = 255, d.sprite.opacity = 255, b = cc.sequence(cc.fadeTo(this._duration, 0), cc.callFunc(this.hideOutShowIn, this), cc.callFunc(this.finish, this)), d.sprite.runAction(b), this.addChild(a, 2, cc.SCENE_FADE)
        }
    },
    onExit: function() {
        this.removeChildByTag(cc.SCENE_FADE, !1), cc.TransitionScene.prototype.onExit.call(this)
    },
    draw: function() {}
}), cc.TransitionCrossFade.create = function(a, b) {
    return new cc.TransitionCrossFade(a, b)
}, cc.TransitionTurnOffTiles = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize(),
            a = cc.turnOffTiles(this._duration, cc.size(0 | 12 * (a.width / a.height), 12)),
            a = this.easeActionWithAction(a);
        this._outScene.runAction(cc.sequence(a, cc.callFunc(this.finish, this), cc.stopGrid()))
    },
    easeActionWithAction: function(a) {
        return a
    }
}), cc.TransitionTurnOffTiles.create = function(a, b) {
    return new cc.TransitionTurnOffTiles(a, b)
}, cc.TransitionSplitCols = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this), this._inScene.visible = !1;
        var a = this.action(),
            a = cc.sequence(a, cc.callFunc(this.hideOutShowIn, this), a.reverse());
        this.runAction(cc.sequence(this.easeActionWithAction(a), cc.callFunc(this.finish, this), cc.stopGrid()))
    },
    easeActionWithAction: function(a) {
        return new cc.EaseInOut(a, 3)
    },
    action: function() {
        return cc.splitCols(this._duration / 2, 3)
    }
}), cc.TransitionSplitCols.create = function(a, b) {
    return new cc.TransitionSplitCols(a, b)
}, cc.TransitionSplitRows = cc.TransitionSplitCols.extend({
    ctor: function(a, b) {
        cc.TransitionSplitCols.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    action: function() {
        return cc.splitRows(this._duration / 2, 3)
    }
}), cc.TransitionSplitRows.create = function(a, b) {
    return new cc.TransitionSplitRows(a, b)
}, cc.TransitionFadeTR = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize(),
            a = this.actionWithSize(cc.size(0 | 12 * (a.width / a.height), 12));
        this._outScene.runAction(cc.Sequence.create(this.easeActionWithAction(a), cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
    },
    easeActionWithAction: function(a) {
        return a
    },
    actionWithSize: function(a) {
        return cc.fadeOutTRTiles(this._duration, a)
    }
}), cc.TransitionFadeTR.create = function(a, b) {
    return new cc.TransitionFadeTR(a, b)
}, cc.TransitionFadeBL = cc.TransitionFadeTR.extend({
    ctor: function(a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    actionWithSize: function(a) {
        return cc.fadeOutBLTiles(this._duration, a)
    }
}), cc.TransitionFadeBL.create = function(a, b) {
    return new cc.TransitionFadeBL(a, b)
}, cc.TransitionFadeUp = cc.TransitionFadeTR.extend({
    ctor: function(a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    actionWithSize: function(a) {
        return new cc.FadeOutUpTiles(this._duration, a)
    }
}), cc.TransitionFadeUp.create = function(a, b) {
    return new cc.TransitionFadeUp(a, b)
}, cc.TransitionFadeDown = cc.TransitionFadeTR.extend({
    ctor: function(a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    actionWithSize: function(a) {
        return cc.fadeOutDownTiles(this._duration, a)
    }
}), cc.TransitionFadeDown.create = function(a, b) {
    return new cc.TransitionFadeDown(a, b)
}, cc.SCENE_RADIAL = 49153, cc.TransitionProgress = cc.TransitionScene.extend({
    _to: 0,
    _from: 0,
    _sceneToBeModified: null,
    _className: "TransitionProgress",
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _setAttrs: function(a, b, c) {
        a.attr({
            x: b,
            y: c,
            anchorX: .5,
            anchorY: .5
        })
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this), this._setupTransition();
        var a = cc.director.getWinSize(),
            b = cc.RenderTexture.create(a.width, a.height);
        b.sprite.anchorX = .5, b.sprite.anchorY = .5, this._setAttrs(b, a.width / 2, a.height / 2), b.clear(0, 0, 0, 1), b.begin(), this._sceneToBeModified.visit(), b.end(), this._sceneToBeModified == this._outScene && this.hideOutShowIn(), a = this._progressTimerNodeWithRenderTexture(b), b = cc.sequence(cc.progressFromTo(this._duration, this._from, this._to), cc.callFunc(this.finish, this)), a.runAction(b), this.addChild(a, 2, cc.SCENE_RADIAL)
    },
    onExit: function() {
        this.removeChildByTag(cc.SCENE_RADIAL, !0), cc.TransitionScene.prototype.onExit.call(this)
    },
    _setupTransition: function() {
        this._sceneToBeModified = this._outScene, this._from = 100, this._to = 0
    },
    _progressTimerNodeWithRenderTexture: function() {
        return cc.log("cc.TransitionProgress._progressTimerNodeWithRenderTexture(): should be overridden in subclass"), null
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    }
}), cc.TransitionProgress.create = function(a, b) {
    return new cc.TransitionProgress(a, b)
}, cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        return a = cc.ProgressTimer.create(a.sprite), cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0), a.type = cc.ProgressTimer.TYPE_RADIAL, a.reverseDir = !1, a.percentage = 100, this._setAttrs(a, b.width / 2, b.height / 2), a
    }
}), cc.TransitionProgressRadialCCW.create = function(a, b) {
    return new cc.TransitionProgressRadialCCW(a, b)
}, cc.TransitionProgressRadialCW = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        return a = cc.ProgressTimer.create(a.sprite), cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0), a.type = cc.ProgressTimer.TYPE_RADIAL, a.reverseDir = !0, a.percentage = 100, this._setAttrs(a, b.width / 2, b.height / 2), a
    }
}), cc.TransitionProgressRadialCW.create = function(a, b) {
    var c = new cc.TransitionProgressRadialCW;
    return null != c && c.initWithDuration(a, b) ? c : new cc.TransitionProgressRadialCW(a, b)
}, cc.TransitionProgressHorizontal = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        return a = cc.ProgressTimer.create(a.sprite), cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0), a.type = cc.ProgressTimer.TYPE_BAR, a.midPoint = cc.p(1, 0), a.barChangeRate = cc.p(1, 0), a.percentage = 100, this._setAttrs(a, b.width / 2, b.height / 2), a
    }
}), cc.TransitionProgressHorizontal.create = function(a, b) {
    return new cc.TransitionProgressHorizontal(a, b)
}, cc.TransitionProgressVertical = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        return a = cc.ProgressTimer.create(a.sprite), cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0), a.type = cc.ProgressTimer.TYPE_BAR, a.midPoint = cc.p(0, 0), a.barChangeRate = cc.p(0, 1), a.percentage = 100, this._setAttrs(a, b.width / 2, b.height / 2), a
    }
}), cc.TransitionProgressVertical.create = function(a, b) {
    return new cc.TransitionProgressVertical(a, b)
}, cc.TransitionProgressInOut = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        return a = cc.ProgressTimer.create(a.sprite), cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0), a.type = cc.ProgressTimer.TYPE_BAR, a.midPoint = cc.p(.5, .5), a.barChangeRate = cc.p(1, 1), a.percentage = 0, this._setAttrs(a, b.width / 2, b.height / 2), a
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    _setupTransition: function() {
        this._sceneToBeModified = this._inScene, this._from = 0, this._to = 100
    }
}), cc.TransitionProgressInOut.create = function(a, b) {
    return new cc.TransitionProgressInOut(a, b)
}, cc.TransitionProgressOutIn = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        return a = cc.ProgressTimer.create(a.sprite), cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0), a.type = cc.ProgressTimer.TYPE_BAR, a.midPoint = cc.p(.5, .5), a.barChangeRate = cc.p(1, 1), a.percentage = 100, this._setAttrs(a, b.width / 2, b.height / 2), a
    }
}), cc.TransitionProgressOutIn.create = function(a, b) {
    return new cc.TransitionProgressOutIn(a, b)
}, cc.TransitionPageTurn = cc.TransitionScene.extend({
    ctor: function(a, b, c) {
        cc.TransitionScene.prototype.ctor.call(this), this.initWithDuration(a, b, c)
    },
    _back: !0,
    _className: "TransitionPageTurn",
    initWithDuration: function(a, b, c) {
        return this._back = c, cc.TransitionScene.prototype.initWithDuration.call(this, a, b), !0
    },
    actionWithSize: function(a) {
        return this._back ? cc.reverseTime(cc.pageTurn3D(this._duration, a)) : cc.pageTurn3D(this._duration, a)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b = cc.director.getWinSize();
        b.width > b.height ? (b = 16, a = 12) : (b = 12, a = 16), b = this.actionWithSize(cc.size(b, a)), this._back ? (this._inScene.visible = !1, this._inScene.runAction(cc.sequence(cc.show(), b, cc.callFunc(this.finish, this), cc.stopGrid()))) : this._outScene.runAction(cc.sequence(b, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = this._back
    }
}), cc.TransitionPageTurn.create = function(a, b, c) {
    return new cc.TransitionPageTurn(a, b, c)
}, cc.Codec = {
    name: "Jacob__Codec"
}, cc.unzip = function() {
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments)
}, cc.unzipBase64 = function() {
    var a = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [a])
}, cc.unzipBase64AsArray = function(a, b) {
    b = b || 1;
    var c, d, e, f = this.unzipBase64(a),
        g = [];
    for (c = 0, e = f.length / b; e > c; c++)
        for (g[c] = 0, d = b - 1; d >= 0; --d) g[c] += f.charCodeAt(c * b + d) << 8 * d;
    return g
}, cc.unzipAsArray = function(a, b) {
    b = b || 1;
    var c, d, e, f = this.unzip(a),
        g = [];
    for (c = 0, e = f.length / b; e > c; c++)
        for (g[c] = 0, d = b - 1; d >= 0; --d) g[c] += f.charCodeAt(c * b + d) << 8 * d;
    return g
}, cc.StringToArray = function(a) {
    a = a.split(",");
    var b, c = [];
    for (b = 0; b < a.length; b++) c.push(parseInt(a[b]));
    return c
}, cc.Codec.Base64 = {
    name: "Jacob__Codec__Base64"
}, cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", cc.Codec.Base64.decode = function(a) {
    var b, c, d, e, f, g = [],
        h = 0;
    for (a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ""); h < a.length;) b = this._keyStr.indexOf(a.charAt(h++)), c = this._keyStr.indexOf(a.charAt(h++)), e = this._keyStr.indexOf(a.charAt(h++)), f = this._keyStr.indexOf(a.charAt(h++)), b = b << 2 | c >> 4, c = (15 & c) << 4 | e >> 2, d = (3 & e) << 6 | f, g.push(String.fromCharCode(b)), 64 != e && g.push(String.fromCharCode(c)), 64 != f && g.push(String.fromCharCode(d));
    return g = g.join("")
}, cc.Codec.Base64.decodeAsArray = function(a, b) {
    var c, d, e, f = this.decode(a),
        g = [];
    for (c = 0, e = f.length / b; e > c; c++)
        for (g[c] = 0, d = b - 1; d >= 0; --d) g[c] += f.charCodeAt(c * b + d) << 8 * d;
    return g
}, cc.uint8ArrayToUint32Array = function(a) {
    if (0 != a.length % 4) return null;
    for (var b = a.length / 4, c = window.Uint32Array ? new Uint32Array(b) : [], d = 0; b > d; d++) {
        var e = 4 * d;
        c[d] = a[e] + 256 * a[e + 1] + 65536 * a[e + 2] + 16777216 * a[e + 3]
    }
    return c
}, cc.Codec.GZip = function(a) {
    this.data = a, this.debug = !1, this.gpflags = void 0, this.files = 0, this.unzipped = [], this.buf32k = Array(32768), this.bIdx = 0, this.modeZIP = !1, this.bytepos = 0, this.bb = 1, this.bits = 0, this.nameBuf = [], this.fileout = void 0, this.literalTree = Array(cc.Codec.GZip.LITERALS), this.distanceTree = Array(32), this.treepos = 0, this.Places = null, this.len = 0, this.fpos = Array(17), this.fpos[0] = 0, this.fmax = this.flens = void 0
}, cc.Codec.GZip.gunzip = function(a) {
    return new cc.Codec.GZip(a).gunzip()[0][0]
}, cc.Codec.GZip.HufNode = function() {
    this.b1 = this.b0 = 0, this.jump = null, this.jumppos = -1
}, cc.Codec.GZip.LITERALS = 288, cc.Codec.GZip.NAMEMAX = 256, cc.Codec.GZip.bitReverse = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255], cc.Codec.GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], cc.Codec.GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99], cc.Codec.GZip.cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], cc.Codec.GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], cc.Codec.GZip.prototype.gunzip = function() {
    return this.outputArr = [], this.nextFile(), this.unzipped
}, cc.Codec.GZip.prototype.readByte = function() {
    return this.bits += 8, this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1
}, cc.Codec.GZip.prototype.byteAlign = function() {
    this.bb = 1
}, cc.Codec.GZip.prototype.readBit = function() {
    var a;
    return this.bits++, a = 1 & this.bb, this.bb >>= 1, 0 == this.bb && (this.bb = this.readByte(), a = 1 & this.bb, this.bb = this.bb >> 1 | 128), a
}, cc.Codec.GZip.prototype.readBits = function(a) {
    for (var b = 0, c = a; c--;) b = b << 1 | this.readBit();
    return a && (b = cc.Codec.GZip.bitReverse[b] >> 8 - a), b
}, cc.Codec.GZip.prototype.flushBuffer = function() {
    this.bIdx = 0
}, cc.Codec.GZip.prototype.addBuffer = function(a) {
    this.buf32k[this.bIdx++] = a, this.outputArr.push(String.fromCharCode(a)), 32768 == this.bIdx && (this.bIdx = 0)
}, cc.Codec.GZip.prototype.IsPat = function() {
    for (;;) {
        if (this.fpos[this.len] >= this.fmax) return -1;
        if (this.flens[this.fpos[this.len]] == this.len) return this.fpos[this.len]++;
        this.fpos[this.len]++
    }
}, cc.Codec.GZip.prototype.Rec = function() {
    var a, b = this.Places[this.treepos];
    if (17 == this.len) return -1;
    if (this.treepos++, this.len++, a = this.IsPat(), a >= 0) b.b0 = a;
    else if (b.b0 = 32768, this.Rec()) return -1;
    if (a = this.IsPat(), a >= 0) b.b1 = a, b.jump = null;
    else if (b.b1 = 32768, b.jump = this.Places[this.treepos], b.jumppos = this.treepos, this.Rec()) return -1;
    return this.len--, 0
}, cc.Codec.GZip.prototype.CreateTree = function(a, b, c) {
    for (this.Places = a, this.treepos = 0, this.flens = c, this.fmax = b, a = 0; 17 > a; a++) this.fpos[a] = 0;
    return this.len = 0, this.Rec() ? -1 : 0
}, cc.Codec.GZip.prototype.DecodeValue = function(a) {
    for (var b, c, d = 0, e = a[d];;)
        if (b = this.readBit()) {
            if (!(32768 & e.b1)) return e.b1;
            for (e = e.jump, b = a.length, c = 0; b > c; c++)
                if (a[c] === e) {
                    d = c;
                    break
                }
        } else {
            if (!(32768 & e.b0)) return e.b0;
            d++, e = a[d]
        }
    return -1
}, cc.Codec.GZip.prototype.DeflateLoop = function() {
    var a, b, c, d, e;
    do
        if (a = this.readBit(), c = this.readBits(2), 0 == c)
            for (this.byteAlign(), c = this.readByte(), c |= this.readByte() << 8, b = this.readByte(), b |= this.readByte() << 8, 65535 & (c ^ ~b) && document.write("BlockLen checksum mismatch\n"); c--;) b = this.readByte(), this.addBuffer(b);
        else if (1 == c)
        for (;;)
            if (c = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1, c > 23 ? (c = c << 1 | this.readBit(), c > 199 ? (c -= 128, c = c << 1 | this.readBit()) : (c -= 48, c > 143 && (c += 136))) : c += 256, 256 > c) this.addBuffer(c);
            else {
                if (256 == c) break;
                var f;
                for (c -= 257, e = this.readBits(cc.Codec.GZip.cplext[c]) + cc.Codec.GZip.cplens[c], c = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3, 8 < cc.Codec.GZip.cpdext[c] ? (f = this.readBits(8), f |= this.readBits(cc.Codec.GZip.cpdext[c] - 8) << 8) : f = this.readBits(cc.Codec.GZip.cpdext[c]), f += cc.Codec.GZip.cpdist[c], c = 0; e > c; c++) b = this.buf32k[this.bIdx - f & 32767], this.addBuffer(b)
            } else if (2 == c) {
        var g = Array(320);
        for (b = 257 + this.readBits(5), f = 1 + this.readBits(5), d = 4 + this.readBits(4), c = 0; 19 > c; c++) g[c] = 0;
        for (c = 0; d > c; c++) g[cc.Codec.GZip.border[c]] = this.readBits(3);
        for (e = this.distanceTree.length, d = 0; e > d; d++) this.distanceTree[d] = new cc.Codec.GZip.HufNode;
        if (this.CreateTree(this.distanceTree, 19, g, 0)) return this.flushBuffer(), 1;
        e = b + f, d = 0;
        for (var h = -1; e > d;)
            if (h++, c = this.DecodeValue(this.distanceTree), 16 > c) g[d++] = c;
            else if (16 == c) {
            var i;
            if (c = 3 + this.readBits(2), d + c > e) return this.flushBuffer(), 1;
            for (i = d ? g[d - 1] : 0; c--;) g[d++] = i
        } else {
            if (c = 17 == c ? 3 + this.readBits(3) : 11 + this.readBits(7), d + c > e) return this.flushBuffer(), 1;
            for (; c--;) g[d++] = 0
        }
        for (e = this.literalTree.length, d = 0; e > d; d++) this.literalTree[d] = new cc.Codec.GZip.HufNode;
        if (this.CreateTree(this.literalTree, b, g, 0)) return this.flushBuffer(), 1;
        for (e = this.literalTree.length, d = 0; e > d; d++) this.distanceTree[d] = new cc.Codec.GZip.HufNode;
        for (c = [], d = b; d < g.length; d++) c[d - b] = g[d];
        if (this.CreateTree(this.distanceTree, f, c, 0)) return this.flushBuffer(), 1;
        for (;;)
            if (c = this.DecodeValue(this.literalTree), c >= 256) {
                if (c -= 256, 0 == c) break;
                for (c--, e = this.readBits(cc.Codec.GZip.cplext[c]) + cc.Codec.GZip.cplens[c], c = this.DecodeValue(this.distanceTree), 8 < cc.Codec.GZip.cpdext[c] ? (f = this.readBits(8), f |= this.readBits(cc.Codec.GZip.cpdext[c] - 8) << 8) : f = this.readBits(cc.Codec.GZip.cpdext[c]), f += cc.Codec.GZip.cpdist[c]; e--;) b = this.buf32k[this.bIdx - f & 32767], this.addBuffer(b)
            } else this.addBuffer(c)
    } while (!a);
    return this.flushBuffer(), this.byteAlign(), 0
}, cc.Codec.GZip.prototype.unzipFile = function(a) {
    var b;
    for (this.gunzip(), b = 0; b < this.unzipped.length; b++)
        if (this.unzipped[b][1] == a) return this.unzipped[b][0]
}, cc.Codec.GZip.prototype.nextFile = function() {
    this.outputArr = [], this.modeZIP = !1;
    var a = [];
    if (a[0] = this.readByte(), a[1] = this.readByte(), 120 == a[0] && 218 == a[1] && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), "geonext.gxt"], this.files++), 31 == a[0] && 139 == a[1] && (this.skipdir(), this.unzipped[this.files] = [this.outputArr.join(""), "file"], this.files++), 80 == a[0] && 75 == a[1] && (this.modeZIP = !0, a[2] = this.readByte(), a[3] = this.readByte(), 3 == a[2] && 4 == a[3])) {
        a[0] = this.readByte(), a[1] = this.readByte(), this.gpflags = this.readByte(), this.gpflags |= this.readByte() << 8, a = this.readByte(), a |= this.readByte() << 8, this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte();
        var b = this.readByte(),
            b = b | this.readByte() << 8,
            c = this.readByte(),
            c = c | this.readByte() << 8,
            d = 0;
        for (this.nameBuf = []; b--;) {
            var e = this.readByte();
            "/" == e | ":" == e ? d = 0 : d < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[d++] = String.fromCharCode(e))
        }
        this.fileout || (this.fileout = this.nameBuf);
        for (var d = 0; c > d;) this.readByte(), d++;
        8 == a && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), this.nameBuf.join("")], this.files++), this.skipdir()
    }
}, cc.Codec.GZip.prototype.skipdir = function() {
    var a, b = [];
    if (8 & this.gpflags && (b[0] = this.readByte(), b[1] = this.readByte(), b[2] = this.readByte(), b[3] = this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte()), this.modeZIP && this.nextFile(), b[0] = this.readByte(), 8 != b[0]) return 0;
    if (this.gpflags = this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), 4 & this.gpflags)
        for (b[0] = this.readByte(), b[2] = this.readByte(), this.len = b[0] + 256 * b[1], b = 0; b < this.len; b++) this.readByte();
    if (8 & this.gpflags)
        for (b = 0, this.nameBuf = []; a = this.readByte();)("7" == a || ":" == a) && (b = 0), b < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[b++] = a);
    if (16 & this.gpflags)
        for (; this.readByte(););
    2 & this.gpflags && (this.readByte(), this.readByte()), this.DeflateLoop(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.modeZIP && this.nextFile()
}, function() {
    function a(a) {
        throw a
    }

    function b(a, b) {
        var c = a.split("."),
            d = u;
        !(c[0] in d) && d.execScript && d.execScript("var " + c[0]);
        for (var e; c.length && (e = c.shift());) c.length || b === s ? d = d[e] ? d[e] : d[e] = {} : d[e] = b
    }

    function c(a) {
        if ("string" == typeof a) {
            a = a.split("");
            var b, c;
            for (b = 0, c = a.length; c > b; b++) a[b] = (255 & a[b].charCodeAt(0)) >>> 0
        }
        b = 1, c = 0;
        for (var d, e = a.length, f = 0; e > 0;) {
            d = e > 1024 ? 1024 : e, e -= d;
            do b += a[f++], c += b; while (--d);
            b %= 65521, c %= 65521
        }
        return (c << 16 | b) >>> 0
    }

    function d(b, c) {
        this.index = "number" == typeof c ? c : 0, this.i = 0, this.buffer = b instanceof(v ? Uint8Array : Array) ? b : new(v ? Uint8Array : Array)(32768), 2 * this.buffer.length <= this.index && a(Error("invalid index")), this.buffer.length <= this.index && this.f()
    }

    function e(a) {
        this.buffer = new(v ? Uint16Array : Array)(2 * a), this.length = 0
    }

    function f(a) {
        var b, c, d, e, f, g, h, i, j, k = a.length,
            l = 0,
            m = Number.POSITIVE_INFINITY;
        for (i = 0; k > i; ++i) a[i] > l && (l = a[i]), a[i] < m && (m = a[i]);
        for (b = 1 << l, c = new(v ? Uint32Array : Array)(b), d = 1, e = 0, f = 2; l >= d;) {
            for (i = 0; k > i; ++i)
                if (a[i] === d) {
                    for (g = 0, h = e, j = 0; d > j; ++j) g = g << 1 | 1 & h, h >>= 1;
                    for (j = g; b > j; j += f) c[j] = d << 16 | i;
                    ++e
                }++d, e <<= 1, f <<= 1
        }
        return [c, l, m]
    }

    function g(a, b) {
        this.h = C, this.w = 0, this.input = a, this.b = 0, b && (b.lazy && (this.w = b.lazy), "number" == typeof b.compressionType && (this.h = b.compressionType), b.outputBuffer && (this.a = v && b.outputBuffer instanceof Array ? new Uint8Array(b.outputBuffer) : b.outputBuffer), "number" == typeof b.outputIndex && (this.b = b.outputIndex)), this.a || (this.a = new(v ? Uint8Array : Array)(32768))
    }

    function h(a, b) {
        this.length = a, this.G = b
    }

    function i() {
        var b = E;
        switch (t) {
            case 3 === b:
                return [257, b - 3, 0];
            case 4 === b:
                return [258, b - 4, 0];
            case 5 === b:
                return [259, b - 5, 0];
            case 6 === b:
                return [260, b - 6, 0];
            case 7 === b:
                return [261, b - 7, 0];
            case 8 === b:
                return [262, b - 8, 0];
            case 9 === b:
                return [263, b - 9, 0];
            case 10 === b:
                return [264, b - 10, 0];
            case 12 >= b:
                return [265, b - 11, 1];
            case 14 >= b:
                return [266, b - 13, 1];
            case 16 >= b:
                return [267, b - 15, 1];
            case 18 >= b:
                return [268, b - 17, 1];
            case 22 >= b:
                return [269, b - 19, 2];
            case 26 >= b:
                return [270, b - 23, 2];
            case 30 >= b:
                return [271, b - 27, 2];
            case 34 >= b:
                return [272, b - 31, 2];
            case 42 >= b:
                return [273, b - 35, 3];
            case 50 >= b:
                return [274, b - 43, 3];
            case 58 >= b:
                return [275, b - 51, 3];
            case 66 >= b:
                return [276, b - 59, 3];
            case 82 >= b:
                return [277, b - 67, 4];
            case 98 >= b:
                return [278, b - 83, 4];
            case 114 >= b:
                return [279, b - 99, 4];
            case 130 >= b:
                return [280, b - 115, 4];
            case 162 >= b:
                return [281, b - 131, 5];
            case 194 >= b:
                return [282, b - 163, 5];
            case 226 >= b:
                return [283, b - 195, 5];
            case 257 >= b:
                return [284, b - 227, 5];
            case 258 === b:
                return [285, b - 258, 0];
            default:
                a("invalid length: " + b)
        }
    }

    function j(b, c) {
        function d(b, c) {
            var d, e = b.G,
                f = [],
                g = 0;
            d = F[b.length], f[g++] = 65535 & d, f[g++] = d >> 16 & 255, f[g++] = d >> 24;
            var h;
            switch (t) {
                case 1 === e:
                    h = [0, e - 1, 0];
                    break;
                case 2 === e:
                    h = [1, e - 2, 0];
                    break;
                case 3 === e:
                    h = [2, e - 3, 0];
                    break;
                case 4 === e:
                    h = [3, e - 4, 0];
                    break;
                case 6 >= e:
                    h = [4, e - 5, 1];
                    break;
                case 8 >= e:
                    h = [5, e - 7, 1];
                    break;
                case 12 >= e:
                    h = [6, e - 9, 2];
                    break;
                case 16 >= e:
                    h = [7, e - 13, 2];
                    break;
                case 24 >= e:
                    h = [8, e - 17, 3];
                    break;
                case 32 >= e:
                    h = [9, e - 25, 3];
                    break;
                case 48 >= e:
                    h = [10, e - 33, 4];
                    break;
                case 64 >= e:
                    h = [11, e - 49, 4];
                    break;
                case 96 >= e:
                    h = [12, e - 65, 5];
                    break;
                case 128 >= e:
                    h = [13, e - 97, 5];
                    break;
                case 192 >= e:
                    h = [14, e - 129, 6];
                    break;
                case 256 >= e:
                    h = [15, e - 193, 6];
                    break;
                case 384 >= e:
                    h = [16, e - 257, 7];
                    break;
                case 512 >= e:
                    h = [17, e - 385, 7];
                    break;
                case 768 >= e:
                    h = [18, e - 513, 8];
                    break;
                case 1024 >= e:
                    h = [19, e - 769, 8];
                    break;
                case 1536 >= e:
                    h = [20, e - 1025, 9];
                    break;
                case 2048 >= e:
                    h = [21, e - 1537, 9];
                    break;
                case 3072 >= e:
                    h = [22, e - 2049, 10];
                    break;
                case 4096 >= e:
                    h = [23, e - 3073, 10];
                    break;
                case 6144 >= e:
                    h = [24, e - 4097, 11];
                    break;
                case 8192 >= e:
                    h = [25, e - 6145, 11];
                    break;
                case 12288 >= e:
                    h = [26, e - 8193, 12];
                    break;
                case 16384 >= e:
                    h = [27, e - 12289, 12];
                    break;
                case 24576 >= e:
                    h = [28, e - 16385, 13];
                    break;
                case 32768 >= e:
                    h = [29, e - 24577, 13];
                    break;
                default:
                    a("invalid distance")
            }
            for (d = h, f[g++] = d[0], f[g++] = d[1], f[g++] = d[2], e = 0, g = f.length; g > e; ++e) n[o++] = f[e];
            q[f[0]]++, r[f[3]]++, p = b.length + c - 1, k = null
        }
        var e, f, g, i, j, k, l, m = {}, n = v ? new Uint16Array(2 * c.length) : [],
            o = 0,
            p = 0,
            q = new(v ? Uint32Array : Array)(286),
            r = new(v ? Uint32Array : Array)(30),
            u = b.w;
        if (!v) {
            for (g = 0; 285 >= g;) q[g++] = 0;
            for (g = 0; 29 >= g;) r[g++] = 0
        }
        for (q[256] = 1, e = 0, f = c.length; f > e; ++e) {
            for (g = j = 0, i = 3; i > g && e + g !== f; ++g) j = j << 8 | c[e + g];
            if (m[j] === s && (m[j] = []), g = m[j], !(0 < p--)) {
                for (; 0 < g.length && 32768 < e - g[0];) g.shift();
                if (e + 3 >= f) {
                    for (k && d(k, -1), g = 0, i = f - e; i > g; ++g) l = c[e + g], n[o++] = l, ++q[l];
                    break
                }
                if (0 < g.length) {
                    j = i = s;
                    var w = 0,
                        x = s,
                        y = s,
                        z = x = s,
                        A = c.length,
                        y = 0,
                        z = g.length;
                    a: for (; z > y; y++) {
                        if (i = g[z - y - 1], x = 3, w > 3) {
                            for (x = w; x > 3; x--)
                                if (c[i + x - 1] !== c[e + x - 1]) continue a;
                            x = w
                        }
                        for (; 258 > x && A > e + x && c[i + x] === c[e + x];)++x;
                        if (x > w && (j = i, w = x), 258 === x) break
                    }
                    i = new h(w, e - j),
                    k ? k.length < i.length ? (l = c[e - 1], n[o++] = l, ++q[l], d(i, 0)) : d(k, -1) : i.length < u ? k = i : d(i, 0)
                } else k ? d(k, -1) : (l = c[e], n[o++] = l, ++q[l])
            }
            g.push(e)
        }
        return n[o++] = 256, q[256]++, b.L = q, b.K = r, v ? n.subarray(0, o) : n
    }

    function k(a, b) {
        function c(a) {
            var b = p[a][q[a]];
            b === k ? (c(a + 1), c(a + 1)) : --l[b], ++q[a]
        }
        var d, f, g, h = a.length,
            i = new e(572),
            j = new(v ? Uint8Array : Array)(h);
        if (!v)
            for (f = 0; h > f; f++) j[f] = 0;
        for (f = 0; h > f; ++f) 0 < a[f] && i.push(f, a[f]);
        if (h = Array(i.length / 2), d = new(v ? Uint32Array : Array)(i.length / 2), 1 === h.length) return j[i.pop().index] = 1, j;
        for (f = 0, g = i.length / 2; g > f; ++f) h[f] = i.pop(), d[f] = h[f].value;
        var k = d.length;
        f = new(v ? Uint16Array : Array)(b);
        var i = new(v ? Uint8Array : Array)(b),
            l = new(v ? Uint8Array : Array)(k);
        g = Array(b);
        var m, n, o, p = Array(b),
            q = Array(b),
            r = (1 << b) - k,
            s = 1 << b - 1;
        for (f[b - 1] = k, m = 0; b > m; ++m) s > r ? i[m] = 0 : (i[m] = 1, r -= s), r <<= 1, f[b - 2 - m] = (f[b - 1 - m] / 2 | 0) + k;
        for (f[0] = i[0], g[0] = Array(f[0]), p[0] = Array(f[0]), m = 1; b > m; ++m) f[m] > 2 * f[m - 1] + i[m] && (f[m] = 2 * f[m - 1] + i[m]), g[m] = Array(f[m]), p[m] = Array(f[m]);
        for (r = 0; k > r; ++r) l[r] = b;
        for (s = 0; s < f[b - 1]; ++s) g[b - 1][s] = d[s], p[b - 1][s] = s;
        for (r = 0; b > r; ++r) q[r] = 0;
        for (1 === i[b - 1] && (--l[0], ++q[b - 1]), m = b - 2; m >= 0; --m) {
            for (n = r = 0, o = q[m + 1], s = 0; s < f[m]; s++) n = g[m + 1][o] + g[m + 1][o + 1], n > d[r] ? (g[m][s] = n, p[m][s] = k, o += 2) : (g[m][s] = d[r], p[m][s] = r, ++r);
            q[m] = 0, 1 === i[m] && c(m)
        }
        for (d = l, f = 0, g = h.length; g > f; ++f) j[h[f].index] = d[f];
        return j
    }

    function l(b) {
        var c, d, e, f = new(v ? Uint16Array : Array)(b.length),
            g = [],
            h = [],
            i = 0;
        for (c = 0, d = b.length; d > c; c++) g[b[c]] = (0 | g[b[c]]) + 1;
        for (c = 1, d = 16; d >= c; c++) h[c] = i, i += 0 | g[c], i > 1 << c && a("overcommitted"), i <<= 1;
        for (65536 > i && a("undercommitted"), c = 0, d = b.length; d > c; c++)
            for (i = h[b[c]], h[b[c]] += 1, g = f[c] = 0, e = b[c]; e > g; g++) f[c] = f[c] << 1 | 1 & i, i >>>= 1;
        return f
    }

    function m(a, b) {
        this.input = a, this.a = new(v ? Uint8Array : Array)(32768), this.h = G.j;
        var c, d = {};
        !b && (b = {}) || "number" != typeof b.compressionType || (this.h = b.compressionType);
        for (c in b) d[c] = b[c];
        d.outputBuffer = this.a, this.z = new g(this.input, d)
    }

    function n(b, c) {
        switch (this.k = [], this.l = 32768, this.e = this.g = this.c = this.q = 0, this.input = v ? new Uint8Array(b) : b, this.s = !1, this.m = I, this.B = !1, (c || !(c = {})) && (c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), c.bufferType && (this.m = c.bufferType), c.resize && (this.B = c.resize)), this.m) {
            case H:
                this.b = 32768, this.a = new(v ? Uint8Array : Array)(32768 + this.l + 258);
                break;
            case I:
                this.b = 0, this.a = new(v ? Uint8Array : Array)(this.l), this.f = this.J, this.t = this.H, this.o = this.I;
                break;
            default:
                a(Error("invalid inflate mode"))
        }
    }

    function o(b, c) {
        for (var d, e = b.g, f = b.e, g = b.input, h = b.c; c > f;) d = g[h++], d === s && a(Error("input buffer is broken")), e |= d << f, f += 8;
        return b.g = e >>> c, b.e = f - c, b.c = h, e & (1 << c) - 1
    }

    function p(b, c) {
        for (var d, e = b.g, f = b.e, g = b.input, h = b.c, i = c[0], j = c[1]; j > f;) d = g[h++], d === s && a(Error("input buffer is broken")), e |= d << f, f += 8;
        return g = i[e & (1 << j) - 1], i = g >>> 16, b.g = e >> i, b.e = f - i, b.c = h, 65535 & g
    }

    function q(a) {
        function b(a, b, c) {
            var d, e, f, g;
            for (g = 0; a > g;) switch (d = p(this, b)) {
                case 16:
                    for (f = 3 + o(this, 2); f--;) c[g++] = e;
                    break;
                case 17:
                    for (f = 3 + o(this, 3); f--;) c[g++] = 0;
                    e = 0;
                    break;
                case 18:
                    for (f = 11 + o(this, 7); f--;) c[g++] = 0;
                    e = 0;
                    break;
                default:
                    e = c[g++] = d
            }
            return c
        }
        var c, d = o(a, 5) + 257,
            e = o(a, 5) + 1,
            g = o(a, 4) + 4,
            h = new(v ? Uint8Array : Array)(J.length);
        for (c = 0; g > c; ++c) h[J[c]] = o(a, 3);
        g = f(h), h = new(v ? Uint8Array : Array)(d), c = new(v ? Uint8Array : Array)(e), a.o(f(b.call(a, d, g, h)), f(b.call(a, e, g, c)))
    }

    function r(b, c) {
        var d, e;
        switch (this.input = b, this.c = 0, (c || !(c = {})) && (c.index && (this.c = c.index), c.verify && (this.M = c.verify)), d = b[this.c++], e = b[this.c++], 15 & d) {
            case Q:
                this.method = Q;
                break;
            default:
                a(Error("unsupported compression method"))
        }
        0 !== ((d << 8) + e) % 31 && a(Error("invalid fcheck flag:" + ((d << 8) + e) % 31)), 32 & e && a(Error("fdict flag is not supported")), this.A = new n(b, {
            index: this.c,
            bufferSize: c.bufferSize,
            bufferType: c.bufferType,
            resize: c.resize
        })
    }
    var s = void 0,
        t = !0,
        u = this,
        v = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array;
    d.prototype.f = function() {
        var a, b = this.buffer,
            c = b.length,
            d = new(v ? Uint8Array : Array)(c << 1);
        if (v) d.set(b);
        else
            for (a = 0; c > a; ++a) d[a] = b[a];
        return this.buffer = d
    }, d.prototype.d = function(a, b, c) {
        var d = this.buffer,
            e = this.index,
            f = this.i,
            g = d[e];
        if (c && b > 1 && (a = b > 8 ? (B[255 & a] << 24 | B[a >>> 8 & 255] << 16 | B[a >>> 16 & 255] << 8 | B[a >>> 24 & 255]) >> 32 - b : B[a] >> 8 - b), 8 > b + f) g = g << b | a, f += b;
        else
            for (c = 0; b > c; ++c) g = g << 1 | a >> b - c - 1 & 1, 8 === ++f && (f = 0, d[e++] = B[g], g = 0, e === d.length && (d = this.f()));
        d[e] = g, this.buffer = d, this.i = f, this.index = e
    }, d.prototype.finish = function() {
        var a, b = this.buffer,
            c = this.index;
        return 0 < this.i && (b[c] <<= 8 - this.i, b[c] = B[b[c]], c++), v ? a = b.subarray(0, c) : (b.length = c, a = b), a
    };
    var w, x = new(v ? Uint8Array : Array)(256);
    for (w = 0; 256 > w; ++w) {
        for (var y = w, z = y, A = 7, y = y >>> 1; y; y >>>= 1) z <<= 1, z |= 1 & y, --A;
        x[w] = (z << A & 255) >>> 0
    }
    var B = x,
        x = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
    v && new Uint32Array(x), e.prototype.getParent = function(a) {
        return 2 * ((a - 2) / 4 | 0)
    }, e.prototype.push = function(a, b) {
        var c, d, e, f = this.buffer;
        for (c = this.length, f[this.length++] = b, f[this.length++] = a; c > 0 && (d = this.getParent(c), f[c] > f[d]);) e = f[c], f[c] = f[d], f[d] = e, e = f[c + 1], f[c + 1] = f[d + 1], f[d + 1] = e, c = d;
        return this.length
    }, e.prototype.pop = function() {
        var a, b, c, d, e, f = this.buffer;
        for (b = f[0], a = f[1], this.length -= 2, f[0] = f[this.length], f[1] = f[this.length + 1], e = 0;
            (d = 2 * e + 2, !(d >= this.length)) && (d + 2 < this.length && f[d + 2] > f[d] && (d += 2), f[d] > f[e]);) c = f[e], f[e] = f[d], f[d] = c, c = f[e + 1], f[e + 1] = f[d + 1], f[d + 1] = c, e = d;
        return {
            index: a,
            value: b,
            length: this.length
        }
    };
    var C = 2,
        x = {
            NONE: 0,
            r: 1,
            j: C,
            N: 3
        }, D = [];
    for (w = 0; 288 > w; w++) switch (t) {
        case 143 >= w:
            D.push([w + 48, 8]);
            break;
        case 255 >= w:
            D.push([w - 144 + 400, 9]);
            break;
        case 279 >= w:
            D.push([w - 256 + 0, 7]);
            break;
        case 287 >= w:
            D.push([w - 280 + 192, 8]);
            break;
        default:
            a("invalid literal: " + w)
    }
    g.prototype.n = function() {
        var b, c, e, f, g = this.input;
        switch (this.h) {
            case 0:
                for (e = 0, f = g.length; f > e;) {
                    c = v ? g.subarray(e, e + 65535) : g.slice(e, e + 65535), e += c.length;
                    var h = e === f,
                        i = s,
                        m = i = s,
                        m = i = s,
                        n = this.a,
                        o = this.b;
                    if (v) {
                        for (n = new Uint8Array(this.a.buffer); n.length <= o + c.length + 5;) n = new Uint8Array(n.length << 1);
                        n.set(this.a)
                    }
                    if (i = h ? 1 : 0, n[o++] = 0 | i, i = c.length, m = ~i + 65536 & 65535, n[o++] = 255 & i, n[o++] = i >>> 8 & 255, n[o++] = 255 & m, n[o++] = m >>> 8 & 255, v) n.set(c, o), o += c.length, n = n.subarray(0, o);
                    else {
                        for (i = 0, m = c.length; m > i; ++i) n[o++] = c[i];
                        n.length = o
                    }
                    this.b = o, this.a = n
                }
                break;
            case 1:
                for (e = new d(new Uint8Array(this.a.buffer), this.b), e.d(1, 1, t), e.d(1, 2, t), g = j(this, g), c = 0, h = g.length; h > c; c++)
                    if (f = g[c], d.prototype.d.apply(e, D[f]), f > 256) e.d(g[++c], g[++c], t), e.d(g[++c], 5), e.d(g[++c], g[++c], t);
                    else if (256 === f) break;
                this.a = e.finish(), this.b = this.a.length;
                break;
            case C:
                f = new d(new Uint8Array(this.a), this.b);
                var p, q, r, u, w, x, y = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                    i = Array(19),
                    n = C;
                for (f.d(1, 1, t), f.d(n, 2, t), g = j(this, g), m = k(this.L, 15), u = l(m), n = k(this.K, 7), o = l(n), p = 286; p > 257 && 0 === m[p - 1]; p--);
                for (q = 30; q > 1 && 0 === n[q - 1]; q--);
                var z = p,
                    A = q;
                b = new(v ? Uint32Array : Array)(z + A);
                var B, E, F = new(v ? Uint32Array : Array)(316);
                for (w = new(v ? Uint8Array : Array)(19), x = r = 0; z > x; x++) b[r++] = m[x];
                for (x = 0; A > x; x++) b[r++] = n[x];
                if (!v)
                    for (x = 0, A = w.length; A > x; ++x) w[x] = 0;
                for (x = B = 0, A = b.length; A > x; x += r) {
                    for (r = 1; A > x + r && b[x + r] === b[x]; ++r);
                    if (z = r, 0 === b[x])
                        if (3 > z)
                            for (; 0 < z--;) F[B++] = 0, w[0]++;
                        else
                            for (; z > 0;) E = 138 > z ? z : 138, E > z - 3 && z > E && (E = z - 3), 10 >= E ? (F[B++] = 17, F[B++] = E - 3, w[17]++) : (F[B++] = 18, F[B++] = E - 11, w[18]++), z -= E;
                        else if (F[B++] = b[x], w[b[x]]++, z--, 3 > z)
                        for (; 0 < z--;) F[B++] = b[x], w[b[x]]++;
                    else
                        for (; z > 0;) E = 6 > z ? z : 6, E > z - 3 && z > E && (E = z - 3), F[B++] = 16, F[B++] = E - 3, w[16]++, z -= E
                }
                for (b = v ? F.subarray(0, B) : F.slice(0, B), w = k(w, 7), x = 0; 19 > x; x++) i[x] = w[y[x]];
                for (r = 19; r > 4 && 0 === i[r - 1]; r--);
                for (y = l(w), f.d(p - 257, 5, t), f.d(q - 1, 5, t), f.d(r - 4, 4, t), x = 0; r > x; x++) f.d(i[x], 3, t);
                for (x = 0, i = b.length; i > x; x++)
                    if (c = b[x], f.d(y[c], w[c], t), c >= 16) {
                        switch (x++, c) {
                            case 16:
                                h = 2;
                                break;
                            case 17:
                                h = 3;
                                break;
                            case 18:
                                h = 7;
                                break;
                            default:
                                a("invalid code: " + c)
                        }
                        f.d(b[x], h, t)
                    }
                for (h = [u, m], o = [o, n], c = h[0], h = h[1], n = o[0], u = o[1], o = 0, i = g.length; i > o; ++o)
                    if (e = g[o], f.d(c[e], h[e], t), e > 256) f.d(g[++o], g[++o], t), m = g[++o], f.d(n[m], u[m], t), f.d(g[++o], g[++o], t);
                    else if (256 === e) break;
                this.a = f.finish(), this.b = this.a.length;
                break;
            default:
                a("invalid compression type")
        }
        return this.a
    }, w = [];
    var E;
    for (E = 3; 258 >= E; E++) y = i(), w[E] = y[2] << 24 | y[1] << 16 | y[0];
    var F = v ? new Uint32Array(w) : w,
        G = x;
    m.prototype.n = function() {
        var b, d, e, f, g = 0;
        switch (f = this.a, b = Q) {
            case Q:
                d = Math.LOG2E * Math.log(32768) - 8;
                break;
            default:
                a(Error("invalid compression method"))
        }
        switch (d = d << 4 | b, f[g++] = d, b) {
            case Q:
                switch (this.h) {
                    case G.NONE:
                        e = 0;
                        break;
                    case G.r:
                        e = 1;
                        break;
                    case G.j:
                        e = 2;
                        break;
                    default:
                        a(Error("unsupported compression type"))
                }
                break;
            default:
                a(Error("invalid compression method"))
        }
        return b = e << 6 | 0, f[g++] = b | 31 - (256 * d + b) % 31, b = c(this.input), this.z.b = g, f = this.z.n(), g = f.length, v && (f = new Uint8Array(f.buffer), f.length <= g + 4 && (this.a = new Uint8Array(f.length + 4), this.a.set(f), f = this.a), f = f.subarray(0, g + 4)), f[g++] = b >> 24 & 255, f[g++] = b >> 16 & 255, f[g++] = b >> 8 & 255, f[g++] = 255 & b, f
    }, b("Zlib.Deflate", m), b("Zlib.Deflate.compress", function(a, b) {
        return new m(a, b).n()
    }), b("Zlib.Deflate.CompressionType", G), b("Zlib.Deflate.CompressionType.NONE", G.NONE), b("Zlib.Deflate.CompressionType.FIXED", G.r), b("Zlib.Deflate.CompressionType.DYNAMIC", G.j);
    var H = 0,
        I = 1,
        x = {
            D: H,
            C: I
        };
    n.prototype.p = function() {
        for (; !this.s;) {
            var b = o(this, 3);
            switch (1 & b && (this.s = t), b >>>= 1) {
                case 0:
                    var b = this.input,
                        c = this.c,
                        d = this.a,
                        e = this.b,
                        f = s,
                        g = s,
                        h = s,
                        i = d.length,
                        f = s;
                    switch (this.e = this.g = 0, f = b[c++], f === s && a(Error("invalid uncompressed block header: LEN (first byte)")), g = f, f = b[c++], f === s && a(Error("invalid uncompressed block header: LEN (second byte)")), g |= f << 8, f = b[c++], f === s && a(Error("invalid uncompressed block header: NLEN (first byte)")), h = f, f = b[c++], f === s && a(Error("invalid uncompressed block header: NLEN (second byte)")), h |= f << 8, g === ~h && a(Error("invalid uncompressed block header: length verify")), c + g > b.length && a(Error("input buffer is broken")), this.m) {
                        case H:
                            for (; e + g > d.length;) {
                                if (f = i - e, g -= f, v) d.set(b.subarray(c, c + f), e), e += f, c += f;
                                else
                                    for (; f--;) d[e++] = b[c++];
                                this.b = e, d = this.f(), e = this.b
                            }
                            break;
                        case I:
                            for (; e + g > d.length;) d = this.f({
                                v: 2
                            });
                            break;
                        default:
                            a(Error("invalid inflate mode"))
                    }
                    if (v) d.set(b.subarray(c, c + g), e), e += g, c += g;
                    else
                        for (; g--;) d[e++] = b[c++];
                    this.c = c, this.b = e, this.a = d;
                    break;
                case 1:
                    this.o(O, P);
                    break;
                case 2:
                    q(this);
                    break;
                default:
                    a(Error("unknown BTYPE: " + b))
            }
        }
        return this.t()
    }, w = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var J = v ? new Uint16Array(w) : w;
    w = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
    var K = v ? new Uint16Array(w) : w;
    w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    var L = v ? new Uint8Array(w) : w;
    w = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    var M = v ? new Uint16Array(w) : w;
    w = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var N = v ? new Uint8Array(w) : w;
    for (w = new(v ? Uint8Array : Array)(288), y = 0, z = w.length; z > y; ++y) w[y] = 143 >= y ? 8 : 255 >= y ? 9 : 279 >= y ? 7 : 8;
    var O = f(w);
    for (w = new(v ? Uint8Array : Array)(30), y = 0, z = w.length; z > y; ++y) w[y] = 5;
    var P = f(w);
    for (n.prototype.o = function(a, b) {
        var c = this.a,
            d = this.b;
        this.u = a;
        for (var e, f, g, h = c.length - 258; 256 !== (e = p(this, a));)
            if (256 > e) d >= h && (this.b = d, c = this.f(), d = this.b), c[d++] = e;
            else
                for (e -= 257, g = K[e], 0 < L[e] && (g += o(this, L[e])), e = p(this, b), f = M[e], 0 < N[e] && (f += o(this, N[e])), d >= h && (this.b = d, c = this.f(), d = this.b); g--;) c[d] = c[d++-f];
        for (; 8 <= this.e;) this.e -= 8, this.c--;
        this.b = d
    }, n.prototype.I = function(a, b) {
        var c = this.a,
            d = this.b;
        this.u = a;
        for (var e, f, g, h = c.length; 256 !== (e = p(this, a));)
            if (256 > e) d >= h && (c = this.f(), h = c.length), c[d++] = e;
            else
                for (e -= 257, g = K[e], 0 < L[e] && (g += o(this, L[e])), e = p(this, b), f = M[e], 0 < N[e] && (f += o(this, N[e])), d + g > h && (c = this.f(), h = c.length); g--;) c[d] = c[d++-f];
        for (; 8 <= this.e;) this.e -= 8, this.c--;
        this.b = d
    }, n.prototype.f = function() {
        var a, b, c = new(v ? Uint8Array : Array)(this.b - 32768),
            d = this.b - 32768,
            e = this.a;
        if (v) c.set(e.subarray(32768, c.length));
        else
            for (a = 0, b = c.length; b > a; ++a) c[a] = e[a + 32768]; if (this.k.push(c), this.q += c.length, v) e.set(e.subarray(d, d + 32768));
        else
            for (a = 0; 32768 > a; ++a) e[a] = e[d + a];
        return this.b = 32768, e
    }, n.prototype.J = function(a) {
        var b, c, d, e, f = this.input.length / this.c + 1 | 0,
            g = this.input,
            h = this.a;
        return a && ("number" == typeof a.v && (f = a.v), "number" == typeof a.F && (f += a.F)), 2 > f ? (c = (g.length - this.c) / this.u[2], e = 258 * (c / 2) | 0, d = e < h.length ? h.length + e : h.length << 1) : d = h.length * f, v ? (b = new Uint8Array(d), b.set(h)) : b = h, this.a = b
    }, n.prototype.t = function() {
        var a, b, c, d, e, f = 0,
            g = this.a,
            h = this.k,
            i = new(v ? Uint8Array : Array)(this.q + (this.b - 32768));
        if (0 === h.length) return v ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
        for (b = 0, c = h.length; c > b; ++b)
            for (a = h[b], d = 0, e = a.length; e > d; ++d) i[f++] = a[d];
        for (b = 32768, c = this.b; c > b; ++b) i[f++] = g[b];
        return this.k = [], this.buffer = i
    }, n.prototype.H = function() {
        var a, b = this.b;
        return v ? this.B ? (a = new Uint8Array(b), a.set(this.a.subarray(0, b))) : a = this.a.subarray(0, b) : (this.a.length > b && (this.a.length = b), a = this.a), this.buffer = a
    }, r.prototype.p = function() {
        var b, d, e = this.input;
        return b = this.A.p(), this.c = this.A.c, this.M && (d = (e[this.c++] << 24 | e[this.c++] << 16 | e[this.c++] << 8 | e[this.c++]) >>> 0, d !== c(b) && a(Error("invalid adler-32 checksum"))), b
    }, b("Zlib.Inflate", r), b("Zlib.Inflate.BufferType", x), x.ADAPTIVE = x.C, x.BLOCK = x.D, b("Zlib.Inflate.prototype.decompress", r.prototype.p), x = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], v && new Uint16Array(x), x = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258], v && new Uint16Array(x), x = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0], v && new Uint8Array(x), x = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], v && new Uint16Array(x), x = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], v && new Uint8Array(x), x = new(v ? Uint8Array : Array)(288), w = 0, y = x.length; y > w; ++w) x[w] = 143 >= w ? 8 : 255 >= w ? 9 : 279 >= w ? 7 : 8;
    for (f(x), x = new(v ? Uint8Array : Array)(30), w = 0, y = x.length; y > w; ++w) x[w] = 5;
    f(x);
    var Q = 8
}.call(this), _p = window, _p = _p.Zlib = _p.Zlib, _p.Deflate = _p.Deflate, _p.Deflate.compress = _p.Deflate.compress, _p.Inflate = _p.Inflate, _p.Inflate.BufferType = _p.Inflate.BufferType, _p.Inflate.prototype.decompress = _p.Inflate.prototype.decompress, cc.PNGReader = cc.Class.extend({
    ctor: function(a) {
        var b, c, d, e;
        for (this.data = a, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, d = null;;) {
            for (b = this.readUInt32(), e = a = void 0, e = [], a = 0; 4 > a; ++a) e.push(String.fromCharCode(this.data[this.pos++]));
            switch (a = e.join("")) {
                case "IHDR":
                    this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
                    break;
                case "acTL":
                    this.animation = {
                        numFrames: this.readUInt32(),
                        numPlays: this.readUInt32() || 1 / 0,
                        frames: []
                    };
                    break;
                case "PLTE":
                    this.palette = this.read(b);
                    break;
                case "fcTL":
                    d && this.animation.frames.push(d), this.pos += 4, d = {
                        width: this.readUInt32(),
                        height: this.readUInt32(),
                        xOffset: this.readUInt32(),
                        yOffset: this.readUInt32()
                    }, a = this.readUInt16(), b = this.readUInt16() || 100, d.delay = 1e3 * a / b, d.disposeOp = this.data[this.pos++], d.blendOp = this.data[this.pos++], d.data = [];
                    break;
                case "IDAT":
                case "fdAT":
                    for ("fdAT" === a && (this.pos += 4, b -= 4), a = (null != d ? d.data : void 0) || this.imgData, e = 0; b >= 0 ? b > e : e > b; b >= 0 ? ++e : --e) a.push(this.data[this.pos++]);
                    break;
                case "tRNS":
                    switch (this.transparency = {}, this.colorType) {
                        case 3:
                            if (this.transparency.indexed = this.read(b), b = 255 - this.transparency.indexed.length, b > 0)
                                for (a = 0; b >= 0 ? b > a : a > b; b >= 0 ? ++a : --a) this.transparency.indexed.push(255);
                            break;
                        case 0:
                            this.transparency.grayscale = this.read(b)[0];
                            break;
                        case 2:
                            this.transparency.rgb = this.read(b)
                    }
                    break;
                case "tEXt":
                    e = this.read(b), b = e.indexOf(0), a = String.fromCharCode.apply(String, e.slice(0, b)), this.text[a] = String.fromCharCode.apply(String, e.slice(b + 1));
                    break;
                case "IEND":
                    d && this.animation.frames.push(d);
                    a: {
                        switch (this.colorType) {
                            case 0:
                            case 3:
                            case 4:
                                d = 1;
                                break a;
                            case 2:
                            case 6:
                                d = 3;
                                break a
                        }
                        d = void 0
                    }
                    this.colors = d,
                    this.hasAlphaChannel = 4 === (c = this.colorType) || 6 === c,
                    c = this.colors + (this.hasAlphaChannel ? 1 : 0),
                    this.pixelBitlength = this.bits * c;
                    a: {
                        switch (this.colors) {
                            case 1:
                                c = "DeviceGray";
                                break a;
                            case 3:
                                c = "DeviceRGB";
                                break a
                        }
                        c = void 0
                    }
                    return this.colorSpace = c,
                    void(Uint8Array != Array && (this.imgData = new Uint8Array(this.imgData)));
                default:
                    this.pos += b
            }
            if (this.pos += 4, this.pos > this.data.length) throw Error("Incomplete or corrupt PNG file")
        }
    },
    read: function(a) {
        var b, c;
        for (c = [], b = 0; a >= 0 ? a > b : b > a; a >= 0 ? ++b : --b) c.push(this.data[this.pos++]);
        return c
    },
    readUInt32: function() {
        var a, b, c, d;
        return a = this.data[this.pos++] << 24, b = this.data[this.pos++] << 16, c = this.data[this.pos++] << 8, d = this.data[this.pos++], a | b | c | d
    },
    readUInt16: function() {
        var a, b;
        return a = this.data[this.pos++] << 8, b = this.data[this.pos++], a | b
    },
    decodePixels: function(a) {
        var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p;
        if (null == a && (a = this.imgData), 0 === a.length) return new Uint8Array(0);
        for (a = new Zlib.Inflate(a, {
            index: 0,
            verify: !1
        }).decompress(), i = this.pixelBitlength / 8, m = i * this.width, j = new Uint8Array(m * this.height), g = a.length, c = k = l = 0; g > k;) {
            switch (a[k++]) {
                case 0:
                    for (b = 0; m > b; b += 1) j[c++] = a[k++];
                    break;
                case 1:
                    for (e = n = 0; m > n; e = n += 1) b = a[k++], f = i > e ? 0 : j[c - i], j[c++] = (b + f) % 256;
                    break;
                case 2:
                    for (e = f = 0; m > f; e = f += 1) b = a[k++], d = (e - e % i) / i, n = l && j[(l - 1) * m + d * i + e % i], j[c++] = (n + b) % 256;
                    break;
                case 3:
                    for (e = p = 0; m > p; e = p += 1) b = a[k++], d = (e - e % i) / i, f = i > e ? 0 : j[c - i], n = l && j[(l - 1) * m + d * i + e % i], j[c++] = (b + Math.floor((f + n) / 2)) % 256;
                    break;
                case 4:
                    for (e = p = 0; m > p; e = p += 1) b = a[k++], d = (e - e % i) / i, f = i > e ? 0 : j[c - i], 0 === l ? n = o = 0 : (n = j[(l - 1) * m + d * i + e % i], o = d && j[(l - 1) * m + (d - 1) * i + e % i]), h = f + n - o, e = Math.abs(h - f), d = Math.abs(h - n), h = Math.abs(h - o), f = d >= e && h >= e ? f : h >= d ? n : o, j[c++] = (b + f) % 256;
                    break;
                default:
                    throw Error("Invalid filter algorithm: " + a[k - 1])
            }
            l++
        }
        return j
    },
    copyToImageData: function(a, b) {
        var c, d, e, f, g, h, i, j;
        if (d = this.colors, j = null, c = this.hasAlphaChannel, this.palette.length && (j = null != (e = this._decodedPalette) ? e : this._decodedPalette = this.decodePalette(), d = 4, c = !0), e = a.data || a, i = e.length, g = j || b, f = h = 0, 1 === d)
            for (; i > f;) d = j ? 4 * b[f / 4] : h, h = g[d++], e[f++] = h, e[f++] = h, e[f++] = h, e[f++] = c ? g[d++] : 255, h = d;
        else
            for (; i > f;) d = j ? 4 * b[f / 4] : h, e[f++] = g[d++], e[f++] = g[d++], e[f++] = g[d++], e[f++] = c ? g[d++] : 255, h = d
    },
    decodePalette: function() {
        var a, b, c, d, e, f, g, h, i;
        for (c = this.palette, f = this.transparency.indexed || [], e = new Uint8Array((f.length || 0) + c.length), b = g = a = d = 0, h = c.length; h > g; b = g += 3) e[d++] = c[b], e[d++] = c[b + 1], e[d++] = c[b + 2], e[d++] = null != (i = f[a++]) ? i : 255;
        return e
    },
    render: function(a) {
        var b;
        return a.width = this.width, a.height = this.height, a = a.getContext("2d"), b = a.createImageData(this.width, this.height), this.copyToImageData(b, this.decodePixels()), a.putImageData(b, 0, 0)
    }
}), cc.tiffReader = {
    _littleEndian: !1,
    _tiffData: null,
    _fileDirectories: [],
    getUint8: function(a) {
        return this._tiffData[a]
    },
    getUint16: function(a) {
        return this._littleEndian ? this._tiffData[a + 1] << 8 | this._tiffData[a] : this._tiffData[a] << 8 | this._tiffData[a + 1]
    },
    getUint32: function(a) {
        var b = this._tiffData;
        return this._littleEndian ? b[a + 3] << 24 | b[a + 2] << 16 | b[a + 1] << 8 | b[a] : b[a] << 24 | b[a + 1] << 16 | b[a + 2] << 8 | b[a + 3]
    },
    checkLittleEndian: function() {
        var a = this.getUint16(0);
        if (18761 === a) this.littleEndian = !0;
        else {
            if (19789 !== a) throw console.log(a), TypeError("Invalid byte order value.");
            this.littleEndian = !1
        }
        return this.littleEndian
    },
    hasTowel: function() {
        if (42 !== this.getUint16(2)) throw RangeError("You forgot your towel!");
        return !0
    },
    getFieldTypeName: function(a) {
        var b = this.fieldTypeNames;
        return a in b ? b[a] : null
    },
    getFieldTagName: function(a) {
        var b = this.fieldTagNames;
        return a in b ? b[a] : (console.log("Unknown Field Tag:", a), "Tag" + a)
    },
    getFieldTypeLength: function(a) {
        return -1 !== ["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(a) ? 1 : -1 !== ["SHORT", "SSHORT"].indexOf(a) ? 2 : -1 !== ["LONG", "SLONG", "FLOAT"].indexOf(a) ? 4 : -1 !== ["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(a) ? 8 : null
    },
    getFieldValues: function(a, b, c, d) {
        a = [];
        var e = this.getFieldTypeLength(b);
        if (4 >= e * c) a.push(!1 === this.littleEndian ? d >>> 8 * (4 - e) : d);
        else
            for (var f = 0; c > f; f++) {
                var g = e * f;
                e >= 8 ? -1 !== ["RATIONAL", "SRATIONAL"].indexOf(b) ? (a.push(this.getUint32(d + g)), a.push(this.getUint32(d + g + 4))) : cc.log("Can't handle this field type or size") : a.push(this.getBytes(e, d + g))
            }
        return "ASCII" === b && a.forEach(function(a, b, c) {
            c[b] = String.fromCharCode(a)
        }), a
    },
    getBytes: function(a, b) {
        if (0 >= a) cc.log("No bytes requested");
        else {
            if (1 >= a) return this.getUint8(b);
            if (2 >= a) return this.getUint16(b);
            if (3 >= a) return this.getUint32(b) >>> 8;
            if (4 >= a) return this.getUint32(b);
            cc.log("Too many bytes requested")
        }
    },
    getBits: function(a, b, c) {
        c = c || 0, b += Math.floor(c / 8);
        var d = c + a;
        a = 32 - a;
        var e, f;
        return 0 >= d ? console.log("No bits requested") : 8 >= d ? (e = 24 + c, f = this.getUint8(b)) : 16 >= d ? (e = 16 + c, f = this.getUint16(b)) : 32 >= d ? (e = c, f = this.getUint32(b)) : console.log("Too many bits requested"), {
            bits: f << e >>> a,
            byteOffset: b + Math.floor(d / 8),
            bitOffset: d % 8
        }
    },
    parseFileDirectory: function(a) {
        var b = this.getUint16(a),
            c = [];
        a += 2;
        for (var d = 0; b > d; a += 12, d++) {
            var e = this.getUint16(a),
                f = this.getUint16(a + 2),
                g = this.getUint32(a + 4),
                h = this.getUint32(a + 8),
                e = this.getFieldTagName(e),
                f = this.getFieldTypeName(f),
                g = this.getFieldValues(e, f, g, h);
            c[e] = {
                type: f,
                values: g
            }
        }
        this._fileDirectories.push(c), b = this.getUint32(a), 0 !== b && this.parseFileDirectory(b)
    },
    clampColorSample: function(a, b) {
        var c = Math.pow(2, 8 - b);
        return Math.floor(a * c + (c - 1))
    },
    parseTIFF: function(a, b) {
        if (b = b || cc.newElement("canvas"), this._tiffData = a, this.canvas = b, this.checkLittleEndian(), this.hasTowel()) {
            var c = this.getUint32(4);
            this._fileDirectories.length = 0, this.parseFileDirectory(c);
            var d = this._fileDirectories[0],
                c = d.ImageWidth.values[0],
                e = d.ImageLength.values[0];
            this.canvas.width = c, this.canvas.height = e;
            var f = [],
                g = d.Compression ? d.Compression.values[0] : 1,
                h = d.SamplesPerPixel.values[0],
                i = [],
                j = 0,
                k = !1;
            if (d.BitsPerSample.values.forEach(function(a, b) {
                i[b] = {
                    bitsPerSample: a,
                    hasBytesPerSample: !1,
                    bytesPerSample: void 0
                }, 0 === a % 8 && (i[b].hasBytesPerSample = !0, i[b].bytesPerSample = a / 8), j += a
            }, this), 0 === j % 8) var k = !0,
            l = j / 8;
            var m = d.StripOffsets.values,
                n = m.length;
            if (d.StripByteCounts) var o = d.StripByteCounts.values;
            else {
                if (cc.log("Missing StripByteCounts!"), 1 !== n) throw Error("Cannot recover from missing StripByteCounts");
                o = [Math.ceil(c * e * j / 8)]
            }
            for (var p = 0; n > p; p++) {
                var q = m[p];
                f[p] = [];
                for (var r = o[p], s = 0, t = 0, u = 1, v = !0, w = [], x = 0, y = 0, z = 0; r > s; s += u) switch (g) {
                    case 1:
                        for (u = 0, w = []; h > u; u++) {
                            if (!i[u].hasBytesPerSample) {
                                var A = this.getBits(i[u].bitsPerSample, q + s, t);
                                throw w.push(A.bits), s = A.byteOffset - q, t = A.bitOffset, RangeError("Cannot handle sub-byte bits per sample")
                            }
                            w.push(this.getBytes(i[u].bytesPerSample, q + s + i[u].bytesPerSample * u))
                        }
                        if (f[p].push(w), !k) throw u = 0, RangeError("Cannot handle sub-byte bits per pixel");
                        u = l;
                        break;
                    case 32773:
                        if (v) {
                            var v = !1,
                                B = 1,
                                C = 1,
                                u = this.getInt8(q + s);
                            u >= 0 && 127 >= u ? B = u + 1 : u >= -127 && -1 >= u ? C = -u + 1 : v = !0
                        } else {
                            for (var D = this.getUint8(q + s), u = 0; C > u; u++) {
                                if (!i[y].hasBytesPerSample) throw RangeError("Cannot handle sub-byte bits per sample");
                                z = z << 8 * x | D, x++, x === i[y].bytesPerSample && (w.push(z), z = x = 0, y++), y === h && (f[p].push(w), w = [], y = 0)
                            }
                            B--, 0 === B && (v = !0)
                        }
                        u = 1
                }
            }
            if (b.getContext) {
                if (l = this.canvas.getContext("2d"), l.fillStyle = "rgba(255, 255, 255, 0)", p = d.RowsPerStrip ? d.RowsPerStrip.values[0] : e, q = f.length, e %= p, e = 0 === e ? p : e, s = p, g = 0, w = d.PhotometricInterpretation.values[0], B = [], C = 0, d.ExtraSamples && (B = d.ExtraSamples.values, C = B.length), d.ColorMap) var A = d.ColorMap.values,
                E = Math.pow(2, i[0].bitsPerSample);
                for (p = 0; q > p; p++) {
                    for (p + 1 === q && (s = e), d = f[p].length, g *= p, k = h = 0; d > k; h++)
                        for (m = 0; c > m; m++, k++) {
                            if (o = f[p][k], v = t = r = 0, n = 1, C > 0)
                                for (r = 0; C > r; r++)
                                    if (1 === B[r] || 2 === B[r]) {
                                        n = o[3 + r] / 256;
                                        break
                                    }
                            switch (w) {
                                case 0:
                                    if (i[0].hasBytesPerSample) var F = Math.pow(16, 2 * i[0].bytesPerSample);
                                    o.forEach(function(a, b, c) {
                                        c[b] = F - a
                                    });
                                case 1:
                                    r = t = v = this.clampColorSample(o[0], i[0].bitsPerSample);
                                    break;
                                case 2:
                                    r = this.clampColorSample(o[0], i[0].bitsPerSample), t = this.clampColorSample(o[1], i[1].bitsPerSample), v = this.clampColorSample(o[2], i[2].bitsPerSample);
                                    break;
                                case 3:
                                    if (void 0 === A) throw Error("Palette image missing color map");
                                    o = o[0], r = this.clampColorSample(A[o], 16), t = this.clampColorSample(A[E + o], 16), v = this.clampColorSample(A[2 * E + o], 16);
                                    break;
                                default:
                                    throw RangeError("Unknown Photometric Interpretation:", w)
                            }
                            l.fillStyle = "rgba(" + r + ", " + t + ", " + v + ", " + n + ")", l.fillRect(m, g + h, 1, 1)
                        }
                    g = s
                }
            }
            return this.canvas
        }
    },
    fieldTagNames: {
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        33723: "IPTC",
        34675: "ICC Profile",
        700: "XMP",
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        34377: "Photoshop"
    },
    fieldTypeNames: {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE"
    }
}, cc.Particle = function(a, b, c, d, e, f, g, h, i, j, k, l) {
    this.pos = a ? a : cc.p(0, 0), this.startPos = b ? b : cc.p(0, 0), this.color = c ? c : {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    }, this.deltaColor = d ? d : {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    }, this.size = e || 0, this.deltaSize = f || 0, this.rotation = g || 0, this.deltaRotation = h || 0, this.timeToLive = i || 0, this.atlasIndex = j || 0, this.modeA = k ? k : new cc.Particle.ModeA, this.modeB = l ? l : new cc.Particle.ModeB, this.isChangeColor = !1, this.drawPos = cc.p(0, 0)
}, cc.Particle.ModeA = function(a, b, c) {
    this.dir = a ? a : cc.p(0, 0), this.radialAccel = b || 0, this.tangentialAccel = c || 0
}, cc.Particle.ModeB = function(a, b, c, d) {
    this.angle = a || 0, this.degreesPerSecond = b || 0, this.radius = c || 0, this.deltaRadius = d || 0
}, cc.Particle.TemporaryPoints = [cc.p(), cc.p(), cc.p(), cc.p()], cc.ParticleSystem = cc.Node.extend({
    _plistFile: "",
    _elapsed: 0,
    _dontTint: !1,
    modeA: null,
    modeB: null,
    _className: "ParticleSystem",
    _pointZeroForParticle: cc.p(0, 0),
    _particles: null,
    _emitCounter: 0,
    _particleIdx: 0,
    _batchNode: null,
    atlasIndex: 0,
    _transformSystemDirty: !1,
    _allocatedParticles: 0,
    drawMode: null,
    shapeType: null,
    _isActive: !1,
    particleCount: 0,
    duration: 0,
    _sourcePosition: null,
    _posVar: null,
    life: 0,
    lifeVar: 0,
    angle: 0,
    angleVar: 0,
    startSize: 0,
    startSizeVar: 0,
    endSize: 0,
    endSizeVar: 0,
    _startColor: null,
    _startColorVar: null,
    _endColor: null,
    _endColorVar: null,
    startSpin: 0,
    startSpinVar: 0,
    endSpin: 0,
    endSpinVar: 0,
    emissionRate: 0,
    _totalParticles: 0,
    _texture: null,
    _blendFunc: null,
    _opacityModifyRGB: !1,
    positionType: null,
    autoRemoveOnFinish: !1,
    emitterMode: 0,
    _quads: null,
    _indices: null,
    _buffersVBO: null,
    _pointRect: null,
    _textureLoaded: null,
    _quadsArrayBuffer: null,
    ctor: function(a) {
        cc.Node.prototype.ctor.call(this), this.emitterMode = cc.ParticleSystem.MODE_GRAVITY, this.modeA = new cc.ParticleSystem.ModeA, this.modeB = new cc.ParticleSystem.ModeB, this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        }, this._particles = [], this._sourcePosition = cc.p(0, 0), this._posVar = cc.p(0, 0), this._startColor = cc.color(255, 255, 255, 255), this._startColorVar = cc.color(255, 255, 255, 255), this._endColor = cc.color(255, 255, 255, 255), this._endColorVar = cc.color(255, 255, 255, 255), this._plistFile = "", this._elapsed = 0, this._dontTint = !1, this._pointZeroForParticle = cc.p(0, 0), this._particleIdx = this._emitCounter = 0, this._batchNode = null, this.atlasIndex = 0, this._transformSystemDirty = !1, this._allocatedParticles = 0, this.drawMode = cc.ParticleSystem.SHAPE_MODE, this.shapeType = cc.ParticleSystem.BALL_SHAPE, this._isActive = !1, this._totalParticles = this.emissionRate = this.endSpinVar = this.endSpin = this.startSpinVar = this.startSpin = this.endSizeVar = this.endSize = this.startSizeVar = this.startSize = this.angleVar = this.angle = this.lifeVar = this.life = this.duration = this.particleCount = 0, this._texture = null, this._opacityModifyRGB = !1, this.positionType = cc.ParticleSystem.TYPE_FREE, this.autoRemoveOnFinish = !1, this._buffersVBO = [0, 0], this._quads = [], this._indices = [], this._pointRect = cc.rect(0, 0, 0, 0), this._textureLoaded = !0, cc._renderType === cc._RENDER_TYPE_WEBGL && (this._quadsArrayBuffer = null), a && "number" != typeof a ? a && this.initWithFile(a) : (a = a || 100, this.setDrawMode(cc.ParticleSystem.TEXTURE_MODE), this.initWithTotalParticles(a))
    },
    initIndices: function() {
        for (var a = this._indices, b = 0, c = this._totalParticles; c > b; ++b) {
            var d = 6 * b,
                e = 4 * b;
            a[d + 0] = e + 0, a[d + 1] = e + 1, a[d + 2] = e + 2, a[d + 5] = e + 1, a[d + 4] = e + 2, a[d + 3] = e + 3
        }
    },
    initTexCoordsWithRect: function(a) {
        var b = cc.contentScaleFactor(),
            c = cc.rect(a.x * b, a.y * b, a.width * b, a.height * b),
            d = a.width,
            e = a.height;
        if (this._texture && (d = this._texture.pixelsWidth, e = this._texture.pixelsHeight), cc._renderType !== cc._RENDER_TYPE_CANVAS) {
            cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (a = (2 * c.x + 1) / (2 * d), b = (2 * c.y + 1) / (2 * e), d = a + (2 * c.width - 2) / (2 * d), c = b + (2 * c.height - 2) / (2 * e)) : (a = c.x / d, b = c.y / e, d = a + c.width / d, c = b + c.height / e);
            var e = c,
                c = b,
                b = e,
                f = 0,
                g = 0;
            for (this._batchNode ? (e = this._batchNode.textureAtlas.quads, f = this.atlasIndex, g = this.atlasIndex + this._totalParticles) : (e = this._quads, f = 0, g = this._totalParticles); g > f; f++) {
                e[f] || (e[f] = cc.V3F_C4B_T2F_QuadZero());
                var h = e[f];
                h.bl.texCoords.u = a, h.bl.texCoords.v = b, h.br.texCoords.u = d, h.br.texCoords.v = b, h.tl.texCoords.u = a, h.tl.texCoords.v = c, h.tr.texCoords.u = d, h.tr.texCoords.v = c
            }
        }
    },
    getBatchNode: function() {
        return this._batchNode
    },
    setBatchNode: function(a) {
        if (this._batchNode != a) {
            var b = this._batchNode;
            if (this._batchNode = a)
                for (var c = this._particles, d = 0; d < this._totalParticles; d++) c[d].atlasIndex = d;
            a ? b || (this._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, this.atlasIndex), cc._renderContext.deleteBuffer(this._buffersVBO[1])) : (this._allocMemory(), this.initIndices(), this.setTexture(b.getTexture()), this._setupVBO())
        }
    },
    getAtlasIndex: function() {
        return this.atlasIndex
    },
    setAtlasIndex: function(a) {
        this.atlasIndex = a
    },
    getDrawMode: function() {
        return this.drawMode
    },
    setDrawMode: function(a) {
        this.drawMode = a
    },
    getShapeType: function() {
        return this.shapeType
    },
    setShapeType: function(a) {
        this.shapeType = a
    },
    isActive: function() {
        return this._isActive
    },
    getParticleCount: function() {
        return this.particleCount
    },
    setParticleCount: function(a) {
        this.particleCount = a
    },
    getDuration: function() {
        return this.duration
    },
    setDuration: function(a) {
        this.duration = a
    },
    getSourcePosition: function() {
        return {
            x: this._sourcePosition.x,
            y: this._sourcePosition.y
        }
    },
    setSourcePosition: function(a) {
        this._sourcePosition = a
    },
    getPosVar: function() {
        return {
            x: this._posVar.x,
            y: this._posVar.y
        }
    },
    setPosVar: function(a) {
        this._posVar = a
    },
    getLife: function() {
        return this.life
    },
    setLife: function(a) {
        this.life = a
    },
    getLifeVar: function() {
        return this.lifeVar
    },
    setLifeVar: function(a) {
        this.lifeVar = a
    },
    getAngle: function() {
        return this.angle
    },
    setAngle: function(a) {
        this.angle = a
    },
    getAngleVar: function() {
        return this.angleVar
    },
    setAngleVar: function(a) {
        this.angleVar = a
    },
    getGravity: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getGravity() : Particle Mode should be Gravity");
        var a = this.modeA.gravity;
        return cc.p(a.x, a.y)
    },
    setGravity: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setGravity() : Particle Mode should be Gravity"), this.modeA.gravity = a
    },
    getSpeed: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeed() : Particle Mode should be Gravity"), this.modeA.speed
    },
    setSpeed: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeed() : Particle Mode should be Gravity"), this.modeA.speed = a
    },
    getSpeedVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeedVar() : Particle Mode should be Gravity"), this.modeA.speedVar
    },
    setSpeedVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeedVar() : Particle Mode should be Gravity"), this.modeA.speedVar = a
    },
    getTangentialAccel: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccel() : Particle Mode should be Gravity"), this.modeA.tangentialAccel
    },
    setTangentialAccel: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccel() : Particle Mode should be Gravity"), this.modeA.tangentialAccel = a
    },
    getTangentialAccelVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccelVar() : Particle Mode should be Gravity"), this.modeA.tangentialAccelVar
    },
    setTangentialAccelVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccelVar() : Particle Mode should be Gravity"), this.modeA.tangentialAccelVar = a
    },
    getRadialAccel: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccel() : Particle Mode should be Gravity"), this.modeA.radialAccel
    },
    setRadialAccel: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccel() : Particle Mode should be Gravity"), this.modeA.radialAccel = a
    },
    getRadialAccelVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccelVar() : Particle Mode should be Gravity"), this.modeA.radialAccelVar
    },
    setRadialAccelVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccelVar() : Particle Mode should be Gravity"), this.modeA.radialAccelVar = a
    },
    getRotationIsDir: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRotationIsDir() : Particle Mode should be Gravity"), this.modeA.rotationIsDir
    },
    setRotationIsDir: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRotationIsDir() : Particle Mode should be Gravity"), this.modeA.rotationIsDir = a
    },
    getStartRadius: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadius() : Particle Mode should be Radius"), this.modeB.startRadius
    },
    setStartRadius: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadius() : Particle Mode should be Radius"), this.modeB.startRadius = a
    },
    getStartRadiusVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadiusVar() : Particle Mode should be Radius"), this.modeB.startRadiusVar
    },
    setStartRadiusVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadiusVar() : Particle Mode should be Radius"), this.modeB.startRadiusVar = a
    },
    getEndRadius: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadius() : Particle Mode should be Radius"), this.modeB.endRadius
    },
    setEndRadius: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadius() : Particle Mode should be Radius"), this.modeB.endRadius = a
    },
    getEndRadiusVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadiusVar() : Particle Mode should be Radius"), this.modeB.endRadiusVar
    },
    setEndRadiusVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadiusVar() : Particle Mode should be Radius"), this.modeB.endRadiusVar = a
    },
    getRotatePerSecond: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecond() : Particle Mode should be Radius"), this.modeB.rotatePerSecond
    },
    setRotatePerSecond: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecond() : Particle Mode should be Radius"), this.modeB.rotatePerSecond = a
    },
    getRotatePerSecondVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecondVar() : Particle Mode should be Radius"), this.modeB.rotatePerSecondVar
    },
    setRotatePerSecondVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecondVar() : Particle Mode should be Radius"), this.modeB.rotatePerSecondVar = a
    },
    setScale: function(a, b) {
        this._transformSystemDirty = !0, cc.Node.prototype.setScale.call(this, a, b)
    },
    setRotation: function(a) {
        this._transformSystemDirty = !0, cc.Node.prototype.setRotation.call(this, a)
    },
    setScaleX: function(a) {
        this._transformSystemDirty = !0, cc.Node.prototype.setScaleX.call(this, a)
    },
    setScaleY: function(a) {
        this._transformSystemDirty = !0, cc.Node.prototype.setScaleY.call(this, a)
    },
    getStartSize: function() {
        return this.startSize
    },
    setStartSize: function(a) {
        this.startSize = a
    },
    getStartSizeVar: function() {
        return this.startSizeVar
    },
    setStartSizeVar: function(a) {
        this.startSizeVar = a
    },
    getEndSize: function() {
        return this.endSize
    },
    setEndSize: function(a) {
        this.endSize = a
    },
    getEndSizeVar: function() {
        return this.endSizeVar
    },
    setEndSizeVar: function(a) {
        this.endSizeVar = a
    },
    getStartColor: function() {
        return cc.color(this._startColor.r, this._startColor.g, this._startColor.b, this._startColor.a)
    },
    setStartColor: function(a) {
        this._startColor = cc.color(a)
    },
    getStartColorVar: function() {
        return cc.color(this._startColorVar.r, this._startColorVar.g, this._startColorVar.b, this._startColorVar.a)
    },
    setStartColorVar: function(a) {
        this._startColorVar = cc.color(a)
    },
    getEndColor: function() {
        return cc.color(this._endColor.r, this._endColor.g, this._endColor.b, this._endColor.a)
    },
    setEndColor: function(a) {
        this._endColor = cc.color(a)
    },
    getEndColorVar: function() {
        return cc.color(this._endColorVar.r, this._endColorVar.g, this._endColorVar.b, this._endColorVar.a)
    },
    setEndColorVar: function(a) {
        this._endColorVar = cc.color(a)
    },
    getStartSpin: function() {
        return this.startSpin
    },
    setStartSpin: function(a) {
        this.startSpin = a
    },
    getStartSpinVar: function() {
        return this.startSpinVar
    },
    setStartSpinVar: function(a) {
        this.startSpinVar = a
    },
    getEndSpin: function() {
        return this.endSpin
    },
    setEndSpin: function(a) {
        this.endSpin = a
    },
    getEndSpinVar: function() {
        return this.endSpinVar
    },
    setEndSpinVar: function(a) {
        this.endSpinVar = a
    },
    getEmissionRate: function() {
        return this.emissionRate
    },
    setEmissionRate: function(a) {
        this.emissionRate = a
    },
    getTotalParticles: function() {
        return this._totalParticles
    },
    setTotalParticles: function(a) {
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) this._totalParticles = 200 > a ? a : 200;
        else {
            if (a > this._allocatedParticles) {
                var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                this._indices = new Uint16Array(6 * a);
                var c = new ArrayBuffer(a * b),
                    d = this._particles;
                d.length = 0;
                for (var e = this._quads, f = e.length = 0; a > f; f++) d[f] = new cc.Particle, e[f] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, c, f * b);
                if (this._totalParticles = this._allocatedParticles = a, this._batchNode)
                    for (b = 0; a > b; b++) d[b].atlasIndex = b;
                this._quadsArrayBuffer = c, this.initIndices(), this._setupVBO(), this._texture && this.initTexCoordsWithRect(cc.rect(0, 0, this._texture.width, this._texture.height))
            } else this._totalParticles = a;
            this.resetSystem()
        }
    },
    getTexture: function() {
        return this._texture
    },
    setTexture: function(a) {
        a.isLoaded() ? this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height)) : (this._textureLoaded = !1, a.addLoadedEventListener(function(a) {
            this._textureLoaded = !0, this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height))
        }, this))
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        void 0 === b ? this._blendFunc != a && (this._blendFunc = a, this._updateBlendFunc()) : (this._blendFunc.src != a || this._blendFunc.dst != b) && (this._blendFunc = {
            src: a,
            dst: b
        }, this._updateBlendFunc())
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function(a) {
        this._opacityModifyRGB = a
    },
    isBlendAdditive: function() {
        return this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst == cc.ONE || this._blendFunc.src == cc.ONE && this._blendFunc.dst == cc.ONE
    },
    setBlendAdditive: function(a) {
        var b = this._blendFunc;
        a ? (b.src = cc.SRC_ALPHA, b.dst = cc.ONE) : cc._renderType === cc._RENDER_TYPE_WEBGL && this._texture && !this._texture.hasPremultipliedAlpha() ? (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA) : (b.src = cc.BLEND_SRC, b.dst = cc.BLEND_DST)
    },
    getPositionType: function() {
        return this.positionType
    },
    setPositionType: function(a) {
        this.positionType = a
    },
    isAutoRemoveOnFinish: function() {
        return this.autoRemoveOnFinish
    },
    setAutoRemoveOnFinish: function(a) {
        this.autoRemoveOnFinish = a
    },
    getEmitterMode: function() {
        return this.emitterMode
    },
    setEmitterMode: function(a) {
        this.emitterMode = a
    },
    init: function() {
        return this.initWithTotalParticles(150)
    },
    initWithFile: function(a) {
        return this._plistFile = a, a = cc.loader.getRes(a), a ? this.initWithDictionary(a, "") : (cc.log("cc.ParticleSystem.initWithFile(): Particles: file not found"), !1)
    },
    getBoundingBoxToWorld: function() {
        return cc.rect(0, 0, cc._canvas.width, cc._canvas.height)
    },
    initWithDictionary: function(a) {
        var b = !1,
            c = null,
            c = this._valueForKey,
            d = parseInt(c("maxParticles", a));
        if (this.initWithTotalParticles(d)) {
            if (this.angle = parseFloat(c("angle", a)), this.angleVar = parseFloat(c("angleVariance", a)), this.duration = parseFloat(c("duration", a)), this._blendFunc.src = parseInt(c("blendFuncSource", a)), this._blendFunc.dst = parseInt(c("blendFuncDestination", a)), b = this._startColor, b.r = 255 * parseFloat(c("startColorRed", a)), b.g = 255 * parseFloat(c("startColorGreen", a)), b.b = 255 * parseFloat(c("startColorBlue", a)), b.a = 255 * parseFloat(c("startColorAlpha", a)), b = this._startColorVar, b.r = 255 * parseFloat(c("startColorVarianceRed", a)), b.g = 255 * parseFloat(c("startColorVarianceGreen", a)), b.b = 255 * parseFloat(c("startColorVarianceBlue", a)), b.a = 255 * parseFloat(c("startColorVarianceAlpha", a)), b = this._endColor, b.r = 255 * parseFloat(c("finishColorRed", a)), b.g = 255 * parseFloat(c("finishColorGreen", a)), b.b = 255 * parseFloat(c("finishColorBlue", a)), b.a = 255 * parseFloat(c("finishColorAlpha", a)), b = this._endColorVar, b.r = 255 * parseFloat(c("finishColorVarianceRed", a)), b.g = 255 * parseFloat(c("finishColorVarianceGreen", a)), b.b = 255 * parseFloat(c("finishColorVarianceBlue", a)), b.a = 255 * parseFloat(c("finishColorVarianceAlpha", a)), this.startSize = parseFloat(c("startParticleSize", a)), this.startSizeVar = parseFloat(c("startParticleSizeVariance", a)), this.endSize = parseFloat(c("finishParticleSize", a)), this.endSizeVar = parseFloat(c("finishParticleSizeVariance", a)), this.setPosition(parseFloat(c("sourcePositionx", a)), parseFloat(c("sourcePositiony", a))), this._posVar.x = parseFloat(c("sourcePositionVariancex", a)), this._posVar.y = parseFloat(c("sourcePositionVariancey", a)), this.startSpin = parseFloat(c("rotationStart", a)), this.startSpinVar = parseFloat(c("rotationStartVariance", a)), this.endSpin = parseFloat(c("rotationEnd", a)), this.endSpinVar = parseFloat(c("rotationEndVariance", a)), this.emitterMode = parseInt(c("emitterType", a)), this.emitterMode == cc.ParticleSystem.MODE_GRAVITY) b = this.modeA, b.gravity.x = parseFloat(c("gravityx", a)), b.gravity.y = parseFloat(c("gravityy", a)), b.speed = parseFloat(c("speed", a)), b.speedVar = parseFloat(c("speedVariance", a)), d = c("radialAcceleration", a), b.radialAccel = d ? parseFloat(d) : 0, d = c("radialAccelVariance", a), b.radialAccelVar = d ? parseFloat(d) : 0, d = c("tangentialAcceleration", a), b.tangentialAccel = d ? parseFloat(d) : 0, d = c("tangentialAccelVariance", a), b.tangentialAccelVar = d ? parseFloat(d) : 0, d = c("rotationIsDir", a).toLowerCase(), b.rotationIsDir = null != d && ("true" === d || "1" === d);
            else {
                if (this.emitterMode != cc.ParticleSystem.MODE_RADIUS) return cc.log("cc.ParticleSystem.initWithDictionary(): Invalid emitterType in config file"), !1;
                b = this.modeB, b.startRadius = parseFloat(c("maxRadius", a)), b.startRadiusVar = parseFloat(c("maxRadiusVariance", a)), b.endRadius = parseFloat(c("minRadius", a)), b.endRadiusVar = 0, b.rotatePerSecond = parseFloat(c("rotatePerSecond", a)), b.rotatePerSecondVar = parseFloat(c("rotatePerSecondVariance", a))
            } if (this.life = parseFloat(c("particleLifespan", a)), this.lifeVar = parseFloat(c("particleLifespanVariance", a)), this.emissionRate = this._totalParticles / this.life, !this._batchNode)
                if (this._opacityModifyRGB = !1, b = c("textureFileName", a), b = cc.path.changeBasename(this._plistFile, b), d = cc.textureCache.getTextureForKey(b)) this.setTexture(d);
                else if (c = c("textureImageData", a), c && 0 !== c.length) {
                if (c = cc.unzipBase64AsArray(c, 1), !c) return cc.log("cc.ParticleSystem: error decoding or ungzipping textureImageData"), !1;
                if (d = cc.getImageFormatByData(c), d !== cc.FMT_TIFF && d !== cc.FMT_PNG) return cc.log("cc.ParticleSystem: unknown image format with Data"), !1;
                var e = cc.newElement("canvas");
                d === cc.FMT_PNG ? new cc.PNGReader(c).render(e) : cc.tiffReader.parseTIFF(c, e), cc.textureCache.cacheImage(b, e), (c = cc.textureCache.getTextureForKey(b)) || cc.log("cc.ParticleSystem.initWithDictionary() : error loading the texture"), this.setTexture(c)
            } else {
                if (d = cc.textureCache.addImage(b), !d) return !1;
                this.setTexture(d)
            }
            b = !0
        }
        return b
    },
    initWithTotalParticles: function(a) {
        this._totalParticles = a;
        var b, c = this._particles;
        for (b = c.length = 0; a > b; b++) c[b] = new cc.Particle;
        if (!c) return cc.log("Particle system: not enough memory"), !1;
        if (this._allocatedParticles = a, this._batchNode)
            for (b = 0; b < this._totalParticles; b++) c[b].atlasIndex = b;
        if (this._isActive = !0, this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, this.positionType = cc.ParticleSystem.TYPE_FREE, this.emitterMode = cc.ParticleSystem.MODE_GRAVITY, this._transformSystemDirty = this.autoRemoveOnFinish = !1, this.scheduleUpdateWithPriority(1), cc._renderType === cc._RENDER_TYPE_WEBGL) {
            if (!this._allocMemory()) return !1;
            this.initIndices(), this._setupVBO(), this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
        }
        return !0
    },
    destroyParticleSystem: function() {
        this.unscheduleUpdate()
    },
    addParticle: function() {
        if (this.isFull()) return !1;
        var a, b = this._particles;
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? this.particleCount < b.length ? a = b[this.particleCount] : (a = new cc.Particle, b.push(a)) : a = b[this.particleCount], this.initParticle(a), ++this.particleCount, !0
    },
    initParticle: function(a) {
        var b = cc.randomMinus1To1;
        a.timeToLive = this.life + this.lifeVar * b(), a.timeToLive = Math.max(0, a.timeToLive), a.pos.x = this._sourcePosition.x + this._posVar.x * b(), a.pos.y = this._sourcePosition.y + this._posVar.y * b();
        var c, d;
        c = this._startColor;
        var e = this._startColorVar,
            f = this._endColor;
        if (d = this._endColorVar, cc._renderType === cc._RENDER_TYPE_CANVAS ? (c = cc.color(cc.clampf(c.r + e.r * b(), 0, 255), cc.clampf(c.g + e.g * b(), 0, 255), cc.clampf(c.b + e.b * b(), 0, 255), cc.clampf(c.a + e.a * b(), 0, 255)), d = cc.color(cc.clampf(f.r + d.r * b(), 0, 255), cc.clampf(f.g + d.g * b(), 0, 255), cc.clampf(f.b + d.b * b(), 0, 255), cc.clampf(f.a + d.a * b(), 0, 255))) : (c = {
            r: cc.clampf(c.r + e.r * b(), 0, 255),
            g: cc.clampf(c.g + e.g * b(), 0, 255),
            b: cc.clampf(c.b + e.b * b(), 0, 255),
            a: cc.clampf(c.a + e.a * b(), 0, 255)
        }, d = {
            r: cc.clampf(f.r + d.r * b(), 0, 255),
            g: cc.clampf(f.g + d.g * b(), 0, 255),
            b: cc.clampf(f.b + d.b * b(), 0, 255),
            a: cc.clampf(f.a + d.a * b(), 0, 255)
        }), a.color = c, e = a.deltaColor, f = a.timeToLive, e.r = (d.r - c.r) / f, e.g = (d.g - c.g) / f, e.b = (d.b - c.b) / f, e.a = (d.a - c.a) / f, c = this.startSize + this.startSizeVar * b(), c = Math.max(0, c), a.size = c, this.endSize === cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE ? a.deltaSize = 0 : (d = this.endSize + this.endSizeVar * b(), d = Math.max(0, d), a.deltaSize = (d - c) / f), c = this.startSpin + this.startSpinVar * b(), d = this.endSpin + this.endSpinVar * b(), a.rotation = c, a.deltaRotation = (d - c) / f, this.positionType == cc.ParticleSystem.TYPE_FREE ? a.startPos = this.convertToWorldSpace(this._pointZeroForParticle) : this.positionType == cc.ParticleSystem.TYPE_RELATIVE && (a.startPos.x = this._position.x, a.startPos.y = this._position.y), c = cc.degreesToRadians(this.angle + this.angleVar * b()), this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) f = this.modeA, d = a.modeA, e = f.speed + f.speedVar * b(), d.dir.x = Math.cos(c), d.dir.y = Math.sin(c), cc.pMultIn(d.dir, e), d.radialAccel = f.radialAccel + f.radialAccelVar * b(), d.tangentialAccel = f.tangentialAccel + f.tangentialAccelVar * b(), f.rotationIsDir && (a.rotation = -cc.radiansToDegrees(cc.pToAngle(d.dir)));
        else {
            d = this.modeB, a = a.modeB;
            var e = d.startRadius + d.startRadiusVar * b(),
                g = d.endRadius + d.endRadiusVar * b();
            a.radius = e, a.deltaRadius = d.endRadius === cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (g - e) / f, a.angle = c, a.degreesPerSecond = cc.degreesToRadians(d.rotatePerSecond + d.rotatePerSecondVar * b())
        }
    },
    stopSystem: function() {
        this._isActive = !1, this._elapsed = this.duration, this._emitCounter = 0
    },
    resetSystem: function() {
        this._isActive = !0, this._elapsed = 0;
        var a = this._particles;
        for (this._particleIdx = 0; this._particleIdx < this.particleCount; ++this._particleIdx) a[this._particleIdx].timeToLive = 0
    },
    isFull: function() {
        return this.particleCount >= this._totalParticles
    },
    updateQuadWithParticle: function(a, b) {
        var c = null;
        this._batchNode ? (c = this._batchNode.textureAtlas.quads[this.atlasIndex + a.atlasIndex], this._batchNode.textureAtlas.dirty = !0) : c = this._quads[this._particleIdx];
        var d, e, f, g;
        this._opacityModifyRGB ? (d = 0 | a.color.r * a.color.a / 255, e = 0 | a.color.g * a.color.a / 255, f = 0 | a.color.b * a.color.a / 255) : (d = 0 | a.color.r, e = 0 | a.color.g, f = 0 | a.color.b), g = 0 | a.color.a;
        var h = c.bl.colors;
        if (h.r = d, h.g = e, h.b = f, h.a = g, h = c.br.colors, h.r = d, h.g = e, h.b = f, h.a = g, h = c.tl.colors, h.r = d, h.g = e, h.b = f, h.a = g, h = c.tr.colors, h.r = d, h.g = e, h.b = f, h.a = g, d = a.size / 2, a.rotation) {
            e = -d, f = -d, g = b.x;
            var h = b.y,
                i = -cc.degreesToRadians(a.rotation),
                j = Math.cos(i),
                i = Math.sin(i);
            c.bl.vertices.x = e * j - f * i + g, c.bl.vertices.y = e * i + f * j + h, c.br.vertices.x = d * j - f * i + g, c.br.vertices.y = d * i + f * j + h, c.tl.vertices.x = e * j - d * i + g, c.tl.vertices.y = e * i + d * j + h, c.tr.vertices.x = d * j - d * i + g, c.tr.vertices.y = d * i + d * j + h
        } else c.bl.vertices.x = b.x - d, c.bl.vertices.y = b.y - d, c.br.vertices.x = b.x + d, c.br.vertices.y = b.y - d, c.tl.vertices.x = b.x - d, c.tl.vertices.y = b.y + d, c.tr.vertices.x = b.x + d, c.tr.vertices.y = b.y + d
    },
    postStep: function() {
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            var a = cc._renderContext;
            a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]), a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW)
        }
    },
    update: function(a) {
        if (this._isActive && this.emissionRate) {
            var b = 1 / this.emissionRate;
            for (this.particleCount < this._totalParticles && (this._emitCounter += a); this.particleCount < this._totalParticles && this._emitCounter > b;) this.addParticle(), this._emitCounter -= b;
            this._elapsed += a, -1 != this.duration && this.duration < this._elapsed && this.stopSystem()
        }
        if (this._particleIdx = 0, b = cc.Particle.TemporaryPoints[0], this.positionType == cc.ParticleSystem.TYPE_FREE ? cc.pIn(b, this.convertToWorldSpace(this._pointZeroForParticle)) : this.positionType == cc.ParticleSystem.TYPE_RELATIVE && (b.x = this._position.x, b.y = this._position.y), this._visible) {
            for (var c = cc.Particle.TemporaryPoints[1], d = cc.Particle.TemporaryPoints[2], e = cc.Particle.TemporaryPoints[3], f = this._particles; this._particleIdx < this.particleCount;) {
                cc.pZeroIn(c), cc.pZeroIn(d), cc.pZeroIn(e);
                var g = f[this._particleIdx];
                if (g.timeToLive -= a, 0 < g.timeToLive) {
                    if (this.emitterMode == cc.ParticleSystem.MODE_GRAVITY) {
                        var h = e,
                            i = c,
                            j = d;
                        g.pos.x || g.pos.y ? (cc.pIn(i, g.pos), cc.pNormalizeIn(i)) : cc.pZeroIn(i), cc.pIn(j, i), cc.pMultIn(i, g.modeA.radialAccel);
                        var k = j.x;
                        j.x = -j.y, j.y = k, cc.pMultIn(j, g.modeA.tangentialAccel), cc.pIn(h, i), cc.pAddIn(h, j), cc.pAddIn(h, this.modeA.gravity), cc.pMultIn(h, a), cc.pAddIn(g.modeA.dir, h), cc.pIn(h, g.modeA.dir), cc.pMultIn(h, a), cc.pAddIn(g.pos, h)
                    } else h = g.modeB, h.angle += h.degreesPerSecond * a, h.radius += h.deltaRadius * a, g.pos.x = -Math.cos(h.angle) * h.radius, g.pos.y = -Math.sin(h.angle) * h.radius;
                    this._dontTint && cc._renderType !== cc._RENDER_TYPE_WEBGL || (g.color.r += g.deltaColor.r * a, g.color.g += g.deltaColor.g * a, g.color.b += g.deltaColor.b * a, g.color.a += g.deltaColor.a * a, g.isChangeColor = !0), g.size += g.deltaSize * a, g.size = Math.max(0, g.size), g.rotation += g.deltaRotation * a, h = c, this.positionType == cc.ParticleSystem.TYPE_FREE || this.positionType == cc.ParticleSystem.TYPE_RELATIVE ? (i = d, cc.pIn(i, b), cc.pSubIn(i, g.startPos), cc.pIn(h, g.pos), cc.pSubIn(h, i)) : cc.pIn(h, g.pos), this._batchNode && (h.x += this._position.x, h.y += this._position.y), cc._renderType == cc._RENDER_TYPE_WEBGL ? this.updateQuadWithParticle(g, h) : cc.pIn(g.drawPos, h), ++this._particleIdx
                } else if (g = g.atlasIndex, this._particleIdx !== this.particleCount - 1 && (h = f[this._particleIdx], f[this._particleIdx] = f[this.particleCount - 1], f[this.particleCount - 1] = h), this._batchNode && (this._batchNode.disableParticle(this.atlasIndex + g), f[this.particleCount - 1].atlasIndex = g), --this.particleCount, 0 == this.particleCount && this.autoRemoveOnFinish) return this.unscheduleUpdate(), void this._parent.removeChild(this, !0)
            }
            this._transformSystemDirty = !1
        }
        this._batchNode || this.postStep()
    },
    updateWithNoTime: function() {
        this.update(0)
    },
    _valueForKey: function(a, b) {
        if (b) {
            var c = b[a];
            return null != c ? c : ""
        }
        return ""
    },
    _updateBlendFunc: function() {
        if (this._batchNode) cc.log("Can't change blending functions when the particle is being batched");
        else {
            var a = this._texture;
            if (a && a instanceof cc.Texture2D) {
                this._opacityModifyRGB = !1;
                var b = this._blendFunc;
                b.src == cc.BLEND_SRC && b.dst == cc.BLEND_DST && (a.hasPremultipliedAlpha() ? this._opacityModifyRGB = !0 : (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA))
            }
        }
    },
    clone: function() {
        var a = new cc.ParticleSystem;
        if (a.initWithTotalParticles(this.getTotalParticles())) {
            a.setAngle(this.getAngle()), a.setAngleVar(this.getAngleVar()), a.setDuration(this.getDuration());
            var b = this.getBlendFunc();
            if (a.setBlendFunc(b.src, b.dst), a.setStartColor(this.getStartColor()), a.setStartColorVar(this.getStartColorVar()), a.setEndColor(this.getEndColor()), a.setEndColorVar(this.getEndColorVar()), a.setStartSize(this.getStartSize()), a.setStartSizeVar(this.getStartSizeVar()), a.setEndSize(this.getEndSize()), a.setEndSizeVar(this.getEndSizeVar()), a.setPosition(cc.p(this.x, this.y)), a.setPosVar(cc.p(this.getPosVar().x, this.getPosVar().y)), a.setStartSpin(this.getStartSpin() || 0), a.setStartSpinVar(this.getStartSpinVar() || 0), a.setEndSpin(this.getEndSpin() || 0), a.setEndSpinVar(this.getEndSpinVar() || 0), a.setEmitterMode(this.getEmitterMode()), this.getEmitterMode() == cc.ParticleSystem.MODE_GRAVITY ? (b = this.getGravity(), a.setGravity(cc.p(b.x, b.y)), a.setSpeed(this.getSpeed()), a.setSpeedVar(this.getSpeedVar()), a.setRadialAccel(this.getRadialAccel()), a.setRadialAccelVar(this.getRadialAccelVar()), a.setTangentialAccel(this.getTangentialAccel()), a.setTangentialAccelVar(this.getTangentialAccelVar())) : this.getEmitterMode() == cc.ParticleSystem.MODE_RADIUS && (a.setStartRadius(this.getStartRadius()), a.setStartRadiusVar(this.getStartRadiusVar()), a.setEndRadius(this.getEndRadius()), a.setEndRadiusVar(this.getEndRadiusVar()), a.setRotatePerSecond(this.getRotatePerSecond()), a.setRotatePerSecondVar(this.getRotatePerSecondVar())), a.setLife(this.getLife()), a.setLifeVar(this.getLifeVar()), a.setEmissionRate(this.getEmissionRate()), !this.getBatchNode() && (a.setOpacityModifyRGB(this.isOpacityModifyRGB()), b = this.getTexture())) {
                var c = b.getContentSize();
                a.setTextureWithRect(b, cc.rect(0, 0, c.width, c.height))
            }
        }
        return a
    },
    setDisplayFrame: function(a) {
        var b = a.getOffsetInPixels();
        (0 != b.x || 0 != b.y) && cc.log("cc.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets"), cc._renderType === cc._RENDER_TYPE_WEBGL && (!this._texture || a.getTexture()._webTextureObj != this._texture._webTextureObj) && this.setTexture(a.getTexture())
    },
    setTextureWithRect: function(a, b) {
        var c = this._texture;
        cc._renderType === cc._RENDER_TYPE_WEBGL ? c && a._webTextureObj == c._webTextureObj || c == a || (this._texture = a, this._updateBlendFunc()) : c && a == c || c == a || (this._texture = a, this._updateBlendFunc()), this._pointRect = b, this.initTexCoordsWithRect(b)
    },
    draw: function(a) {
        this._textureLoaded && !this._batchNode && (cc._renderType === cc._RENDER_TYPE_CANVAS ? this._drawForCanvas(a) : this._drawForWebGL(a), cc.g_NumberOfDraws++)
    },
    _drawForCanvas: function(a) {
        a = a || cc._renderContext, a.save(), a.globalCompositeOperation = this.isBlendAdditive() ? "lighter" : "source-over";
        for (var b = this._texture.getHtmlElementObj(), c = 0; c < this.particleCount; c++) {
            var d = this._particles[c],
                e = 0 | .5 * d.size;
            if (this.drawMode == cc.ParticleSystem.TEXTURE_MODE) {
                if (b.width && b.height) {
                    a.save(), a.globalAlpha = d.color.a / 255, a.translate(0 | d.drawPos.x, -(0 | d.drawPos.y));
                    var e = 4 * Math.floor(d.size / 4),
                        f = this._pointRect.width,
                        g = this._pointRect.height;
                    a.scale(Math.max(1 / f * e, 1e-6), Math.max(1 / g * e, 1e-6)), d.rotation && a.rotate(cc.degreesToRadians(d.rotation)), a.translate(-(0 | f / 2), -(0 | g / 2)), (d = d.isChangeColor ? this._changeTextureColor(b, d.color, this._pointRect) : b) && a.drawImage(d, 0, 0), a.restore()
                }
            } else a.save(), a.globalAlpha = d.color.a / 255, a.translate(0 | d.drawPos.x, -(0 | d.drawPos.y)), this.shapeType == cc.ParticleSystem.STAR_SHAPE ? (d.rotation && a.rotate(cc.degreesToRadians(d.rotation)), cc._drawingUtil.drawStar(a, e, d.color)) : cc._drawingUtil.drawColorBall(a, e, d.color), a.restore()
        }
        a.restore()
    },
    _changeTextureColor: function(a, b, c) {
        return a.tintCache || (a.tintCache = document.createElement("canvas"), a.tintCache.width = a.width, a.tintCache.height = a.height), cc.generateTintImageWithMultiply(a, b, c, a.tintCache)
    },
    _drawForWebGL: function(a) {
        this._texture && (a = a || cc._renderContext, this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBindTexture2D(this._texture), cc.glBlendFuncForParticle(this._blendFunc.src, this._blendFunc.dst), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 24, 16), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), a.drawElements(a.TRIANGLES, 6 * this._particleIdx, a.UNSIGNED_SHORT, 0))
    },
    listenBackToForeground: function() {
        cc.TEXTURE_ATLAS_USE_VAO ? this._setupVBOandVAO() : this._setupVBO()
    },
    _setupVBOandVAO: function() {},
    _setupVBO: function() {
        if (cc._renderType != cc._RENDER_TYPE_CANVAS) {
            var a = cc._renderContext;
            this._buffersVBO[0] = a.createBuffer(), a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]), a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW), this._buffersVBO[1] = a.createBuffer(), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
        }
    },
    _allocMemory: function() {
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) return !0;
        if (this._batchNode) return cc.log("cc.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode"), !1;
        var a = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            b = this._totalParticles,
            c = this._quads;
        c.length = 0, this._indices = new Uint16Array(6 * b);
        for (var d = new ArrayBuffer(a * b), e = 0; b > e; e++) c[e] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, d, e * a);
        return c && this._indices ? (this._quadsArrayBuffer = d, !0) : (cc.log("cocos2d: Particle system: not enough memory"), !1)
    }
}), _p = cc.ParticleSystem.prototype, cc._renderType === cc._RENDER_TYPE_CANVAS && !cc.sys._supportCanvasNewBlendModes && (_p._changeTextureColor = function(a, b, c) {
    var d = cc.textureCache.getTextureColors(a);
    return d ? (d.tintCache || (d.tintCache = document.createElement("canvas"), d.tintCache.width = a.width, d.tintCache.height = a.height), cc.generateTintImage(a, d, b, c, d.tintCache), d.tintCache) : null
}), cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB), cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode), cc.defineGetterSetter(_p, "active", _p.isActive), cc.defineGetterSetter(_p, "sourcePos", _p.getSourcePosition, _p.setSourcePosition), cc.defineGetterSetter(_p, "posVar", _p.getPosVar, _p.setPosVar), cc.defineGetterSetter(_p, "gravity", _p.getGravity, _p.setGravity), cc.defineGetterSetter(_p, "speed", _p.getSpeed, _p.setSpeed), cc.defineGetterSetter(_p, "speedVar", _p.getSpeedVar, _p.setSpeedVar), cc.defineGetterSetter(_p, "tangentialAccel", _p.getTangentialAccel, _p.setTangentialAccel), cc.defineGetterSetter(_p, "tangentialAccelVar", _p.getTangentialAccelVar, _p.setTangentialAccelVar), cc.defineGetterSetter(_p, "radialAccel", _p.getRadialAccel, _p.setRadialAccel), cc.defineGetterSetter(_p, "radialAccelVar", _p.getRadialAccelVar, _p.setRadialAccelVar), cc.defineGetterSetter(_p, "rotationIsDir", _p.getRotationIsDir, _p.setRotationIsDir), cc.defineGetterSetter(_p, "startRadius", _p.getStartRadius, _p.setStartRadius), cc.defineGetterSetter(_p, "startRadiusVar", _p.getStartRadiusVar, _p.setStartRadiusVar), cc.defineGetterSetter(_p, "endRadius", _p.getEndRadius, _p.setEndRadius), cc.defineGetterSetter(_p, "endRadiusVar", _p.getEndRadiusVar, _p.setEndRadiusVar), cc.defineGetterSetter(_p, "rotatePerS", _p.getRotatePerSecond, _p.setRotatePerSecond), cc.defineGetterSetter(_p, "rotatePerSVar", _p.getRotatePerSecondVar, _p.setRotatePerSecondVar), cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor), cc.defineGetterSetter(_p, "startColorVar", _p.getStartColorVar, _p.setStartColorVar), cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor), cc.defineGetterSetter(_p, "endColorVar", _p.getEndColorVar, _p.setEndColorVar), cc.defineGetterSetter(_p, "totalParticles", _p.getTotalParticles, _p.setTotalParticles), cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture), cc.ParticleSystem.create = function(a) {
    return new cc.ParticleSystem(a)
}, cc.ParticleSystem.createWithTotalParticles = cc.ParticleSystem.create, cc.ParticleSystem.ModeA = function(a, b, c, d, e, f, g, h) {
    this.gravity = a ? a : cc.p(0, 0), this.speed = b || 0, this.speedVar = c || 0, this.tangentialAccel = d || 0, this.tangentialAccelVar = e || 0, this.radialAccel = f || 0, this.radialAccelVar = g || 0, this.rotationIsDir = h || !1
}, cc.ParticleSystem.ModeB = function(a, b, c, d, e, f) {
    this.startRadius = a || 0, this.startRadiusVar = b || 0, this.endRadius = c || 0, this.endRadiusVar = d || 0, this.rotatePerSecond = e || 0, this.rotatePerSecondVar = f || 0
}, cc.ParticleSystem.SHAPE_MODE = 0, cc.ParticleSystem.TEXTURE_MODE = 1, cc.ParticleSystem.STAR_SHAPE = 0, cc.ParticleSystem.BALL_SHAPE = 1, cc.ParticleSystem.DURATION_INFINITY = -1, cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE = -1, cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS = -1, cc.ParticleSystem.MODE_GRAVITY = 0, cc.ParticleSystem.MODE_RADIUS = 1, cc.ParticleSystem.TYPE_FREE = 0, cc.ParticleSystem.TYPE_RELATIVE = 1, cc.ParticleSystem.TYPE_GROUPED = 2, cc.ParticleFire = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 300 : 150)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(60), this.setSpeedVar(20), this.setAngle(90), this.setAngleVar(10), a = cc.director.getWinSize(), this.setPosition(a.width / 2, 60), this.setPosVar(cc.p(40, 20)), this.setLife(3), this.setLifeVar(.25), this.setStartSize(54), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
}), cc.ParticleFire.create = function() {
    return new cc.ParticleFire
}, cc.ParticleFireworks = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 1500 : 150)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -90)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(180), this.setSpeedVar(50), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setAngle(90), this.setAngleVar(20), this.setLife(3.5), this.setLifeVar(1), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 255)), this.setEndColor(cc.color(26, 26, 26, 51)), this.setEndColorVar(cc.color(26, 26, 26, 51)), this.setStartSize(8), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setBlendAdditive(!1), !0) : !1
    }
}), cc.ParticleFireworks.create = function() {
    return new cc.ParticleFireworks
}, cc.ParticleSun = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 350 : 150)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setBlendAdditive(!0), this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(20), this.setSpeedVar(5), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(1), this.setLifeVar(.5), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), !0) : !1
    }
}), cc.ParticleSun.create = function() {
    return new cc.ParticleSun
}, cc.ParticleGalaxy = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(60), this.setSpeedVar(10), this.setRadialAccel(-80), this.setRadialAccelVar(0), this.setTangentialAccel(80), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(37), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(31, 64, 194, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
}), cc.ParticleGalaxy.create = function() {
    return new cc.ParticleGalaxy
}, cc.ParticleFlower = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 250 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(80), this.setSpeedVar(10), this.setRadialAccel(-60), this.setRadialAccelVar(0), this.setTangentialAccel(15), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 128)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
}), cc.ParticleFlower.create = function() {
    return new cc.ParticleFlower
}, cc.ParticleMeteor = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 150 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(-200, 200)), this.setSpeed(15), this.setSpeedVar(5), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(2), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(51, 102, 179)), this.setStartColorVar(cc.color(0, 0, 51, 26)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
}), cc.ParticleMeteor.create = function() {
    return new cc.ParticleMeteor
}, cc.ParticleSpiral = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 500 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(150), this.setSpeedVar(0), this.setRadialAccel(-380), this.setRadialAccelVar(0), this.setTangentialAccel(45), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(0), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(12), this.setLifeVar(0), this.setStartSize(20), this.setStartSizeVar(0), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 255)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
    }
}), cc.ParticleSpiral.create = function() {
    return new cc.ParticleSpiral
}, cc.ParticleExplosion = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 300)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(.1), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(70), this.setSpeedVar(40), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(5), this.setLifeVar(2), this.setStartSize(15), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getDuration()), this.setStartColor(cc.color(179, 26, 51, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 0)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
    }
}), cc.ParticleExplosion.create = function() {
    return new cc.ParticleExplosion
}, cc.ParticleSmoke = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(25), this.setSpeedVar(10), this.setAngle(90), this.setAngleVar(5), a = cc.director.getWinSize(), this.setPosition(a.width / 2, 0), this.setPosVar(cc.p(20, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(204, 204, 204, 255)), this.setStartColorVar(cc.color(5, 5, 5, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
}), cc.ParticleSmoke.create = function() {
    return new cc.ParticleSmoke
}, cc.ParticleSnow = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 250)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -1)), this.setSpeed(5), this.setSpeedVar(1), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height + 10), this.setPosVar(cc.p(a.width / 2, 0)), this.setAngle(-90), this.setAngleVar(5), this.setLife(45), this.setLifeVar(15), this.setStartSize(10), this.setStartSizeVar(5), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(10), this.setStartColor(cc.color(255, 255, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(255, 255, 255, 0)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
}), cc.ParticleSnow.create = function() {
    return new cc.ParticleSnow
}, cc.ParticleRain = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 1e3 : 300)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(10, -10)), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1), this.setSpeed(130), this.setSpeedVar(30), this.setAngle(-90), this.setAngleVar(5), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height), this.setPosVar(cc.p(a.width / 2, 0)), this.setLife(4.5), this.setLifeVar(0), this.setStartSize(4), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(20), this.setStartColor(cc.color(179, 204, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(179, 204, 255, 128)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
}), cc.ParticleRain.create = function() {
    return new cc.ParticleRain
}, cc.PARTICLE_DEFAULT_CAPACITY = 500, cc.ParticleBatchNode = cc.Node.extend({
    textureAtlas: null,
    TextureProtocol: !0,
    _blendFunc: null,
    _className: "ParticleBatchNode",
    ctor: function(a, b) {
        cc.Node.prototype.ctor.call(this), this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        }, "string" == typeof a ? this.init(a, b) : a instanceof cc.Texture2D && this.initWithTexture(a, b)
    },
    initWithTexture: function(a, b) {
        return this.textureAtlas = new cc.TextureAtlas, this.textureAtlas.initWithTexture(a, b), this._children.length = 0, cc._renderType === cc._RENDER_TYPE_WEBGL && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)), !0
    },
    initWithFile: function(a, b) {
        var c = cc.textureCache.addImage(a);
        return this.initWithTexture(c, b)
    },
    init: function(a, b) {
        var c = cc.TextureCache.getInstance().addImage(a);
        return this.initWithTexture(c, b)
    },
    addChild: function(a, b, c) {
        if (!a) throw "cc.ParticleBatchNode.addChild() : child should be non-null";
        if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.addChild() : only supports cc.ParticleSystem as children";
        if (b = null == b ? a.zIndex : b, c = null == c ? a.tag : c, a.getTexture() != this.textureAtlas.texture) throw "cc.ParticleSystem.addChild() : the child is not using the same texture id";
        var d = a.getBlendFunc();
        if (0 === this._children.length) this.setBlendFunc(d);
        else if (d.src != this._blendFunc.src || d.dst != this._blendFunc.dst) return void cc.log("cc.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function");
        b = this._addChildHelper(a, b, c), c = 0, 0 != b ? (b = this._children[b - 1], c = b.getAtlasIndex() + b.getTotalParticles()) : c = 0, this.insertChild(a, c), a.setBatchNode(this)
    },
    insertChild: function(a, b) {
        var c = a.getTotalParticles(),
            d = this.textureAtlas,
            e = d.totalQuads;
        a.setAtlasIndex(b), e + c > d.getCapacity() && (this._increaseAtlasCapacityTo(e + c), d.fillWithEmptyQuadsFromIndex(d.getCapacity() - c, c)), a.getAtlasIndex() + c != e && d.moveQuadsFromIndex(b, b + c), d.increaseTotalQuadsWith(c), this._updateAllAtlasIndexes()
    },
    removeChild: function(a, b) {
        if (null != a) {
            if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.removeChild(): only supports cc.ParticleSystem as children";
            if (-1 == this._children.indexOf(a)) cc.log("cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it");
            else {
                cc.Node.prototype.removeChild.call(this, a, b);
                var c = this.textureAtlas;
                c.removeQuadsAtIndex(a.getAtlasIndex(), a.getTotalParticles()), c.fillWithEmptyQuadsFromIndex(c.totalQuads, a.getTotalParticles()), a.setBatchNode(null), this._updateAllAtlasIndexes()
            }
        }
    },
    reorderChild: function(a, b) {
        if (!a) throw "cc.ParticleBatchNode.reorderChild(): child should be non-null";
        if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children";
        if (-1 === this._children.indexOf(a)) cc.log("cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch");
        else if (b != a.zIndex) {
            if (1 < this._children.length) {
                var c = this._getCurrentIndex(a, b);
                if (c.oldIndex != c.newIndex) {
                    this._children.splice(c.oldIndex, 1), this._children.splice(c.newIndex, 0, a), c = a.getAtlasIndex(), this._updateAllAtlasIndexes();
                    for (var d = 0, e = this._children, f = 0; f < e.length; f++)
                        if (e[f] == a) {
                            d = a.getAtlasIndex();
                            break
                        }
                    this.textureAtlas.moveQuadsFromIndex(c, a.getTotalParticles(), d), a.updateWithNoTime()
                }
            }
            a._setLocalZOrder(b)
        }
    },
    removeChildAtIndex: function(a, b) {
        this.removeChild(this._children[i], b)
    },
    removeAllChildren: function(a) {
        for (var b = this._children, c = 0; c < b.length; c++) b[c].setBatchNode(null);
        cc.Node.prototype.removeAllChildren.call(this, a), this.textureAtlas.removeAllQuads()
    },
    disableParticle: function(a) {
        a = this.textureAtlas.quads[a], a.br.vertices.x = a.br.vertices.y = a.tr.vertices.x = a.tr.vertices.y = a.tl.vertices.x = a.tl.vertices.y = a.bl.vertices.x = a.bl.vertices.y = 0, this.textureAtlas._setDirty(!0)
    },
    draw: function() {
        cc._renderType !== cc._RENDER_TYPE_CANVAS && 0 != this.textureAtlas.totalQuads && (cc.nodeDrawSetup(this), cc.glBlendFuncForParticle(this._blendFunc.src, this._blendFunc.dst), this.textureAtlas.drawQuads())
    },
    getTexture: function() {
        return this.textureAtlas.texture
    },
    setTexture: function(a) {
        this.textureAtlas.texture = a;
        var b = this._blendFunc;
        a && !a.hasPremultipliedAlpha() && b.src == cc.BLEND_SRC && b.dst == cc.BLEND_DST && (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    setBlendFunc: function(a, b) {
        void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.src = b)
    },
    getBlendFunc: function() {
        return {
            src: this._blendFunc.src,
            dst: this._blendFunc.dst
        }
    },
    visit: function(a) {
        cc._renderType !== cc._RENDER_TYPE_CANVAS && this._visible && (cc.kmGLPushMatrix(), this.grid && this.grid.isActive() && (this.grid.beforeDraw(), this.transformAncestors()), this.transform(a), this.draw(a), this.grid && this.grid.isActive() && this.grid.afterDraw(this), cc.kmGLPopMatrix())
    },
    _updateAllAtlasIndexes: function() {
        for (var a = 0, b = this._children, c = 0; c < b.length; c++) {
            var d = b[c];
            d.setAtlasIndex(a), a += d.getTotalParticles()
        }
    },
    _increaseAtlasCapacityTo: function(a) {
        cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this.textureAtlas.getCapacity() + "] to [" + a + "]."), this.textureAtlas.resizeCapacity(a) || cc.log("cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas")
    },
    _searchNewPositionInChildrenForZ: function(a) {
        for (var b = this._children, c = b.length, d = 0; c > d; d++)
            if (b[d].zIndex > a) return d;
        return c
    },
    _getCurrentIndex: function(a, b) {
        for (var c = !1, d = !1, e = 0, f = 0, g = 0, h = this._children, i = h.length, j = 0; i > j; j++) {
            var k = h[j];
            if (k.zIndex > b && !d && (e = j, d = !0, c && d)) break;
            if (a == k && (f = j, c = !0, d || (g = -1), c && d)) break
        }
        return d || (e = i), {
            newIndex: e + g,
            oldIndex: f
        }
    },
    _addChildHelper: function(a, b, c) {
        if (!a) throw "cc.ParticleBatchNode._addChildHelper(): child should be non-null";
        if (a.parent) return cc.log("cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again"), null;
        this._children || (this._children = []);
        var d = this._searchNewPositionInChildrenForZ(b);
        return this._children.splice(d, 0, a), a.tag = c, a._setLocalZOrder(b), a.parent = this, this._running && (a.onEnter(), a.onEnterTransitionDidFinish()), d
    },
    _updateBlendFunc: function() {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    }
}), _p = cc.ParticleBatchNode.prototype, cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture), cc.ParticleBatchNode.create = function(a, b) {
    return new cc.ParticleBatchNode(a, b)
}, cc.IMEKeyboardNotificationInfo = function(a, b, c) {
    this.begin = a || cc.rect(0, 0, 0, 0), this.end = b || cc.rect(0, 0, 0, 0), this.duration = c || 0
}, cc.IMEDelegate = cc.Class.extend({
    ctor: function() {
        cc.imeDispatcher.addDelegate(this)
    },
    removeDelegate: function() {
        cc.imeDispatcher.removeDelegate(this)
    },
    attachWithIME: function() {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function() {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function() {
        return !1
    },
    didAttachWithIME: function() {},
    canDetachWithIME: function() {
        return !1
    },
    didDetachWithIME: function() {},
    insertText: function() {},
    deleteBackward: function() {},
    getContentText: function() {
        return ""
    },
    keyboardWillShow: function() {},
    keyboardDidShow: function() {},
    keyboardWillHide: function() {},
    keyboardDidHide: function() {}
}), cc.IMEDispatcher = cc.Class.extend({
    _domInputControl: null,
    impl: null,
    _currentInputString: "",
    _lastClickPosition: null,
    ctor: function() {
        this.impl = new cc.IMEDispatcher.Impl, this._lastClickPosition = cc.p(0, 0)
    },
    init: function() {
        if (!cc.sys.isMobile) {
            this._domInputControl = cc.$("#imeDispatcherInput"), this._domInputControl || (this._domInputControl = cc.$new("input"), this._domInputControl.setAttribute("type", "text"), this._domInputControl.setAttribute("id", "imeDispatcherInput"), this._domInputControl.resize(0, 0), this._domInputControl.translates(0, 0), this._domInputControl.style.opacity = "0", this._domInputControl.style.fontSize = "1px", this._domInputControl.setAttribute("tabindex", 2), this._domInputControl.style.position = "absolute", this._domInputControl.style.top = 0, this._domInputControl.style.left = 0, document.body.appendChild(this._domInputControl));
            var a = this;
            cc._addEventListener(this._domInputControl, "input", function() {
                a._processDomInputString(a._domInputControl.value)
            }, !1), cc._addEventListener(this._domInputControl, "keydown", function(b) {
                b.keyCode === cc.KEY.tab ? (b.stopPropagation(), b.preventDefault()) : b.keyCode == cc.KEY.enter && (a.dispatchInsertText("\n", 1), b.stopPropagation(), b.preventDefault())
            }, !1), /msie/i.test(navigator.userAgent) && cc._addEventListener(this._domInputControl, "keyup", function(b) {
                b.keyCode == cc.KEY.backspace && a._processDomInputString(a._domInputControl.value)
            }, !1), cc._addEventListener(window, "mousedown", function(b) {
                var c = b.pageY || 0;
                a._lastClickPosition.x = b.pageX || 0, a._lastClickPosition.y = c
            }, !1)
        }
    },
    _processDomInputString: function(a) {
        var b, c;
        for (b = this._currentInputString.length < a.length ? this._currentInputString.length : a.length, c = 0; b > c && a[c] === this._currentInputString[c]; c++);
        var d = this._currentInputString.length - c,
            e = a.length - c;
        for (b = 0; d > b; b++) this.dispatchDeleteBackward();
        for (b = 0; e > b; b++) this.dispatchInsertText(a[c + b], 1);
        this._currentInputString = a
    },
    dispatchInsertText: function(a, b) {
        this.impl && a && !(0 >= b) && this.impl._delegateWithIme && this.impl._delegateWithIme.insertText(a, b)
    },
    dispatchDeleteBackward: function() {
        this.impl && this.impl._delegateWithIme && this.impl._delegateWithIme.deleteBackward()
    },
    getContentText: function() {
        if (this.impl && this.impl._delegateWithIme) {
            var a = this.impl._delegateWithIme.getContentText();
            return a ? a : ""
        }
        return ""
    },
    dispatchKeyboardWillShow: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardWillShow(a)
            }
    },
    dispatchKeyboardDidShow: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardDidShow(a)
            }
    },
    dispatchKeyboardWillHide: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardWillHide(a)
            }
    },
    dispatchKeyboardDidHide: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardDidHide(a)
            }
    },
    addDelegate: function(a) {
        a && this.impl && (-1 < this.impl._delegateList.indexOf(a) || this.impl._delegateList.splice(0, 0, a))
    },
    attachDelegateWithIME: function(a) {
        if (!this.impl || !a || -1 == this.impl._delegateList.indexOf(a)) return !1;
        if (this.impl._delegateWithIme) {
            if (!this.impl._delegateWithIme.canDetachWithIME() || !a.canAttachWithIME()) return !1;
            var b = this.impl._delegateWithIme;
            return this.impl._delegateWithIme = null, b.didDetachWithIME(), this._focusDomInput(a), !0
        }
        return a.canAttachWithIME() ? (this._focusDomInput(a), !0) : !1
    },
    _focusDomInput: function(a) {
        cc.sys.isMobile ? (this.impl._delegateWithIme = a, a.didAttachWithIME(), this._currentInputString = a.string || "", a = prompt("please enter your word:", this._currentInputString), null != a && this._processDomInputString(a), this.dispatchInsertText("\n", 1)) : (this.impl._delegateWithIme = a, this._currentInputString = a.string || "", a.didAttachWithIME(), this._domInputControl.focus(), this._domInputControl.value = this._currentInputString, this._domInputControlTranslate())
    },
    _domInputControlTranslate: function() {
        /msie/i.test(navigator.userAgent) ? (this._domInputControl.style.left = this._lastClickPosition.x + "px", this._domInputControl.style.top = this._lastClickPosition.y + "px") : this._domInputControl.translates(this._lastClickPosition.x, this._lastClickPosition.y)
    },
    detachDelegateWithIME: function(a) {
        return this.impl && a && this.impl._delegateWithIme == a && a.canDetachWithIME() ? (this.impl._delegateWithIme = null, a.didDetachWithIME(), cc._canvas.focus(), !0) : !1
    },
    removeDelegate: function(a) {
        this.impl && a && -1 != this.impl._delegateList.indexOf(a) && (this.impl._delegateWithIme && a == this.impl._delegateWithIme && (this.impl._delegateWithIme = null), cc.arrayRemoveObject(this.impl._delegateList, a))
    },
    processKeycode: function(a) {
        32 > a ? a == cc.KEY.backspace ? this.dispatchDeleteBackward() : a == cc.KEY.enter && this.dispatchInsertText("\n", 1) : 255 > a && this.dispatchInsertText(String.fromCharCode(a), 1)
    }
}), cc.IMEDispatcher.Impl = cc.Class.extend({
    _delegateWithIme: null,
    _delegateList: null,
    ctor: function() {
        this._delegateList = []
    },
    findDelegate: function(a) {
        for (var b = 0; b < this._delegateList.length; b++)
            if (this._delegateList[b] == a) return b;
        return null
    }
}), cc.imeDispatcher = new cc.IMEDispatcher, document.body ? cc.imeDispatcher.init() : cc._addEventListener(window, "load", function() {
    cc.imeDispatcher.init()
}, !1), cc.TextFieldDelegate = cc.Class.extend({
    onTextFieldAttachWithIME: function() {
        return !1
    },
    onTextFieldDetachWithIME: function() {
        return !1
    },
    onTextFieldInsertText: function() {
        return !1
    },
    onTextFieldDeleteBackward: function() {
        return !1
    },
    onDraw: function() {
        return !1
    }
}), cc.TextFieldTTF = cc.LabelTTF.extend({
    delegate: null,
    colorSpaceHolder: null,
    _lens: null,
    _inputText: "",
    _placeHolder: "",
    _charCount: 0,
    _className: "TextFieldTTF",
    ctor: function(a, b, c, d, e) {
        this.colorSpaceHolder = cc.color(127, 127, 127), cc.imeDispatcher.addDelegate(this), cc.LabelTTF.prototype.ctor.call(this), void 0 !== e ? (this.initWithPlaceHolder("", b, c, d, e), a && this.setPlaceHolder(a)) : void 0 === d && void 0 !== c && (this.initWithString("", b, c), a && this.setPlaceHolder(a))
    },
    getDelegate: function() {
        return this.delegate
    },
    setDelegate: function(a) {
        this.delegate = a
    },
    getCharCount: function() {
        return this._charCount
    },
    getColorSpaceHolder: function() {
        return this.colorSpaceHolder
    },
    setColorSpaceHolder: function(a) {
        this.colorSpaceHolder = a
    },
    initWithPlaceHolder: function(a, b, c, d, e) {
        switch (arguments.length) {
            case 5:
                return a && this.setPlaceHolder(a), this.initWithString(this._placeHolder, d, e, b, c);
            case 3:
                return a && this.setPlaceHolder(a), this.initWithString(this._placeHolder, arguments[1], arguments[2]);
            default:
                throw "Argument must be non-nil "
        }
    },
    setString: function(a) {
        this._inputText = (a = String(a)) || "", this._inputText.length ? cc.LabelTTF.prototype.setString.call(this, this._inputText) : cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this._charCount = this._inputText.length
    },
    getString: function() {
        return this._inputText
    },
    setPlaceHolder: function(a) {
        this._placeHolder = a || "", this._inputText.length || cc.LabelTTF.prototype.setString.call(this, this._placeHolder)
    },
    getPlaceHolder: function() {
        return this._placeHolder
    },
    draw: function(a) {
        if (a = a || cc._renderContext, !this.delegate || !this.delegate.onDraw(this))
            if (this._inputText && 0 < this._inputText.length) cc.LabelTTF.prototype.draw.call(this, a);
            else {
                var b = this.color;
                this.color = this.colorSpaceHolder, cc._renderType === cc._RENDER_TYPE_CANVAS && this._updateTexture(), cc.LabelTTF.prototype.draw.call(this, a), this.color = b
            }
    },
    visit: function(a) {
        this._super(a)
    },
    attachWithIME: function() {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function() {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function() {
        return this.delegate ? !this.delegate.onTextFieldAttachWithIME(this) : !0
    },
    didAttachWithIME: function() {},
    canDetachWithIME: function() {
        return this.delegate ? !this.delegate.onTextFieldDetachWithIME(this) : !0
    },
    didDetachWithIME: function() {},
    deleteBackward: function() {
        var a = this._inputText.length;
        0 == a || this.delegate && this.delegate.onTextFieldDeleteBackward(this, this._inputText[a - 1], 1) || (1 >= a ? (this._inputText = "", this._charCount = 0, cc.LabelTTF.prototype.setString.call(this, this._placeHolder)) : this.string = this._inputText.substring(0, a - 1))
    },
    removeDelegate: function() {
        cc.imeDispatcher.removeDelegate(this)
    },
    insertText: function(a) {
        var b = a,
            c = b.indexOf("\n");
        if (c > -1 && (b = b.substring(0, c)), 0 < b.length) {
            if (this.delegate && this.delegate.onTextFieldInsertText(this, b, b.length)) return;
            b = this._inputText + b, this._charCount = b.length, this.string = b
        } - 1 != c && (!this.delegate || !this.delegate.onTextFieldInsertText(this, "\n", 1)) && this.detachWithIME()
    },
    getContentText: function() {
        return this._inputText
    },
    keyboardWillShow: function() {},
    keyboardDidShow: function() {},
    keyboardWillHide: function() {},
    keyboardDidHide: function() {}
}), _p = cc.TextFieldTTF.prototype, cc.defineGetterSetter(_p, "charCount", _p.getCharCount), cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder), cc.TextFieldTTF.create = function(a, b, c, d, e) {
    return new cc.TextFieldTTF(a, b, c, d, e)
}, cc._globalFontSize = cc.ITEM_SIZE, cc._globalFontName = "Arial", cc._globalFontNameRelease = !1, cc.MenuItem = cc.Node.extend({
    _enabled: !1,
    _target: null,
    _callback: null,
    _isSelected: !1,
    _className: "MenuItem",
    ctor: function(a, b) {
        var c = cc.Node.prototype;
        c.ctor.call(this), this._callback = this._target = null, this._enabled = this._isSelected = !1, c.setAnchorPoint.call(this, .5, .5), this._target = b || null, (this._callback = a || null) && (this._enabled = !0)
    },
    isSelected: function() {
        return this._isSelected
    },
    setOpacityModifyRGB: function() {},
    isOpacityModifyRGB: function() {
        return !1
    },
    setTarget: function(a, b) {
        this._target = b, this._callback = a
    },
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    initWithCallback: function(a, b) {
        return this.anchorY = this.anchorX = .5, this._target = b, this._callback = a, this._enabled = !0, this._isSelected = !1, !0
    },
    rect: function() {
        var a = this._position,
            b = this._contentSize,
            c = this._anchorPoint;
        return cc.rect(a.x - b.width * c.x, a.y - b.height * c.y, b.width, b.height)
    },
    selected: function() {
        this._isSelected = !0
    },
    unselected: function() {
        this._isSelected = !1
    },
    setCallback: function(a, b) {
        this._target = b, this._callback = a
    },
    activate: function() {
        if (this._enabled) {
            var a = this._target,
                b = this._callback;
            b && (a && "string" == typeof b ? a[b](this) : a && "function" == typeof b ? b.call(a, this) : b(this))
        }
    }
}), _p = cc.MenuItem.prototype, cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled), cc.MenuItem.create = function(a, b) {
    return new cc.MenuItem(a, b)
}, cc.MenuItemLabel = cc.MenuItem.extend({
    _disabledColor: null,
    _label: null,
    _orginalScale: 0,
    _colorBackup: null,
    ctor: function(a, b, c) {
        cc.MenuItem.prototype.ctor.call(this, b, c), this._label = this._disabledColor = null, this._orginalScale = 0, this._colorBackup = null, a && (this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(a), this.cascadeOpacity = this.cascadeColor = !0)
    },
    getDisabledColor: function() {
        return this._disabledColor
    },
    setDisabledColor: function(a) {
        this._disabledColor = a
    },
    getLabel: function() {
        return this._label
    },
    setLabel: function(a) {
        a && (this.addChild(a), a.anchorX = 0, a.anchorY = 0, this.width = a.width, this.height = a.height), this._label && this.removeChild(this._label, !0), this._label = a
    },
    setEnabled: function(a) {
        if (this._enabled != a) {
            var b = this._label;
            a ? b.color = this._colorBackup : (this._colorBackup = b.color, b.color = this._disabledColor)
        }
        cc.MenuItem.prototype.setEnabled.call(this, a)
    },
    setOpacity: function(a) {
        this._label.opacity = a
    },
    getOpacity: function() {
        return this._label.opacity
    },
    setColor: function(a) {
        this._label.color = a
    },
    getColor: function() {
        return this._label.color
    },
    initWithLabel: function(a, b, c) {
        return this.initWithCallback(b, c), this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(a), this.cascadeOpacity = this.cascadeColor = !0
    },
    setString: function(a) {
        this._label.string = a, this.width = this._label.width, this.height = this._label.height
    },
    getString: function() {
        return this._label.string
    },
    activate: function() {
        this._enabled && (this.stopAllActions(), this.scale = this._originalScale, cc.MenuItem.prototype.activate.call(this))
    },
    selected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.selected.call(this);
            var a = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            a ? this.stopAction(a) : this._originalScale = this.scale, a = cc.ScaleTo.create(.1, 1.2 * this._originalScale), a.setTag(cc.ZOOM_ACTION_TAG), this.runAction(a)
        }
    },
    unselected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.unselected.call(this), this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var a = cc.ScaleTo.create(.1, this._originalScale);
            a.setTag(cc.ZOOM_ACTION_TAG), this.runAction(a)
        }
    }
}), _p = cc.MenuItemLabel.prototype, cc.defineGetterSetter(_p, "string", _p.getString, _p.setString), cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor), cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel), cc.MenuItemLabel.create = function(a, b, c) {
    return new cc.MenuItemLabel(a, b, c)
}, cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
    ctor: function(a, b, c, d, e, f, g) {
        var h;
        a && 0 < a.length && (h = cc.LabelAtlas.create(a, b, c, d, e)), cc.MenuItemLabel.prototype.ctor.call(this, h, f, g)
    },
    initWithString: function(a, b, c, d, e, f, g) {
        if (!a || 0 == a.length) throw "cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0";
        var h = new cc.LabelAtlas;
        return h.initWithString(a, b, c, d, e), this.initWithLabel(h, f, g), !0
    }
}), cc.MenuItemAtlasFont.create = function(a, b, c, d, e, f, g) {
    return new cc.MenuItemAtlasFont(a, b, c, d, e, f, g)
}, cc.MenuItemFont = cc.MenuItemLabel.extend({
    _fontSize: null,
    _fontName: null,
    ctor: function(a, b, c) {
        var d;
        a && 0 < a.length ? (this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, d = cc.LabelTTF.create(a, this._fontName, this._fontSize)) : (this._fontSize = 0, this._fontName = ""), cc.MenuItemLabel.prototype.ctor.call(this, d, b, c)
    },
    initWithString: function(a, b, c) {
        if (!a || 0 == a.length) throw "Value should be non-null and its length should be greater than 0";
        return this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, a = cc.LabelTTF.create(a, this._fontName, this._fontSize), this.initWithLabel(a, b, c), !0
    },
    setFontSize: function(a) {
        this._fontSize = a, this._recreateLabel()
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._fontName = a, this._recreateLabel()
    },
    getFontName: function() {
        return this._fontName
    },
    _recreateLabel: function() {
        var a = cc.LabelTTF.create(this._label.string, this._fontName, this._fontSize);
        this.setLabel(a)
    }
}), cc.MenuItemFont.setFontSize = function(a) {
    cc._globalFontSize = a
}, cc.MenuItemFont.fontSize = function() {
    return cc._globalFontSize
}, cc.MenuItemFont.setFontName = function(a) {
    cc._globalFontNameRelease && (cc._globalFontName = ""), cc._globalFontName = a, cc._globalFontNameRelease = !0
}, _p = cc.MenuItemFont.prototype, cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize), cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName), cc.MenuItemFont.fontName = function() {
    return cc._globalFontName
}, cc.MenuItemFont.create = function(a, b, c) {
    return new cc.MenuItemFont(a, b, c)
}, cc.MenuItemSprite = cc.MenuItem.extend({
    _normalImage: null,
    _selectedImage: null,
    _disabledImage: null,
    ctor: function(a, b, c, d, e) {
        if (cc.MenuItem.prototype.ctor.call(this), this._disabledImage = this._selectedImage = this._normalImage = null, void 0 !== b) {
            var f, g, h;
            void 0 !== e ? (f = c, h = d, g = e) : void 0 !== d && "function" == typeof d ? (f = c, h = d) : void 0 !== d && "function" == typeof c ? (g = d, h = c, f = cc.Sprite.create(b)) : void 0 === c && (f = cc.Sprite.create(b)), this.initWithNormalSprite(a, b, f, h, g)
        }
    },
    getNormalImage: function() {
        return this._normalImage
    },
    setNormalImage: function(a) {
        this._normalImage != a && (a && (this.addChild(a, 0, cc.NORMAL_TAG), a.anchorX = 0, a.anchorY = 0), this._normalImage && this.removeChild(this._normalImage, !0), this._normalImage = a, this.width = this._normalImage.width, this.height = this._normalImage.height, this._updateImagesVisibility(), a.textureLoaded && !a.textureLoaded() && a.addLoadedEventListener(function(a) {
            this.width = a.width, this.height = a.height
        }, this))
    },
    getSelectedImage: function() {
        return this._selectedImage
    },
    setSelectedImage: function(a) {
        this._selectedImage != a && (a && (this.addChild(a, 0, cc.SELECTED_TAG), a.anchorX = 0, a.anchorY = 0), this._selectedImage && this.removeChild(this._selectedImage, !0), this._selectedImage = a, this._updateImagesVisibility())
    },
    getDisabledImage: function() {
        return this._disabledImage
    },
    setDisabledImage: function(a) {
        this._disabledImage != a && (a && (this.addChild(a, 0, cc.DISABLE_TAG), a.anchorX = 0, a.anchorY = 0), this._disabledImage && this.removeChild(this._disabledImage, !0), this._disabledImage = a, this._updateImagesVisibility())
    },
    initWithNormalSprite: function(a, b, c, d, e) {
        return this.initWithCallback(d, e), this.setNormalImage(a), this.setSelectedImage(b), this.setDisabledImage(c), (a = this._normalImage) && (this.width = a.width, this.height = a.height, a.textureLoaded && !a.textureLoaded() && a.addLoadedEventListener(function(a) {
            this.width = a.width, this.height = a.height, this.cascadeOpacity = this.cascadeColor = !0
        }, this)), this.cascadeOpacity = this.cascadeColor = !0
    },
    setColor: function(a) {
        this._normalImage.color = a, this._selectedImage && (this._selectedImage.color = a), this._disabledImage && (this._disabledImage.color = a)
    },
    getColor: function() {
        return this._normalImage.color
    },
    setOpacity: function(a) {
        this._normalImage.opacity = a, this._selectedImage && (this._selectedImage.opacity = a), this._disabledImage && (this._disabledImage.opacity = a)
    },
    getOpacity: function() {
        return this._normalImage.opacity
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this), this._normalImage && (this._disabledImage && (this._disabledImage.visible = !1), this._selectedImage ? (this._normalImage.visible = !1, this._selectedImage.visible = !0) : this._normalImage.visible = !0)
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this), this._normalImage && (this._normalImage.visible = !0, this._selectedImage && (this._selectedImage.visible = !1), this._disabledImage && (this._disabledImage.visible = !1))
    },
    setEnabled: function(a) {
        this._enabled != a && (cc.MenuItem.prototype.setEnabled.call(this, a), this._updateImagesVisibility())
    },
    _updateImagesVisibility: function() {
        var a = this._normalImage,
            b = this._selectedImage,
            c = this._disabledImage;
        this._enabled ? (a && (a.visible = !0), b && (b.visible = !1), c && (c.visible = !1)) : c ? (a && (a.visible = !1), b && (b.visible = !1), c && (c.visible = !0)) : (a && (a.visible = !0), b && (b.visible = !1))
    }
}), _p = cc.MenuItemSprite.prototype, cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage), cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage), cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage), cc.MenuItemSprite.create = function(a, b, c, d, e) {
    return new cc.MenuItemSprite(a, b, c, d, e || void 0)
}, cc.MenuItemImage = cc.MenuItemSprite.extend({
    ctor: function(a, b, c, d, e) {
        var f = null,
            g = null,
            h = null,
            i = null,
            j = null;
        void 0 === a ? cc.MenuItemSprite.prototype.ctor.call(this) : (f = cc.Sprite.create(a), b && (g = cc.Sprite.create(b)), void 0 === d ? i = c : void 0 === e ? (i = c, j = d) : e && (h = cc.Sprite.create(c), i = d, j = e), cc.MenuItemSprite.prototype.ctor.call(this, f, g, h, i, j))
    },
    setNormalSpriteFrame: function(a) {
        this.setNormalImage(cc.Sprite.create(a))
    },
    setSelectedSpriteFrame: function(a) {
        this.setSelectedImage(cc.Sprite.create(a))
    },
    setDisabledSpriteFrame: function(a) {
        this.setDisabledImage(cc.Sprite.create(a))
    },
    initWithNormalImage: function(a, b, c, d, e) {
        var f = null,
            g = null,
            h = null;
        return a && (f = cc.Sprite.create(a)), b && (g = cc.Sprite.create(b)), c && (h = cc.Sprite.create(c)), this.initWithNormalSprite(f, g, h, d, e)
    }
}), cc.MenuItemImage.create = function(a, b, c, d, e) {
    return new cc.MenuItemImage(a, b, c, d, e)
}, cc.MenuItemToggle = cc.MenuItem.extend({
    subItems: null,
    _selectedIndex: 0,
    _opacity: null,
    _color: null,
    ctor: function() {
        cc.MenuItem.prototype.ctor.call(this), this._selectedIndex = 0, this.subItems = [], this._opacity = 0, this._color = cc.color.WHITE, 0 < arguments.length && this.initWithItems(Array.prototype.slice.apply(arguments))
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(a) {
        if (this._opacity = a, this.subItems && 0 < this.subItems.length)
            for (var b = 0; b < this.subItems.length; b++) this.subItems[b].opacity = a;
        this._color.a = a
    },
    getColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setColor: function(a) {
        var b = this._color;
        if (b.r = a.r, b.g = a.g, b.b = a.b, this.subItems && 0 < this.subItems.length)
            for (b = 0; b < this.subItems.length; b++) this.subItems[b].setColor(a);
        void 0 !== a.a && !a.a_undefined && this.setOpacity(a.a)
    },
    getSelectedIndex: function() {
        return this._selectedIndex
    },
    setSelectedIndex: function(a) {
        if (a != this._selectedIndex) {
            this._selectedIndex = a, (a = this.getChildByTag(cc.CURRENT_ITEM)) && a.removeFromParent(!1), a = this.subItems[this._selectedIndex], this.addChild(a, 0, cc.CURRENT_ITEM);
            var b = a.width,
                c = a.height;
            this.width = b, this.height = c, a.setPosition(b / 2, c / 2)
        }
    },
    getSubItems: function() {
        return this.subItems
    },
    setSubItems: function(a) {
        this.subItems = a
    },
    initWithItems: function(a) {
        var b = a.length;
        "function" == typeof a[a.length - 2] ? (this.initWithCallback(a[a.length - 2], a[a.length - 1]), b -= 2) : "function" == typeof a[a.length - 1] ? (this.initWithCallback(a[a.length - 1], null), b -= 1) : this.initWithCallback(null, null);
        for (var c = this.subItems, d = c.length = 0; b > d; d++) a[d] && c.push(a[d]);
        return this._selectedIndex = cc.UINT_MAX, this.setSelectedIndex(0), this.cascadeOpacity = this.cascadeColor = !0
    },
    addSubItem: function(a) {
        this.subItems.push(a)
    },
    activate: function() {
        this._enabled && this.setSelectedIndex((this._selectedIndex + 1) % this.subItems.length), cc.MenuItem.prototype.activate.call(this)
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this), this.subItems[this._selectedIndex].selected()
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this), this.subItems[this._selectedIndex].unselected()
    },
    setEnabled: function(a) {
        if (this._enabled != a) {
            cc.MenuItem.prototype.setEnabled.call(this, a);
            var b = this.subItems;
            if (b && 0 < b.length)
                for (var c = 0; c < b.length; c++) b[c].enabled = a
        }
    },
    selectedItem: function() {
        return this.subItems[this._selectedIndex]
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this), this.setSelectedIndex(this._selectedIndex)
    }
}), _p = cc.MenuItemToggle.prototype, cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex), cc.MenuItemToggle.create = function() {
    0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    var a = new cc.MenuItemToggle;
    return a.initWithItems(Array.prototype.slice.apply(arguments)), a
}, cc.MENU_STATE_WAITING = 0, cc.MENU_STATE_TRACKING_TOUCH = 1, cc.MENU_HANDLER_PRIORITY = -128, cc.DEFAULT_PADDING = 5, cc.Menu = cc.Layer.extend({
    enabled: !1,
    _color: null,
    _opacity: 0,
    _selectedItem: null,
    _state: -1,
    _touchListener: null,
    _className: "Menu",
    ctor: function(a) {
        cc.Layer.prototype.ctor.call(this), this._color = cc.color.WHITE, this.enabled = !1, this._opacity = 255, this._selectedItem = null, this._state = -1, this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this._onTouchBegan,
            onTouchMoved: this._onTouchMoved,
            onTouchEnded: this._onTouchEnded,
            onTouchCancelled: this._onTouchCancelled
        }), 0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var b, c = arguments.length;
        if (0 == c) b = [];
        else if (1 == c) b = a instanceof Array ? a : [a];
        else if (c > 1) {
            b = [];
            for (var d = 0; c > d; d++) arguments[d] && b.push(arguments[d])
        }
        this.initWithArray(b)
    },
    onEnter: function() {
        var a = this._touchListener;
        a._isRegistered() || cc.eventManager.addListener(a, this), cc.Node.prototype.onEnter.call(this)
    },
    getColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setColor: function(a) {
        var b = this._color;
        if (b.r = a.r, b.g = a.g, b.b = a.b, (b = this._children) && 0 < b.length)
            for (var c = 0; c < b.length; c++) b[c].setColor(a);
        void 0 !== a.a && !a.a_undefined && this.setOpacity(a.a)
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(a) {
        this._opacity = a;
        var b = this._children;
        if (b && 0 < b.length)
            for (var c = 0; c < b.length; c++) b[c].setOpacity(a);
        this._color.a = a
    },
    isEnabled: function() {
        return this.enabled
    },
    setEnabled: function(a) {
        this.enabled = a
    },
    initWithItems: function(a) {
        var b = [];
        if (a)
            for (var c = 0; c < a.length; c++) a[c] && b.push(a[c]);
        return this.initWithArray(b)
    },
    initWithArray: function(a) {
        if (cc.Layer.prototype.init.call(this)) {
            this.enabled = !0;
            var b = cc.winSize;
            if (this.setPosition(b.width / 2, b.height / 2), this.setContentSize(b), this.setAnchorPoint(.5, .5), this.ignoreAnchorPointForPosition(!0), a)
                for (b = 0; b < a.length; b++) this.addChild(a[b], b);
            return this._selectedItem = null, this._state = cc.MENU_STATE_WAITING, this.cascadeOpacity = this.cascadeColor = !0
        }
        return !1
    },
    addChild: function(a, b, c) {
        if (!(a instanceof cc.MenuItem)) throw "cc.Menu.addChild() : Menu only supports MenuItem objects as children";
        cc.Layer.prototype.addChild.call(this, a, b, c)
    },
    alignItemsVertically: function() {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsVerticallyWithPadding: function(a) {
        var b, c, d, e, f = -a,
            g = this._children;
        if (g && 0 < g.length) {
            for (c = 0, b = g.length; b > c; c++) f += g[c].height * g[c].scaleY + a;
            var h = f / 2;
            for (c = 0, b = g.length; b > c; c++) e = g[c], d = e.height, f = e.scaleY, e.setPosition(0, h - d * f / 2), h -= d * f + a
        }
    },
    alignItemsHorizontally: function() {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsHorizontallyWithPadding: function(a) {
        var b, c, d, e, f = -a,
            g = this._children;
        if (g && 0 < g.length) {
            for (b = 0, c = g.length; c > b; b++) f += g[b].width * g[b].scaleX + a;
            var h = -f / 2;
            for (b = 0, c = g.length; c > b; b++) e = g[b], f = e.scaleX, d = g[b].width, e.setPosition(h + d * f / 2, 0), h += d * f + a
        }
    },
    alignItemsInColumns: function() {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        for (var a = [], b = 0; b < arguments.length; b++) a.push(arguments[b]);
        var c, d, e, f = -5,
            g = 0,
            h = 0,
            i = 0,
            j = this._children;
        if (j && 0 < j.length)
            for (b = 0, e = j.length; e > b; b++) g >= a.length || !(c = a[g]) || (d = j[b].height, h = h >= d || isNaN(d) ? h : d, ++i, i >= c && (f += h + 5, h = i = 0, ++g));
        var k = cc.director.getWinSize(),
            l = c = h = g = 0,
            m = 0,
            f = f / 2;
        if (j && 0 < j.length)
            for (b = 0, e = j.length; e > b; b++) {
                var n = j[b];
                0 == c && (c = a[g], m = l = k.width / (1 + c)), d = n._getHeight(), h = h >= d || isNaN(d) ? h : d, n.setPosition(m - k.width / 2, f - d / 2), m += l, ++i, i >= c && (f -= h + 5, h = c = i = 0, ++g)
            }
    },
    alignItemsInRows: function() {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var a, b = [];
        for (a = 0; a < arguments.length; a++) b.push(arguments[a]);
        var c, d, e, f, g = [],
            h = [],
            i = -10,
            j = -5,
            k = 0,
            l = 0,
            m = 0,
            n = this._children;
        if (n && 0 < n.length)
            for (a = 0, e = n.length; e > a; a++) d = n[a], k >= b.length || !(c = b[k]) || (f = d.width, l = l >= f || isNaN(f) ? l : f, j += d.height + 5, ++m, m >= c && (g.push(l), h.push(j), i += l + 10, l = m = 0, j = -5, ++k));
        j = cc.director.getWinSize(), c = l = k = 0;
        var i = -i / 2,
            o = 0;
        if (n && 0 < n.length)
            for (a = 0, e = n.length; e > a; a++) d = n[a], 0 == c && (c = b[k], o = h[k]), f = d._getWidth(), l = l >= f || isNaN(f) ? l : f, d.setPosition(i + g[k] / 2, o - j.height / 2), o -= d.height + 10, ++m, m >= c && (i += l + 5, l = c = m = 0, ++k)
    },
    removeChild: function(a, b) {
        null != a && (a instanceof cc.MenuItem ? (this._selectedItem == a && (this._selectedItem = null), cc.Node.prototype.removeChild.call(this, a, b)) : cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children"))
    },
    _onTouchBegan: function(a, b) {
        var c = b.getCurrentTarget();
        if (c._state != cc.MENU_STATE_WAITING || !c._visible || !c.enabled) return !1;
        for (var d = c.parent; null != d; d = d.parent)
            if (!d.isVisible()) return !1;
        return c._selectedItem = c._itemForTouch(a), c._selectedItem ? (c._state = cc.MENU_STATE_TRACKING_TOUCH, c._selectedItem.selected(), !0) : !1
    },
    _onTouchEnded: function(a, b) {
        var c = b.getCurrentTarget();
        c._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchEnded(): invalid state") : (c._selectedItem && (c._selectedItem.unselected(), c._selectedItem.activate()), c._state = cc.MENU_STATE_WAITING)
    },
    _onTouchCancelled: function(a, b) {
        var c = b.getCurrentTarget();
        c._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchCancelled(): invalid state") : (this._selectedItem && c._selectedItem.unselected(), c._state = cc.MENU_STATE_WAITING)
    },
    _onTouchMoved: function(a, b) {
        var c = b.getCurrentTarget();
        if (c._state !== cc.MENU_STATE_TRACKING_TOUCH) cc.log("cc.Menu.onTouchMoved(): invalid state");
        else {
            var d = c._itemForTouch(a);
            d != c._selectedItem && (c._selectedItem && c._selectedItem.unselected(), c._selectedItem = d, c._selectedItem && c._selectedItem.selected())
        }
    },
    onExit: function() {
        this._state == cc.MENU_STATE_TRACKING_TOUCH && (this._selectedItem && (this._selectedItem.unselected(), this._selectedItem = null), this._state = cc.MENU_STATE_WAITING), cc.Node.prototype.onExit.call(this)
    },
    setOpacityModifyRGB: function() {},
    isOpacityModifyRGB: function() {
        return !1
    },
    _itemForTouch: function(a) {
        a = a.getLocation();
        var b, c = this._children;
        if (c && 0 < c.length)
            for (var d = 0; d < c.length; d++)
                if (b = c[d], b.isVisible() && b.isEnabled()) {
                    var e = b.convertToNodeSpace(a),
                        f = b.rect();
                    if (f.x = 0, f.y = 0, cc.rectContainsPoint(f, e)) return b
                }
        return null
    }
}), _p = cc.Menu.prototype, cc.Menu.create = function(a) {
    var b = arguments.length;
    return b > 0 && null == arguments[b - 1] && cc.log("parameters should not be ending with null in Javascript"), 0 == b ? new cc.Menu : new cc.Menu(1 == b ? a : Array.prototype.slice.call(arguments, 0))
}, cc.TGA_OK = 0, cc.TGA_ERROR_FILE_OPEN = 1, cc.TGA_ERROR_READING_FILE = 2, cc.TGA_ERROR_INDEXED_COLOR = 3, cc.TGA_ERROR_MEMORY = 4, cc.TGA_ERROR_COMPRESSED_FILE = 5, cc.ImageTGA = function(a, b, c, d, e, f, g) {
    this.status = a || 0, this.type = b || 0, this.pixelDepth = c || 0, this.width = d || 0, this.height = e || 0, this.imageData = f || [], this.flipped = g || 0
}, cc.tgaLoadHeader = function(a, b, c) {
    var d = 2;
    return d + 1 > b ? !1 : (a = new cc.BinaryStreamReader(a), a.setOffset(d), c.type = a.readByte(), d += 10, d + 4 + 1 > b ? !1 : (a.setOffset(d), c.width = a.readUnsignedShort(), c.height = a.readUnsignedInteger(), c.pixelDepth = a.readByte(), d + 5 + 1 > b ? !1 : (b = a.readByte(), c.flipped = 0, 32 & b && (c.flipped = 1), !0)))
}, cc.tgaLoadImageData = function(a, b, c) {
    var d, e;
    if (d = 0 | c.pixelDepth / 2, e = c.height * c.width * d, 18 + e > b) return !1;
    if (c.imageData = cc.__getSubArray(a, 18, 18 + e), d >= 3)
        for (a = 0; e > a; a += d) b = c.imageData[a], c.imageData[a] = c.imageData[a + 2], c.imageData[a + 2] = b;
    return !0
}, cc.tgaRGBtogreyscale = function(a) {
    var b, c;
    if (8 !== a.pixelDepth) {
        var d = a.pixelDepth / 8,
            e = new Uint8Array(a.height * a.width);
        if (null !== e) {
            for (c = b = 0; c < a.width * a.height; b += d, c++) e[c] = .3 * a.imageData[b] + .59 * a.imageData[b + 1] + .11 * a.imageData[b + 2];
            a.pixelDepth = 8, a.type = 3, a.imageData = e
        }
    }
}, cc.tgaDestroy = function(a) {
    a && (a.imageData = null)
}, cc.tgaLoadRLEImageData = function(a, b, c) {
    var d, e, f, g = 0,
        h = 0,
        i = 0,
        j = [],
        k = 0,
        l = 18;
    for (d = c.pixelDepth / 8, e = c.height * c.width, f = 0; e > f; f++) {
        if (0 != k) k--, h = 0 != i;
        else {
            if (l + 1 > b) break;
            k = a[l], l += 1, (i = 128 & k) && (k -= 128), h = 0
        } if (!h) {
            if (l + d > b) break;
            j = cc.__getSubArray(a, l, l + d), l += d, d >= 3 && (h = j[0], j[0] = j[2], j[2] = h)
        }
        for (h = 0; d > h; h++) c.imageData[g + h] = j[h];
        g += d
    }
    return !0
}, cc.tgaFlipImage = function(a) {
    for (var b = a.width * (a.pixelDepth / 8), c = 0; c < a.height / 2; c++) {
        var d = cc.__getSubArray(a.imageData, c * b, c * b + b);
        cc.__setDataToArray(cc.__getSubArray(a.imageData, (a.height - (c + 1)) * b, b), a.imageData, c * b), cc.__setDataToArray(d, a.imageData, (a.height - (c + 1)) * b)
    }
    a.flipped = 0
}, cc.__getSubArray = function(a, b, c) {
    return a instanceof Array ? a.slice(b, c) : a.subarray(b, c)
}, cc.__setDataToArray = function(a, b, c) {
    for (var d = 0; d < a.length; d++) b[c + d] = a[d]
}, cc.BinaryStreamReader = cc.Class.extend({
    _binaryData: null,
    _offset: 0,
    ctor: function(a) {
        this._binaryData = a
    },
    setBinaryData: function(a) {
        this._binaryData = a, this._offset = 0
    },
    getBinaryData: function() {
        return this._binaryData
    },
    _checkSize: function(a) {
        if (!(this._offset + Math.ceil(a / 8) < this._data.length)) throw Error("Index out of bound")
    },
    _decodeFloat: function(a, b) {
        var c = a + b + 1,
            d = c >> 3;
        this._checkSize(c);
        var c = Math.pow(2, b - 1) - 1,
            e = this._readBits(a + b, 1, d),
            f = this._readBits(a, b, d),
            g = 0,
            h = 2,
            i = 0;
        do
            for (var j = this._readByte(++i, d), k = a % 8 || 8, l = 1 << k; l >>= 1;) j & l && (g += 1 / h), h *= 2;
        while (a -= k);
        return this._offset += d, f == (c << 1) + 1 ? g ? 0 / 0 : e ? -1 / 0 : 1 / 0 : (1 + -2 * e) * (f || g ? f ? Math.pow(2, f - c) * (1 + g) : Math.pow(2, -c + 1) * g : 0)
    },
    _readByte: function(a, b) {
        return this._data[this._offset + b - a - 1]
    },
    _decodeInt: function(a, b) {
        var c = this._readBits(0, a, a / 8),
            d = Math.pow(2, a);
        return this._offset += a / 8, b && c >= d / 2 ? c - d : c
    },
    _shl: function(a, b) {
        for (++b; --b; a = 1073741824 == (1073741824 & (a %= 2147483648)) ? 2 * a : 2 * (a - 1073741824) + 2147483648);
        return a
    },
    _readBits: function(a, b, c) {
        var d = (a + b) % 8,
            e = a % 8,
            f = c - (a >> 3) - 1;
        a = c + (-(a + b) >> 3);
        var g = f - a;
        for (b = this._readByte(f, c) >> e & (1 << (g ? 8 - e : b)) - 1, g && d && (b += (this._readByte(a++, c) & (1 << d) - 1) << (g-- << 3) - e); g;) b += this._shl(this._readByte(a++, c), (g-- << 3) - e);
        return b
    },
    readInteger: function() {
        return this._decodeInt(32, !0)
    },
    readUnsignedInteger: function() {
        return this._decodeInt(32, !1)
    },
    readSingle: function() {
        return this._decodeFloat(23, 8)
    },
    readShort: function() {
        return this._decodeInt(16, !0)
    },
    readUnsignedShort: function() {
        return this._decodeInt(16, !1)
    },
    readByte: function() {
        var a = this._data[this._offset];
        return this._offset += 1, a
    },
    readData: function(a, b) {
        return this._binaryData instanceof Array ? this._binaryData.slice(a, b) : this._binaryData.subarray(a, b)
    },
    setOffset: function(a) {
        this._offset = a
    },
    getOffset: function() {
        return this._offset
    }
}), cc.TMX_ORIENTATION_ORTHO = 0, cc.TMX_ORIENTATION_HEX = 1, cc.TMX_ORIENTATION_ISO = 2, cc.TMXTiledMap = cc.Node.extend({
    properties: null,
    mapOrientation: null,
    objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _tileProperties: null,
    _className: "TMXTiledMap",
    ctor: function(a, b) {
        cc.Node.prototype.ctor.call(this), this._mapSize = cc.size(0, 0), this._tileSize = cc.size(0, 0), void 0 !== b ? this.initWithXML(a, b) : void 0 !== a && this.initWithTMXFile(a)
    },
    getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function(a) {
        this._mapSize.width = a.width, this._mapSize.height = a.height
    },
    _getMapWidth: function() {
        return this._mapSize.width
    },
    _setMapWidth: function(a) {
        this._mapSize.width = a
    },
    _getMapHeight: function() {
        return this._mapSize.height
    },
    _setMapHeight: function(a) {
        this._mapSize.height = a
    },
    getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function(a) {
        this._tileSize.width = a.width, this._tileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._tileSize.width
    },
    _setTileWidth: function(a) {
        this._tileSize.width = a
    },
    _getTileHeight: function() {
        return this._tileSize.height
    },
    _setTileHeight: function(a) {
        this._tileSize.height = a
    },
    getMapOrientation: function() {
        return this.mapOrientation
    },
    setMapOrientation: function(a) {
        this.mapOrientation = a
    },
    getObjectGroups: function() {
        return this.objectGroups
    },
    setObjectGroups: function(a) {
        this.objectGroups = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTMXFile: function(a) {
        if (!a || 0 == a.length) throw "cc.TMXTiledMap.initWithTMXFile(): tmxFile should be non-null or non-empty string.";
        if (this.height = this.width = 0, a = cc.TMXMapInfo.create(a), !a) return !1;
        var b = a.getTilesets();
        return (!b || 0 === b.length) && cc.log("cc.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename."), this._buildWithMapInfo(a), !0
    },
    initWithXML: function(a, b) {
        this.height = this.width = 0;
        var c = cc.TMXMapInfo.create(a, b),
            d = c.getTilesets();
        return (!d || 0 === d.length) && cc.log("cc.TMXTiledMap.initWithXML(): Map not found. Please check the filename."), this._buildWithMapInfo(c), !0
    },
    _buildWithMapInfo: function(a) {
        this._mapSize = a.getMapSize(), this._tileSize = a.getTileSize(), this.mapOrientation = a.orientation, this.objectGroups = a.getObjectGroups(), this.properties = a.properties, this._tileProperties = a.getTileProperties();
        var b = 0,
            c = a.getLayers();
        if (c)
            for (var d = null, e = 0, f = c.length; f > e; e++)(d = c[e]) && d.visible && (d = this._parseLayer(d, a), this.addChild(d, b, b), this.width = Math.max(this.width, d.width), this.height = Math.max(this.height, d.height), b++)
    },
    allLayers: function() {
        for (var a = [], b = this._children, c = 0, d = b.length; d > c; c++) {
            var e = b[c];
            e && e instanceof cc.TMXLayer && a.push(e)
        }
        return a
    },
    getLayer: function(a) {
        if (!a || 0 === a.length) throw "cc.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.";
        for (var b = this._children, c = 0; c < b.length; c++) {
            var d = b[c];
            if (d && d.layerName == a) return d
        }
        return null
    },
    getObjectGroup: function(a) {
        if (!a || 0 === a.length) throw "cc.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.";
        if (this.objectGroups)
            for (var b = 0; b < this.objectGroups.length; b++) {
                var c = this.objectGroups[b];
                if (c && c.groupName == a) return c
            }
        return null
    },
    getProperty: function(a) {
        return this.properties[a.toString()]
    },
    propertiesForGID: function(a) {
        return cc.log("propertiesForGID is deprecated. Please use getPropertiesForGID instead."), this.getPropertiesForGID[a]
    },
    getPropertiesForGID: function(a) {
        return this._tileProperties[a]
    },
    _parseLayer: function(a, b) {
        var c = this._tilesetForLayer(a, b),
            c = cc.TMXLayer.create(c, a, b);
        return a.ownTiles = !1, c.setupTiles(), c
    },
    _tilesetForLayer: function(a, b) {
        var c = a._layerSize,
            d = b.getTilesets();
        if (d)
            for (var e = d.length - 1; e >= 0; e--) {
                var f = d[e];
                if (f)
                    for (var g = 0; g < c.height; g++)
                        for (var h = 0; h < c.width; h++) {
                            var i = a._tiles[h + c.width * g];
                            if (0 != i && (i & cc.TMX_TILE_FLIPPED_MASK) >>> 0 >= f.firstGid) return f
                        }
            }
        return cc.log("cocos2d: Warning: TMX Layer " + a.name + " has no tiles"), null
    }
}), _p = cc.TMXTiledMap.prototype, cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth), cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight), cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth), cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight), cc.TMXTiledMap.create = function(a, b) {
    return new cc.TMXTiledMap(a, b)
}, cc.TMX_PROPERTY_NONE = 0, cc.TMX_PROPERTY_MAP = 1, cc.TMX_PROPERTY_LAYER = 2, cc.TMX_PROPERTY_OBJECTGROUP = 3, cc.TMX_PROPERTY_OBJECT = 4, cc.TMX_PROPERTY_TILE = 5, cc.TMX_TILE_HORIZONTAL_FLAG = 2147483648, cc.TMX_TILE_VERTICAL_FLAG = 1073741824, cc.TMX_TILE_DIAGONAL_FLAG = 536870912, cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0, cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0, cc.TMXLayerInfo = cc.Class.extend({
    properties: null,
    name: "",
    _layerSize: null,
    _tiles: null,
    visible: null,
    _opacity: null,
    ownTiles: !0,
    _minGID: 1e5,
    _maxGID: 0,
    offset: null,
    ctor: function() {
        this.properties = [], this.name = "", this._layerSize = null, this._tiles = [], this.visible = !0, this._opacity = 0, this.ownTiles = !0, this._minGID = 1e5, this._maxGID = 0, this.offset = cc.p(0, 0)
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    }
}), cc.TMXTilesetInfo = cc.Class.extend({
    name: "",
    firstGid: 0,
    _tileSize: null,
    spacing: 0,
    margin: 0,
    sourceImage: "",
    imageSize: null,
    ctor: function() {
        this._tileSize = cc.size(0, 0), this.imageSize = cc.size(0, 0)
    },
    rectForGID: function(a) {
        var b = cc.rect(0, 0, 0, 0);
        b.width = this._tileSize.width, b.height = this._tileSize.height, a &= cc.TMX_TILE_FLIPPED_MASK, a -= parseInt(this.firstGid, 10);
        var c = parseInt((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing), 10);
        return b.x = parseInt(a % c * (this._tileSize.width + this.spacing) + this.margin, 10), b.y = parseInt(parseInt(a / c, 10) * (this._tileSize.height + this.spacing) + this.margin, 10), b
    }
}), cc.TMXMapInfo = cc.SAXParser.extend({
    properties: null,
    orientation: null,
    parentElement: null,
    parentGID: null,
    layerAttrs: 0,
    storingCharacters: !1,
    tmxFileName: null,
    currentString: null,
    _objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _layers: null,
    _tilesets: null,
    _tileProperties: null,
    _resources: "",
    _currentFirstGID: 0,
    ctor: function(a, b) {
        cc.SAXParser.prototype.ctor.apply(this), this._mapSize = cc.size(0, 0), this._tileSize = cc.size(0, 0), this._layers = [], this._tilesets = [], this._objectGroups = [], this.properties = [], this._tileProperties = {}, this._currentFirstGID = 0, void 0 !== b ? this.initWithXML(a, b) : void 0 !== a && this.initWithTMXFile(a)
    },
    getOrientation: function() {
        return this.orientation
    },
    setOrientation: function(a) {
        this.orientation = a
    },
    getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function(a) {
        this._mapSize.width = a.width, this._mapSize.height = a.height
    },
    _getMapWidth: function() {
        return this._mapSize.width
    },
    _setMapWidth: function(a) {
        this._mapSize.width = a
    },
    _getMapHeight: function() {
        return this._mapSize.height
    },
    _setMapHeight: function(a) {
        this._mapSize.height = a
    },
    getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function(a) {
        this._tileSize.width = a.width, this._tileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._tileSize.width
    },
    _setTileWidth: function(a) {
        this._tileSize.width = a
    },
    _getTileHeight: function() {
        return this._tileSize.height
    },
    _setTileHeight: function(a) {
        this._tileSize.height = a
    },
    getLayers: function() {
        return this._layers
    },
    setLayers: function(a) {
        this._layers.push(a)
    },
    getTilesets: function() {
        return this._tilesets
    },
    setTilesets: function(a) {
        this._tilesets.push(a)
    },
    getObjectGroups: function() {
        return this._objectGroups
    },
    setObjectGroups: function(a) {
        this._objectGroups.push(a)
    },
    getParentElement: function() {
        return this.parentElement
    },
    setParentElement: function(a) {
        this.parentElement = a
    },
    getParentGID: function() {
        return this.parentGID
    },
    setParentGID: function(a) {
        this.parentGID = a
    },
    getLayerAttribs: function() {
        return this.layerAttrs
    },
    setLayerAttribs: function(a) {
        this.layerAttrs = a
    },
    getStoringCharacters: function() {
        return this.storingCharacters
    },
    setStoringCharacters: function(a) {
        this.storingCharacters = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTMXFile: function(a) {
        return this._internalInit(a, null), this.parseXMLFile(a)
    },
    initWithXML: function(a, b) {
        return this._internalInit(null, b), this.parseXMLString(a)
    },
    parseXMLFile: function(a, b) {
        var c = (b = b || !1) ? a : cc.loader.getRes(a);
        if (!c) throw "Please load the resource first : " + a;
        var d, e, c = this._parseXML(c).documentElement;
        if (d = c.getAttribute("version"), e = c.getAttribute("orientation"), "map" == c.nodeName && ("1.0" != d && null !== d && cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + d), "orthogonal" == e ? this.orientation = cc.TMX_ORIENTATION_ORTHO : "isometric" == e ? this.orientation = cc.TMX_ORIENTATION_ISO : "hexagonal" == e ? this.orientation = cc.TMX_ORIENTATION_HEX : null !== e && cc.log("cocos2d: TMXFomat: Unsupported orientation:" + e), d = cc.size(0, 0), d.width = parseFloat(c.getAttribute("width")), d.height = parseFloat(c.getAttribute("height")), this.setMapSize(d), d = cc.size(0, 0), d.width = parseFloat(c.getAttribute("tilewidth")), d.height = parseFloat(c.getAttribute("tileheight")), this.setTileSize(d), e = c.querySelectorAll("map > properties >  property"))) {
            var f = {};
            for (d = 0; d < e.length; d++) f[e[d].getAttribute("name")] = e[d].getAttribute("value");
            this.properties = f
        }
        for (f = c.getElementsByTagName("tileset"), "map" !== c.nodeName && (f = [], f.push(c)), d = 0; d < f.length; d++) {
            e = f[d];
            var g = e.getAttribute("source");
            if (g) e = b ? cc.path.join(this._resources, g) : cc.path.changeBasename(a, g), this.parseXMLFile(e);
            else {
                g = new cc.TMXTilesetInfo, g.name = e.getAttribute("name") || "", g.firstGid = parseInt(e.getAttribute("firstgid")) || 0, g.spacing = parseInt(e.getAttribute("spacing")) || 0, g.margin = parseInt(e.getAttribute("margin")) || 0;
                var h = cc.size(0, 0);
                h.width = parseFloat(e.getAttribute("tilewidth")), h.height = parseFloat(e.getAttribute("tileheight")), g._tileSize = h;
                var h = e.getElementsByTagName("image")[0].getAttribute("source"),
                    i = -1;
                if (this.tmxFileName && (i = this.tmxFileName.lastIndexOf("/")), -1 !== i ? (i = this.tmxFileName.substr(0, i + 1), g.sourceImage = i + h) : g.sourceImage = this._resources + (this._resources ? "/" : "") + h, this.setTilesets(g), h = e.getElementsByTagName("tile"))
                    for (i = 0; i < h.length; i++) {
                        e = h[i], this.parentGID = parseInt(g.firstGid) + parseInt(e.getAttribute("id") || 0);
                        var j = e.querySelectorAll("properties > property");
                        if (j) {
                            var k = {};
                            for (e = 0; e < j.length; e++) {
                                var l = j[e].getAttribute("name");
                                k[l] = j[e].getAttribute("value")
                            }
                            this._tileProperties[this.parentGID] = k
                        }
                    }
            }
        }
        if (f = c.getElementsByTagName("layer"))
            for (d = 0; d < f.length; d++) {
                for (h = f[d], i = h.getElementsByTagName("data")[0], g = new cc.TMXLayerInfo, g.name = h.getAttribute("name"), e = cc.size(0, 0), e.width = parseFloat(h.getAttribute("width")), e.height = parseFloat(h.getAttribute("height")), g._layerSize = e, e = h.getAttribute("visible"), g.visible = "0" != e, e = h.getAttribute("opacity") || 1, g._opacity = e ? parseInt(255 * parseFloat(e)) : 255, g.offset = cc.p(parseFloat(h.getAttribute("x")) || 0, parseFloat(h.getAttribute("y")) || 0), j = "", e = 0; e < i.childNodes.length; e++) j += i.childNodes[e].nodeValue;
                if (j = j.trim(), e = i.getAttribute("compression"), k = i.getAttribute("encoding"), e && "gzip" !== e && "zlib" !== e) return cc.log("cc.TMXMapInfo.parseXMLFile(): unsupported compression method"), null;
                switch (e) {
                    case "gzip":
                        g._tiles = cc.unzipBase64AsArray(j, 4);
                        break;
                    case "zlib":
                        e = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(j, 1)), g._tiles = cc.uint8ArrayToUint32Array(e.decompress());
                        break;
                    case null:
                    case "":
                        if ("base64" == k) g._tiles = cc.Codec.Base64.decodeAsArray(j, 4);
                        else if ("csv" === k)
                            for (g._tiles = [], e = j.split(","), i = 0; i < e.length; i++) g._tiles.push(parseInt(e[i]));
                        else
                            for (e = i.getElementsByTagName("tile"), g._tiles = [], i = 0; i < e.length; i++) g._tiles.push(parseInt(e[i].getAttribute("gid")));
                        break;
                    default:
                        this.layerAttrs == cc.TMXLayerInfo.ATTRIB_NONE && cc.log("cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported")
                }
                if (h = h.querySelectorAll("properties > property")) {
                    for (i = {}, e = 0; e < h.length; e++) i[h[e].getAttribute("name")] = h[e].getAttribute("value");
                    g.properties = i
                }
                this.setLayers(g)
            }
        if (f = c.getElementsByTagName("objectgroup"))
            for (d = 0; d < f.length; d++) {
                if (h = f[d], g = new cc.TMXObjectGroup, g.groupName = h.getAttribute("name"), g.setPositionOffset(cc.p(parseFloat(h.getAttribute("x")) * this.getTileSize().width || 0, parseFloat(h.getAttribute("y")) * this.getTileSize().height || 0)), i = h.querySelectorAll("objectgroup > properties > property"))
                    for (e = 0; e < i.length; e++) j = {}, j[i[e].getAttribute("name")] = i[e].getAttribute("value"), g.properties = j;
                if (h = h.querySelectorAll("object"))
                    for (e = 0; e < h.length; e++) {
                        if (j = h[e], i = {}, i.name = j.getAttribute("name") || "", i.type = j.getAttribute("type") || "", i.x = parseInt(j.getAttribute("x") || 0) + g.getPositionOffset().x, k = parseInt(j.getAttribute("y") || 0) + g.getPositionOffset().y, i.width = parseInt(j.getAttribute("width")) || 0, i.height = parseInt(j.getAttribute("height")) || 0, i.y = parseInt(this.getMapSize().height * this.getTileSize().height) - k - i.height, k = j.querySelectorAll("properties > property"))
                            for (l = 0; l < k.length; l++) i[k[l].getAttribute("name")] = k[l].getAttribute("value");
                        (k = j.querySelectorAll("polygon")) && 0 < k.length && (k = k[0].getAttribute("points")) && (i.polygonPoints = this._parsePointsString(k)), (j = j.querySelectorAll("polyline")) && 0 < j.length && (j = j[0].getAttribute("points")) && (i.polylinePoints = this._parsePointsString(j)), g.setObjects(i)
                    }
                this.setObjectGroups(g)
            }
        return c
    },
    _parsePointsString: function(a) {
        if (!a) return null;
        var b = [];
        a = a.split(" ");
        for (var c = 0; c < a.length; c++) {
            var d = a[c].split(",");
            b.push({
                x: d[0],
                y: d[1]
            })
        }
        return b
    },
    parseXMLString: function(a) {
        return this.parseXMLFile(a, !0)
    },
    getTileProperties: function() {
        return this._tileProperties
    },
    setTileProperties: function(a) {
        this._tileProperties.push(a)
    },
    getCurrentString: function() {
        return this.currentString
    },
    setCurrentString: function(a) {
        this.currentString = a
    },
    getTMXFileName: function() {
        return this.tmxFileName
    },
    setTMXFileName: function(a) {
        this.tmxFileName = a
    },
    _internalInit: function(a, b) {
        this._tilesets.length = 0, this._layers.length = 0, this.tmxFileName = a, b && (this._resources = b), this._objectGroups.length = 0, this.properties.length = 0, this._tileProperties.length = 0, this.currentString = "", this.storingCharacters = !1, this.layerAttrs = cc.TMXLayerInfo.ATTRIB_NONE, this.parentElement = cc.TMX_PROPERTY_NONE, this._currentFirstGID = 0
    }
}), _p = cc.TMXMapInfo.prototype, cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth), cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight), cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth), cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight), cc.TMXMapInfo.create = function(a, b) {
    return new cc.TMXMapInfo(a, b)
}, cc.loader.register(["tmx", "tsx"], cc._txtLoader), cc.TMXLayerInfo.ATTRIB_NONE = 1, cc.TMXLayerInfo.ATTRIB_BASE64 = 2, cc.TMXLayerInfo.ATTRIB_GZIP = 4, cc.TMXLayerInfo.ATTRIB_ZLIB = 8, cc.TMXObjectGroup = cc.Class.extend({
    properties: null,
    groupName: "",
    _positionOffset: null,
    _objects: null,
    ctor: function() {
        this.groupName = "", this._positionOffset = cc.p(0, 0), this.properties = [], this._objects = []
    },
    getPositionOffset: function() {
        return cc.p(this._positionOffset)
    },
    setPositionOffset: function(a) {
        this._positionOffset.x = a.x, this._positionOffset.y = a.y
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties.push(a)
    },
    getGroupName: function() {
        return this.groupName.toString()
    },
    setGroupName: function(a) {
        this.groupName = a
    },
    propertyNamed: function(a) {
        return this.properties[a]
    },
    objectNamed: function(a) {
        if (this._objects && 0 < this._objects.length)
            for (var b = this._objects, c = 0, d = b.length; d > c; c++) {
                var e = b[c].name;
                if (e && e == a) return b[c]
            }
        return null
    },
    getObjects: function() {
        return this._objects
    },
    setObjects: function(a) {
        this._objects.push(a)
    }
}), cc.TMXLayer = cc.SpriteBatchNode.extend({
    tiles: null,
    tileset: null,
    layerOrientation: null,
    properties: null,
    layerName: "",
    _layerSize: null,
    _mapTileSize: null,
    _opacity: 255,
    _minGID: null,
    _maxGID: null,
    _vertexZvalue: null,
    _useAutomaticVertexZ: null,
    _alphaFuncValue: null,
    _reusedTile: null,
    _atlasIndexArray: null,
    _contentScaleFactor: null,
    _cacheCanvas: null,
    _cacheContext: null,
    _cacheTexture: null,
    _subCacheCanvas: null,
    _subCacheContext: null,
    _subCacheCount: 0,
    _subCacheWidth: 0,
    _maxCachePixel: 1e7,
    _className: "TMXLayer",
    ctor: function(a, b, c) {
        if (cc.SpriteBatchNode.prototype.ctor.call(this), this._descendants = [], this._layerSize = cc.size(0, 0), this._mapTileSize = cc.size(0, 0), cc._renderType === cc._RENDER_TYPE_CANVAS) {
            var d = cc._canvas,
                e = cc.newElement("canvas");
            e.width = d.width, e.height = d.height, this._cacheCanvas = e, this._cacheContext = this._cacheCanvas.getContext("2d");
            var f = new cc.Texture2D;
            f.initWithElement(e), f.handleLoadedTexture(), this._cacheTexture = f, this.width = d.width, this.height = d.height, this._cachedParent = this
        }
        void 0 !== c && this.initWithTilesetInfo(a, b, c)
    },
    setContentSize: function(a, b) {
        var c = this._contentSize;
        if (cc.Node.prototype.setContentSize.call(this, a, b), cc._renderType === cc._RENDER_TYPE_CANVAS) {
            var d = this._cacheCanvas,
                e = cc.contentScaleFactor();
            if (d.width = 0 | 1.5 * c.width * e, d.height = 0 | 1.5 * c.height * e, this.layerOrientation === cc.TMX_ORIENTATION_HEX ? this._cacheContext.translate(0, d.height - .5 * this._mapTileSize.height) : this._cacheContext.translate(0, d.height), c = this._cacheTexture._contentSize, c.width = d.width, c.height = d.height, c = d.width * d.height, c > this._maxCachePixel) {
                for (this._subCacheCanvas || (this._subCacheCanvas = []), this._subCacheContext || (this._subCacheContext = []), this._subCacheCount = Math.ceil(c / this._maxCachePixel), c = this._subCacheCanvas, e = 0; e < this._subCacheCount; e++) {
                    c[e] || (c[e] = document.createElement("canvas"), this._subCacheContext[e] = c[e].getContext("2d"));
                    var f = c[e];
                    f.width = this._subCacheWidth = Math.round(d.width / this._subCacheCount), f.height = d.height
                }
                for (e = this._subCacheCount; e < c.length; e++) f.width = 0, f.height = 0
            } else this._subCacheCount = 0
        }
    },
    getTexture: null,
    _getTextureForCanvas: function() {
        return this._cacheTexture
    },
    visit: null,
    _visitForCanvas: function(a) {
        var b = a || cc._renderContext;
        if (this._visible) {
            b.save(), this.transform(a);
            var c, d = this._children;
            if (this._cacheDirty) {
                var e = cc.view;
                e._setScaleXYForRenderTexture();
                var f = this._cacheContext,
                    g = this._cacheCanvas;
                if (f.clearRect(0, 0, g.width, -g.height), f.save(), f.translate(this._anchorPointInPoints.x, -this._anchorPointInPoints.y), d)
                    for (this.sortAllChildren(), c = 0; c < d.length; c++) d[c] && d[c].visit(f);
                if (f.restore(), 0 < this._subCacheCount)
                    for (d = this._subCacheWidth, f = g.height, c = 0; c < this._subCacheCount; c++) this._subCacheContext[c].drawImage(g, c * d, 0, d, f, 0, 0, d, f);
                e._resetScale(), this._cacheDirty = !1
            }
            this.draw(a), b.restore()
        }
    },
    draw: null,
    _drawForCanvas: function(a) {
        a = a || cc._renderContext;
        var b = 0 | -this._anchorPointInPoints.x,
            c = 0 | -this._anchorPointInPoints.y,
            d = cc.view,
            e = this._cacheCanvas;
        if (e) {
            var f = this._subCacheCount,
                g = e.height * d._scaleY,
                h = .5 * this._mapTileSize.height * d._scaleY;
            if (f > 0)
                for (var e = this._subCacheCanvas, i = 0; f > i; i++) {
                    var j = e[i];
                    this.layerOrientation === cc.TMX_ORIENTATION_HEX ? a.drawImage(e[i], 0, 0, j.width, j.height, b + i * this._subCacheWidth, -(c + g) + h, j.width * d._scaleX, g) : a.drawImage(e[i], 0, 0, j.width, j.height, b + i * this._subCacheWidth, -(c + g), j.width * d._scaleX, g)
                } else this.layerOrientation === cc.TMX_ORIENTATION_HEX ? a.drawImage(e, 0, 0, e.width, e.height, b, -(c + g) + h, e.width * d._scaleX, g) : a.drawImage(e, 0, 0, e.width, e.height, b, -(c + g), e.width * d._scaleX, g)
        }
    },
    getLayerSize: function() {
        return cc.size(this._layerSize.width, this._layerSize.height)
    },
    setLayerSize: function(a) {
        this._layerSize.width = a.width, this._layerSize.height = a.height
    },
    _getLayerWidth: function() {
        return this._layerSize.width
    },
    _setLayerWidth: function(a) {
        this._layerSize.width = a
    },
    _getLayerHeight: function() {
        return this._layerSize.height
    },
    _setLayerHeight: function(a) {
        this._layerSize.height = a
    },
    getMapTileSize: function() {
        return cc.size(this._mapTileSize.width, this._mapTileSize.height)
    },
    setMapTileSize: function(a) {
        this._mapTileSize.width = a.width, this._mapTileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._mapTileSize.width
    },
    _setTileWidth: function(a) {
        this._mapTileSize.width = a
    },
    _getTileHeight: function() {
        return this._mapTileSize.height
    },
    _setTileHeight: function(a) {
        this._mapTileSize.height = a
    },
    getTiles: function() {
        return this.tiles
    },
    setTiles: function(a) {
        this.tiles = a
    },
    getTileset: function() {
        return this.tileset
    },
    setTileset: function(a) {
        this.tileset = a
    },
    getLayerOrientation: function() {
        return this.layerOrientation
    },
    setLayerOrientation: function(a) {
        this.layerOrientation = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTilesetInfo: function(a, b, c) {
        var d, e = b._layerSize,
            f = .35 * parseInt(e.width * e.height) + 1;
        return a && (d = cc.textureCache.addImage(a.sourceImage)), this.initWithTexture(d, f) ? (this.layerName = b.name, this._layerSize = e, this.tiles = b._tiles, this._minGID = b._minGID, this._maxGID = b._maxGID, this._opacity = b._opacity, this.properties = b.properties, this._contentScaleFactor = cc.director.getContentScaleFactor(), this.tileset = a, this._mapTileSize = c.getTileSize(), this.layerOrientation = c.orientation, a = this._calculateLayerOffset(b.offset), this.setPosition(cc.pointPixelsToPoints(a)), this._atlasIndexArray = [], this.setContentSize(cc.sizePixelsToPoints(cc.size(this._layerSize.width * this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height))), this._useAutomaticVertexZ = !1, this._vertexZvalue = 0, !0) : !1
    },
    releaseMap: function() {
        this.tiles && (this.tiles = null), this._atlasIndexArray && (this._atlasIndexArray = null)
    },
    getTileAt: function(a, b) {
        if (!a) throw "cc.TMXLayer.getTileAt(): pos should be non-null";
        if (void 0 !== b && (a = cc.p(a, b)), a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.getTileAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) return cc.log("cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released"), null;
        var c = null,
            d = this.getTileGIDAt(a);
        if (0 === d) return c;
        var e = 0 | a.x + a.y * this._layerSize.width,
            c = this.getChildByTag(e);
        return c || (d = this.tileset.rectForGID(d), d = cc.rectPixelsToPoints(d), c = new cc.Sprite, c.initWithTexture(this.texture, d), c.batchNode = this, c.setPosition(this.getPositionAt(a)), c.vertexZ = this._vertexZForPos(a), c.anchorX = 0, c.anchorY = 0, c.opacity = this._opacity, d = this._atlasIndexForExistantZ(e), this.addSpriteWithoutQuad(c, d, e)), c
    },
    getTileGIDAt: function(a, b) {
        if (!a) throw "cc.TMXLayer.getTileGIDAt(): pos should be non-null";
        if (void 0 !== b && (a = cc.p(a, b)), a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.getTileGIDAt(): invalid position";
        return this.tiles && this._atlasIndexArray ? (this.tiles[0 | a.x + a.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_MASK) >>> 0 : (cc.log("cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released"), null)
    },
    getTileFlagsAt: function(a, b) {
        if (!a) throw "cc.TMXLayer.getTileFlagsAt(): pos should be non-null";
        if (void 0 !== b && (a = cc.p(a, b)), a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.getTileFlagsAt(): invalid position";
        return this.tiles && this._atlasIndexArray ? (this.tiles[0 | a.x + a.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_ALL) >>> 0 : (cc.log("cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released"), null)
    },
    setTileGID: function(a, b, c, d) {
        if (!b) throw "cc.TMXLayer.setTileGID(): pos should be non-null";
        if (void 0 !== d ? b = cc.p(b, c) : d = c, b.x >= this._layerSize.width || b.y >= this._layerSize.height || 0 > b.x || 0 > b.y) throw "cc.TMXLayer.setTileGID(): invalid position";
        if (this.tiles && this._atlasIndexArray)
            if (0 !== a && a < this.tileset.firstGid) cc.log("cc.TMXLayer.setTileGID(): invalid gid:" + a);
            else {
                d = d || 0, this._setNodeDirtyForCache(), c = this.getTileFlagsAt(b);
                var e = this.getTileGIDAt(b);
                if (e != a || c != d)
                    if (c = (a | d) >>> 0, 0 === a) this.removeTileAt(b);
                    else if (0 === e) this._insertTileForGID(c, b);
                else {
                    var e = b.x + b.y * this._layerSize.width,
                        f = this.getChildByTag(e);
                    f ? (a = this.tileset.rectForGID(a), a = cc.rectPixelsToPoints(a), f.setTextureRect(a, !1), null != d && this._setupTileSprite(f, b, c), this.tiles[e] = c) : this._updateTileForGID(c, b)
                }
            } else cc.log("cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released")
    },
    removeTileAt: function(a, b) {
        if (!a) throw "cc.TMXLayer.removeTileAt(): pos should be non-null";
        if (void 0 !== b && (a = cc.p(a, b)), a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.removeTileAt(): invalid position";
        if (this.tiles && this._atlasIndexArray) {
            if (0 !== this.getTileGIDAt(a)) {
                cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
                var c = 0 | a.x + a.y * this._layerSize.width,
                    d = this._atlasIndexForExistantZ(c);
                if (this.tiles[c] = 0, this._atlasIndexArray.splice(d, 1), c = this.getChildByTag(c)) cc.SpriteBatchNode.prototype.removeChild.call(this, c, !0);
                else if (cc._renderType === cc._RENDER_TYPE_WEBGL && this.textureAtlas.removeQuadAtIndex(d), this._children)
                    for (var c = this._children, e = 0, f = c.length; f > e; e++) {
                        var g = c[e];
                        if (g) {
                            var h = g.atlasIndex;
                            h >= d && (g.atlasIndex = h - 1)
                        }
                    }
            }
        } else cc.log("cc.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released")
    },
    getPositionAt: function(a, b) {
        void 0 !== b && (a = cc.p(a, b));
        var c = cc.p(0, 0);
        switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ORTHO:
                c = this._positionForOrthoAt(a);
                break;
            case cc.TMX_ORIENTATION_ISO:
                c = this._positionForIsoAt(a);
                break;
            case cc.TMX_ORIENTATION_HEX:
                c = this._positionForHexAt(a)
        }
        return cc.pointPixelsToPoints(c)
    },
    getProperty: function(a) {
        return this.properties[a]
    },
    setupTiles: function() {
        cc._renderType === cc._RENDER_TYPE_CANVAS ? this.tileset.imageSize = this._originalTexture.getContentSizeInPixels() : (this.tileset.imageSize = this.textureAtlas.texture.getContentSizeInPixels(), this.textureAtlas.texture.setAliasTexParameters()), this._parseInternalProperties(), cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
        for (var a = this._layerSize.height, b = this._layerSize.width, c = 0; a > c; c++)
            for (var d = 0; b > d; d++) {
                var e = this.tiles[d + b * c];
                0 !== e && (this._appendTileForGID(e, cc.p(d, c)), this._minGID = Math.min(e, this._minGID), this._maxGID = Math.max(e, this._maxGID))
            }
        this._maxGID >= this.tileset.firstGid && this._minGID >= this.tileset.firstGid || cc.log("cocos2d:TMX: Only 1 tileset per layer is supported")
    },
    addChild: function() {
        cc.log("addChild: is not supported on cc.TMXLayer. Instead use setTileGID or tileAt.")
    },
    removeChild: function(a, b) {
        if (a)
            if (-1 === this._children.indexOf(a)) cc.log("cc.TMXLayer.removeChild(): Tile does not belong to TMXLayer");
            else {
                cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
                var c = a.atlasIndex;
                this.tiles[this._atlasIndexArray[c]] = 0, this._atlasIndexArray.splice(c, 1), cc.SpriteBatchNode.prototype.removeChild.call(this, a, b)
            }
    },
    getLayerName: function() {
        return this.layerName
    },
    setLayerName: function(a) {
        this.layerName = a
    },
    _positionForIsoAt: function(a) {
        return cc.p(this._mapTileSize.width / 2 * (this._layerSize.width + a.x - a.y - 1), this._mapTileSize.height / 2 * (2 * this._layerSize.height - a.x - a.y - 2))
    },
    _positionForOrthoAt: function(a) {
        return cc.p(a.x * this._mapTileSize.width, (this._layerSize.height - a.y - 1) * this._mapTileSize.height)
    },
    _positionForHexAt: function(a) {
        return cc.p(3 * a.x * this._mapTileSize.width / 4, (this._layerSize.height - a.y - 1) * this._mapTileSize.height + (1 == a.x % 2 ? -this._mapTileSize.height / 2 : 0))
    },
    _calculateLayerOffset: function(a) {
        var b = cc.p(0, 0);
        switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ORTHO:
                b = cc.p(a.x * this._mapTileSize.width, -a.y * this._mapTileSize.height);
                break;
            case cc.TMX_ORIENTATION_ISO:
                b = cc.p(this._mapTileSize.width / 2 * (a.x - a.y), this._mapTileSize.height / 2 * (-a.x - a.y));
                break;
            case cc.TMX_ORIENTATION_HEX:
                (0 !== a.x || 0 !== a.y) && cc.log("offset for hexagonal map not implemented yet")
        }
        return b
    },
    _appendTileForGID: function(a, b) {
        var c = this.tileset.rectForGID(a),
            c = cc.rectPixelsToPoints(c),
            d = 0 | b.x + b.y * this._layerSize.width,
            c = this._reusedTileWithRect(c);
        this._setupTileSprite(c, b, a);
        var e = this._atlasIndexArray.length;
        return this.insertQuadFromSprite(c, e), this._atlasIndexArray.splice(e, 0, d), c
    },
    _insertTileForGID: function(a, b) {
        var c = this.tileset.rectForGID(a),
            c = cc.rectPixelsToPoints(c),
            d = 0 | b.x + b.y * this._layerSize.width,
            c = this._reusedTileWithRect(c);
        this._setupTileSprite(c, b, a);
        var e = this._atlasIndexForNewZ(d);
        if (this.insertQuadFromSprite(c, e), this._atlasIndexArray.splice(e, 0, d), this._children)
            for (var f = this._children, g = 0, h = f.length; h > g; g++) {
                var i = f[g];
                if (i) {
                    var j = i.atlasIndex;
                    j >= e && (i.atlasIndex = j + 1)
                }
            }
        return this.tiles[d] = a, c
    },
    _updateTileForGID: function(a, b) {
        var c = this.tileset.rectForGID(a),
            d = this._contentScaleFactor,
            c = cc.rect(c.x / d, c.y / d, c.width / d, c.height / d),
            d = b.x + b.y * this._layerSize.width,
            c = this._reusedTileWithRect(c);
        return this._setupTileSprite(c, b, a), c.atlasIndex = this._atlasIndexForExistantZ(d), c.dirty = !0, c.updateTransform(), this.tiles[d] = a, c
    },
    _parseInternalProperties: function() {
        var a = this.getProperty("cc_vertexz");
        if (a)
            if ("automatic" == a) {
                this._useAutomaticVertexZ = !0;
                var b = this.getProperty("cc_alpha_func"),
                    a = 0;
                b && (a = parseFloat(b)), cc._renderType === cc._RENDER_TYPE_WEBGL && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), b = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S), this.shaderProgram.use(), this.shaderProgram.setUniformLocationWith1f(b, a))
            } else this._vertexZvalue = parseInt(a, 10)
    },
    _setupTileSprite: function(a, b, c) {
        var d = b.x + b.y * this._layerSize.width;
        a.setPosition(this.getPositionAt(b)), cc._renderType === cc._RENDER_TYPE_WEBGL ? a.vertexZ = this._vertexZForPos(b) : a.tag = d, a.anchorX = 0, a.anchorY = 0, a.opacity = this._opacity, cc._renderType === cc._RENDER_TYPE_WEBGL && (a.rotation = 0), a.setFlippedX(!1), a.setFlippedY(!1), (c & cc.TMX_TILE_DIAGONAL_FLAG) >>> 0 ? (a.anchorX = .5, a.anchorY = .5, a.x = this.getPositionAt(b).x + a.width / 2, a.y = this.getPositionAt(b).y + a.height / 2, b = (c & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0) >>> 0, b == cc.TMX_TILE_HORIZONTAL_FLAG ? a.rotation = 90 : b == cc.TMX_TILE_VERTICAL_FLAG ? a.rotation = 270 : (a.rotation = b == (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 ? 90 : 270, a.setFlippedX(!0))) : ((c & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 && a.setFlippedX(!0), (c & cc.TMX_TILE_VERTICAL_FLAG) >>> 0 && a.setFlippedY(!0))
    },
    _reusedTileWithRect: function(a) {
        return cc._renderType === cc._RENDER_TYPE_WEBGL ? (this._reusedTile ? (this._reusedTile.batchNode = null, this._reusedTile.setTextureRect(a, !1)) : (this._reusedTile = new cc.Sprite, this._reusedTile.initWithTexture(this.texture, a, !1)), this._reusedTile.batchNode = this) : (this._reusedTile = new cc.Sprite, this._reusedTile.initWithTexture(this._textureForCanvas, a, !1), this._reusedTile.batchNode = this, this._reusedTile.parent = this), this._reusedTile
    },
    _vertexZForPos: function(a) {
        var b = 0,
            c = 0;
        if (this._useAutomaticVertexZ) switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ISO:
                c = this._layerSize.width + this._layerSize.height, b = -(c - (a.x + a.y));
                break;
            case cc.TMX_ORIENTATION_ORTHO:
                b = -(this._layerSize.height - a.y);
                break;
            case cc.TMX_ORIENTATION_HEX:
                cc.log("TMX Hexa zOrder not supported");
                break;
            default:
                cc.log("TMX invalid value")
        } else b = this._vertexZvalue;
        return b
    },
    _atlasIndexForExistantZ: function(a) {
        var b;
        if (this._atlasIndexArray)
            for (var c = this._atlasIndexArray, d = 0, e = c.length; e > d && (b = c[d], !(b == a)); d++);
        return "number" != typeof b && cc.log("cc.TMXLayer._atlasIndexForExistantZ(): TMX atlas index not found. Shall not happen"), d
    },
    _atlasIndexForNewZ: function(a) {
        for (var b = this._atlasIndexArray, c = 0, d = b.length; d > c && !(a < b[c]); c++);
        return c
    }
}), _p = cc.TMXLayer.prototype, cc._renderType == cc._RENDER_TYPE_WEBGL ? (_p.draw = cc.SpriteBatchNode.prototype.draw, _p.visit = cc.SpriteBatchNode.prototype.visit, _p.getTexture = cc.SpriteBatchNode.prototype.getTexture) : (_p.draw = _p._drawForCanvas, _p.visit = _p._visitForCanvas, _p.getTexture = _p._getTextureForCanvas), cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture), cc.defineGetterSetter(_p, "layerWidth", _p._getLayerWidth, _p._setLayerWidth), cc.defineGetterSetter(_p, "layerHeight", _p._getLayerHeight, _p._setLayerHeight), cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth), cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight), cc.TMXLayer.create = function(a, b, c) {
    return new cc.TMXLayer(a, b, c)
}, cc.PointObject = cc.Class.extend({
    _ratio: null,
    _offset: null,
    _child: null,
    ctor: function(a, b) {
        this.initWithCCPoint(a, b)
    },
    getRatio: function() {
        return this._ratio
    },
    setRatio: function(a) {
        this._ratio = a
    },
    getOffset: function() {
        return this._offset
    },
    setOffset: function(a) {
        this._offset = a
    },
    getChild: function() {
        return this._child
    },
    setChild: function(a) {
        this._child = a
    },
    initWithCCPoint: function(a, b) {
        return this._ratio = a, this._offset = b, this._child = null, !0
    }
}), cc.PointObject.create = function(a, b) {
    return new cc.PointObject(a, b)
}, cc.ParallaxNode = cc.Node.extend({
    parallaxArray: null,
    _lastPosition: null,
    _className: "ParallaxNode",
    getParallaxArray: function() {
        return this.parallaxArray
    },
    setParallaxArray: function(a) {
        this.parallaxArray = a
    },
    ctor: function() {
        cc.Node.prototype.ctor.call(this), this.parallaxArray = [], this._lastPosition = cc.p(-100, -100)
    },
    addChild: function(a, b, c, d) {
        if (3 === arguments.length) cc.log("ParallaxNode: use addChild(child, z, ratio, offset) instead");
        else {
            if (!a) throw "cc.ParallaxNode.addChild(): child should be non-null";
            var e = new cc.PointObject(c, d);
            e.setChild(a), this.parallaxArray.push(e), a.setPosition(this._position.x * c.x + d.x, this._position.y * c.y + d.y), cc.Node.prototype.addChild.call(this, a, b, a.tag)
        }
    },
    removeChild: function(a, b) {
        for (var c = this.parallaxArray, d = 0; d < c.length; d++)
            if (c[d].getChild() == a) {
                c.splice(d, 1);
                break
            }
        cc.Node.prototype.removeChild.call(this, a, b)
    },
    removeAllChildren: function(a) {
        this.parallaxArray.length = 0, cc.Node.prototype.removeAllChildren.call(this, a)
    },
    visit: function() {
        var a = this._absolutePosition();
        if (!cc.pointEqualToPoint(a, this._lastPosition)) {
            for (var b = this.parallaxArray, c = 0, d = b.length; d > c; c++) {
                var e = b[c];
                e.getChild().setPosition(-a.x + a.x * e.getRatio().x + e.getOffset().x, -a.y + a.y * e.getRatio().y + e.getOffset().y)
            }
            this._lastPosition = a
        }
        cc.Node.prototype.visit.call(this)
    },
    _absolutePosition: function() {
        for (var a = this._position, b = this; null != b.parent;) b = b.parent, a = cc.pAdd(a, b.getPosition());
        return a
    }
}), cc.ParallaxNode.create = function() {
    return new cc.ParallaxNode
}, cc.sys._supportWebAudio) {
    var _ctx = cc.webAudioContext = new(window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
    cc.WebAudio = cc.Class.extend({
        _events: null,
        _buffer: null,
        _sourceNode: null,
        _volumeNode: null,
        src: null,
        preload: null,
        autoplay: null,
        controls: null,
        mediagroup: null,
        currentTime: 0,
        startTime: 0,
        duration: 0,
        _loop: null,
        _volume: 1,
        _pauseTime: 0,
        _paused: !1,
        _stopped: !0,
        _loadState: -1,
        ctor: function(a) {
            this._events = {}, this.src = a, this._volumeNode = _ctx.createGain ? _ctx.createGain() : _ctx.createGainNode(), this._onSuccess1 = this._onSuccess.bind(this), this._onError1 = this._onError.bind(this)
        },
        _play: function(a) {
            var b = this._sourceNode = _ctx.createBufferSource(),
                c = this._volumeNode;
            a = a || 0, b.buffer = this._buffer, c.gain.value = this._volume, b.connect(c), c.connect(_ctx.destination), b.loop = this._loop, b._stopped = !1, b.playbackState || (b.onended = function() {
                this._stopped = !0
            }), this._stopped = this._paused = !1, b.start ? b.start(0, a) : b.noteGrainOn ? (c = b.buffer.duration, this.loop ? b.noteGrainOn(0, a, c) : b.noteGrainOn(0, a, c - a)) : b.noteOn(0), this._pauseTime = 0
        },
        _stop: function() {
            var a = this._sourceNode;
            this._stopped || (a.stop ? a.stop(0) : a.noteOff(0), this._stopped = !0)
        },
        play: function() {
            if (-1 == this._loadState) this._loadState = 0;
            else if (1 == this._loadState) {
                var a = this._sourceNode;
                (this._stopped || !a || 2 != a.playbackState && a._stopped) && (this.startTime = _ctx.currentTime, this._play(0))
            }
        },
        pause: function() {
            this._pauseTime = _ctx.currentTime, this._paused = !0, this._stop()
        },
        resume: function() {
            this._paused && this._play(this._buffer ? (this._pauseTime - this.startTime) % this._buffer.duration : 0)
        },
        stop: function() {
            this._pauseTime = 0, this._paused = !1, this._stop()
        },
        load: function() {
            var a = this;
            if (1 != a._loadState) {
                a._loadState = -1, a.played = !1, a.ended = !0;
                var b = new XMLHttpRequest;
                b.open("GET", a.src, !0), b.responseType = "arraybuffer", b.onload = function() {
                    _ctx.decodeAudioData(b.response, a._onSuccess1, a._onError1)
                }, b.send()
            }
        },
        addEventListener: function(a, b) {
            this._events[a] = b.bind(this)
        },
        removeEventListener: function(a) {
            delete this._events[a]
        },
        canplay: function() {
            return cc.sys._supportWebAudio
        },
        _onSuccess: function(a) {
            this._buffer = a, a = this._events.success;
            var b = this._events.canplaythrough;
            a && a(), b && b(), (0 == this._loadState || "autoplay" == this.autoplay || 1 == this.autoplay) && this._play(), this._loadState = 1
        },
        _onError: function() {
            var a = this._events.error;
            a && a(), this._loadState = -2
        },
        cloneNode: function() {
            var a = new cc.WebAudio(this.src);
            return a.volume = this.volume, a._loadState = this._loadState, a._buffer = this._buffer, (0 == a._loadState || -1 == a._loadState) && a.load(), a
        }
    }), _p = cc.WebAudio.prototype, cc.defineGetterSetter(_p, "loop", function() {
        return this._loop
    }, function(a) {
        this._loop = a, this._sourceNode && (this._sourceNode.loop = a)
    }), cc.defineGetterSetter(_p, "volume", function() {
        return this._volume
    }, function(a) {
        this._volume = a, this._volumeNode.gain.value = a
    }), cc.defineGetterSetter(_p, "paused", function() {
        return this._paused
    }), cc.defineGetterSetter(_p, "ended", function() {
        var a = this._sourceNode;
        return this._paused ? !1 : this._stopped && !a ? !0 : null == a.playbackState ? a._stopped : 3 == a.playbackState
    }), cc.defineGetterSetter(_p, "played", function() {
        var a = this._sourceNode;
        return a && (2 == a.playbackState || !a._stopped)
    })
}
cc.AudioEngine = cc.Class.extend({
    _soundSupported: !1,
    _currMusic: null,
    _currMusicPath: null,
    _musicPlayState: 0,
    _audioID: 0,
    _effects: {},
    _audioPool: {},
    _effectsVolume: 1,
    _maxAudioInstance: 5,
    _effectPauseCb: null,
    _playings: [],
    ctor: function() {
        this._soundSupported = 0 < cc._audioLoader._supportedAudioTypes.length, this._effectPauseCb && (this._effectPauseCb = this._effectPauseCb.bind(this))
    },
    willPlayMusic: function() {
        return !1
    },
    getEffectsVolume: function() {
        return this._effectsVolume
    },
    playMusic: function(a, b) {
        if (this._soundSupported) {
            var c = this._currMusic;
            c && this._stopAudio(c), cc.sys.isMobile && cc.sys.os == cc.sys.OS_IOS ? (c = this._getAudioByUrl(a), this._currMusic = c.cloneNode(), this._currMusicPath = a) : a != this._currMusicPath && (this._currMusic = c = this._getAudioByUrl(a), this._currMusicPath = a), this._currMusic && (this._currMusic.loop = b || !1, this._playMusic(this._currMusic))
        }
    },
    _getAudioByUrl: function(a) {
        var b = cc.loader,
            c = b.getRes(a);
        return c || (b.load(a), c = b.getRes(a)), c
    },
    _playMusic: function(a) {
        a.ended || (a.stop ? a.stop() : (a.pause(), 2 < a.readyState && (a.currentTime = 0))), this._musicPlayState = 2, a.play()
    },
    stopMusic: function(a) {
        if (0 < this._musicPlayState) {
            var b = this._currMusic;
            b && this._stopAudio(b) && (a && cc.loader.release(this._currMusicPath), this._currMusicPath = this._currMusic = null, this._musicPlayState = 0)
        }
    },
    _stopAudio: function(a) {
        return a && !a.ended ? (a.stop ? a.stop() : (a.pause(), 2 < a.readyState && a.duration && 1 / 0 != a.duration && (a.currentTime = a.duration)), !0) : !1
    },
    pauseMusic: function() {
        2 == this._musicPlayState && (this._currMusic.pause(), this._musicPlayState = 1)
    },
    resumeMusic: function() {
        1 == this._musicPlayState && (this._resumeAudio(this._currMusic), this._musicPlayState = 2)
    },
    _resumeAudio: function(a) {
        a && !a.ended && (a.resume ? a.resume() : a.play())
    },
    rewindMusic: function() {
        this._currMusic && this._playMusic(this._currMusic)
    },
    getMusicVolume: function() {
        return 0 == this._musicPlayState ? 0 : this._currMusic.volume
    },
    setMusicVolume: function(a) {
        0 < this._musicPlayState && (this._currMusic.volume = Math.min(Math.max(a, 0), 1))
    },
    isMusicPlaying: function() {
        return 2 == this._musicPlayState && this._currMusic && !this._currMusic.ended
    },
    _getEffectList: function(a) {
        var b = this._audioPool[a];
        return b || (b = this._audioPool[a] = []), b
    },
    _getEffect: function(a) {
        var b;
        if (!this._soundSupported) return null;
        var c = this._getEffectList(a);
        if (cc.sys.isMobile && cc.sys.os == cc.sys.OS_IOS) b = this._getEffectAudio(c, a);
        else {
            for (var d = 0, e = c.length; e > d; d++) {
                var f = c[d];
                if (f.ended) {
                    b = f, 2 < b.readyState && (b.currentTime = 0), window.chrome && b.load();
                    break
                }
            }
            b || (b = this._getEffectAudio(c, a)) && c.push(b)
        }
        return b
    },
    _getEffectAudio: function(a, b) {
        var c;
        return a.length >= this._maxAudioInstance ? (cc.log("Error: " + b + " greater than " + this._maxAudioInstance), null) : (c = this._getAudioByUrl(b)) ? (c = c.cloneNode(!0), this._effectPauseCb && cc._addEventListener(c, "pause", this._effectPauseCb), c.volume = this._effectsVolume, c) : null
    },
    playEffect: function(a, b) {
        var c = this._getEffect(a);
        if (!c) return null;
        c.loop = b || !1, c.play();
        var d = this._audioID++;
        return this._effects[d] = c, d
    },
    setEffectsVolume: function(a) {
        a = this._effectsVolume = Math.min(Math.max(a, 0), 1);
        var b, c = this._effects;
        for (b in c) c[b].volume = a
    },
    pauseEffect: function(a) {
        (a = this._effects[a]) && !a.ended && a.pause()
    },
    pauseAllEffects: function() {
        var a, b = this._effects;
        for (a in b) {
            var c = b[a];
            c.ended || c.pause()
        }
    },
    resumeEffect: function(a) {
        this._resumeAudio(this._effects[a])
    },
    resumeAllEffects: function() {
        var a, b = this._effects;
        for (a in b) this._resumeAudio(b[a])
    },
    stopEffect: function(a) {
        this._stopAudio(this._effects[a]), delete this._effects[a]
    },
    stopAllEffects: function() {
        var a, b = this._effects;
        for (a in b) this._stopAudio(b[a]), delete b[a]
    },
    unloadEffect: function(a) {
        var b = cc.loader,
            c = this._effects,
            d = this._getEffectList(a);
        if (b.release(a), 0 != d.length) {
            b = d[0].src, delete this._audioPool[a];
            for (var e in c) c[e].src == b && (this._stopAudio(c[e]), delete c[e])
        }
    },
    end: function() {
        this.stopMusic(), this.stopAllEffects()
    },
    _pausePlaying: function() {
        var a, b, c = this._effects;
        for (b in c)!(a = c[b]) || a.ended || a.paused || (this._playings.push(a), a.pause());
        this.isMusicPlaying() && (this._playings.push(this._currMusic), this._currMusic.pause())
    },
    _resumePlaying: function() {
        for (var a = this._playings, b = 0, c = a.length; c > b; b++) this._resumeAudio(a[b]);
        a.length = 0
    }
}), !cc.sys._supportWebAudio && 0 > cc.sys._supportMultipleAudio && (cc.AudioEngineForSingle = cc.AudioEngine.extend({
    _waitingEffIds: [],
    _pausedEffIds: [],
    _currEffect: null,
    _maxAudioInstance: 2,
    _effectCache4Single: {},
    _needToResumeMusic: !1,
    _expendTime4Music: 0,
    _isHiddenMode: !1,
    _playMusic: function(a) {
        this._stopAllEffects(), this._super(a)
    },
    resumeMusic: function() {
        1 == this._musicPlayState && (this._stopAllEffects(), this._needToResumeMusic = !1, this._expendTime4Music = 0, this._super())
    },
    playEffect: function(a, b) {
        var c = this._currEffect,
            d = b ? this._getEffect(a) : this._getSingleEffect(a);
        if (!d) return null;
        d.loop = b || !1;
        var e = this._audioID++;
        return this._effects[e] = d, this.isMusicPlaying() && (this.pauseMusic(), this._needToResumeMusic = !0), c ? (c != d && this._waitingEffIds.push(this._currEffectId), this._waitingEffIds.push(e), c.pause()) : (this._currEffect = d, this._currEffectId = e, d.play()), e
    },
    pauseEffect: function() {
        cc.log("pauseEffect not supported in single audio mode!")
    },
    pauseAllEffects: function() {
        var a = this._waitingEffIds,
            b = this._pausedEffIds,
            c = this._currEffect;
        if (c) {
            for (var d = 0, e = a.length; e > d; d++) b.push(a[d]);
            a.length = 0, b.push(this._currEffectId), c.pause()
        }
    },
    resumeEffect: function() {
        cc.log("resumeEffect not supported in single audio mode!")
    },
    resumeAllEffects: function() {
        var a = this._waitingEffIds,
            b = this._pausedEffIds;
        this.isMusicPlaying() && (this.pauseMusic(), this._needToResumeMusic = !0);
        for (var c = 0, d = b.length; d > c; c++) a.push(b[c]);
        b.length = 0, !this._currEffect && 0 <= a.length && (a = a.pop(), b = this._effects[a]) && (this._currEffectId = a, this._currEffect = b, this._resumeAudio(b))
    },
    stopEffect: function(a) {
        var b = this._currEffect,
            c = this._waitingEffIds,
            d = this._pausedEffIds;
        b && this._currEffectId == a ? this._stopAudio(b) : (b = c.indexOf(a), b >= 0 ? c.splice(b, 1) : (b = d.indexOf(a), b >= 0 && d.splice(b, 1)))
    },
    stopAllEffects: function() {
        this._stopAllEffects(), !this._currEffect && this._needToResumeMusic && (this._resumeAudio(this._currMusic), this._musicPlayState = 2, this._needToResumeMusic = !1, this._expendTime4Music = 0)
    },
    unloadEffect: function(a) {
        var b = cc.loader,
            c = this._effects,
            d = this._effectCache4Single,
            e = this._getEffectList(a),
            f = this._currEffect;
        if (b.release(a), 0 != e.length || d[a]) {
            b = 0 < e.length ? e[0].src : d[a].src, delete this._audioPool[a], delete d[a];
            for (var g in c) c[g].src == b && delete c[g];
            f && f.src == b && this._stopAudio(f)
        }
    },
    _getSingleEffect: function(a) {
        var b = this._effectCache4Single[a],
            c = this._waitingEffIds,
            d = this._pausedEffIds,
            e = this._effects;
        if (b) 2 < b.readyState && (b.currentTime = 0);
        else {
            if (b = this._getAudioByUrl(a), !b) return null;
            b = b.cloneNode(!0), this._effectPauseCb && cc._addEventListener(b, "pause", this._effectPauseCb), b.volume = this._effectsVolume, this._effectCache4Single[a] = b
        }
        a = 0;
        for (var f = c.length; f > a;) e[c[a]] == b ? c.splice(a, 1) : a++;
        for (a = 0, f = d.length; f > a;) e[d[a]] == b ? d.splice(a, 1) : a++;
        return b._isToPlay = !0, b
    },
    _stopAllEffects: function() {
        var a = this._currEffect,
            b = this._audioPool,
            c = this._effectCache4Single,
            d = this._waitingEffIds,
            e = this._pausedEffIds;
        if (a || 0 != d.length || 0 != e.length) {
            for (var f in c) {
                var g = c[f];
                2 < g.readyState && g.duration && 1 / 0 != g.duration && (g.currentTime = g.duration)
            }
            d.length = 0, e.length = 0;
            for (f in b)
                for (c = b[f], d = 0, e = c.length; e > d; d++) g = c[d], g.loop = !1, 2 < g.readyState && g.duration && 1 / 0 != g.duration && (g.currentTime = g.duration);
            a && this._stopAudio(a)
        }
    },
    _effectPauseCb: function() {
        if (!this._isHiddenMode) {
            var a = this._getWaitingEffToPlay();
            if (a) a._isToPlay ? (delete a._isToPlay, a.play()) : this._resumeAudio(a);
            else if (this._needToResumeMusic) {
                if (a = this._currMusic, 2 < a.readyState && a.duration && 1 / 0 != a.duration) {
                    var b = a.currentTime + this._expendTime4Music,
                        b = b - a.duration * (b / a.duration | 0);
                    a.currentTime = b
                }
                this._expendTime4Music = 0, this._resumeAudio(a), this._musicPlayState = 2, this._needToResumeMusic = !1
            }
        }
    },
    _getWaitingEffToPlay: function() {
        var a = this._waitingEffIds,
            b = this._effects,
            c = this._currEffect,
            d = c ? c.currentTime - (c.startTime || 0) : 0;
        for (this._expendTime4Music += d; 0 != a.length;) {
            var e = a.pop();
            if (c = b[e]) {
                if (c._isToPlay || c.loop || c.duration && c.currentTime + d < c.duration) return this._currEffectId = e, this._currEffect = c, !c._isToPlay && 2 < c.readyState && c.duration && 1 / 0 != c.duration && (a = c.currentTime + d, a -= c.duration * (a / c.duration | 0), c.currentTime = a), c._isToPlay = !1, c;
                2 < c.readyState && c.duration && 1 / 0 != c.duration && (c.currentTime = c.duration)
            }
        }
        return this._currEffect = this._currEffectId = null
    },
    _pausePlaying: function() {
        var a = this._currEffect;
        this._isHiddenMode = !0, (a = 2 == this._musicPlayState ? this._currMusic : a) && (this._playings.push(a), a.pause())
    },
    _resumePlaying: function() {
        var a = this._playings;
        this._isHiddenMode = !1, 0 < a.length && (this._resumeAudio(a[0]), a.length = 0)
    }
})), cc._audioLoader = {
    _supportedAudioTypes: null,
    getBasePath: function() {
        return cc.loader.audioPath
    },
    _load: function(a, b, c, d, e, f, g) {
        var h = this,
            i = cc.loader,
            j = cc.path,
            k = this._supportedAudioTypes,
            l = "";
        if (0 == k.length) return g("can not support audio!");
        if (-1 == d) l = (j.extname(a) || "").toLowerCase(), h.audioTypeSupported(l) || (l = k[0], d = 0);
        else {
            if (!(d < k.length)) return g("can not found the resource of audio! Last match url is : " + a);
            l = k[d]
        }
        return 0 <= e.indexOf(l) ? h._load(a, b, c, d + 1, e, f, g) : (a = j.changeExtname(a, l), e.push(l), f = h._loadAudio(a, f, function(i) {
            return i ? h._load(a, b, c, d + 1, e, f, g) : void g(null, f)
        }, d == k.length - 1), void(i.cache[b] = f))
    },
    audioTypeSupported: function(a) {
        return a ? 0 <= this._supportedAudioTypes.indexOf(a.toLowerCase()) : !1
    },
    _loadAudio: function(a, b, c, d) {
        var e;
        return e = "object" != typeof window.cc && "firefox" == cc.sys.browserType ? Audio : "file://" == location.origin ? Audio : cc.WebAudio || Audio, 2 == arguments.length ? (c = b, b = new e) : 3 < arguments.length && !b && (b = new e), b.src = a, b.preload = "auto", e = navigator.userAgent, /Mobile/.test(e) && (/iPhone OS/.test(e) || /iPad/.test(e) || /Firefox/.test(e)) || /MSIE/.test(e) ? (b.load(), c(null, b)) : (cc._addEventListener(b, "canplaythrough", function() {
            c(null, b), this.removeEventListener("canplaythrough", arguments.callee, !1), this.removeEventListener("error", arguments.callee, !1)
        }, !1), cc._addEventListener(b, "error", function() {
            c("load " + a + " failed"), d && (this.removeEventListener("canplaythrough", arguments.callee, !1), this.removeEventListener("error", arguments.callee, !1))
        }, !1), b.load()), b
    },
    load: function(a, b, c, d) {
        this._load(a, b, c, -1, [], null, d)
    }
}, cc._audioLoader._supportedAudioTypes = function() {
    var a = cc.newElement("audio"),
        b = [];
    if (a.canPlayType) {
        var c = function(b) {
            return b = a.canPlayType(b), "no" != b && "" != b
        };
        c('audio/ogg; codecs="vorbis"') && b.push(".ogg"), c("audio/mpeg") && b.push(".mp3"), c('audio/wav; codecs="1"') && b.push(".wav"), c("audio/mp4") && b.push(".mp4"), (c("audio/x-m4a") || c("audio/aac")) && b.push(".m4a")
    }
    return b
}(), cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], cc._audioLoader), cc.audioEngine = cc.AudioEngineForSingle ? new cc.AudioEngineForSingle : new cc.AudioEngine, cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {
    cc.audioEngine._pausePlaying()
}), cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
    cc.audioEngine._resumePlaying()
}), cc.CONTROL_EVENT_TOTAL_NUMBER = 9, cc.CONTROL_EVENT_TOUCH_DOWN = 1, cc.CONTROL_EVENT_TOUCH_DRAG_INSIDE = 2, cc.CONTROL_EVENT_TOUCH_DRAG_OUTSIDE = 4, cc.CONTROL_EVENT_TOUCH_DRAG_ENTER = 8, cc.CONTROL_EVENT_TOUCH_DRAG_EXIT = 16, cc.CONTROL_EVENT_TOUCH_UP_INSIDE = 32, cc.CONTROL_EVENT_TOUCH_UP_OUTSIDE = 64, cc.CONTROL_EVENT_TOUCH_CANCEL = 128, cc.CONTROL_EVENT_VALUECHANGED = 256, cc.CONTROL_STATE_NORMAL = 1, cc.CONTROL_STATE_HIGHLIGHTED = 2, cc.CONTROL_STATE_DISABLED = 4, cc.CONTROL_STATE_SELECTED = 8, cc.CONTROL_STATE_INITIAL = 8, cc.Control = cc.Layer.extend({
    _isOpacityModifyRGB: !1,
    _hasVisibleParents: !1,
    _touchListener: null,
    _className: "Control",
    isOpacityModifyRGB: function() {
        return this._isOpacityModifyRGB
    },
    setOpacityModifyRGB: function(a) {
        this._isOpacityModifyRGB = a;
        for (var b = this.getChildren(), c = 0, d = b.length; d > c; c++) {
            var e = b[c];
            e && e.setOpacityModifyRGB(a)
        }
    },
    _state: cc.CONTROL_STATE_NORMAL,
    getState: function() {
        return this._state
    },
    _enabled: !1,
    _selected: !1,
    _highlighted: !1,
    _dispatchTable: null,
    setEnabled: function(a) {
        this._state = (this._enabled = a) ? cc.CONTROL_STATE_NORMAL : cc.CONTROL_STATE_DISABLED, this.needsLayout()
    },
    isEnabled: function() {
        return this._enabled
    },
    setSelected: function(a) {
        this._selected = a, this.needsLayout()
    },
    isSelected: function() {
        return this._selected
    },
    setHighlighted: function(a) {
        this._highlighted = a, this.needsLayout()
    },
    isHighlighted: function() {
        return this._highlighted
    },
    hasVisibleParents: function() {
        for (var a = this.getParent(); null != a; a = a.getParent())
            if (!a.isVisible()) return !1;
        return !0
    },
    ctor: function() {
        cc.Layer.prototype.ctor.call(this), this._dispatchTable = {}, this._color = cc.color.WHITE
    },
    init: function() {
        if (cc.Layer.prototype.init.call(this)) {
            this._state = cc.CONTROL_STATE_NORMAL, this._enabled = !0, this._highlighted = this._selected = !1;
            var a = cc.EventListener.create({
                event: cc.EventListener.TOUCH_ONE_BY_ONE
            });
            return this.onTouchBegan && (a.onTouchBegan = this.onTouchBegan.bind(this)), this.onTouchMoved && (a.onTouchMoved = this.onTouchMoved.bind(this)), this.onTouchEnded && (a.onTouchEnded = this.onTouchEnded.bind(this)), this.onTouchCancelled && (a.onTouchCancelled = this.onTouchCancelled.bind(this)), this._touchListener = a, !0
        }
        return !1
    },
    onEnter: function() {
        var a = this._touchListener;
        a._isRegistered() || cc.eventManager.addListener(a, this), cc.Node.prototype.onEnter.call(this)
    },
    sendActionsForControlEvents: function(a) {
        for (var b = 0, c = cc.CONTROL_EVENT_TOTAL_NUMBER; c > b; b++)
            if (a & 1 << b)
                for (var d = this._dispatchListforControlEvent(1 << b), e = 0, f = d.length; f > e; e++) d[e].invoke(this)
    },
    addTargetWithActionForControlEvents: function(a, b, c) {
        for (var d = 0, e = cc.CONTROL_EVENT_TOTAL_NUMBER; e > d; d++) c & 1 << d && this._addTargetWithActionForControlEvent(a, b, 1 << d)
    },
    removeTargetWithActionForControlEvents: function(a, b, c) {
        for (var d = 0, e = cc.CONTROL_EVENT_TOTAL_NUMBER; e > d; d++) c & 1 << d && this._removeTargetWithActionForControlEvent(a, b, 1 << d)
    },
    getTouchLocation: function(a) {
        return a = a.getLocation(), this.convertToNodeSpace(a)
    },
    isTouchInside: function(a) {
        return a = a.getLocation(), a = this.getParent().convertToNodeSpace(a), cc.rectContainsPoint(this.getBoundingBox(), a)
    },
    _invocationWithTargetAndActionForControlEvent: function() {
        return null
    },
    _dispatchListforControlEvent: function(a) {
        return a = a.toString(), this._dispatchTable[a] || (this._dispatchTable[a] = []), this._dispatchTable[a]
    },
    _addTargetWithActionForControlEvent: function(a, b, c) {
        a = new cc.Invocation(a, b, c), this._dispatchListforControlEvent(c).push(a)
    },
    _removeTargetWithActionForControlEvent: function(a, b, c) {
        if (c = this._dispatchListforControlEvent(c), a || b)
            for (var d = 0; d < c.length;) {
                var e = c[d],
                    f = !0;
                a && (f = a == e.getTarget()), b && (f = f && b == e.getAction()), f ? cc.arrayRemoveObject(c, e) : d++
            } else c.length = 0
    },
    needsLayout: function() {}
}), _p = cc.Control.prototype, cc.defineGetterSetter(_p, "state", _p.getState), cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled), cc.defineGetterSetter(_p, "selected", _p.isSelected, _p.setSelected), cc.defineGetterSetter(_p, "highlighted", _p.isHighlighted, _p.setHighlighted), _p = null, cc.Control.create = function() {
    var a = new cc.Control;
    return a && a.init() ? a : null
}, cc.CONTROL_ZOOM_ACTION_TAG = 3435855873, cc.ControlButton = cc.Control.extend({
    _doesAdjustBackgroundImage: !1,
    zoomOnTouchDown: !1,
    _preferredSize: null,
    _labelAnchorPoint: null,
    _currentTitle: null,
    _currentTitleColor: null,
    _titleLabel: null,
    _backgroundSprite: null,
    _opacity: 0,
    _isPushed: !1,
    _titleDispatchTable: null,
    _titleColorDispatchTable: null,
    _titleLabelDispatchTable: null,
    _backgroundSpriteDispatchTable: null,
    _parentInited: !1,
    _marginV: 0,
    _marginH: 0,
    _className: "ControlButton",
    ctor: function(a, b, c) {
        cc.Control.prototype.ctor.call(this), this._preferredSize = cc.size(0, 0), this._labelAnchorPoint = cc.p(0, 0), this._currentTitle = "", this._currentTitleColor = cc.color.WHITE, this._titleDispatchTable = {}, this._titleColorDispatchTable = {}, this._titleLabelDispatchTable = {}, this._backgroundSpriteDispatchTable = {}, void 0 != c ? this.initWithTitleAndFontNameAndFontSize(a, b, c) : void 0 != b ? this.initWithLabelAndBackgroundSprite(a, b) : void 0 != a ? this.initWithBackgroundSprite(a) : this.init()
    },
    init: function() {
        return this.initWithLabelAndBackgroundSprite(cc.LabelTTF.create("", "Arial", 12), cc.Scale9Sprite.create())
    },
    needsLayout: function() {
        if (this._parentInited) {
            this._titleLabel && this._titleLabel.setVisible(!1), this._backgroundSprite && this._backgroundSprite.setVisible(!1), this.setLabelAnchorPoint(this._labelAnchorPoint);
            var a = this._state;
            this._currentTitle = this.getTitleForState(a), this._currentTitleColor = this.getTitleColorForState(a);
            var b = this._titleLabel = this.getTitleLabelForState(a);
            b && b.setString && b.setString(this._currentTitle), b && b.setColor(this._currentTitleColor);
            var c = this.getContentSize();
            if (b && b.setPosition(c.width / 2, c.height / 2), (a = this._backgroundSprite = this.getBackgroundSpriteForState(a)) && a.setPosition(c.width / 2, c.height / 2), c = cc.size(0, 0), b) {
                var d = b.getBoundingBox();
                c.width = d.width, c.height = d.height
            }
            this._doesAdjustBackgroundImage ? a && a.setContentSize(c.width + 2 * this._marginH, c.height + 2 * this._marginV) : a && (d = a.getPreferredSize(), d = cc.size(d.width, d.height), 0 >= d.width && (d.width = c.width), 0 >= d.height && (d.height = c.height), a.setContentSize(d)), c = b ? b.getBoundingBox() : cc.rect(0, 0, 0, 0), d = a ? a.getBoundingBox() : cc.rect(0, 0, 0, 0), c = cc.rectUnion(c, d), this.setContentSize(c.width, c.height), c = this.getContentSize(), b && (b.setPosition(c.width / 2, c.height / 2), b.setVisible(!0)), a && (a.setPosition(c.width / 2, c.height / 2), a.setVisible(!0))
        }
    },
    initWithLabelAndBackgroundSprite: function(a, b) {
        if (!a) throw "cc.ControlButton.initWithLabelAndBackgroundSprite(): label should be non-null";
        if (!b) throw "cc.ControlButton.initWithLabelAndBackgroundSprite(): backgroundSprite should be non-null";
        if (cc.Control.prototype.init.call(this, !0)) {
            this._parentInited = !0, this._titleDispatchTable = {}, this._titleColorDispatchTable = {}, this._titleLabelDispatchTable = {}, this._backgroundSpriteDispatchTable = {}, this._isPushed = !1, this.zoomOnTouchDown = !0, this._currentTitle = null, this.setAdjustBackgroundImage(!0), this.setPreferredSize(cc.size(0, 0)), this.zoomOnTouchDown = !0, this.ignoreAnchorPointForPosition(!1), this.setAnchorPoint(.5, .5), this._titleLabel = a, this._backgroundSprite = b, this.setOpacity(255), this.setOpacityModifyRGB(!0);
            var c = a.getString();
            return this.setTitleForState(c, cc.CONTROL_STATE_NORMAL), this.setTitleColorForState(a.getColor(), cc.CONTROL_STATE_NORMAL), this.setTitleLabelForState(a, cc.CONTROL_STATE_NORMAL), this.setBackgroundSpriteForState(b, cc.CONTROL_STATE_NORMAL), this._state = cc.CONTROL_STATE_NORMAL, this._marginH = 24, this._marginV = 12, this._labelAnchorPoint = cc.p(.5, .5), this.setPreferredSize(cc.size(0, 0)), this.needsLayout(), !0
        }
        return !1
    },
    initWithTitleAndFontNameAndFontSize: function(a, b, c) {
        return a = cc.LabelTTF.create(a, b, c), this.initWithLabelAndBackgroundSprite(a, cc.Scale9Sprite.create())
    },
    initWithBackgroundSprite: function(a) {
        var b = cc.LabelTTF.create("", "Arial", 30);
        return this.initWithLabelAndBackgroundSprite(b, a)
    },
    doesAdjustBackgroundImage: function() {
        return this._doesAdjustBackgroundImage
    },
    setAdjustBackgroundImage: function(a) {
        this._doesAdjustBackgroundImage = a, this.needsLayout()
    },
    getZoomOnTouchDown: function() {
        return this.zoomOnTouchDown
    },
    setZoomOnTouchDown: function(a) {
        return this.zoomOnTouchDown = a
    },
    getPreferredSize: function() {
        return this._preferredSize
    },
    setPreferredSize: function(a) {
        if (0 === a.width && 0 === a.height) this._doesAdjustBackgroundImage = !0;
        else {
            this._doesAdjustBackgroundImage = !1;
            var b, c = this._backgroundSpriteDispatchTable;
            for (b in c) c[b].setPreferredSize(a)
        }
        this._preferredSize = a, this.needsLayout()
    },
    getLabelAnchorPoint: function() {
        return this._labelAnchorPoint
    },
    setLabelAnchorPoint: function(a) {
        this._labelAnchorPoint = a, this._titleLabel && this._titleLabel.setAnchorPoint(a)
    },
    _getCurrentTitle: function() {
        return this._currentTitle
    },
    _getCurrentTitleColor: function() {
        return this._currentTitleColor
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(a) {
        cc.Control.prototype.setOpacity.call(this, a);
        var b, c = this._backgroundSpriteDispatchTable;
        for (b in c) c[b].setOpacity(a)
    },
    setColor: function(a) {
        cc.Control.prototype.setColor.call(this, a);
        var b, c = this._backgroundSpriteDispatchTable;
        for (b in c) c[b].setColor(a)
    },
    getColor: function() {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    isPushed: function() {
        return this._isPushed
    },
    _getVerticalMargin: function() {
        return this._marginV
    },
    _getHorizontalOrigin: function() {
        return this._marginH
    },
    setMargins: function(a, b) {
        this._marginV = b, this._marginH = a, this.needsLayout()
    },
    setEnabled: function(a) {
        cc.Control.prototype.setEnabled.call(this, a), this.needsLayout()
    },
    setSelected: function(a) {
        cc.Control.prototype.setSelected.call(this, a), this.needsLayout()
    },
    setHighlighted: function(a) {
        this._state = a ? cc.CONTROL_STATE_HIGHLIGHTED : cc.CONTROL_STATE_NORMAL, cc.Control.prototype.setHighlighted.call(this, a), (a = this.getActionByTag(cc.CONTROL_ZOOM_ACTION_TAG)) && this.stopAction(a), this.needsLayout(), this.zoomOnTouchDown && (a = this.isHighlighted() && this.isEnabled() && !this.isSelected() ? 1.1 : 1, a = cc.ScaleTo.create(.05, a), a.setTag(cc.CONTROL_ZOOM_ACTION_TAG), this.runAction(a))
    },
    onTouchBegan: function(a) {
        return this.isTouchInside(a) && this.isEnabled() && this.isVisible() && this.hasVisibleParents() ? (this._isPushed = !0, this.setHighlighted(!0), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DOWN), !0) : !1
    },
    onTouchMoved: function(a) {
        if (this._enabled && this._isPushed && !this._selected) {
            var b = this.isTouchInside(a);
            b && !this._highlighted ? (this.setHighlighted(!0), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_ENTER)) : b && this._highlighted ? this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_INSIDE) : !b && this._highlighted ? (this.setHighlighted(!1), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_EXIT)) : !b && !this._highlighted && this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_OUTSIDE)
        } else this._highlighted && this.setHighlighted(!1)
    },
    onTouchEnded: function(a) {
        this._isPushed = !1, this.setHighlighted(!1), this.sendActionsForControlEvents(this.isTouchInside(a) ? cc.CONTROL_EVENT_TOUCH_UP_INSIDE : cc.CONTROL_EVENT_TOUCH_UP_OUTSIDE)
    },
    onTouchCancelled: function() {
        this._isPushed = !1, this.setHighlighted(!1), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_CANCEL)
    },
    getTitleForState: function(a) {
        var b = this._titleDispatchTable;
        return b ? b[a] ? b[a] : b[cc.CONTROL_STATE_NORMAL] : ""
    },
    setTitleForState: function(a, b) {
        this._titleDispatchTable[b] = a || "", this.getState() == b && this.needsLayout()
    },
    getTitleColorForState: function(a) {
        return (a = this._titleColorDispatchTable[a]) ? a : (a = this._titleColorDispatchTable[cc.CONTROL_STATE_NORMAL]) ? a : cc.color.WHITE
    },
    setTitleColorForState: function(a, b) {
        this._titleColorDispatchTable[b] = a, this.getState() == b && this.needsLayout()
    },
    getTitleLabelForState: function(a) {
        var b = this._titleLabelDispatchTable;
        return b[a] ? b[a] : b[cc.CONTROL_STATE_NORMAL]
    },
    setTitleLabelForState: function(a, b) {
        var c = this._titleLabelDispatchTable;
        if (c[b]) {
            var d = c[b];
            d && this.removeChild(d, !0)
        }
        c[b] = a, a.setVisible(!1), a.setAnchorPoint(.5, .5), this.addChild(a, 1), this.getState() == b && this.needsLayout()
    },
    setTitleTTFForState: function(a, b) {
        var c = this.getTitleForState(b);
        c || (c = ""), this.setTitleLabelForState(cc.LabelTTF.create(c, a, 12), b)
    },
    getTitleTTFForState: function(a) {
        return a = this.getTitleLabelForState(a), null != a && a instanceof cc.LabelTTF ? a.getFontName() : ""
    },
    setTitleTTFSizeForState: function(a, b) {
        var c = this.getTitleLabelForState(b);
        null != c && c instanceof cc.LabelTTF && c.setFontSize(a)
    },
    getTitleTTFSizeForState: function(a) {
        return a = this.getTitleLabelForState(a), null != a && a instanceof cc.LabelTTF ? a.getFontSize() : 0
    },
    setTitleBMFontForState: function(a, b) {
        var c = this.getTitleForState(b);
        c || (c = ""), this.setTitleLabelForState(cc.LabelBMFont.create(c, a), b)
    },
    getTitleBMFontForState: function(a) {
        return a = this.getTitleLabelForState(a), null != a && a instanceof cc.LabelBMFont ? a.getFntFile() : ""
    },
    getBackgroundSpriteForState: function(a) {
        var b = this._backgroundSpriteDispatchTable;
        return b[a] ? b[a] : b[cc.CONTROL_STATE_NORMAL]
    },
    setBackgroundSpriteForState: function(a, b) {
        var c = this._backgroundSpriteDispatchTable;
        if (c[b]) {
            var d = c[b];
            d && this.removeChild(d, !0)
        }
        c[b] = a, a.setVisible(!1), a.setAnchorPoint(.5, .5), this.addChild(a), c = this._preferredSize, (0 !== c.width || 0 !== c.height) && a.setPreferredSize(c), this._state === b && this.needsLayout()
    },
    setBackgroundSpriteFrameForState: function(a, b) {
        var c = cc.Scale9Sprite.createWithSpriteFrame(a);
        this.setBackgroundSpriteForState(c, b)
    }
}), _p = cc.ControlButton.prototype, cc.defineGetterSetter(_p, "adjustBackground", _p.getAdjustBackgroundImage, _p.setAdjustBackgroundImage), cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize), cc.defineGetterSetter(_p, "labelAnchor", _p.getLabelAnchorPoint, _p.setLabelAnchorPoint), _p = null, cc.ControlButton.create = function(a, b, c) {
    return new cc.ControlButton(a, b, c)
}, cc.RGBA = function(a, b, c, d) {
    this.r = a, this.g = b, this.b = c, this.a = d
}, cc.HSV = function(a, b, c) {
    this.h = a, this.s = b, this.v = c
}, cc.ControlUtils = {}, cc.ControlUtils.addSpriteToTargetWithPosAndAnchor = function(a, b, c, d) {
    return (a = cc.Sprite.create("#" + a)) ? (a.setPosition(c), a.setAnchorPoint(d), b.addChild(a), a) : null
}, cc.ControlUtils.HSVfromRGB = function(a) {
    var b, c, d = new cc.HSV;
    return b = a.r < a.g ? a.r : a.g, b = b < a.b ? b : a.b, c = a.r > a.g ? a.r : a.g, c = c > a.b ? c : a.b, d.v = c, b = c - b, c > 0 ? (d.s = b / c, d.h = a.r >= c ? (a.g - a.b) / b : a.g >= c ? 2 + (a.b - a.r) / b : 4 + (a.r - a.g) / b, d.h *= 60, 0 > d.h && (d.h += 360), d) : (d.s = 0, d.h = -1, d)
}, cc.ControlUtils.RGBfromHSV = function(a) {
    var b, c, d, e, f = new cc.RGBA;
    if (f.a = 1, 0 >= a.s) return a.h ? (f.r = 0, f.g = 0, f.b = 0, f) : (f.r = a.v, f.g = a.v, f.b = a.v, f);
    switch (b = a.h, b >= 360 && (b = 0), b /= 60, e = 0 | b, d = b - e, b = a.v * (1 - a.s), c = a.v * (1 - a.s * d), d = a.v * (1 - a.s * (1 - d)), e) {
        case 0:
            f.r = a.v, f.g = d, f.b = b;
            break;
        case 1:
            f.r = c, f.g = a.v, f.b = b;
            break;
        case 2:
            f.r = b, f.g = a.v, f.b = d;
            break;
        case 3:
            f.r = b, f.g = c, f.b = a.v;
            break;
        case 4:
            f.r = d, f.g = b, f.b = a.v;
            break;
        default:
            f.r = a.v, f.g = b, f.b = c
    }
    return f
}, cc.ControlUtils.CCRectUnion = function(a, b) {
    return cc.rectUnion(a, b)
}, cc.Invocation = cc.Class.extend({
    _action: null,
    _target: null,
    _controlEvent: null,
    ctor: function(a, b, c) {
        this._target = a, this._action = b, this._controlEvent = c
    },
    getAction: function() {
        return this._action
    },
    getTarget: function() {
        return this._target
    },
    getControlEvent: function() {
        return this._controlEvent
    },
    invoke: function(a) {
        this._target && this._action && ("string" == typeof this._action ? this._target[this._action](a, this._controlEvent) : this._action.call(this._target, a, this._controlEvent))
    }
}), cc.Scale9Sprite = cc.Node.extend({
    _spriteRect: null,
    _capInsetsInternal: null,
    _positionsAreDirty: !1,
    _scale9Image: null,
    _topLeft: null,
    _top: null,
    _topRight: null,
    _left: null,
    _centre: null,
    _right: null,
    _bottomLeft: null,
    _bottom: null,
    _bottomRight: null,
    _cacheSprite: null,
    _cacheCanvas: null,
    _cacheContext: null,
    _cacheTexture: null,
    _scale9Dirty: !0,
    _opacityModifyRGB: !1,
    _originalSize: null,
    _preferredSize: null,
    _opacity: 0,
    _color: null,
    _capInsets: null,
    _insetLeft: 0,
    _insetTop: 0,
    _insetRight: 0,
    _insetBottom: 0,
    _spritesGenerated: !1,
    _spriteFrameRotated: !1,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _className: "Scale9Sprite",
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: b
        })
    },
    _callLoadedEventCallbacks: function() {
        this._textureLoaded = !0;
        for (var a = this._loadedEventListeners, b = 0, c = a.length; c > b; b++) {
            var d = a[b];
            d.eventCallback.call(d.eventTarget, this)
        }
        a.length = 0
    },
    _updateCapInset: function() {
        var a;
        a = this._insetLeft;
        var b = this._insetTop,
            c = this._insetRight,
            d = this._spriteRect,
            e = this._insetBottom;
        a = 0 === a && 0 === b && 0 === c && 0 === e ? cc.rect(0, 0, 0, 0) : this._spriteFrameRotated ? cc.rect(e, a, d.width - c - a, d.height - b - e) : cc.rect(a, b, d.width - a - c, d.height - b - e), this.setCapInsets(a)
    },
    _updatePositions: function() {
        if (this._topLeft && this._topRight && this._bottomRight && this._bottomLeft && this._centre) {
            var a = this._contentSize,
                b = this._topLeft,
                c = this._topRight,
                d = this._bottomRight,
                e = this._bottomLeft,
                f = this._centre,
                g = this._centre.getContentSize(),
                h = b.getContentSize(),
                i = e.getContentSize(),
                j = a.width - h.width - c.getContentSize().width,
                a = a.height - h.height - d.getContentSize().height,
                j = j / g.width,
                a = a / g.height,
                h = g.width * j,
                k = g.height * a,
                l = i.width,
                i = i.height;
            if (cc._renderType == cc._RENDER_TYPE_WEBGL) {
                var m = Math.round(h);
                h != m && (h = m, j = h / g.width), m = Math.round(k), k != m && (k = m, a = k / g.height)
            }
            f.setScaleX(j), f.setScaleY(a);
            var g = this._left,
                m = this._right,
                n = this._top,
                o = this._bottom,
                p = cc.p(0, 0);
            e.setAnchorPoint(p), d.setAnchorPoint(p), b.setAnchorPoint(p), c.setAnchorPoint(p), g.setAnchorPoint(p), m.setAnchorPoint(p), n.setAnchorPoint(p), o.setAnchorPoint(p), f.setAnchorPoint(p), e.setPosition(0, 0), d.setPosition(l + h, 0), b.setPosition(0, i + k), c.setPosition(l + h, i + k), g.setPosition(0, i), g.setScaleY(a), m.setPosition(l + h, i), m.setScaleY(a), o.setPosition(l, 0), o.setScaleX(j), n.setPosition(l, i + k), n.setScaleX(j), f.setPosition(l, i)
        }
    },
    _cacheScale9Sprite: function() {
        if (this._scale9Image) {
            var a = this._contentSize,
                b = this._cacheCanvas,
                c = !1;
            (b.width != a.width || b.height != a.height) && (b.width = a.width, b.height = a.height, this._cacheContext.translate(0, a.height), c = !0), cc.view._setScaleXYForRenderTexture(), this._scale9Image.visit(this._cacheContext), cc.view._resetScale(), c && this._cacheSprite.setTextureRect(cc.rect(0, 0, a.width, a.height)), this._cacheSprite.getParent() || this.addChild(this._cacheSprite)
        }
    },
    ctor: function(a, b, c) {
        if (cc.Node.prototype.ctor.call(this), this._spriteRect = cc.rect(0, 0, 0, 0), this._capInsetsInternal = cc.rect(0, 0, 0, 0), this._originalSize = cc.size(0, 0), this._preferredSize = cc.size(0, 0), this._capInsets = cc.rect(0, 0, 0, 0), this._loadedEventListeners = [], cc._renderType === cc._RENDER_TYPE_CANVAS) {
            var d = this._cacheCanvas = cc.newElement("canvas");
            d.width = 1, d.height = 1, this._cacheContext = d.getContext("2d");
            var e = this._cacheTexture = new cc.Texture2D;
            e.initWithElement(d), e.handleLoadedTexture(), this._cacheSprite = new cc.Sprite(e), this._cacheSprite.setAnchorPoint(0, 0), this.addChild(this._cacheSprite)
        }
        void 0 != a ? a instanceof cc.SpriteFrame ? this.initWithSpriteFrame(a, b) : (d = cc.spriteFrameCache.getSpriteFrame(a), null != d ? this.initWithSpriteFrame(d, b) : this.initWithFile(a, b, c)) : this.init()
    },
    getOriginalSize: function() {
        return cc.size(this._originalSize)
    },
    getPreferredSize: function() {
        return cc.size(this._preferredSize)
    },
    _getPreferredWidth: function() {
        return this._preferredSize.width
    },
    _getPreferredHeight: function() {
        return this._preferredSize.height
    },
    setPreferredSize: function(a) {
        this.setContentSize(a), this._preferredSize = a
    },
    _setPreferredWidth: function(a) {
        this._setWidth(a), this._preferredSize.width = a
    },
    _setPreferredHeight: function(a) {
        this._setHeight(a), this._preferredSize.height = a
    },
    setOpacity: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.setOpacity.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                d && d.setOpacity(a)
            }
            this._scale9Dirty = !0
        }
    },
    updateDisplayedOpacity: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.updateDisplayedOpacity.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                d && d.updateDisplayedOpacity(a)
            }
            this._scale9Dirty = !0
        }
    },
    setColor: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.setColor.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                d && d.setColor(a)
            }
            this._scale9Dirty = !0
        }
    },
    updateDisplayedColor: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.updateDisplayedColor.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                d && (cc._renderType === cc._RENDER_TYPE_CANVAS ? (cc.Node.prototype.updateDisplayedColor.call(d, a), (255 !== a.r || 255 !== a.g || 255 !== a.b) && (d._changeTextureColor(), d._setNodeDirtyForCache())) : d.updateDisplayedColor(a))
            }
            this._scale9Dirty = !0
        }
    },
    getCapInsets: function() {
        return cc.rect(this._capInsets)
    },
    setCapInsets: function(a) {
        if (this._scale9Image) {
            var b = this._contentSize,
                c = b.width,
                b = b.height;
            this.updateWithBatchNode(this._scale9Image, this._spriteRect, this._spriteFrameRotated, a), this.setContentSize(c, b)
        }
    },
    getInsetLeft: function() {
        return this._insetLeft
    },
    setInsetLeft: function(a) {
        this._insetLeft = a, this._updateCapInset()
    },
    getInsetTop: function() {
        return this._insetTop
    },
    setInsetTop: function(a) {
        this._insetTop = a, this._updateCapInset()
    },
    getInsetRight: function() {
        return this._insetRight
    },
    setInsetRight: function(a) {
        this._insetRight = a, this._updateCapInset()
    },
    getInsetBottom: function() {
        return this._insetBottom
    },
    setInsetBottom: function(a) {
        this._insetBottom = a, this._updateCapInset()
    },
    setContentSize: function(a, b) {
        cc.Node.prototype.setContentSize.call(this, a, b), this._positionsAreDirty = !0
    },
    _setWidth: function(a) {
        cc.Node.prototype._setWidth.call(this, a), this._positionsAreDirty = !0
    },
    _setHeight: function(a) {
        cc.Node.prototype._setHeight.call(this, a), this._positionsAreDirty = !0
    },
    visit: function(a) {
        this._positionsAreDirty && (this._updatePositions(), this._positionsAreDirty = !1, this._scale9Dirty = !0), this._scale9Dirty && cc._renderType === cc._RENDER_TYPE_CANVAS && (this._scale9Dirty = !1, this._cacheScale9Sprite()), cc.Node.prototype.visit.call(this, a)
    },
    init: function() {
        return this.initWithBatchNode(null, cc.rect(0, 0, 0, 0), !1, cc.rect(0, 0, 0, 0))
    },
    initWithBatchNode: function(a, b, c, d) {
        return void 0 === d && (d = c, c = !1), a && this.updateWithBatchNode(a, b, c, d), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0), this.setAnchorPoint(.5, .5), this._positionsAreDirty = !0
    },
    initWithFile: function(a, b, c) {
        if (a instanceof cc.Rect ? (c = a = b, b = cc.rect(0, 0, 0, 0)) : (b = b || cc.rect(0, 0, 0, 0), c = c || cc.rect(0, 0, 0, 0)), !a) throw "cc.Scale9Sprite.initWithFile(): file should be non-null";
        var d = cc.textureCache.getTextureForKey(a);
        d || (d = cc.textureCache.addImage(a));
        var e = d.isLoaded();
        return (this._textureLoaded = e) || d.addLoadedEventListener(function(a) {
            var b = this._preferredSize,
                b = cc.size(b.width, b.height);
            a = a.getContentSize(), this.updateWithBatchNode(this._scale9Image, cc.rect(0, 0, a.width, a.height), !1, this._capInsets), this.setPreferredSize(b), this._positionsAreDirty = !0, this._callLoadedEventCallbacks()
        }, this), this.initWithBatchNode(cc.SpriteBatchNode.create(a, 9), b, !1, c)
    },
    initWithSpriteFrame: function(a, b) {
        if (!a || !a.getTexture()) throw "cc.Scale9Sprite.initWithSpriteFrame(): spriteFrame should be non-null and its texture should be non-null";
        b = b || cc.rect(0, 0, 0, 0);
        var c = a.textureLoaded();
        return (this._textureLoaded = c) || a.addLoadedEventListener(function(a) {
            var b = this._preferredSize,
                b = cc.size(b.width, b.height);
            this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets), this.setPreferredSize(b), this._positionsAreDirty = !0, this._callLoadedEventCallbacks()
        }, this), c = cc.SpriteBatchNode.create(a.getTexture(), 9), this.initWithBatchNode(c, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), b)
    },
    initWithSpriteFrameName: function(a, b) {
        if (!a) throw "cc.Scale9Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null";
        b = b || cc.rect(0, 0, 0, 0);
        var c = cc.spriteFrameCache.getSpriteFrame(a);
        return null == c ? (cc.log("cc.Scale9Sprite.initWithSpriteFrameName(): can't find the sprite frame by spriteFrameName"), !1) : this.initWithSpriteFrame(c, b)
    },
    resizableSpriteWithCapInsets: function(a) {
        var b = new cc.Scale9Sprite;
        return b && b.initWithBatchNode(this._scale9Image, this._spriteRect, !1, a) ? b : null
    },
    setOpacityModifyRGB: function(a) {
        if (this._scale9Image) {
            this._opacityModifyRGB = a;
            var b = this._scale9Image.getChildren();
            if (b)
                for (var c = 0, d = b.length; d > c; c++) b[c].setOpacityModifyRGB(a)
        }
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    updateWithBatchNode: function(a, b, c, d) {
        var e = this.getOpacity(),
            f = this.getColor();
        if (b = cc.rect(b.x, b.y, b.width, b.height), this.removeAllChildren(!0), this._scale9Image != a && (this._scale9Image = a), !this._scale9Image) return !1;
        a = a.getTexture();
        var g = a.isLoaded();
        if (this._textureLoaded = g, !g) return a.addLoadedEventListener(function() {
            this._positionsAreDirty = !0, this._callLoadedEventCallbacks()
        }, this), !0;
        a = this._scale9Image, a.removeAllChildren(!0), g = this._capInsets, g.x = d.x, g.y = d.y, g.width = d.width, g.height = d.height, this._spriteFrameRotated = c, g = a.getTexture(), cc._rectEqualToZero(b) && (b = g.getContentSize(), b = cc.rect(0, 0, b.width, b.height));
        var h = this._spriteRect = b;
        h.x = b.x, h.y = b.y, h.width = b.width, h.height = b.height, this._originalSize.width = b.width, this._originalSize.height = b.height, h = this._preferredSize, 0 === h.width && 0 === h.height && (h.width = b.width, h.height = b.height), h = this._capInsetsInternal, d && (h.x = d.x, h.y = d.y, h.width = d.width, h.height = d.height);
        var i = b.width;
        d = b.height, cc._rectEqualToZero(h) && (h.x = i / 3, h.y = d / 3, h.width = i / 3, h.height = d / 3);
        var j = h.x,
            k = h.width,
            l = i - (j + k),
            m = h.y,
            n = h.height,
            o = d - (m + n),
            p = 0,
            q = 0;
        d = cc.rect(p + .5 | 0, q + .5 | 0, j + .5 | 0, m + .5 | 0);
        var p = p + j,
            h = cc.rect(p + .5 | 0, q + .5 | 0, k + .5 | 0, m + .5 | 0),
            i = cc.rect(p + k + .5 | 0, q + .5 | 0, l + .5 | 0, m + .5 | 0),
            p = 0,
            q = 0 + m,
            r = cc.rect(p + .5 | 0, q + .5 | 0, j + .5 | 0, n + .5 | 0),
            p = p + j,
            s = cc.rect(p + .5 | 0, q + .5 | 0, k + .5 | 0, n + .5 | 0),
            p = p + k,
            t = cc.rect(p + .5 | 0, q + .5 | 0, l + .5 | 0, n + .5 | 0),
            p = 0,
            q = 0 + m + n,
            m = cc.rect(p + .5 | 0, q + .5 | 0, j + .5 | 0, o + .5 | 0),
            p = p + j,
            j = cc.rect(p + .5 | 0, q + .5 | 0, k + .5 | 0, o + .5 | 0),
            p = p + k,
            k = cc.rect(p + .5 | 0, q + .5 | 0, l + .5 | 0, o + .5 | 0),
            l = cc.affineTransformMakeIdentity();
        if (c) {
            c = s;
            var o = k,
                p = m,
                q = i,
                n = d,
                u = t,
                v = r,
                w = j,
                x = h,
                l = cc.affineTransformTranslate(l, b.height + b.x, b.y),
                l = cc.affineTransformRotate(l, 1.57079633),
                s = cc.rectApplyAffineTransform(s, l),
                k = cc.rectApplyAffineTransform(k, l),
                m = cc.rectApplyAffineTransform(m, l),
                i = cc.rectApplyAffineTransform(i, l);
            d = cc.rectApplyAffineTransform(d, l), t = cc.rectApplyAffineTransform(t, l), r = cc.rectApplyAffineTransform(r, l), j = cc.rectApplyAffineTransform(j, l), h = cc.rectApplyAffineTransform(h, l), c.x = s.x, c.y = s.y, o.x = k.x, o.y = k.y, p.x = m.x, p.y = m.y, q.x = i.x, q.y = i.y, n.x = d.x, n.y = d.y, u.x = t.x, u.y = t.y, v.x = r.x, v.y = r.y, w.x = j.x, w.y = j.y, x.x = h.x, x.y = h.y, this._centre = new cc.Sprite, this._centre.initWithTexture(g, c, !0), a.addChild(this._centre, 0, cc.Scale9Sprite.POSITIONS_CENTRE), this._top = new cc.Sprite, this._top.initWithTexture(g, x, !0), a.addChild(this._top, 1, cc.Scale9Sprite.POSITIONS_TOP), this._bottom = new cc.Sprite, this._bottom.initWithTexture(g, w, !0), a.addChild(this._bottom, 1, cc.Scale9Sprite.POSITIONS_BOTTOM), this._left = new cc.Sprite, this._left.initWithTexture(g, v, !0), a.addChild(this._left, 1, cc.Scale9Sprite.POSITIONS_LEFT), this._right = new cc.Sprite, this._right.initWithTexture(g, u, !0), a.addChild(this._right, 1, cc.Scale9Sprite.POSITIONS_RIGHT), this._topLeft = new cc.Sprite, this._topLeft.initWithTexture(g, n, !0), a.addChild(this._topLeft, 2, cc.Scale9Sprite.POSITIONS_TOPLEFT), this._topRight = new cc.Sprite, this._topRight.initWithTexture(g, q, !0), a.addChild(this._topRight, 2, cc.Scale9Sprite.POSITIONS_TOPRIGHT), this._bottomLeft = new cc.Sprite, this._bottomLeft.initWithTexture(g, p, !0), a.addChild(this._bottomLeft, 2, cc.Scale9Sprite.POSITIONS_BOTTOMLEFT), this._bottomRight = new cc.Sprite, this._bottomRight.initWithTexture(g, o, !0)
        } else l = cc.affineTransformTranslate(l, b.x, b.y), cc._rectApplyAffineTransformIn(s, l), cc._rectApplyAffineTransformIn(k, l), cc._rectApplyAffineTransformIn(m, l), cc._rectApplyAffineTransformIn(i, l), cc._rectApplyAffineTransformIn(d, l), cc._rectApplyAffineTransformIn(t, l), cc._rectApplyAffineTransformIn(r, l), cc._rectApplyAffineTransformIn(j, l), cc._rectApplyAffineTransformIn(h, l), this._centre = new cc.Sprite, this._centre.initWithTexture(g, s), a.addChild(this._centre, 0, cc.Scale9Sprite.POSITIONS_CENTRE), this._top = new cc.Sprite, this._top.initWithTexture(g, h), a.addChild(this._top, 1, cc.Scale9Sprite.POSITIONS_TOP), this._bottom = new cc.Sprite, this._bottom.initWithTexture(g, j), a.addChild(this._bottom, 1, cc.Scale9Sprite.POSITIONS_BOTTOM), this._left = new cc.Sprite, this._left.initWithTexture(g, r), a.addChild(this._left, 1, cc.Scale9Sprite.POSITIONS_LEFT), this._right = new cc.Sprite, this._right.initWithTexture(g, t), a.addChild(this._right, 1, cc.Scale9Sprite.POSITIONS_RIGHT), this._topLeft = new cc.Sprite, this._topLeft.initWithTexture(g, d), a.addChild(this._topLeft, 2, cc.Scale9Sprite.POSITIONS_TOPLEFT), this._topRight = new cc.Sprite, this._topRight.initWithTexture(g, i), a.addChild(this._topRight, 2, cc.Scale9Sprite.POSITIONS_TOPRIGHT), this._bottomLeft = new cc.Sprite, this._bottomLeft.initWithTexture(g, m), a.addChild(this._bottomLeft, 2, cc.Scale9Sprite.POSITIONS_BOTTOMLEFT), this._bottomRight = new cc.Sprite, this._bottomRight.initWithTexture(g, k);
        return a.addChild(this._bottomRight, 2, cc.Scale9Sprite.POSITIONS_BOTTOMRIGHT), this.setContentSize(b.width, b.height), cc._renderType === cc._RENDER_TYPE_WEBGL && this.addChild(a), this._spritesGenerated && (this.setOpacity(e), this.setColor(f)), this._spritesGenerated = !0
    },
    setSpriteFrame: function(a) {
        var b = cc.SpriteBatchNode.create(a.getTexture(), 9),
            c = a.textureLoaded();
        (this._textureLoaded = c) || a.addLoadedEventListener(function(a) {
                var b = this._preferredSize,
                    b = cc.size(b.width, b.height);
                this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets), this.setPreferredSize(b), this._positionsAreDirty = !0, this._callLoadedEventCallbacks()
            }, this), this.updateWithBatchNode(b, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), cc.rect(0, 0, 0, 0)), this._insetBottom = this._insetRight = this._insetTop = this._insetLeft = 0
    }
}), _p = cc.Scale9Sprite.prototype, cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize), cc.defineGetterSetter(_p, "capInsets", _p.getCapInsets, _p.setCapInsets), cc.defineGetterSetter(_p, "insetLeft", _p.getInsetLeft, _p.setInsetLeft), cc.defineGetterSetter(_p, "insetTop", _p.getInsetTop, _p.setInsetTop), cc.defineGetterSetter(_p, "insetRight", _p.getInsetRight, _p.setInsetRight), cc.defineGetterSetter(_p, "insetBottom", _p.getInsetBottom, _p.setInsetBottom), _p = null, cc.Scale9Sprite.create = function(a, b, c) {
    return new cc.Scale9Sprite(a, b, c)
}, cc.Scale9Sprite.createWithSpriteFrame = function(a, b) {
    return new cc.Scale9Sprite(a, b)
}, cc.Scale9Sprite.createWithSpriteFrameName = function(a, b) {
    return new cc.Scale9Sprite(a, b)
}, cc.Scale9Sprite.POSITIONS_CENTRE = 0, cc.Scale9Sprite.POSITIONS_TOP = 1, cc.Scale9Sprite.POSITIONS_LEFT = 2, cc.Scale9Sprite.POSITIONS_RIGHT = 3, cc.Scale9Sprite.POSITIONS_BOTTOM = 4, cc.Scale9Sprite.POSITIONS_TOPRIGHT = 5, cc.Scale9Sprite.POSITIONS_TOPLEFT = 6, cc.Scale9Sprite.POSITIONS_BOTTOMRIGHT = 7, cc.Spacer = cc.Layer.extend({}), cc.Spacer.verticalSpacer = function(a) {
    var b = new cc.Spacer;
    return b.init(), b.setContentSize(0, a), b
}, cc.Spacer.horizontalSpacer = function(a) {
    var b = new cc.Spacer;
    return b.init(), b.setContentSize(a, 0), b
}, cc.MenuPassive = cc.Layer.extend({
    _color: null,
    _opacity: 0,
    _className: "MenuPassive",
    ctor: function() {},
    getColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setColor: function(a) {
        var b = this._color;
        if (b.r = a.r, b.g = a.g, b.b = a.b, this._children && 0 < this._children.length)
            for (b = 0; b < this._children.length; b++) this._children[b] && this._children[b].setColor(a);
        void 0 !== a.a && !a.a_undefined && this.setOpacity(a.a)
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(a) {
        if (this._opacity = a, this._children && 0 < this._children.length)
            for (var b = 0; b < this._children.length; b++) this._children[b] && this._children[b].setOpacity(a);
        this._color.a = a
    },
    initWithItems: function(a, b) {
        if (this.init()) {
            var c = cc.director.getWinSize();
            if (this.ignoreAnchorPointForPosition(!0), this.setAnchorPoint(.5, .5), this.setContentSize(c), this.setPosition(c.width / 2, c.height / 2), c = 0, a) {
                this.addChild(a, c);
                for (var d = 0; d < b.length; d++) b[d] && (c++, this.addChild(b[d], c))
            }
            return !0
        }
        return !1
    },
    alignItemsVertically: function() {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsVerticallyWithPadding: function(a) {
        var b, c = -a;
        if (this._children && 0 < this._children.length)
            for (b = 0; b < this._children.length; b++) this._children[b] && (c += this._children[b].getContentSize().height * this._children[b].getScaleY() + a);
        var d = 0,
            e = c / 2;
        if (this._children && 0 < this._children.length)
            for (b = 0; b < this._children.length; b++) this._children[b] && (d = Math.max(d, this._children[b].getContentSize().width), this._children[b].setPosition(0, e - this._children[b].getContentSize().height * this._children[b].getScaleY() / 2), e -= this._children[b].getContentSize().height * this._children[b].getScaleY() + a);
        this.setContentSize(d, c)
    },
    alignItemsHorizontally: function() {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsHorizontallyWithPadding: function(a) {
        var b, c = -a;
        if (this._children && 0 < this._children.length)
            for (b = 0; b < this._children.length; b++) this._children[b] && (c += this._children[b].getContentSize().width * this._children[b].getScaleX() + a);
        var d = 0,
            e = -c / 2;
        if (this._children && 0 < this._children.length)
            for (b = 0; b < this._children.length; b++) this._children[b] && (d = Math.max(d, this._children[b].getContentSize().height), this._children[b].setPosition(e + this._children[b].getContentSize().width * this._children[b].getScaleX() / 2, 0), e += this._children[b].getContentSize().width * this._children[b].getScaleX() + a);
        this.setContentSize(c, d)
    },
    alignItemsInColumns: function() {
        var a, b = [];
        for (a = 1; a < arguments.length; a++) b.push(arguments[a]);
        var c, d, e = -5,
            f = 0,
            g = 0,
            h = 0;
        if (this._children && 0 < this._children.length)
            for (a = 0; a < this._children.length; a++) this._children[a] && (f >= b.length ? cc.log("cc.MenuPassive.alignItemsInColumns(): invalid row index") : (c = b[f]) ? (d = this._children[a].getContentSize().height, g = 0 | (g >= d || null == d ? g : d), ++h, h >= c && (e += g + 5, g = h = 0, ++f)) : cc.log("cc.MenuPassive.alignItemsInColumns(): can not have zero columns on a row"));
        var i = cc.director.getWinSize(),
            j = c = g = f = 0,
            k = 0,
            e = e / 2;
        if (this._children && 0 < this._children.length)
            for (a = 0; a < this._children.length; a++) this._children[a] && (0 == c && (c = b[f], k = j = i.width / (1 + c)), d = this._children[a].getContentSize().height, g = 0 | (g >= d || null == d ? g : d), this._children[a].setPosition(k - i.width / 2, e - this._children[a].getContentSize().height / 2), k += j, ++h, h >= c && (e -= g + 5, g = c = h = 0, ++f))
    },
    alignItemsInRows: function() {
        var a, b = [];
        for (a = 1; a < arguments.length; a++) b.push(arguments[a]);
        var c, d, e = [],
            f = [],
            g = -10,
            h = -5,
            i = 0,
            j = 0,
            k = 0;
        if (this._children && 0 < this._children.length)
            for (a = 0; a < this._children.length; a++) this._children[a] && (i >= b.length ? cc.log("cc.MenuPassive.alignItemsInRows(): invalid row index") : (c = b[i]) ? (d = this._children[a].getContentSize().width, j = 0 | (j >= d || null == d ? j : d), h += 0 | this._children[a].getContentSize().height + 5, ++k, k >= c && (e.push(j), f.push(h), g += j + 10, j = k = 0, h = -5, ++i)) : cc.log("cc.MenuPassive.alignItemsInColumns(): can't have zero rows on a column"));
        h = cc.director.getWinSize(), j = i = 0, c = null;
        var g = -g / 2,
            l = 0;
        if (this._children && 0 < this._children.length)
            for (a = 0; a < this._children.length; a++) this._children[a] && (null == c && (c = b[i], l = f[i]), d = this._children[a].getContentSize().width, j = 0 | (j >= d || null == d ? j : d), this._children[a].setPosition(g + e[i] / 2, l - h.height / 2), l -= this._children[a].getContentSize().height + 10, ++k, k >= c && (g += j + 5, j = c = k = 0, ++i))
    },
    setOpacityModifyRGB: function() {},
    isOpacityModifyRGB: function() {
        return !1
    }
}), cc.MenuPassive.create = function(a) {
    a || (a = null);
    for (var b = [], c = 1; c < arguments.length; c++) b.push(arguments[c]);
    return (c = new cc.MenuPassive) && c.initWithItems(a, b) ? c : null
}, cc.MenuPassive.createWithItem = function(a) {
    return cc.MenuPassive.create(a, null)
}, cc.ControlSaturationBrightnessPicker = cc.Control.extend({
    _saturation: 0,
    _brightness: 0,
    _background: null,
    _overlay: null,
    _shadow: null,
    _slider: null,
    _startPos: null,
    _boxPos: 0,
    _boxSize: 0,
    _className: "ControlSaturationBrightnessPicker",
    ctor: function(a, b) {
        cc.Control.prototype.ctor.call(this), b && this.initWithTargetAndPos(a, b)
    },
    getSaturation: function() {
        return this._saturation
    },
    getBrightness: function() {
        return this._brightness
    },
    getBackground: function() {
        return this._background
    },
    getOverlay: function() {
        return this._brightness
    },
    getShadow: function() {
        return this._shadow
    },
    getSlider: function() {
        return this._slider
    },
    getStartPos: function() {
        return this._startPos
    },
    initWithTargetAndPos: function(a, b) {
        return cc.Control.prototype.init.call(this) ? (this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerBackground.png", a, b, cc.p(0, 0)), this._overlay = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerOverlay.png", a, b, cc.p(0, 0)), this._shadow = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerShadow.png", a, b, cc.p(0, 0)), this._slider = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPicker.png", a, b, cc.p(.5, .5)), this._startPos = b, this._boxPos = 35, this._boxSize = this._background.getContentSize().width / 2, !0) : !1
    },
    setEnabled: function(a) {
        cc.Control.prototype.setEnabled.call(this, a), this._slider && this._slider.setOpacity(a ? 255 : 128)
    },
    updateWithHSV: function(a) {
        var b = new cc.HSV;
        b.s = 1, b.h = a.h, b.v = 1, a = cc.ControlUtils.RGBfromHSV(b), this._background.setColor(cc.color(0 | 255 * a.r, 0 | 255 * a.g, 0 | 255 * a.b))
    },
    updateDraggerWithHSV: function(a) {
        a = cc.p(this._startPos.x + this._boxPos + this._boxSize * (1 - a.s), this._startPos.y + this._boxPos + this._boxSize * a.v), this._updateSliderPosition(a)
    },
    _updateSliderPosition: function(a) {
        var b = this._startPos.x + .5 * this._background.getBoundingBox().width,
            c = this._startPos.y + .5 * this._background.getBoundingBox().height,
            d = a.x - b,
            e = a.y - c,
            f = Math.sqrt(d * d + e * e),
            d = Math.atan2(e, d),
            e = .5 * this._background.getBoundingBox().width;
        f > e && (a.x = b + e * Math.cos(d), a.y = c + e * Math.sin(d)), this._slider.setPosition(a), a.x < this._startPos.x + this._boxPos ? a.x = this._startPos.x + this._boxPos : a.x > this._startPos.x + this._boxPos + this._boxSize - 1 && (a.x = this._startPos.x + this._boxPos + this._boxSize - 1), a.y < this._startPos.y + this._boxPos ? a.y = this._startPos.y + this._boxPos : a.y > this._startPos.y + this._boxPos + this._boxSize && (a.y = this._startPos.y + this._boxPos + this._boxSize), this._saturation = 1 - Math.abs((this._startPos.x + this._boxPos - a.x) / this._boxSize), this._brightness = Math.abs((this._startPos.y + this._boxPos - a.y) / this._boxSize)
    },
    _checkSliderPosition: function(a) {
        var b = this._startPos.x + .5 * this._background.getBoundingBox().width,
            c = this._startPos.y + .5 * this._background.getBoundingBox().height,
            b = a.x - b,
            c = a.y - c;
        return Math.sqrt(b * b + c * c) <= .5 * this._background.getBoundingBox().width ? (this._updateSliderPosition(a), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED), !0) : !1
    },
    onTouchBegan: function(a) {
        if (!this.isEnabled() || !this.isVisible()) return !1;
        var b = this.getTouchLocation(a);
        return this._checkSliderPosition(b)
    },
    onTouchMoved: function(a) {
        var b = this.getTouchLocation(a);
        this._checkSliderPosition(b)
    }
}), _p = cc.ControlSaturationBrightnessPicker.prototype, cc.defineGetterSetter(_p, "saturation", _p.getSaturation), cc.defineGetterSetter(_p, "brightness", _p.getBrightness), cc.defineGetterSetter(_p, "background", _p.getBackground), cc.defineGetterSetter(_p, "overlay", _p.getOverlay), cc.defineGetterSetter(_p, "shadow", _p.getShadow), cc.defineGetterSetter(_p, "slider", _p.getSlider), cc.defineGetterSetter(_p, "startPos", _p.getStartPos), _p = null, cc.ControlSaturationBrightnessPicker.create = function(a, b) {
    return new cc.ControlSaturationBrightnessPicker(a, b)
}, cc.ControlHuePicker = cc.Control.extend({
    _hue: 0,
    _huePercentage: 0,
    _background: null,
    _slider: null,
    _startPos: null,
    _className: "ControlHuePicker",
    ctor: function(a, b) {
        cc.Control.prototype.ctor.call(this), b && this.initWithTargetAndPos(a, b)
    },
    getHue: function() {
        return this._hue
    },
    setHue: function(a) {
        this._hue = a, this.setHuePercentage(this._hue / 360)
    },
    getHuePercentage: function() {
        return this._huePercentage
    },
    setHuePercentage: function(a) {
        this._huePercentage = a, this._hue = 360 * this._huePercentage;
        var b = this._background.getBoundingBox(),
            c = this._startPos.x + .5 * b.width;
        a = this._startPos.y + .5 * b.height;
        var b = .5 * b.width - 15,
            d = cc.degreesToRadians(360 * this._huePercentage - 180),
            c = c + b * Math.cos(d);
        a += b * Math.sin(d), this._slider.setPosition(c, a)
    },
    setEnabled: function(a) {
        cc.Control.prototype.setEnabled.call(this, a), this._slider && this._slider.setOpacity(a ? 255 : 128)
    },
    getBackground: function() {
        return this._background
    },
    getSlider: function() {
        return this._slider
    },
    getStartPos: function() {
        return this._startPos
    },
    initWithTargetAndPos: function(a, b) {
        return cc.Control.prototype.init.call(this) ? (this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("huePickerBackground.png", a, b, cc.p(0, 0)), this._slider = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPicker.png", a, b, cc.p(.5, .5)), this._slider.setPosition(b.x, b.y + .5 * this._background.getBoundingBox().height), this._startPos = b, this._huePercentage = this._hue = 0, !0) : !1
    },
    _updateSliderPosition: function(a) {
        var b = this._background.getBoundingBox();
        a = Math.atan2(a.y - (this._startPos.y + .5 * b.height), a.x - (this._startPos.x + .5 * b.width)), a = cc.radiansToDegrees(a) + 180, this.setHue(a), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    _checkSliderPosition: function(a) {
        var b = Math.sqrt(Math.pow(a.x + 10, 2) + Math.pow(a.y, 2));
        return 80 > b && b > 59 ? (this._updateSliderPosition(a), !0) : !1
    },
    onTouchBegan: function(a) {
        if (!this.isEnabled() || !this.isVisible()) return !1;
        var b = this.getTouchLocation(a);
        return this._checkSliderPosition(b)
    },
    onTouchMoved: function(a) {
        var b = this.getTouchLocation(a);
        this._checkSliderPosition(b)
    }
}), _p = cc.ControlHuePicker.prototype, cc.defineGetterSetter(_p, "hue", _p.getHue, _p.setHue), cc.defineGetterSetter(_p, "huePercent", _p.getHuePercentage, _p.setHuePercentage), cc.defineGetterSetter(_p, "background", _p.getBackground), cc.defineGetterSetter(_p, "slider", _p.getSlider), cc.defineGetterSetter(_p, "startPos", _p.getStartPos), _p = null, cc.ControlHuePicker.create = function(a, b) {
    return new cc.ControlHuePicker(a, b)
}, cc.ControlColourPicker = cc.Control.extend({
    _hsv: null,
    _colourPicker: null,
    _huePicker: null,
    _background: null,
    _className: "ControlColourPicker",
    ctor: function() {
        cc.Control.prototype.ctor.call(this), this.init()
    },
    hueSliderValueChanged: function(a) {
        this._hsv.h = a.getHue();
        var b = cc.ControlUtils.RGBfromHSV(this._hsv);
        cc.Control.prototype.setColor.call(this, cc.color(0 | 255 * b.r, 0 | 255 * b.g, 0 | 255 * b.b)), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED), this._updateControlPicker()
    },
    colourSliderValueChanged: function(a) {
        this._hsv.s = a.getSaturation(), this._hsv.v = a.getBrightness();
        var b = cc.ControlUtils.RGBfromHSV(this._hsv);
        cc.Control.prototype.setColor.call(this, cc.color(0 | 255 * b.r, 0 | 255 * b.g, 0 | 255 * b.b)), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    setColor: function(a) {
        cc.Control.prototype.setColor.call(this, a);
        var b = new cc.RGBA;
        b.r = a.r / 255, b.g = a.g / 255, b.b = a.b / 255, b.a = 1, this._hsv = cc.ControlUtils.HSVfromRGB(b), this._updateHueAndControlPicker()
    },
    getBackground: function() {
        return this._background
    },
    init: function() {
        if (cc.Control.prototype.init.call(this)) {
            cc.spriteFrameCache.addSpriteFrames(res.CCControlColourPickerSpriteSheet_plist);
            var a = cc.SpriteBatchNode.create(res.CCControlColourPickerSpriteSheet_png);
            this.addChild(a), this._hsv = new cc.HSV(0, 0, 0), this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("menuColourPanelBackground.png", a, cc.p(0, 0), cc.p(.5, .5));
            var b = cc.pSub(this._background.getPosition(), cc.p(this._background.getContentSize().width / 2, this._background.getContentSize().height / 2));
            return this._huePicker = cc.ControlHuePicker.create(a, cc.p(b.x + 8, b.y + 8)), this._colourPicker = cc.ControlSaturationBrightnessPicker.create(a, cc.p(b.x + 28, b.y + 28)), this._huePicker.addTargetWithActionForControlEvents(this, this.hueSliderValueChanged, cc.CONTROL_EVENT_VALUECHANGED), this._colourPicker.addTargetWithActionForControlEvents(this, this.colourSliderValueChanged, cc.CONTROL_EVENT_VALUECHANGED), this._updateHueAndControlPicker(), this.addChild(this._huePicker), this.addChild(this._colourPicker), this.setContentSize(this._background.getContentSize()), !0
        }
        return !1
    },
    _updateControlPicker: function() {
        this._huePicker.setHue(this._hsv.h), this._colourPicker.updateWithHSV(this._hsv)
    },
    _updateHueAndControlPicker: function() {
        this._huePicker.setHue(this._hsv.h), this._colourPicker.updateWithHSV(this._hsv), this._colourPicker.updateDraggerWithHSV(this._hsv)
    },
    setEnabled: function(a) {
        cc.Control.prototype.setEnabled.call(this, a), null != this._huePicker && this._huePicker.setEnabled(a), this._colourPicker && this._colourPicker.setEnabled(a)
    },
    onTouchBegan: function() {
        return !1
    }
}), _p = cc.ControlColourPicker.prototype, cc.defineGetterSetter(_p, "background", _p.getBackground), _p = null, cc.ControlColourPicker.create = function() {
    return new cc.ControlColourPicker
};
var res = res || {};
res.CCControlColourPickerSpriteSheet_plist = res.CCControlColourPickerSpriteSheet_plist || "res/extensions/CCControlColourPickerSpriteSheet.plist", res.CCControlColourPickerSpriteSheet_png = res.CCControlColourPickerSpriteSheet_png || "res/extensions/CCControlColourPickerSpriteSheet.png", cc.SLIDER_MARGIN_H = 24, cc.SLIDER_MARGIN_V = 8, cc.ControlSlider = cc.Control.extend({
    _value: 0,
    _minimumValue: 0,
    _maximumValue: 0,
    _minimumAllowedValue: 0,
    _maximumAllowedValue: 0,
    _thumbSprite: null,
    _progressSprite: null,
    _backgroundSprite: null,
    _className: "ControlSlider",
    ctor: function(a, b, c) {
        cc.Control.prototype.ctor.call(this), void 0 != c && (bgSprite = cc.Sprite.create(a), progressSprite = cc.Sprite.create(b), thumbSprite = cc.Sprite.create(c), this.initWithSprites(bgSprite, progressSprite, thumbSprite))
    },
    getValue: function() {
        return this._value
    },
    setValue: function(a) {
        a = Math.max(a, this._minimumValue), this._value = a = Math.min(a, this._maximumValue), this.needsLayout(), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    getMinimumValue: function() {
        return this._minimumValue
    },
    setMinimumValue: function(a) {
        this._minimumAllowedValue = this._minimumValue = a, this._minimumValue >= this._maximumValue && (this._maximumValue = this._minimumValue + 1), this.setValue(this._value)
    },
    getMaximumValue: function() {
        return this._maximumValue
    },
    setMaximumValue: function(a) {
        this._maximumAllowedValue = this._maximumValue = a, this._maximumValue <= this._minimumValue && (this._minimumValue = this._maximumValue - 1), this.setValue(this._value)
    },
    isTouchInside: function(a) {
        a = a.getLocation(), a = this.getParent().convertToNodeSpace(a);
        var b = this.getBoundingBox();
        return b.width += this._thumbSprite.getContentSize().width, b.x -= this._thumbSprite.getContentSize().width / 2, cc.rectContainsPoint(b, a)
    },
    locationFromTouch: function(a) {
        return a = a.getLocation(), a = this.convertToNodeSpace(a), 0 > a.x ? a.x = 0 : a.x > this._backgroundSprite.getContentSize().width && (a.x = this._backgroundSprite.getContentSize().width), a
    },
    getMinimumAllowedValue: function() {
        return this._minimumAllowedValue
    },
    setMinimumAllowedValue: function(a) {
        this._minimumAllowedValue = a
    },
    getMaximumAllowedValue: function() {
        return this._maximumAllowedValue
    },
    setMaximumAllowedValue: function(a) {
        this._maximumAllowedValue = a
    },
    getThumbSprite: function() {
        return this._thumbSprite
    },
    getProgressSprite: function() {
        return this._progressSprite
    },
    getBackgroundSprite: function() {
        return this._backgroundSprite
    },
    initWithSprites: function(a, b, c) {
        return cc.Control.prototype.init.call(this) ? (this.ignoreAnchorPointForPosition(!1), this._backgroundSprite = a, this._progressSprite = b, this._thumbSprite = c, a = cc.ControlUtils.CCRectUnion(a.getBoundingBox(), c.getBoundingBox()), this.setContentSize(a.width, a.height), this._backgroundSprite.setAnchorPoint(.5, .5), this._backgroundSprite.setPosition(a.width / 2, a.height / 2), this.addChild(this._backgroundSprite), this._progressSprite.setAnchorPoint(0, .5), this._progressSprite.setPosition(0, a.height / 2), this.addChild(this._progressSprite), this._thumbSprite.setPosition(0, a.height / 2), this.addChild(this._thumbSprite), this._minimumValue = 0, this._maximumValue = 1, this.setValue(this._minimumValue), !0) : !1
    },
    setEnabled: function(a) {
        cc.Control.prototype.setEnabled.call(this, a), this._thumbSprite && this._thumbSprite.setOpacity(a ? 255 : 128)
    },
    sliderBegan: function(a) {
        this.setSelected(!0), this.getThumbSprite().setColor(cc.color.GRAY), this.setValue(this.valueForLocation(a))
    },
    sliderMoved: function(a) {
        this.setValue(this.valueForLocation(a))
    },
    sliderEnded: function() {
        this.isSelected() && this.setValue(this.valueForLocation(this._thumbSprite.getPosition())), this._thumbSprite.setColor(cc.color.WHITE), this.setSelected(!1)
    },
    getTouchLocationInControl: function(a) {
        return a = a.getLocation(), a = this.convertToNodeSpace(a), 0 > a.x ? a.x = 0 : a.x > this._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H && (a.x = this._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H), a
    },
    onTouchBegan: function(a) {
        if (!this.isTouchInside(a) || !this.isEnabled() || !this.isVisible()) return !1;
        var b = this.locationFromTouch(a);
        return this.sliderBegan(b), !0
    },
    onTouchMoved: function(a) {
        var b = this.locationFromTouch(a);
        this.sliderMoved(b)
    },
    onTouchEnded: function() {
        this.sliderEnded(cc.p(0, 0))
    },
    needsLayout: function() {
        this._thumbSprite.setPositionX((this._value - this._minimumValue) / (this._maximumValue - this._minimumValue) * this._backgroundSprite.getContentSize().width);
        var a = this._progressSprite.getTextureRect(),
            a = cc.rect(a.x, a.y, this._thumbSprite.getPositionX(), a.height);
        this._progressSprite.setTextureRect(a, this._progressSprite.isTextureRectRotated())
    },
    valueForLocation: function(a) {
        return a = a.x / this._backgroundSprite.getContentSize().width, Math.max(Math.min(this._minimumValue + a * (this._maximumValue - this._minimumValue), this._maximumAllowedValue), this._minimumAllowedValue)
    }
}), _p = cc.ControlSlider.prototype, cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue), cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue), cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue), cc.defineGetterSetter(_p, "minAllowedValue", _p.getMinimumAllowedValue, _p.setMinimumAllowedValue), cc.defineGetterSetter(_p, "maxAllowedValue", _p.getMaximumAllowedValue, _p.setMaximumAllowedValue), cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite), cc.defineGetterSetter(_p, "progressSprite", _p.getProgressSprite), cc.defineGetterSetter(_p, "backgroundSprite", _p.getBackgroundSprite), _p = null, cc.ControlSlider.create = function(a, b, c) {
    return new cc.ControlSlider(a, b, c)
}, cc.ControlSwitch = cc.Control.extend({
    _switchSprite: null,
    _initialTouchXPosition: 0,
    _moved: !1,
    _on: !1,
    _className: "ControlSwitch",
    ctor: function(a, b, c, d, e, f) {
        cc.Control.prototype.ctor.call(this), f && this.initWithMaskSprite(a, b, c, d, e, f)
    },
    initWithMaskSprite: function(a, b, c, d, e, f) {
        if (!a) throw "cc.ControlSwitch.initWithMaskSprite(): maskSprite should be non-null.";
        if (!b) throw "cc.ControlSwitch.initWithMaskSprite(): onSprite should be non-null.";
        if (!c) throw "cc.ControlSwitch.initWithMaskSprite(): offSprite should be non-null.";
        if (!d) throw "cc.ControlSwitch.initWithMaskSprite(): thumbSprite should be non-null.";
        return this.init() ? (this._on = !0, this._switchSprite = new cc.ControlSwitchSprite, this._switchSprite.initWithMaskSprite(a, b, c, d, e, f), this._switchSprite.setPosition(this._switchSprite.getContentSize().width / 2, this._switchSprite.getContentSize().height / 2), this.addChild(this._switchSprite), this.ignoreAnchorPointForPosition(!1), this.setAnchorPoint(.5, .5), this.setContentSize(this._switchSprite.getContentSize()), !0) : !1
    },
    setOn: function(a, b) {
        b = b || !1;
        var c = (this._on = a) ? this._switchSprite.getOnPosition() : this._switchSprite.getOffPosition();
        b ? this._switchSprite.runAction(cc.ActionTween.create(.2, "sliderXPosition", this._switchSprite.getSliderXPosition(), c)) : this._switchSprite.setSliderXPosition(c), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    isOn: function() {
        return this._on
    },
    hasMoved: function() {
        return this._moved
    },
    setEnabled: function(a) {
        this._enabled = a, this._switchSprite.setOpacity(a ? 255 : 128)
    },
    locationFromTouch: function(a) {
        return a = a.getLocation(), a = this.convertToNodeSpace(a)
    },
    onTouchBegan: function(a) {
        return this.isTouchInside(a) && this.isEnabled() && this.isVisible() ? (this._moved = !1, this._initialTouchXPosition = this.locationFromTouch(a).x - this._switchSprite.getSliderXPosition(), this._switchSprite.getThumbSprite().setColor(cc.color.GRAY), this._switchSprite.needsLayout(), !0) : !1
    },
    onTouchMoved: function(a) {
        var b = this.locationFromTouch(a),
            b = cc.p(b.x - this._initialTouchXPosition, 0);
        this._moved = !0, this._switchSprite.setSliderXPosition(b.x)
    },
    onTouchEnded: function(a) {
        var b = this.locationFromTouch(a);
        this._switchSprite.getThumbSprite().setColor(cc.color.WHITE), this.hasMoved() ? this.setOn(!(b.x < this._switchSprite.getContentSize().width / 2), !0) : this.setOn(!this._on, !0)
    },
    onTouchCancelled: function(a) {
        var b = this.locationFromTouch(a);
        this._switchSprite.getThumbSprite().setColor(cc.color.WHITE), this.hasMoved() ? this.setOn(!(b.x < this._switchSprite.getContentSize().width / 2), !0) : this.setOn(!this._on, !0)
    }
}), cc.ControlSwitch.create = function(a, b, c, d, e, f) {
    return new cc.ControlSwitch(a, b, c, d, e, f)
}, cc.ControlSwitchSprite = cc.Sprite.extend({
    _sliderXPosition: 0,
    _onPosition: 0,
    _offPosition: 0,
    _textureLocation: 0,
    _maskLocation: 0,
    _maskSize: null,
    _onSprite: null,
    _offSprite: null,
    _thumbSprite: null,
    _onLabel: null,
    _offLabel: null,
    _clipper: null,
    _stencil: null,
    _backRT: null,
    ctor: function() {
        cc.Sprite.prototype.ctor.call(this), this._maskLocation = this._offPosition = this._onPosition = this._sliderXPosition = 0, this._maskSize = cc.size(0, 0), this._offLabel = this._onLabel = this._thumbSprite = this._offSprite = this._onSprite = null
    },
    initWithMaskSprite: function(a, b, c, d, e, f) {
        return cc.Sprite.prototype.initWithTexture.call(this, a.getTexture()) ? (this._onPosition = 0, this._offPosition = -b.getContentSize().width + d.getContentSize().width / 2, this._sliderXPosition = this._onPosition, this.setOnSprite(b), this.setOffSprite(c), this.setThumbSprite(d), this.setOnLabel(e), this.setOffLabel(f), this._stencil = a, a = this._maskSize = this._stencil.getContentSize(), this._stencil.setPosition(0, 0), this._clipper = cc.ClippingNode.create(), this._clipper.setAnchorPoint(.5, .5), this._clipper.setPosition(a.width / 2, a.height / 2), this._clipper.setStencil(this._stencil), this.addChild(this._clipper), this._clipper.addChild(b), this._clipper.addChild(c), this._clipper.addChild(e), this._clipper.addChild(f), this.addChild(this._thumbSprite), this.needsLayout(), !0) : !1
    },
    needsLayout: function() {
        var a = this._maskSize;
        this._onSprite.setPosition(this._onSprite.getContentSize().width / 2 + this._sliderXPosition - a.width / 2, this._onSprite.getContentSize().height / 2 - a.height / 2), this._offSprite.setPosition(this._onSprite.getContentSize().width + this._offSprite.getContentSize().width / 2 + this._sliderXPosition - a.width / 2, this._offSprite.getContentSize().height / 2 - a.height / 2), this._onLabel && this._onLabel.setPosition(this._onSprite.getPositionX() - this._thumbSprite.getContentSize().width / 6, this._onSprite.getContentSize().height / 2 - a.height / 2), this._offLabel && this._offLabel.setPosition(this._offSprite.getPositionX() + this._thumbSprite.getContentSize().width / 6, this._offSprite.getContentSize().height / 2 - a.height / 2), this._thumbSprite.setPosition(this._onSprite.getContentSize().width + this._sliderXPosition, this._maskSize.height / 2)
    },
    setSliderXPosition: function(a) {
        a <= this._offPosition ? a = this._offPosition : a >= this._onPosition && (a = this._onPosition), this._sliderXPosition = a, this.needsLayout()
    },
    getSliderXPosition: function() {
        return this._sliderXPosition
    },
    _getOnSideWidth: function() {
        return this._onSprite.getContentSize().width
    },
    _getOffSideWidth: function() {
        return this._offSprite.getContentSize().height
    },
    updateTweenAction: function(a, b) {
        cc.log("key = " + b + ", value = " + a), this.setSliderXPosition(a)
    },
    setOnPosition: function(a) {
        this._onPosition = a
    },
    getOnPosition: function() {
        return this._onPosition
    },
    setOffPosition: function(a) {
        this._offPosition = a
    },
    getOffPosition: function() {
        return this._offPosition
    },
    setMaskTexture: function(a) {
        this._stencil.setTexture(a)
    },
    getMaskTexture: function() {
        return this._stencil.getTexture()
    },
    setTextureLocation: function(a) {
        this._textureLocation = a
    },
    getTextureLocation: function() {
        return this._textureLocation
    },
    setMaskLocation: function(a) {
        this._maskLocation = a
    },
    getMaskLocation: function() {
        return this._maskLocation
    },
    setOnSprite: function(a) {
        this._onSprite = a
    },
    getOnSprite: function() {
        return this._onSprite
    },
    setOffSprite: function(a) {
        this._offSprite = a
    },
    getOffSprite: function() {
        return this._offSprite
    },
    setThumbSprite: function(a) {
        this._thumbSprite = a
    },
    getThumbSprite: function() {
        return this._thumbSprite
    },
    setOnLabel: function(a) {
        this._onLabel = a
    },
    getOnLabel: function() {
        return this._onLabel
    },
    setOffLabel: function(a) {
        this._offLabel = a
    },
    getOffLabel: function() {
        return this._offLabel
    }
}), _p = cc.ControlSwitchSprite.prototype, cc.defineGetterSetter(_p, "sliderX", _p.getSliderXPosition, _p.setSliderXPosition), cc.defineGetterSetter(_p, "onPos", _p.getOnPosition, _p.setOnPosition), cc.defineGetterSetter(_p, "offPos", _p.getOffPosition, _p.setOffPosition), cc.defineGetterSetter(_p, "maskTexture", _p.getMaskTexture, _p.setMaskTexture), cc.defineGetterSetter(_p, "maskPos", _p.getMaskLocation, _p.setMaskLocation), cc.defineGetterSetter(_p, "onSprite", _p.getOnSprite, _p.setOnSprite), cc.defineGetterSetter(_p, "offSprite", _p.getOffSprite, _p.setOffSprite), cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite, _p.setThumbSprite), cc.defineGetterSetter(_p, "onLabel", _p.getOnLabel, _p.setOnLabel), cc.defineGetterSetter(_p, "offLabel", _p.getOffLabel, _p.setOffLabel), cc.defineGetterSetter(_p, "onSideWidth", _p._getOnSideWidth), cc.defineGetterSetter(_p, "offSideWidth", _p._getOffSideWidth), _p = null, cc.CONTROL_STEPPER_PARTMINUS = 0, cc.CONTROL_STEPPER_PARTPLUS = 1, cc.CONTROL_STEPPER_PARTNONE = 2, cc.CONTROL_STEPPER_LABELCOLOR_ENABLED = cc.color(55, 55, 55), cc.CONTROL_STEPPER_LABELCOLOR_DISABLED = cc.color(147, 147, 147), cc.CONTROL_STEPPER_LABELFONT = "CourierNewPSMT", cc.AUTOREPEAT_DELTATIME = .15, cc.AUTOREPEAT_INCREASETIME_INCREMENT = 12, cc.ControlStepper = cc.Control.extend({
    _minusSprite: null,
    _plusSprite: null,
    _minusLabel: null,
    _plusLabel: null,
    _value: 0,
    _continuous: !1,
    _autorepeat: !1,
    _wraps: !1,
    _minimumValue: 0,
    _maximumValue: 0,
    _stepValue: 0,
    _touchInsideFlag: !1,
    _touchedPart: cc.CONTROL_STEPPER_PARTNONE,
    _autorepeatCount: 0,
    _className: "ControlStepper",
    ctor: function(a, b) {
        cc.Control.prototype.ctor.call(this), this._plusLabel = this._minusLabel = this._plusSprite = this._minusSprite = null, this._value = 0, this._wraps = this._autorepeat = this._continuous = !1, this._stepValue = this._maximumValue = this._minimumValue = 0, this._touchInsideFlag = !1, this._touchedPart = cc.CONTROL_STEPPER_PARTNONE, this._autorepeatCount = 0, b && this.initWithMinusSpriteAndPlusSprite(a, b)
    },
    initWithMinusSpriteAndPlusSprite: function(a, b) {
        if (!a) throw "cc.ControlStepper.initWithMinusSpriteAndPlusSprite(): Minus sprite should be non-null.";
        if (!b) throw "cc.ControlStepper.initWithMinusSpriteAndPlusSprite(): Plus sprite should be non-null.";
        if (this.init()) {
            this._continuous = this._autorepeat = !0, this._minimumValue = 0, this._maximumValue = 100, this._value = 0, this._stepValue = 1, this._wraps = !1, this.ignoreAnchorPointForPosition(!1), this.setMinusSprite(a), this._minusSprite.setPosition(a.getContentSize().width / 2, a.getContentSize().height / 2), this.addChild(this._minusSprite), this.setMinusLabel(cc.LabelTTF.create("-", cc.CONTROL_STEPPER_LABELFONT, 40, cc.size(40, 40), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER)), this._minusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_DISABLED), this._minusLabel.setPosition(this._minusSprite.getContentSize().width / 2, this._minusSprite.getContentSize().height / 2), this._minusSprite.addChild(this._minusLabel), this.setPlusSprite(b), this._plusSprite.setPosition(a.getContentSize().width + b.getContentSize().width / 2, a.getContentSize().height / 2), this.addChild(this._plusSprite), this.setPlusLabel(cc.LabelTTF.create("+", cc.CONTROL_STEPPER_LABELFONT, 40, cc.size(40, 40), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER)), this._plusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED), this._plusLabel.setPosition(this._plusSprite.getContentSize().width / 2, this._plusSprite.getContentSize().height / 2), this._plusSprite.addChild(this._plusLabel);
            var c = cc.ControlUtils.CCRectUnion(this._minusSprite.getBoundingBox(), this._plusSprite.getBoundingBox());
            return this.setContentSize(this._minusSprite.getContentSize().width + this._plusSprite.getContentSize().height, c.height), !0
        }
        return !1
    },
    setWraps: function(a) {
        (this._wraps = a) && (this._minusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED), this._plusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED)), this.setValue(this._value)
    },
    getWraps: function() {
        return this._wraps
    },
    setMinimumValue: function(a) {
        if (a >= this._maximumValue) throw "cc.ControlStepper.setMinimumValue(): minimumValue should be numerically less than maximumValue.";
        this._minimumValue = a, this.setValue(this._value)
    },
    getMinimumValue: function() {
        return this._minimumValue
    },
    setMaximumValue: function(a) {
        if (a <= this._minimumValue) throw "cc.ControlStepper.setMaximumValue(): maximumValue should be numerically less than maximumValue.";
        this._maximumValue = a, this.setValue(this._value)
    },
    getMaximumValue: function() {
        return this._maximumValue
    },
    setValue: function(a) {
        this.setValueWithSendingEvent(a, !0)
    },
    getValue: function() {
        return this._value
    },
    setStepValue: function(a) {
        if (0 >= a) throw "cc.ControlStepper.setMaximumValue(): stepValue should be numerically greater than 0.";
        this._stepValue = a
    },
    getStepValue: function() {
        return this._stepValue
    },
    isContinuous: function() {
        return this._continuous
    },
    setValueWithSendingEvent: function(a, b) {
        a < this._minimumValue ? a = this._wraps ? this._maximumValue : this._minimumValue : a > this._maximumValue && (a = this._wraps ? this._minimumValue : this._maximumValue), this._value = a, this._wraps || (this._minusLabel.setColor(a == this._minimumValue ? cc.CONTROL_STEPPER_LABELCOLOR_DISABLED : cc.CONTROL_STEPPER_LABELCOLOR_ENABLED), this._plusLabel.setColor(a == this._maximumValue ? cc.CONTROL_STEPPER_LABELCOLOR_DISABLED : cc.CONTROL_STEPPER_LABELCOLOR_ENABLED)), b && this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    startAutorepeat: function() {
        this._autorepeatCount = -1, this.schedule(this.update, cc.AUTOREPEAT_DELTATIME, cc.REPEAT_FOREVER, 3 * cc.AUTOREPEAT_DELTATIME)
    },
    stopAutorepeat: function() {
        this.unschedule(this.update)
    },
    update: function() {
        this._autorepeatCount++, this._autorepeatCount < cc.AUTOREPEAT_INCREASETIME_INCREMENT && 0 != this._autorepeatCount % 3 || (this._touchedPart == cc.CONTROL_STEPPER_PARTMINUS ? this.setValueWithSendingEvent(this._value - this._stepValue, this._continuous) : this._touchedPart == cc.CONTROL_STEPPER_PARTPLUS && this.setValueWithSendingEvent(this._value + this._stepValue, this._continuous))
    },
    updateLayoutUsingTouchLocation: function(a) {
        a.x < this._minusSprite.getContentSize().width && this._value > this._minimumValue ? (this._touchedPart = cc.CONTROL_STEPPER_PARTMINUS, this._minusSprite.setColor(cc.color.GRAY), this._plusSprite.setColor(cc.color.WHITE)) : a.x >= this._minusSprite.getContentSize().width && this._value < this._maximumValue ? (this._touchedPart = cc.CONTROL_STEPPER_PARTPLUS, this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.GRAY)) : (this._touchedPart = cc.CONTROL_STEPPER_PARTNONE, this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.WHITE))
    },
    onTouchBegan: function(a) {
        if (!this.isTouchInside(a) || !this.isEnabled() || !this.isVisible()) return !1;
        var b = this.getTouchLocation(a);
        return this.updateLayoutUsingTouchLocation(b), this._touchInsideFlag = !0, this._autorepeat && this.startAutorepeat(), !0
    },
    onTouchMoved: function(a) {
        if (this.isTouchInside(a)) {
            var b = this.getTouchLocation(a);
            this.updateLayoutUsingTouchLocation(b), this._touchInsideFlag || (this._touchInsideFlag = !0, this._autorepeat && this.startAutorepeat())
        } else this._touchInsideFlag = !1, this._touchedPart = cc.CONTROL_STEPPER_PARTNONE, this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.WHITE), this._autorepeat && this.stopAutorepeat()
    },
    onTouchEnded: function(a) {
        if (this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.WHITE), this._autorepeat && this.stopAutorepeat(), this.isTouchInside(a)) {
            var b = this.getTouchLocation(a);
            this.setValue(this._value + (b.x < this._minusSprite.getContentSize().width ? 0 - this._stepValue : this._stepValue))
        }
    },
    setMinusSprite: function(a) {
        this._minusSprite = a
    },
    getMinusSprite: function() {
        return this._minusSprite
    },
    setPlusSprite: function(a) {
        this._plusSprite = a
    },
    getPlusSprite: function() {
        return this._plusSprite
    },
    setMinusLabel: function(a) {
        this._minusLabel = a
    },
    getMinusLabel: function() {
        return this._minusLabel
    },
    setPlusLabel: function(a) {
        this._plusLabel = a
    },
    getPlusLabel: function() {
        return this._plusLabel
    }
}), _p = cc.ControlStepper.prototype, cc.defineGetterSetter(_p, "wraps", _p.getWraps, _p.setWraps), cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue), cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue), cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue), cc.defineGetterSetter(_p, "stepValue", _p.getStepValue, _p.setStepValue), cc.defineGetterSetter(_p, "continuous", _p.isContinuous), cc.defineGetterSetter(_p, "minusSprite", _p.getMinusSprite, _p.setMinusSprite), cc.defineGetterSetter(_p, "plusSprite", _p.getPlusSprite, _p.setPlusSprite), cc.defineGetterSetter(_p, "minusLabel", _p.getMinusLabel, _p.setMinusLabel), cc.defineGetterSetter(_p, "plusLabel", _p.getPlusLabel, _p.setPlusLabel), _p = null, cc.ControlStepper.create = function(a, b) {
    return new cc.ControlStepper(a, b)
}, cc.ControlPotentiometer = cc.Control.extend({
    _thumbSprite: null,
    _progressTimer: null,
    _previousLocation: null,
    _value: 0,
    _minimumValue: 0,
    _maximumValue: 1,
    _className: "ControlPotentiometer",
    ctor: function(a, b, c) {
        cc.Control.prototype.ctor.call(this), void 0 != c && (a = cc.Sprite.create(a), c = cc.Sprite.create(c), b = cc.ProgressTimer.create(cc.Sprite.create(b)), this.initWithTrackSprite_ProgressTimer_ThumbSprite(a, b, c))
    },
    initWithTrackSprite_ProgressTimer_ThumbSprite: function(a, b, c) {
        return this.init() ? (this.setProgressTimer(b), this.setThumbSprite(c), this._thumbSprite.setPosition(b.getPosition()), this.addChild(c, 2), this.addChild(b, 1), this.addChild(a), this.setContentSize(a.getContentSize()), this._minimumValue = 0, this._maximumValue = 1, this.setValue(this._minimumValue), !0) : !1
    },
    setEnabled: function(a) {
        this.setEnabled(a), this._thumbSprite != NULL && this._thumbSprite.setOpacity(a ? 255 : 128)
    },
    setValue: function(a) {
        a < this._minimumValue && (a = this._minimumValue), a > this._maximumValue && (a = this._maximumValue), this._value = a, a = (a - this._minimumValue) / (this._maximumValue - this._minimumValue), this._progressTimer.setPercentage(100 * a), this._thumbSprite.setRotation(360 * a), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    getValue: function() {
        return this._value
    },
    setMinimumValue: function(a) {
        this._minimumValue = a, this._minimumValue >= this._maximumValue && (this._maximumValue = this._minimumValue + 1), this.setValue(this._maximumValue)
    },
    getMinimumValue: function() {
        return this._minimumValue
    },
    setMaximumValue: function(a) {
        this._maximumValue = a, this._maximumValue <= this._minimumValue && (this._minimumValue = this._maximumValue - 1), this.setValue(this._minimumValue)
    },
    getMaximumValue: function() {
        return this._maximumValue
    },
    isTouchInside: function(a) {
        return a = this.getTouchLocation(a), this.distanceBetweenPointAndPoint(this._progressTimer.getPosition(), a) < Math.min(this.getContentSize().width / 2, this.getContentSize().height / 2)
    },
    onTouchBegan: function(a) {
        return this.isTouchInside(a) && this.isEnabled() && this.isVisible() ? (this._previousLocation = this.getTouchLocation(a), this.potentiometerBegan(this._previousLocation), !0) : !1
    },
    onTouchMoved: function(a) {
        var b = this.getTouchLocation(a);
        this.potentiometerMoved(b)
    },
    onTouchEnded: function() {
        this.potentiometerEnded(cc.p(0, 0))
    },
    distanceBetweenPointAndPoint: function(a, b) {
        var c = a.x - b.x,
            d = a.y - b.y;
        return Math.sqrt(c * c + d * d)
    },
    angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint: function(a, b, c, d) {
        var e = d.x - c.x;
        return c = d.y - c.y, a = Math.atan2(b.x - a.x, b.y - a.y), e = Math.atan2(e, c), 180 * (a - e) / Math.PI
    },
    potentiometerBegan: function() {
        this.setSelected(!0), this.getThumbSprite().setColor(cc.color.GRAY)
    },
    potentiometerMoved: function(a) {
        var b = this.angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(this._progressTimer.getPosition(), a, this._progressTimer.getPosition(), this._previousLocation);
        b > 180 ? b -= 360 : -180 > b && (b += 360), this.setValue(this._value + b / 360 * (this._maximumValue - this._minimumValue)), this._previousLocation = a
    },
    potentiometerEnded: function() {
        this.getThumbSprite().setColor(cc.color.WHITE), this.setSelected(!1)
    },
    setThumbSprite: function(a) {
        this._thumbSprite = a
    },
    getThumbSprite: function() {
        return this._thumbSprite
    },
    setProgressTimer: function(a) {
        this._progressTimer = a
    },
    getProgressTimer: function() {
        return this._progressTimer
    },
    setPreviousLocation: function(a) {
        this._previousLocation = a
    },
    getPreviousLocation: function() {
        return this._previousLocation
    }
}), _p = cc.ControlPotentiometer.prototype, cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue), cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue), cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue), cc.defineGetterSetter(_p, "progressTimer", _p.getProgressTimer, _p.setProgressTimer), cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite, _p.setThumbSprite), cc.defineGetterSetter(_p, "prevLocation", _p.getPreviousLocation, _p.setPreviousLocation), _p = null, cc.ControlPotentiometer.create = function(a, b, c) {
    return new cc.ControlPotentiometer(a, b, c)
}, cc.SCROLLVIEW_DIRECTION_NONE = -1, cc.SCROLLVIEW_DIRECTION_HORIZONTAL = 0, cc.SCROLLVIEW_DIRECTION_VERTICAL = 1, cc.SCROLLVIEW_DIRECTION_BOTH = 2;
var SCROLL_DEACCEL_RATE = .95,
    SCROLL_DEACCEL_DIST = 1,
    BOUNCE_DURATION = .15,
    INSET_RATIO = .2,
    MOVE_INCH = .04375,
    BOUNCE_BACK_FACTOR = .35;
cc.convertDistanceFromPointToInch = function(a) {
    var b = cc.view,
        b = (b.getScaleX() + b.getScaleY()) / 2;
    return a * b / 160
}, cc.ScrollViewDelegate = cc.Class.extend({
    scrollViewDidScroll: function() {},
    scrollViewDidZoom: function() {}
}), cc.ScrollView = cc.Layer.extend({
    _zoomScale: 0,
    _minZoomScale: 0,
    _maxZoomScale: 0,
    _delegate: null,
    _direction: cc.SCROLLVIEW_DIRECTION_BOTH,
    _dragging: !1,
    _contentOffset: null,
    _container: null,
    _touchMoved: !1,
    _maxInset: null,
    _minInset: null,
    _bounceable: !1,
    _clippingToBounds: !1,
    _scrollDistance: null,
    _touchPoint: null,
    _touchLength: 0,
    _touches: null,
    _viewSize: null,
    _minScale: 0,
    _maxScale: 0,
    _parentScissorRect: null,
    _scissorRestored: !1,
    _tmpViewRect: null,
    _touchListener: null,
    _className: "ScrollView",
    ctor: function(a, b) {
        cc.Layer.prototype.ctor.call(this), this._contentOffset = cc.p(0, 0), this._maxInset = cc.p(0, 0), this._minInset = cc.p(0, 0), this._scrollDistance = cc.p(0, 0), this._touchPoint = cc.p(0, 0), this._touches = [], this._viewSize = cc.size(0, 0), this._parentScissorRect = new cc.Rect(0, 0, 0, 0), this._tmpViewRect = new cc.Rect(0, 0, 0, 0), void 0 != b ? this.initWithViewSize(a, b) : this.initWithViewSize(cc.size(200, 200), null)
    },
    init: function() {
        return this.initWithViewSize(cc.size(200, 200), null)
    },
    initWithViewSize: function(a, b) {
        var c = cc.p(0, 0);
        return cc.Layer.prototype.init.call(this) ? (this._container = b, this._container || (this._container = cc.Layer.create(), this._container.ignoreAnchorPointForPosition(!1), this._container.setAnchorPoint(c)), this.setViewSize(a), this.setTouchEnabled(!0), this._touches.length = 0, this._delegate = null, this._clippingToBounds = this._bounceable = !0, this._direction = cc.SCROLLVIEW_DIRECTION_BOTH, this._container.setPosition(c), this._touchLength = 0, this.addChild(this._container), this._minScale = this._maxScale = 1, !0) : !1
    },
    setContentOffset: function(a, b) {
        if (b) this.setContentOffsetInDuration(a, BOUNCE_DURATION);
        else {
            if (!this._bounceable) {
                var c = this.minContainerOffset(),
                    d = this.maxContainerOffset();
                a.x = Math.max(c.x, Math.min(d.x, a.x)), a.y = Math.max(c.y, Math.min(d.y, a.y))
            }
            this._container.setPosition(a), c = this._delegate, null != c && c.scrollViewDidScroll && c.scrollViewDidScroll(this)
        }
    },
    getContentOffset: function() {
        var a = this._container.getPosition();
        return cc.p(a.x, a.y)
    },
    setContentOffsetInDuration: function(a, b) {
        var c = cc.MoveTo.create(b, a),
            d = cc.CallFunc.create(this._stoppedAnimatedScroll, this);
        this._container.runAction(cc.Sequence.create(c, d)), this.schedule(this._performedAnimatedScroll)
    },
    setZoomScale: function(a, b) {
        if (b) this.setZoomScaleInDuration(a, BOUNCE_DURATION);
        else {
            var c = this._container;
            if (c.getScale() != a) {
                var d, e;
                0 == this._touchLength ? (e = this._viewSize, e = cc.p(.5 * e.width, .5 * e.height), e = this.convertToWorldSpace(e)) : e = this._touchPoint, d = c.convertToNodeSpace(e), c.setScale(Math.max(this._minScale, Math.min(this._maxScale, a))), d = c.convertToWorldSpace(d), e = cc.pSub(e, d), this._delegate && this._delegate.scrollViewDidZoom && this._delegate.scrollViewDidZoom(this), this.setContentOffset(cc.pAdd(c.getPosition(), e))
            }
        }
    },
    getZoomScale: function() {
        return this._container.getScale()
    },
    setZoomScaleInDuration: function(a, b) {
        if (b > 0) {
            var c = this._container.getScale();
            c != a && (c = cc.ActionTween.create(b, "zoomScale", c, a), this.runAction(c))
        } else this.setZoomScale(a)
    },
    minContainerOffset: function() {
        var a = this._container,
            b = a.getContentSize(),
            c = this._viewSize;
        return cc.p(c.width - b.width * a.getScaleX(), c.height - b.height * a.getScaleY())
    },
    maxContainerOffset: function() {
        return cc.p(0, 0)
    },
    isNodeVisible: function(a) {
        var b = this.getContentOffset(),
            c = this.getViewSize(),
            d = this.getZoomScale(),
            b = cc.rect(-b.x / d, -b.y / d, c.width / d, c.height / d);
        return cc.rectIntersectsRect(b, a.getBoundingBox())
    },
    pause: function(a) {
        this._container.pause(), a = this._container.getChildren();
        for (var b = 0; b < a.length; b++) a[b].pause();
        this._super()
    },
    resume: function(a) {
        a = this._container.getChildren();
        for (var b = 0, c = a.length; c > b; b++) a[b].resume();
        this._container.resume(), this._super()
    },
    isDragging: function() {
        return this._dragging
    },
    isTouchMoved: function() {
        return this._touchMoved
    },
    isBounceable: function() {
        return this._bounceable
    },
    setBounceable: function(a) {
        this._bounceable = a
    },
    getViewSize: function() {
        return this._viewSize
    },
    setViewSize: function(a) {
        this._viewSize = a, cc.Node.prototype.setContentSize.call(this, a)
    },
    getContainer: function() {
        return this._container
    },
    setContainer: function(a) {
        a && (this.removeAllChildren(!0), this._container = a, a.ignoreAnchorPointForPosition(!1), a.setAnchorPoint(0, 0), this.addChild(a), this.setViewSize(this._viewSize))
    },
    getDirection: function() {
        return this._direction
    },
    setDirection: function(a) {
        this._direction = a
    },
    getDelegate: function() {
        return this._delegate
    },
    setDelegate: function(a) {
        this._delegate = a
    },
    onTouchBegan: function(a) {
        if (!this.isVisible()) return !1;
        var b = this._getViewRect(),
            c = this._container,
            d = c.convertToWorldSpace(c.convertTouchToNodeSpace(a)),
            e = this._touches;
        return 2 < e.length || this._touchMoved || !cc.rectContainsPoint(b, d) ? !1 : (e.push(a), 1 === e.length ? (this._touchPoint = this.convertTouchToNodeSpace(a), this._touchMoved = !1, this._dragging = !0, this._scrollDistance.x = 0, this._touchLength = this._scrollDistance.y = 0) : 2 == e.length && (this._touchPoint = cc.pMidpoint(this.convertTouchToNodeSpace(e[0]), this.convertTouchToNodeSpace(e[1])), this._touchLength = cc.pDistance(c.convertTouchToNodeSpace(e[0]), c.convertTouchToNodeSpace(e[1])), this._dragging = !1), !0)
    },
    onTouchMoved: function(a) {
        if (this.isVisible())
            if (1 === this._touches.length && this._dragging) {
                this._touchMoved = !0, this._getViewRect();
                var b, c = this.convertTouchToNodeSpace(a),
                    d = cc.pSub(c, this._touchPoint),
                    e = 0,
                    f = this._direction;
                if (f === cc.SCROLLVIEW_DIRECTION_VERTICAL) e = d.y, b = this._container.getPositionY(), this.minContainerOffset().y <= b && b <= this.maxContainerOffset().y || (d.y *= BOUNCE_BACK_FACTOR);
                else if (f === cc.SCROLLVIEW_DIRECTION_HORIZONTAL) e = d.x, b = this._container.getPositionX(), this.minContainerOffset().x <= b && b <= this.maxContainerOffset().x || (d.x *= BOUNCE_BACK_FACTOR);
                else {
                    e = Math.sqrt(d.x * d.x + d.y * d.y), b = this._container.getPositionY();
                    var g = this.minContainerOffset(),
                        h = this.maxContainerOffset();
                    g.y <= b && b <= h.y || (d.y *= BOUNCE_BACK_FACTOR), b = this._container.getPositionX(), g.x <= b && b <= h.x || (d.x *= BOUNCE_BACK_FACTOR)
                } if ((this._touchMoved || !(Math.abs(cc.convertDistanceFromPointToInch(e)) < MOVE_INCH)) && (this._touchMoved || (d.x = 0, d.y = 0), this._touchPoint = c, this._touchMoved = !0, this._dragging)) {
                    switch (f) {
                        case cc.SCROLLVIEW_DIRECTION_VERTICAL:
                            d.x = 0;
                            break;
                        case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                            d.y = 0
                    }
                    e = this._container.getPosition(), c = e.x + d.x, e = e.y + d.y, this._scrollDistance = d, this.setContentOffset(cc.p(c, e))
                }
            } else 2 === this._touches.length && !this._dragging && (d = cc.pDistance(this._container.convertTouchToNodeSpace(this._touches[0]), this._container.convertTouchToNodeSpace(this._touches[1])), this.setZoomScale(this.getZoomScale() * d / this._touchLength))
    },
    onTouchEnded: function() {
        this.isVisible() && (1 == this._touches.length && this._touchMoved && this.schedule(this._deaccelerateScrolling), this._touches.length = 0, this._touchMoved = this._dragging = !1)
    },
    onTouchCancelled: function() {
        this.isVisible() && (this._touches.length = 0, this._touchMoved = this._dragging = !1)
    },
    setContentSize: function(a, b) {
        null != this.getContainer() && (void 0 === b ? this.getContainer().setContentSize(a) : this.getContainer().setContentSize(a, b), this.updateInset())
    },
    _setWidth: function(a) {
        var b = this.getContainer();
        null != b && (b._setWidth(a), this.updateInset())
    },
    _setHeight: function(a) {
        var b = this.getContainer();
        null != b && (b._setHeight(a), this.updateInset())
    },
    getContentSize: function() {
        return this._container.getContentSize()
    },
    updateInset: function() {
        if (null != this.getContainer()) {
            var a = this._viewSize,
                b = this.maxContainerOffset();
            this._maxInset.x = b.x + a.width * INSET_RATIO, this._maxInset.y = b.y + a.height * INSET_RATIO, b = this.minContainerOffset(), this._minInset.x = b.x - a.width * INSET_RATIO, this._minInset.y = b.y - a.height * INSET_RATIO
        }
    },
    isClippingToBounds: function() {
        return this._clippingToBounds
    },
    setClippingToBounds: function(a) {
        this._clippingToBounds = a
    },
    visit: function(a) {
        if (this.isVisible()) {
            a = a || cc._renderContext;
            var b, c, d, e = this._children;
            if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
                if (a.save(), this.transform(a), this._beforeDraw(a), e && 0 < e.length) {
                    for (d = e.length, this.sortAllChildren(), b = 0; d > b && ((c = e[b]) && 0 > c._localZOrder); b++) c.visit(a);
                    for (this.draw(a); d > b; b++) e[b].visit(a)
                } else this.draw(a);
                this._afterDraw(), a.restore()
            } else {
                cc.kmGLPushMatrix();
                var f = this.grid;
                if (f && f.isActive() && (f.beforeDraw(), this.transformAncestors()), this.transform(a), this._beforeDraw(a), e && 0 < e.length) {
                    for (d = e.length, b = 0; d > b && ((c = e[b]) && 0 > c._localZOrder); b++) c.visit();
                    for (this.draw(a); d > b; b++) e[b].visit()
                } else this.draw(a);
                this._afterDraw(a), f && f.isActive() && f.afterDraw(this), cc.kmGLPopMatrix()
            }
        }
    },
    addChild: function(a, b, c) {
        if (!a) throw Error("child must not nil!");
        b = b || a.getLocalZOrder(), c = c || a.getTag(), this._container != a ? this._container.addChild(a, b, c) : cc.Layer.prototype.addChild.call(this, a, b, c)
    },
    isTouchEnabled: function() {
        return null != this._touchListener
    },
    setTouchEnabled: function(a) {
        this._touchListener && cc.eventManager.removeListener(this._touchListener), this._touchListener = null, a ? (a = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE
        }), this.onTouchBegan && (a.onTouchBegan = this.onTouchBegan.bind(this)), this.onTouchMoved && (a.onTouchMoved = this.onTouchMoved.bind(this)), this.onTouchEnded && (a.onTouchEnded = this.onTouchEnded.bind(this)), this.onTouchCancelled && (a.onTouchCancelled = this.onTouchCancelled.bind(this)), this._touchListener = a, cc.eventManager.addListener(a, this)) : (this._touchMoved = this._dragging = !1, this._touches.length = 0)
    },
    _initWithViewSize: function() {
        return null
    },
    _relocateContainer: function(a) {
        var b = this.minContainerOffset(),
            c = this.maxContainerOffset(),
            d = this._direction,
            e = this._container.getPosition(),
            f = e.x,
            g = e.y;
        (d === cc.SCROLLVIEW_DIRECTION_BOTH || d === cc.SCROLLVIEW_DIRECTION_HORIZONTAL) && (f = Math.max(f, b.x), f = Math.min(f, c.x)), (d == cc.SCROLLVIEW_DIRECTION_BOTH || d == cc.SCROLLVIEW_DIRECTION_VERTICAL) && (g = Math.min(g, c.y), g = Math.max(g, b.y)), (g != e.y || f != e.x) && this.setContentOffset(cc.p(f, g), a)
    },
    _deaccelerateScrolling: function(a) {
        if (this._dragging) this.unschedule(this._deaccelerateScrolling);
        else {
            var b, c;
            b = this._container.getPosition(), a = this._scrollDistance, this._container.setPosition(b.x + a.x, b.y + a.y), this._bounceable ? (b = this._maxInset, c = this._minInset) : (b = this.maxContainerOffset(), c = this.minContainerOffset());
            var d = this._container.getPositionX(),
                e = this._container.getPositionY();
            a.x *= SCROLL_DEACCEL_RATE, a.y *= SCROLL_DEACCEL_RATE, this.setContentOffset(cc.p(d, e)), (Math.abs(a.x) <= SCROLL_DEACCEL_DIST && Math.abs(a.y) <= SCROLL_DEACCEL_DIST || e > b.y || e < c.y || d > b.x || d < c.x || d == b.x || d == c.x || e == b.y || e == c.y) && (this.unschedule(this._deaccelerateScrolling), this._relocateContainer(!0))
        }
    },
    _performedAnimatedScroll: function() {
        this._dragging ? this.unschedule(this._performedAnimatedScroll) : this._delegate && this._delegate.scrollViewDidScroll && this._delegate.scrollViewDidScroll(this)
    },
    _stoppedAnimatedScroll: function() {
        this.unschedule(this._performedAnimatedScroll), this._delegate && this._delegate.scrollViewDidScroll && this._delegate.scrollViewDidScroll(this)
    },
    _beforeDraw: function(a) {
        if (this._clippingToBounds) {
            this._scissorRestored = !1;
            var b = this._getViewRect(),
                c = cc.view,
                d = this.getScaleX(),
                e = this.getScaleY();
            if (a = a || cc._renderContext, cc._renderType === cc._RENDER_TYPE_CANVAS) b = this._viewSize.width * d * c.getScaleX(), c = this._viewSize.height * e * c.getScaleY(), a.beginPath(), a.rect(0, 0, b, -c), a.clip(), a.closePath();
            else if (c = cc.view, c.isScissorEnabled()) {
                if (this._scissorRestored = !0, this._parentScissorRect = c.getScissorRect(), cc.rectIntersection(b, this._parentScissorRect)) {
                    var f = this._parentScissorRect;
                    a = Math.max(b.x, f.x), e = Math.max(b.y, f.y), d = Math.min(b.x + b.width, f.x + f.width), b = Math.min(b.y + b.height, f.y + f.height), c.setScissorInPoints(a, e, d - a, b - e)
                }
            } else a.enable(a.SCISSOR_TEST), c.setScissorInPoints(b.x, b.y, b.width, b.height)
        }
    },
    _afterDraw: function(a) {
        this._clippingToBounds && cc._renderType === cc._RENDER_TYPE_WEBGL && (this._scissorRestored ? (a = this._parentScissorRect, cc.view.setScissorInPoints(a.x, a.y, a.width, a.height)) : (a = a || cc._renderContext, a.disable(a.SCISSOR_TEST)))
    },
    _handleZoom: function() {},
    _getViewRect: function() {
        for (var a = this.convertToWorldSpace(cc.p(0, 0)), b = this._viewSize, c = this.getScaleX(), d = this.getScaleY(), e = this._parent; null != e; e = e.getParent()) c *= e.getScaleX(), d *= e.getScaleY();
        return 0 > c && (a.x += b.width * c, c = -c), 0 > d && (a.y += b.height * d, d = -d), e = this._tmpViewRect, e.x = a.x, e.y = a.y, e.width = b.width * c, e.height = b.height * d, e
    }
}), _p = cc.ScrollView.prototype, cc.defineGetterSetter(_p, "minOffset", _p.minContainerOffset), cc.defineGetterSetter(_p, "maxOffset", _p.maxContainerOffset), cc.defineGetterSetter(_p, "bounceable", _p.isBounceable, _p.setBounceable), cc.defineGetterSetter(_p, "viewSize", _p.getViewSize, _p.setViewSize), cc.defineGetterSetter(_p, "container", _p.getContainer, _p.setContainer), cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection), cc.defineGetterSetter(_p, "delegate", _p.getDelegate, _p.setDelegate), cc.defineGetterSetter(_p, "clippingToBounds", _p.isClippingToBounds, _p.setClippingToBounds), _p = null, cc.ScrollView.create = function(a, b) {
    return new cc.ScrollView(a, b)
}, cc.SortableObject = cc.Class.extend({
    setObjectID: function() {},
    getObjectID: function() {
        return 0
    }
}), cc.SortedObject = cc.SortableObject.extend({
    _objectID: 0,
    ctor: function() {
        this._objectID = 0
    },
    setObjectID: function(a) {
        this._objectID = a
    },
    getObjectID: function() {
        return this._objectID
    }
});
var _compareObject = function(a, b) {
    return a.getObjectID() - b.getObjectID()
};
cc.ArrayForObjectSorting = cc.Class.extend({
    _saveObjectArr: null,
    ctor: function() {
        this._saveObjectArr = []
    },
    insertSortedObject: function(a) {
        if (!a) throw "cc.ArrayForObjectSorting.insertSortedObject(): addObject should be non-null.";
        var b = this.indexOfSortedObject(a);
        this.insertObject(a, b)
    },
    removeSortedObject: function(a) {
        if (0 != this.count()) {
            var b = this.indexOfSortedObject(a);
            b < this.count() && b != cc.INVALID_INDEX && this.objectAtIndex(b).getObjectID() == a.getObjectID() && this.removeObjectAtIndex(b)
        }
    },
    setObjectID_ofSortedObject: function(a, b) {
        var c = this.indexOfSortedObject(b);
        if (c < this.count() && c != cc.INVALID_INDEX) {
            var d = this.objectAtIndex(c);
            d.getObjectID() == b.getObjectID() && (this.removeObjectAtIndex(c), d.setObjectID(a), this.insertSortedObject(d))
        }
    },
    objectWithObjectID: function(a) {
        if (0 == this.count()) return null;
        var b = new cc.SortedObject;
        b.setObjectID(a);
        var c = this.indexOfSortedObject(b);
        return c < this.count() && c != cc.INVALID_INDEX && (b = this.objectAtIndex(c), b.getObjectID() != a && (b = null)), b
    },
    getObjectWithObjectID: function() {
        return null
    },
    indexOfSortedObject: function(a) {
        var b = 0;
        if (a) {
            var c = 0;
            a = a.getObjectID();
            for (var d = this._saveObjectArr, e = 0; e < d.length; e++) {
                var f = d[e].getObjectID();
                if (a == f || a >= c && f > a) break;
                c = f, b++
            }
        } else b = cc.INVALID_INDEX;
        return b
    },
    count: function() {
        return this._saveObjectArr.length
    },
    lastObject: function() {
        var a = this._saveObjectArr;
        return 0 == a.length ? null : a[a.length - 1]
    },
    objectAtIndex: function(a) {
        return this._saveObjectArr[a]
    },
    addObject: function(a) {
        this._saveObjectArr.push(a), this._saveObjectArr.sort(_compareObject)
    },
    removeObjectAtIndex: function(a) {
        this._saveObjectArr.splice(a, 1), this._saveObjectArr.sort(_compareObject)
    },
    insertObject: function(a, b) {
        this._saveObjectArr.splice(b, 0, a), this._saveObjectArr.sort(_compareObject)
    }
}), cc.TABLEVIEW_FILL_TOPDOWN = 0, cc.TABLEVIEW_FILL_BOTTOMUP = 1, cc.TableViewCell = cc.Node.extend({
    _idx: 0,
    _className: "TableViewCell",
    getIdx: function() {
        return this._idx
    },
    setIdx: function(a) {
        this._idx = a
    },
    reset: function() {
        this._idx = cc.INVALID_INDEX
    },
    setObjectID: function(a) {
        this._idx = a
    },
    getObjectID: function() {
        return this._idx
    }
}), _p = cc.TableViewCell.prototype, cc.defineGetterSetter(_p, "objectId", _p.getObjectID, _p.setObjectID), _p = null, cc.TableViewDelegate = cc.ScrollViewDelegate.extend({
    tableCellTouched: function() {},
    tableCellHighlight: function() {},
    tableCellUnhighlight: function() {},
    tableCellWillRecycle: function() {}
}), cc.TableViewDataSource = cc.Class.extend({
    tableCellSizeForIndex: function(a) {
        return this.cellSizeForTable(a)
    },
    cellSizeForTable: function() {
        return cc.size(0, 0)
    },
    tableCellAtIndex: function() {
        return null
    },
    numberOfCellsInTableView: function() {
        return 0
    }
}), cc.TableView = cc.ScrollView.extend({
    _vOrdering: null,
    _indices: null,
    _cellsFreed: null,
    _dataSource: null,
    _tableViewDelegate: null,
    _oldDirection: null,
    _cellsPositions: null,
    _touchedCell: null,
    ctor: function(a, b, c) {
        cc.ScrollView.prototype.ctor.call(this), this._oldDirection = cc.SCROLLVIEW_DIRECTION_NONE, this._cellsPositions = [], this.initWithViewSize(b, c), this.setDataSource(a), this._updateCellPositions(), this._updateContentSize()
    },
    __indexFromOffset: function(a) {
        var b = 0,
            c = this._dataSource.numberOfCellsInTableView(this) - 1;
        switch (this.getDirection()) {
            case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                a = a.x;
                break;
            default:
                a = a.y
        }
        for (var d = this._cellsPositions; c >= b;) {
            var e = 0 | b + (c - b) / 2,
                f = d[e],
                g = d[e + 1];
            if (a >= f && g >= a) return e;
            f > a ? c = e - 1 : b = e + 1
        }
        return 0 >= b ? 0 : -1
    },
    _indexFromOffset: function(a) {
        var b = {
            x: a.x,
            y: a.y
        };
        return a = this._dataSource.numberOfCellsInTableView(this) - 1, this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (b.y = this.getContainer().getContentSize().height - b.y), b = this.__indexFromOffset(b), -1 != b && (b = Math.max(0, b), b > a && (b = cc.INVALID_INDEX)), b
    },
    __offsetFromIndex: function(a) {
        switch (this.getDirection()) {
            case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                a = cc.p(this._cellsPositions[a], 0);
                break;
            default:
                a = cc.p(0, this._cellsPositions[a])
        }
        return a
    },
    _offsetFromIndex: function(a) {
        var b = this.__offsetFromIndex(a);
        return a = this._dataSource.tableCellSizeForIndex(this, a), this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (b.y = this.getContainer().getContentSize().height - b.y - a.height), b
    },
    _updateCellPositions: function() {
        var a = this._dataSource.numberOfCellsInTableView(this),
            b = this._cellsPositions;
        if (a > 0) {
            for (var c, d = 0, e = this._dataSource, f = 0; a > f; f++) switch (b[f] = d, c = e.tableCellSizeForIndex(this, f), this.getDirection()) {
                case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                    d += c.width;
                    break;
                default:
                    d += c.height
            }
            this._cellsPositions[a] = d
        }
    },
    _updateContentSize: function() {
        var a = cc.size(0, 0),
            b = this._dataSource.numberOfCellsInTableView(this);
        if (b > 0) switch (a = this._cellsPositions[b], this.getDirection()) {
            case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                a = cc.size(a, this._viewSize.height);
                break;
            default:
                a = cc.size(this._viewSize.width, a)
        }
        this.setContentSize(a), this._oldDirection != this._direction && (this.setContentOffset(this._direction == cc.SCROLLVIEW_DIRECTION_HORIZONTAL ? cc.p(0, 0) : cc.p(0, this.minContainerOffset().y)), this._oldDirection = this._direction)
    },
    _moveCellOutOfSight: function(a) {
        this._tableViewDelegate && this._tableViewDelegate.tableCellWillRecycle && this._tableViewDelegate.tableCellWillRecycle(this, a), this._cellsFreed.addObject(a), this._cellsUsed.removeSortedObject(a), cc.arrayRemoveObject(this._indices, a.getIdx()), a.reset(), a.getParent() == this.getContainer() && this.getContainer().removeChild(a, !0)
    },
    _setIndexForCell: function(a, b) {
        b.setAnchorPoint(0, 0), b.setPosition(this._offsetFromIndex(a)), b.setIdx(a)
    },
    _addCellIfNecessary: function(a) {
        a.getParent() != this.getContainer() && this.getContainer().addChild(a), this._cellsUsed.insertSortedObject(a);
        var b = this._indices;
        a = a.getIdx(), -1 == b.indexOf(a) && (b.push(a), b.sort(function(a, b) {
            return a - b
        }))
    },
    getDataSource: function() {
        return this._dataSource
    },
    setDataSource: function(a) {
        this._dataSource = a
    },
    getDelegate: function() {
        return this._tableViewDelegate
    },
    setDelegate: function(a) {
        this._tableViewDelegate = a
    },
    setVerticalFillOrder: function(a) {
        this._vOrdering != a && (this._vOrdering = a, 0 < this._cellsUsed.count() && this.reloadData())
    },
    getVerticalFillOrder: function() {
        return this._vOrdering
    },
    initWithViewSize: function(a, b) {
        return cc.ScrollView.prototype.initWithViewSize.call(this, a, b) ? (this._cellsUsed = new cc.ArrayForObjectSorting, this._cellsFreed = new cc.ArrayForObjectSorting, this._indices = [], this._tableViewDelegate = null, this._vOrdering = cc.TABLEVIEW_FILL_BOTTOMUP, this.setDirection(cc.SCROLLVIEW_DIRECTION_VERTICAL), cc.ScrollView.prototype.setDelegate.call(this, this), !0) : !1
    },
    updateCellAtIndex: function(a) {
        if (!(a == cc.INVALID_INDEX || a > this._dataSource.numberOfCellsInTableView(this) - 1)) {
            var b = this.cellAtIndex(a);
            b && this._moveCellOutOfSight(b), b = this._dataSource.tableCellAtIndex(this, a), this._setIndexForCell(a, b), this._addCellIfNecessary(b)
        }
    },
    insertCellAtIndex: function(a) {
        if (!(a == cc.INVALID_INDEX || a > this._dataSource.numberOfCellsInTableView(this) - 1)) {
            var b, c = this._cellsUsed;
            if (b = c.objectWithObjectID(a))
                for (var d = b = c.indexOfSortedObject(b); d < c.count(); d++) b = c.objectAtIndex(d), this._setIndexForCell(b.getIdx() + 1, b);
            b = this._dataSource.tableCellAtIndex(this, a), this._setIndexForCell(a, b), this._addCellIfNecessary(b), this._updateCellPositions(), this._updateContentSize()
        }
    },
    removeCellAtIndex: function(a) {
        if (!(a == cc.INVALID_INDEX || a > this._dataSource.numberOfCellsInTableView(this) - 1)) {
            var b = this.cellAtIndex(a);
            if (b) {
                var c = this._cellsUsed,
                    d = c.indexOfSortedObject(b);
                for (this._moveCellOutOfSight(b), cc.arrayRemoveObject(this._indices, a), this._updateCellPositions(), a = c.count() - 1; a > d; a--) b = c.objectAtIndex(a), this._setIndexForCell(b.getIdx() - 1, b)
            }
        }
    },
    reloadData: function() {
        this._oldDirection = cc.SCROLLVIEW_DIRECTION_NONE;
        for (var a = this._cellsUsed, b = this._cellsFreed, c = this.getContainer(), d = 0, e = a.count(); e > d; d++) {
            var f = a.objectAtIndex(d);
            this._tableViewDelegate && this._tableViewDelegate.tableCellWillRecycle && this._tableViewDelegate.tableCellWillRecycle(this, f), b.addObject(f), f.reset(), f.getParent() == c && c.removeChild(f, !0)
        }
        this._indices = [], this._cellsUsed = new cc.ArrayForObjectSorting, this._updateCellPositions(), this._updateContentSize(), 0 < this._dataSource.numberOfCellsInTableView(this) && this.scrollViewDidScroll(this)
    },
    dequeueCell: function() {
        if (0 === this._cellsFreed.count()) return null;
        var a = this._cellsFreed.objectAtIndex(0);
        return this._cellsFreed.removeObjectAtIndex(0), a
    },
    cellAtIndex: function(a) {
        return -1 == this._indices.indexOf(a) ? null : this._cellsUsed.objectWithObjectID(a)
    },
    scrollViewDidScroll: function(a) {
        var b = this._dataSource.numberOfCellsInTableView(this);
        if (0 !== b) {
            null != this._tableViewDelegate && this._tableViewDelegate.scrollViewDidScroll && this._tableViewDelegate.scrollViewDidScroll(this);
            var c = 0,
                d = this._viewSize,
                c = this.getContainer(),
                e = this.getContentOffset();
            e.x *= -1, e.y *= -1;
            var f = Math.max(b - 1, 0);
            if (this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (e.y += d.height / c.getScaleY()), a = this._indexFromOffset(e), a === cc.INVALID_INDEX && (a = b - 1), e.y = this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN ? e.y - d.height / c.getScaleY() : e.y + d.height / c.getScaleY(), e.x += d.width / c.getScaleX(), d = this._indexFromOffset(e), d === cc.INVALID_INDEX && (d = b - 1), e = this._cellsUsed, 0 < e.count())
                for (b = e.objectAtIndex(0), c = b.getIdx(); a > c && (this._moveCellOutOfSight(b), 0 < e.count());) b = e.objectAtIndex(0), c = b.getIdx();
            if (0 < e.count())
                for (b = e.lastObject(), c = b.getIdx(); f >= c && c > d && (this._moveCellOutOfSight(b), 0 < e.count());) b = e.lastObject(), c = b.getIdx();
            for (f = this._indices; d >= a; a++) - 1 == f.indexOf(a) && this.updateCellAtIndex(a)
        }
    },
    scrollViewDidZoom: function() {},
    onTouchEnded: function(a, b) {
        if (this.isVisible()) {
            if (this._touchedCell) {
                var c = this.getBoundingBox(),
                    d = cc.p(c.x, c.y),
                    d = this._parent.convertToWorldSpace(d);
                c.x = d.x, c.y = d.y, d = this._tableViewDelegate, cc.rectContainsPoint(c, a.getLocation()) && null != d && (d.tableCellUnhighlight && d.tableCellUnhighlight(this, this._touchedCell), d.tableCellTouched && d.tableCellTouched(this, this._touchedCell)), this._touchedCell = null
            }
            cc.ScrollView.prototype.onTouchEnded.call(this, a, b)
        }
    },
    onTouchBegan: function(a, b) {
        if (!this.isVisible()) return !1;
        var c = cc.ScrollView.prototype.onTouchBegan.call(this, a, b);
        if (1 === this._touches.length) {
            var d;
            d = this.getContainer().convertTouchToNodeSpace(a), d = this._indexFromOffset(d), (this._touchedCell = d === cc.INVALID_INDEX ? null : this.cellAtIndex(d)) && null != this._tableViewDelegate && this._tableViewDelegate.tableCellHighlight && this._tableViewDelegate.tableCellHighlight(this, this._touchedCell)
        } else this._touchedCell && (null != this._tableViewDelegate && this._tableViewDelegate.tableCellUnhighlight && this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null);
        return c
    },
    onTouchMoved: function(a, b) {
        cc.ScrollView.prototype.onTouchMoved.call(this, a, b), this._touchedCell && this.isTouchMoved() && (null != this._tableViewDelegate && this._tableViewDelegate.tableCellUnhighlight && this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null)
    },
    onTouchCancelled: function(a, b) {
        cc.ScrollView.prototype.onTouchCancelled.call(this, a, b), this._touchedCell && (null != this._tableViewDelegate && this._tableViewDelegate.tableCellUnhighlight && this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null)
    }
}), _p = cc.TableView.prototype, cc.defineGetterSetter(_p, "dataSource", _p.getDataSource, _p.setDataSource), cc.defineGetterSetter(_p, "delegate", _p.getDelegate, _p.setDelegate), cc.defineGetterSetter(_p, "verticalFillOrder", _p.getVerticalFillOrder, _p.setVerticalFillOrder), _p = null, cc.TableView.create = function(a, b, c) {
    return cc.TableView(a, b, c)
};
var PROPERTY_POSITION = "position",
    PROPERTY_CONTENTSIZE = "contentSize",
    PROPERTY_SKEW = "skew",
    PROPERTY_ANCHORPOINT = "anchorPoint",
    PROPERTY_SCALE = "scale",
    PROPERTY_ROTATION = "rotation",
    PROPERTY_TAG = "tag",
    PROPERTY_IGNOREANCHORPOINTFORPOSITION = "ignoreAnchorPointForPosition",
    PROPERTY_VISIBLE = "visible",
    ASSERT_FAIL_UNEXPECTED_PROPERTY = function(a) {
        cc.log("Unexpected property: '" + a + "'!")
    }, ASSERT_FAIL_UNEXPECTED_PROPERTYTYPE = function(a) {
        cc.log("Unexpected property type: '" + a + "'!")
    };
cc.NodeLoader = cc.Class.extend({
    _customProperties: null,
    ctor: function() {
        this._customProperties = new cc._Dictionary
    },
    loadCCNode: function(a, b) {
        return this._createCCNode(a, b)
    },
    parseProperties: function(a, b, c) {
        for (var d = c.readInt(!1), e = c.readInt(!1), e = d + e, f = 0; e > f; f++) {
            var g = f >= d,
                h = c.readInt(!1),
                i = c.readCachedString(),
                j = !1,
                k = c.readByte();
            switch ((k === CCB_PLATFORM_ALL || k === CCB_PLATFORM_IOS || k === CCB_PLATFORM_MAC) && (j = !0), a instanceof cc.BuilderFile ? a.getCCBFileNode() && g && (a = a.getCCBFileNode(), j = -1 != a.userObject.indexOf(i)) : g && a == c.getAnimationManager().getRootNode() && (g = a.userObject, g || (g = [], a.userObject = g), g.push(i)), h) {
                case CCB_PROPTYPE_POSITION:
                    h = this.parsePropTypePosition(a, b, c, i), j && this.onHandlePropTypePosition(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_POINT:
                    h = this.parsePropTypePoint(a, b, c), j && this.onHandlePropTypePoint(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_POINTLOCK:
                    h = this.parsePropTypePointLock(a, b, c), j && this.onHandlePropTypePointLock(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_SIZE:
                    h = this.parsePropTypeSize(a, b, c), j && this.onHandlePropTypeSize(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_SCALELOCK:
                    h = this.parsePropTypeScaleLock(a, b, c, i), j && this.onHandlePropTypeScaleLock(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_FLOATXY:
                    h = this.parsePropTypeFloatXY(a, b, c), j && this.onHandlePropTypeFloatXY(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_FLOAT:
                    h = this.parsePropTypeFloat(a, b, c), j && this.onHandlePropTypeFloat(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_DEGREES:
                    h = this.parsePropTypeDegrees(a, b, c, i), j && this.onHandlePropTypeDegrees(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_FLOATSCALE:
                    h = this.parsePropTypeFloatScale(a, b, c), j && this.onHandlePropTypeFloatScale(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_INTEGER:
                    h = this.parsePropTypeInteger(a, b, c), j && this.onHandlePropTypeInteger(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_INTEGERLABELED:
                    h = this.parsePropTypeIntegerLabeled(a, b, c), j && this.onHandlePropTypeIntegerLabeled(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_FLOATVAR:
                    h = this.parsePropTypeFloatVar(a, b, c), j && this.onHandlePropTypeFloatVar(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_CHECK:
                    h = this.parsePropTypeCheck(a, b, c, i), j && this.onHandlePropTypeCheck(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_SPRITEFRAME:
                    h = this.parsePropTypeSpriteFrame(a, b, c, i), j && this.onHandlePropTypeSpriteFrame(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_ANIMATION:
                    h = this.parsePropTypeAnimation(a, b, c), j && this.onHandlePropTypeAnimation(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_TEXTURE:
                    h = this.parsePropTypeTexture(a, b, c), j && this.onHandlePropTypeTexture(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_BYTE:
                    h = this.parsePropTypeByte(a, b, c, i), j && this.onHandlePropTypeByte(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_COLOR3:
                    h = this.parsePropTypeColor3(a, b, c, i), j && this.onHandlePropTypeColor3(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_COLOR4VAR:
                    h = this.parsePropTypeColor4FVar(a, b, c), j && this.onHandlePropTypeColor4FVar(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_FLIP:
                    h = this.parsePropTypeFlip(a, b, c), j && this.onHandlePropTypeFlip(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_BLENDMODE:
                    h = this.parsePropTypeBlendFunc(a, b, c), j && this.onHandlePropTypeBlendFunc(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_FNTFILE:
                    h = c.getCCBRootPath() + this.parsePropTypeFntFile(a, b, c), j && this.onHandlePropTypeFntFile(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_FONTTTF:
                    h = this.parsePropTypeFontTTF(a, b, c), j && this.onHandlePropTypeFontTTF(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_STRING:
                    h = this.parsePropTypeString(a, b, c), j && this.onHandlePropTypeString(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_TEXT:
                    h = this.parsePropTypeText(a, b, c), j && this.onHandlePropTypeText(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_BLOCK:
                    h = this.parsePropTypeBlock(a, b, c), j && this.onHandlePropTypeBlock(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_BLOCKCCCONTROL:
                    h = this.parsePropTypeBlockCCControl(a, b, c), j && null != h && this.onHandlePropTypeBlockCCControl(a, b, i, h, c);
                    break;
                case CCB_PROPTYPE_CCBFILE:
                    h = this.parsePropTypeCCBFile(a, b, c), j && this.onHandlePropTypeCCBFile(a, b, i, h, c);
                    break;
                default:
                    ASSERT_FAIL_UNEXPECTED_PROPERTYTYPE(h)
            }
        }
    },
    getCustomProperties: function() {
        return this._customProperties
    },
    _createCCNode: function() {
        return cc.Node.create()
    },
    parsePropTypePosition: function(a, b, c, d) {
        var e = c.readFloat(),
            f = c.readFloat(),
            g = c.readInt(!1),
            h = c.getAnimationManager().getContainerSize(b);
        return b = cc._getAbsolutePosition(e, f, g, h, d), a.setPosition(cc.getAbsolutePosition(b, g, h, d)), -1 < c.getAnimatedProperties().indexOf(d) && (e = [e, f, g], c.getAnimationManager().setBaseValue(e, a, d)), b
    },
    parsePropTypePoint: function(a, b, c) {
        return a = c.readFloat(), c = c.readFloat(), cc.p(a, c)
    },
    parsePropTypePointLock: function(a, b, c) {
        return a = c.readFloat(), c = c.readFloat(), cc.p(a, c)
    },
    parsePropTypeSize: function(a, b, c) {
        a = c.readFloat();
        var d = c.readFloat(),
            e = c.readInt(!1);
        switch (b = c.getAnimationManager().getContainerSize(b), e) {
            case CCB_SIZETYPE_ABSOLUTE:
                break;
            case CCB_SIZETYPE_RELATIVE_CONTAINER:
                a = b.width - a, d = b.height - d;
                break;
            case CCB_SIZETYPE_PERCENT:
                a = b.width * a / 100, d = b.height * d / 100;
                break;
            case CCB_SIZETYPE_HORIZONTAL_PERCENT:
                a = b.width * a / 100;
                break;
            case CCB_SIZETYPE_VERTICAL_PERCENT:
                d = b.height * d / 100;
                break;
            case CCB_SIZETYPE_MULTIPLY_RESOLUTION:
                b = cc.BuilderReader.getResolutionScale(), a *= b, d *= b;
                break;
            default:
                cc.log("Unknown CCB type.")
        }
        return cc.size(a, d)
    },
    parsePropTypeScaleLock: function(a, b, c, d) {
        b = c.readFloat();
        var e = c.readFloat(),
            f = c.readInt(!1);
        return cc.setRelativeScale(a, b, e, f, d), -1 < c.getAnimatedProperties().indexOf(d) && c.getAnimationManager().setBaseValue([b, e, f], a, d), f == CCB_SCALETYPE_MULTIPLY_RESOLUTION && (b *= cc.BuilderReader.getResolutionScale(), e *= cc.BuilderReader.getResolutionScale()), [b, e]
    },
    parsePropTypeFloat: function(a, b, c) {
        return c.readFloat()
    },
    parsePropTypeDegrees: function(a, b, c, d) {
        return b = c.readFloat(), -1 < c.getAnimatedProperties().indexOf(d) && c.getAnimationManager().setBaseValue(b, a, d), b
    },
    parsePropTypeFloatScale: function(a, b, c) {
        return a = c.readFloat(), c.readInt(!1) == CCB_SCALETYPE_MULTIPLY_RESOLUTION && (a *= cc.BuilderReader.getResolutionScale()), a
    },
    parsePropTypeInteger: function(a, b, c) {
        return c.readInt(!0)
    },
    parsePropTypeIntegerLabeled: function(a, b, c) {
        return c.readInt(!0)
    },
    parsePropTypeFloatVar: function(a, b, c) {
        return a = c.readFloat(), c = c.readFloat(), [a, c]
    },
    parsePropTypeCheck: function(a, b, c, d) {
        return b = c.readBool(), -1 < c.getAnimatedProperties().indexOf(d) && c.getAnimationManager().setBaseValue(b, a, d), b
    },
    parsePropTypeSpriteFrame: function(a, b, c, d) {
        b = c.readCachedString();
        var e, f = c.readCachedString();
        return null != f && 0 != f.length && (0 == b.length ? (f = c.getCCBRootPath() + f, b = cc.textureCache.addImage(f), f = b.getContentSize(), f = cc.rect(0, 0, f.width, f.height), e = cc.SpriteFrame.create(b, f)) : (e = cc.spriteFrameCache, b = c.getCCBRootPath() + b, -1 == c.getLoadedSpriteSheet().indexOf(b) && (e.addSpriteFrames(b), c.getLoadedSpriteSheet().push(b)), e = e.getSpriteFrame(f)), -1 < c.getAnimatedProperties().indexOf(d) && c.getAnimationManager().setBaseValue(e, a, d)), e
    },
    parsePropTypeAnimation: function(a, b, c) {
        return a = c.getCCBRootPath() + c.readCachedString(), c = c.readCachedString(), b = null, c = cc.BuilderReader.lastPathComponent(c), a = cc.BuilderReader.lastPathComponent(a), null != c && "" != c && (b = cc.animationCache, b.addAnimations(a), b = b.getAnimation(c)), b
    },
    parsePropTypeTexture: function(a, b, c) {
        return a = c.getCCBRootPath() + c.readCachedString(), "" != a ? cc.textureCache.addImage(a) : null
    },
    parsePropTypeByte: function(a, b, c, d) {
        return b = c.readByte(), -1 < c.getAnimatedProperties().indexOf(d) && c.getAnimationManager().setBaseValue(b, a, d), b
    },
    parsePropTypeColor3: function(a, b, c, d) {
        b = c.readByte();
        var e = c.readByte(),
            f = c.readByte();
        return b = {
            r: b,
            g: e,
            b: f
        }, -1 < c.getAnimatedProperties().indexOf(d) && c.getAnimationManager().setBaseValue(cc.Color3BWapper.create(b), a, d), b
    },
    parsePropTypeColor4FVar: function(a, b, c) {
        a = 0 | 255 * c.readFloat(), b = 0 | 255 * c.readFloat();
        var d = 0 | 255 * c.readFloat(),
            e = c.readFloat(),
            e = 1 >= e ? 0 | 255 * e : e,
            f = 0 | 255 * c.readFloat(),
            g = 0 | 255 * c.readFloat(),
            h = 0 | 255 * c.readFloat();
        c = c.readFloat();
        var i = [];
        return i[0] = {
            r: a,
            g: b,
            b: d,
            a: e
        }, i[1] = {
            r: f,
            g: g,
            b: h,
            a: 1 >= c ? 0 | 255 * c : c
        }, i
    },
    parsePropTypeFlip: function(a, b, c) {
        return a = c.readBool(), c = c.readBool(), [a, c]
    },
    parsePropTypeBlendFunc: function(a, b, c) {
        return a = c.readInt(!1), c = c.readInt(!1), new cc.BlendFunc(a, c)
    },
    parsePropTypeFntFile: function(a, b, c) {
        return c.readCachedString()
    },
    parsePropTypeString: function(a, b, c) {
        return c.readCachedString()
    },
    parsePropTypeText: function(a, b, c) {
        return c.readCachedString()
    },
    parsePropTypeFontTTF: function(a, b, c) {
        return c.readCachedString()
    },
    parsePropTypeBlock: function(a, b, c) {
        b = c.readCachedString();
        var d = c.readInt(!1);
        if (d !== CCB_TARGETTYPE_NONE) {
            var e = null;
            if (c.isJSControlled()) d === CCB_TARGETTYPE_DOCUMENTROOT ? (c.addDocumentCallbackNode(a), c.addDocumentCallbackName(b), c.addDocumentCallbackControlEvents(0)) : (c.addOwnerCallbackNode(a), c.addOwnerCallbackName(b), c.addOwnerCallbackControlEvents(0));
            else if (d === CCB_TARGETTYPE_DOCUMENTROOT ? e = c.getAnimationManager().getRootNode() : d === CCB_TARGETTYPE_OWNER && (e = c.getOwner()), null != e)
                if (0 < b.length) {
                    if (a = 0, null != e && e.onResolveCCBCCMenuItemSelector && (a = e.onResolveCCBCCMenuItemSelector(e, b)), 0 == a && (c = c.getCCBSelectorResolver(), null != c && (a = c.onResolveCCBCCMenuItemSelector(e, b))), 0 != a) return new BlockData(a, e);
                    cc.log("Skipping selector '" + b + "' since no CCBSelectorResolver is present.")
                } else cc.log("Unexpected empty selector.");
                else cc.log("Unexpected NULL target for selector.")
        }
        return null
    },
    parsePropTypeBlockCCControl: function(a, b, c) {
        b = c.readCachedString();
        var d = c.readInt(!1),
            e = c.readInt(!1);
        if (d !== CCB_TARGETTYPE_NONE)
            if (c.isJSControlled()) d == CCB_TARGETTYPE_DOCUMENTROOT ? (c.addDocumentCallbackNode(a), c.addDocumentCallbackName(b), c.addDocumentCallbackControlEvents(e)) : (c.addOwnerCallbackNode(a), c.addOwnerCallbackName(b), c.addOwnerCallbackControlEvents(e));
            else if (a = null, d == CCB_TARGETTYPE_DOCUMENTROOT ? a = c.getAnimationManager().getRootNode() : d == CCB_TARGETTYPE_OWNER && (a = c.getOwner()), null != a)
            if (0 < b.length) {
                if (d = 0, null != a && a.onResolveCCBCCControlSelector && (d = a.onResolveCCBCCControlSelector(a, b)), 0 == d && (c = c.getCCBSelectorResolver(), null != c && (d = c.onResolveCCBCCControlSelector(a, b))), 0 != d) return new BlockCCControlData(d, a, e);
                cc.log("Skipping selector '" + b + "' since no CCBSelectorResolver is present.")
            } else cc.log("Unexpected empty selector.");
            else cc.log("Unexpected NULL target for selector.");
        return null
    },
    parsePropTypeCCBFile: function(a, b, c) {
        var d = c.getCCBRootPath() + c.readCachedString(),
            d = cc.BuilderReader.deletePathExtension(d) + ".ccbi";
        a = new cc.BuilderReader(c);
        var e = cc.loader.getRes(d);
        return e || (e = cc.loader.getUrl(d), e = cc.loader.loadBinarySync(e), cc.loader.cache[d] = e), a.initWithData(e, c.getOwner()), a.getAnimationManager().setRootContainerSize(b.getContentSize()), a.setAnimationManagers(c.getAnimationManagers()), a.getAnimationManager().setOwner(c.getOwner()), b = a.readFileWithCleanUp(!1), c.setAnimationManagers(a.getAnimationManagers()), b && -1 != a.getAnimationManager().getAutoPlaySequenceId() && a.getAnimationManager().runAnimations(a.getAnimationManager().getAutoPlaySequenceId(), 0), b
    },
    parsePropTypeFloatXY: function(a, b, c) {
        return a = c.readFloat(), c = c.readFloat(), [a, c]
    },
    onHandlePropTypePosition: function(a, b, c, d) {
        c === PROPERTY_POSITION ? a.setPosition(d) : ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypePoint: function(a, b, c, d) {
        c === PROPERTY_ANCHORPOINT ? a.setAnchorPoint(d) : ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypePointLock: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeSize: function(a, b, c, d) {
        c === PROPERTY_CONTENTSIZE ? a.setContentSize(d) : ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeScaleLock: function(a, b, c, d) {
        c === PROPERTY_SCALE ? (a.setScaleX(d[0]), a.setScaleY(d[1])) : ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeFloatXY: function(a, b, c, d, e) {
        c === PROPERTY_SKEW ? (a.setSkewX(d[0]), a.setSkewY(d[1])) : (b = c + "X", e = c + "Y", (!a[b] || !a[e]) && ASSERT_FAIL_UNEXPECTED_PROPERTY(c), a[b](d[0]), a[e](d[1]))
    },
    onHandlePropTypeFloat: function(a, b, c, d) {
        this._customProperties.setObject(d, c)
    },
    onHandlePropTypeDegrees: function(a, b, c, d) {
        c === PROPERTY_ROTATION ? a.setRotation(d) : ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeFloatScale: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeInteger: function(a, b, c, d) {
        c === PROPERTY_TAG ? a.setTag(d) : ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeIntegerLabeled: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeFloatVar: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeCheck: function(a, b, c, d) {
        c === PROPERTY_VISIBLE ? a.setVisible(d) : c === PROPERTY_IGNOREANCHORPOINTFORPOSITION ? a.ignoreAnchorPointForPosition(d) : ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeSpriteFrame: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeAnimation: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeTexture: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeByte: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeColor3: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeColor4FVar: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeFlip: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeBlendFunc: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeFntFile: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeString: function(a, b, c, d) {
        this._customProperties.setObject(d, c)
    },
    onHandlePropTypeText: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeFontTTF: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeBlock: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeBlockCCControl: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeCCBFile: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    }
}), cc.NodeLoader.loader = function() {
    return new cc.NodeLoader
}, cc.NodeLoaderListener = cc.Class.extend({
    onNodeLoaded: function() {}
}), cc.BuilderSelectorResolver = cc.Class.extend({
    onResolveCCBCCMenuItemSelector: function() {},
    onResolveCCBCCCallFuncSelector: function() {},
    onResolveCCBCCControlSelector: function() {}
}), cc.BuilderScriptOwnerProtocol = cc.Class.extend({
    createNew: function() {}
}), cc.BuilderMemberVariableAssigner = cc.Class.extend({
    onAssignCCBMemberVariable: function() {
        return !1
    },
    onAssignCCBCustomProperty: function() {
        return !1
    }
});
var PROPERTY_CCBFILE = "ccbFile";
cc.BuilderFileLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        return cc.BuilderFile.create()
    },
    onHandlePropTypeCCBFile: function(a, b, c, d, e) {
        c == PROPERTY_CCBFILE ? a.setCCBFileNode(d) : cc.NodeLoader.prototype.onHandlePropTypeCCBFile.call(this, a, b, c, d, e)
    }
}), cc.BuilderFileLoader.loader = function() {
    return new cc.BuilderFileLoader
};
var PROPERTY_ENABLED = "enabled",
    PROPERTY_SELECTED = "selected",
    PROPERTY_CCCONTROL = "ccControl";
cc.ControlLoader = cc.NodeLoader.extend({
    _createCCNode: function() {},
    onHandlePropTypeBlockCCControl: function(a, b, c, d, e) {
        c == PROPERTY_CCCONTROL ? a.addTargetWithActionForControlEvents(d.target, d.selCCControlHandler, d.controlEvents) : cc.NodeLoader.prototype.onHandlePropTypeBlockCCControl.call(this, a, b, c, d, e)
    },
    onHandlePropTypeCheck: function(a, b, c, d, e) {
        c == PROPERTY_ENABLED ? a.setEnabled(d) : c == PROPERTY_SELECTED ? a.setSelected(d) : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, a, b, c, d, e)
    }
});
var PROPERTY_ZOOMONTOUCHDOWN = "zoomOnTouchDown",
    PROPERTY_TITLE_NORMAL = "title|1",
    PROPERTY_TITLE_HIGHLIGHTED = "title|2",
    PROPERTY_TITLE_DISABLED = "title|3",
    PROPERTY_TITLECOLOR_NORMAL = "titleColor|1",
    PROPERTY_TITLECOLOR_HIGHLIGHTED = "titleColor|2",
    PROPERTY_TITLECOLOR_DISABLED = "titleColor|3",
    PROPERTY_TITLETTF_NORMAL = "titleTTF|1",
    PROPERTY_TITLETTF_HIGHLIGHTED = "titleTTF|2",
    PROPERTY_TITLETTF_DISABLED = "titleTTF|3",
    PROPERTY_TITLETTFSIZE_NORMAL = "titleTTFSize|1",
    PROPERTY_TITLETTFSIZE_HIGHLIGHTED = "titleTTFSize|2",
    PROPERTY_TITLETTFSIZE_DISABLED = "titleTTFSize|4",
    PROPERTY_LABELANCHORPOINT = "labelAnchorPoint",
    PROPERTY_PREFEREDSIZE = "preferedSize",
    PROPERTY_BACKGROUNDSPRITEFRAME_NORMAL = "backgroundSpriteFrame|1",
    PROPERTY_BACKGROUNDSPRITEFRAME_HIGHLIGHTED = "backgroundSpriteFrame|2",
    PROPERTY_BACKGROUNDSPRITEFRAME_DISABLED = "backgroundSpriteFrame|3";
cc.ControlButtonLoader = cc.ControlLoader.extend({
    _createCCNode: function() {
        return cc.ControlButton.create()
    },
    onHandlePropTypeCheck: function(a, b, c, d, e) {
        c == PROPERTY_ZOOMONTOUCHDOWN ? a.setZoomOnTouchDown(d) : cc.ControlLoader.prototype.onHandlePropTypeCheck.call(this, a, b, c, d, e)
    },
    onHandlePropTypeString: function(a, b, c, d, e) {
        c == PROPERTY_TITLE_NORMAL ? a.setTitleForState(d, cc.CONTROL_STATE_NORMAL) : c == PROPERTY_TITLE_HIGHLIGHTED ? a.setTitleForState(d, cc.CONTROL_STATE_HIGHLIGHTED) : c == PROPERTY_TITLE_DISABLED ? a.setTitleForState(d, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeString.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFontTTF: function(a, b, c, d, e) {
        c == PROPERTY_TITLETTF_NORMAL ? a.setTitleTTFForState(d, cc.CONTROL_STATE_NORMAL) : c == PROPERTY_TITLETTF_HIGHLIGHTED ? a.setTitleTTFForState(d, cc.CONTROL_STATE_HIGHLIGHTED) : c == PROPERTY_TITLETTF_DISABLED ? a.setTitleTTFForState(d, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeFontTTF.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFloatScale: function(a, b, c, d, e) {
        c == PROPERTY_TITLETTFSIZE_NORMAL ? a.setTitleTTFSizeForState(d, cc.CONTROL_STATE_NORMAL) : c == PROPERTY_TITLETTFSIZE_HIGHLIGHTED ? a.setTitleTTFSizeForState(d, cc.CONTROL_STATE_HIGHLIGHTED) : c == PROPERTY_TITLETTFSIZE_DISABLED ? a.setTitleTTFSizeForState(d, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeFloatScale.call(this, a, b, c, d, e)
    },
    onHandlePropTypePoint: function(a, b, c, d, e) {
        c == PROPERTY_LABELANCHORPOINT ? a.setLabelAnchorPoint(d) : cc.ControlLoader.prototype.onHandlePropTypePoint.call(this, a, b, c, d, e)
    },
    onHandlePropTypeSize: function(a, b, c, d, e) {
        c == PROPERTY_PREFEREDSIZE ? a.setPreferredSize(d) : cc.ControlLoader.prototype.onHandlePropTypeSize.call(this, a, b, c, d, e)
    },
    onHandlePropTypeSpriteFrame: function(a, b, c, d, e) {
        c == PROPERTY_BACKGROUNDSPRITEFRAME_NORMAL ? null != d && a.setBackgroundSpriteFrameForState(d, cc.CONTROL_STATE_NORMAL) : c == PROPERTY_BACKGROUNDSPRITEFRAME_HIGHLIGHTED ? null != d && a.setBackgroundSpriteFrameForState(d, cc.CONTROL_STATE_HIGHLIGHTED) : c == PROPERTY_BACKGROUNDSPRITEFRAME_DISABLED ? null != d && a.setBackgroundSpriteFrameForState(d, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeSpriteFrame.call(this, a, b, c, d, e)
    },
    onHandlePropTypeColor3: function(a, b, c, d, e) {
        c == PROPERTY_TITLECOLOR_NORMAL ? a.setTitleColorForState(d, cc.CONTROL_STATE_NORMAL) : c == PROPERTY_TITLECOLOR_HIGHLIGHTED ? a.setTitleColorForState(d, cc.CONTROL_STATE_HIGHLIGHTED) : c == PROPERTY_TITLECOLOR_DISABLED ? a.setTitleColorForState(d, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeColor3.call(this, a, b, c, d, e)
    }
}), cc.ControlButtonLoader.loader = function() {
    return new cc.ControlButtonLoader
};
var PROPERTY_CONTAINER = "container",
    PROPERTY_DIRECTION = "direction",
    PROPERTY_CLIPSTOBOUNDS = "clipsToBounds",
    PROPERTY_BOUNCES = "bounces",
    PROPERTY_SCALE = "scale";
cc.ScrollViewLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        return cc.ScrollView.create()
    },
    onHandlePropTypeSize: function(a, b, c, d, e) {
        c == PROPERTY_CONTENTSIZE ? a.setViewSize(d) : cc.NodeLoader.prototype.onHandlePropTypeSize.call(this, a, b, c, d, e)
    },
    onHandlePropTypeCCBFile: function(a, b, c, d, e) {
        c == PROPERTY_CONTAINER ? (a.setContainer(d), a.updateInset()) : cc.NodeLoader.prototype.onHandlePropTypeCCBFile.call(this, a, b, c, d, e)
    },
    onHandlePropTypeCheck: function(a, b, c, d, e) {
        c == PROPERTY_CLIPSTOBOUNDS ? a.setClippingToBounds(d) : c == PROPERTY_BOUNCES ? a.setBounceable(d) : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFloat: function(a, b, c, d, e) {
        c == PROPERTY_SCALE ? a.setScale(d) : cc.NodeLoader.prototype.onHandlePropTypeFloat.call(this, a, b, c, d, e)
    },
    onHandlePropTypeIntegerLabeled: function(a, b, c, d, e) {
        c == PROPERTY_DIRECTION ? a.setDirection(d) : cc.NodeLoader.prototype.onHandlePropTypeIntegerLabeled.call(this, a, b, c, d, e)
    }
}), cc.ScrollViewLoader.loader = function() {
    return new cc.ScrollViewLoader
};
var PROPERTY_CONTENTSIZE = "contentSize",
    PROPERTY_SPRITEFRAME = "spriteFrame",
    PROPERTY_COLOR = "color",
    PROPERTY_OPACITY = "opacity",
    PROPERTY_BLENDFUNC = "blendFunc",
    PROPERTY_INSETLEFT = "insetLeft",
    PROPERTY_INSETTOP = "insetTop",
    PROPERTY_INSETRIGHT = "insetRight",
    PROPERTY_INSETBOTTOM = "insetBottom";
cc.Scale9SpriteLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        var a = cc.Scale9Sprite.create();
        return a.setAnchorPoint(0, 0), a
    },
    onHandlePropTypeColor3: function(a, b, c, d, e) {
        c == PROPERTY_COLOR ? (255 !== d.r || 255 !== d.g || 255 !== d.b) && a.setColor(d) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, a, b, c, d, e)
    },
    onHandlePropTypeByte: function(a, b, c, d, e) {
        c == PROPERTY_OPACITY ? a.setOpacity(d) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, a, b, c, d, e)
    },
    onHandlePropTypeBlendFunc: function(a, b, c, d, e) {
        c != PROPERTY_BLENDFUNC && cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, c, d, e)
    },
    onHandlePropTypeSpriteFrame: function(a, b, c, d, e) {
        c == PROPERTY_SPRITEFRAME ? a.setSpriteFrame(d) : cc.NodeLoader.prototype.onHandlePropTypeSpriteFrame.call(this, a, b, c, d, e)
    },
    onHandlePropTypeSize: function(a, b, c, d, e) {
        c != PROPERTY_CONTENTSIZE && (c == PROPERTY_PREFEREDSIZE ? a.setPreferredSize(d) : cc.NodeLoader.prototype.onHandlePropTypeSize.call(this, a, b, c, d, e))
    },
    onHandlePropTypeFloat: function(a, b, c, d, e) {
        c == PROPERTY_INSETLEFT ? a.setInsetLeft(d) : c == PROPERTY_INSETTOP ? a.setInsetTop(d) : c == PROPERTY_INSETRIGHT ? a.setInsetRight(d) : c == PROPERTY_INSETBOTTOM ? a.setInsetBottom(d) : cc.NodeLoader.prototype.onHandlePropTypeFloat.call(this, a, b, c, d, e)
    }
}), cc.Scale9SpriteLoader.loader = function() {
    return new cc.Scale9SpriteLoader
};
var PROPERTY_FLIP = "flip",
    PROPERTY_DISPLAYFRAME = "displayFrame",
    PROPERTY_COLOR = "color",
    PROPERTY_OPACITY = "opacity",
    PROPERTY_BLENDFUNC = "blendFunc";
cc.SpriteLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        return cc.Sprite.create()
    },
    onHandlePropTypeColor3: function(a, b, c, d, e) {
        c === PROPERTY_COLOR ? (255 !== d.r || 255 !== d.g || 255 !== d.b) && a.setColor(d) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, a, b, c, d, e)
    },
    onHandlePropTypeByte: function(a, b, c, d, e) {
        c === PROPERTY_OPACITY ? a.setOpacity(d) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, a, b, c, d, e)
    },
    onHandlePropTypeBlendFunc: function(a, b, c, d, e) {
        c === PROPERTY_BLENDFUNC ? a.setBlendFunc(d) : cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, c, d, e)
    },
    onHandlePropTypeSpriteFrame: function(a, b, c, d, e) {
        c === PROPERTY_DISPLAYFRAME ? d ? a.setSpriteFrame(d) : cc.log("ERROR: SpriteFrame is null") : cc.NodeLoader.prototype.onHandlePropTypeSpriteFrame.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFlip: function(a, b, c, d, e) {
        c === PROPERTY_FLIP ? (a.setFlippedX(d[0]), a.setFlippedY(d[1])) : cc.NodeLoader.prototype.onHandlePropTypeFlip.call(this, a, b, c, d, e)
    }
}), cc.SpriteLoader.loader = function() {
    return new cc.SpriteLoader
};
var PROPERTY_TOUCH_ENABLED = "touchEnabled",
    PROPERTY_IS_TOUCH_ENABLED = "isTouchEnabled",
    PROPERTY_ACCELEROMETER_ENABLED = "accelerometerEnabled",
    PROPERTY_IS_ACCELEROMETER_ENABLED = "isAccelerometerEnabled",
    PROPERTY_IS_MOUSE_ENABLED = "isMouseEnabled",
    PROPERTY_MOUSE_ENABLED = "mouseEnabled",
    PROPERTY_KEYBOARD_ENABLED = "keyboardEnabled",
    PROPERTY_IS_KEYBOARD_ENABLED = "isKeyboardEnabled";
cc.LayerLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        var a = cc.Layer.create();
        return a.setContentSize(0, 0), a
    },
    onHandlePropTypeCheck: function(a, b, c, d, e) {
        c === PROPERTY_TOUCH_ENABLED || c === PROPERTY_IS_TOUCH_ENABLED || c === PROPERTY_ACCELEROMETER_ENABLED || c === PROPERTY_IS_ACCELEROMETER_ENABLED || c === PROPERTY_MOUSE_ENABLED || c === PROPERTY_IS_MOUSE_ENABLED || (c === PROPERTY_KEYBOARD_ENABLED || c === PROPERTY_IS_KEYBOARD_ENABLED ? a.setKeyboardEnabled && !cc.sys.isNative ? a.setKeyboardEnabled(d) : cc.log("The property '" + PROPERTY_IS_KEYBOARD_ENABLED + "' is not supported!") : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, a, b, c, d, e))
    }
}), cc.LayerLoader.loader = function() {
    return new cc.LayerLoader
}, cc.LayerColorLoader = cc.LayerLoader.extend({
    _createCCNode: function() {
        return cc.LayerColor.create()
    },
    onHandlePropTypeColor3: function(a, b, c, d, e) {
        c === PROPERTY_COLOR ? a.setColor(d) : cc.LayerLoader.prototype.onHandlePropTypeColor3.call(this, a, b, c, d, e)
    },
    onHandlePropTypeByte: function(a, b, c, d, e) {
        c === PROPERTY_OPACITY ? a.setOpacity(d) : cc.LayerLoader.prototype.onHandlePropTypeByte.call(this, a, b, c, d, e)
    },
    onHandlePropTypeBlendFunc: function(a, b, c, d, e) {
        c === PROPERTY_BLENDFUNC ? a.setBlendFunc(d) : cc.LayerLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, c, d, e)
    }
}), cc.LayerColorLoader.loader = function() {
    return new cc.LayerColorLoader
};
var PROPERTY_STARTCOLOR = "startColor",
    PROPERTY_ENDCOLOR = "endColor",
    PROPERTY_STARTOPACITY = "startOpacity",
    PROPERTY_ENDOPACITY = "endOpacity",
    PROPERTY_VECTOR = "vector";
cc.LayerGradientLoader = cc.LayerLoader.extend({
    _createCCNode: function() {
        return cc.LayerGradient.create()
    },
    onHandlePropTypeColor3: function(a, b, c, d, e) {
        c === PROPERTY_STARTCOLOR ? a.setStartColor(d) : c == PROPERTY_ENDCOLOR ? a.setEndColor(d) : cc.LayerLoader.prototype.onHandlePropTypeColor3.call(this, a, b, c, d, e)
    },
    onHandlePropTypeByte: function(a, b, c, d, e) {
        c === PROPERTY_STARTOPACITY ? a.setStartOpacity(d) : c === PROPERTY_ENDOPACITY ? a.setEndOpacity(d) : cc.LayerLoader.prototype.onHandlePropTypeByte.call(this, a, b, c, d, e)
    },
    onHandlePropTypePoint: function(a, b, c, d, e) {
        c === PROPERTY_VECTOR ? a.setVector(d) : cc.LayerLoader.prototype.onHandlePropTypePoint.call(this, a, b, c, d, e)
    },
    onHandlePropTypeBlendFunc: function(a, b, c, d, e) {
        c === PROPERTY_BLENDFUNC ? a.setBlendFunc(d) : cc.LayerLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, c, d, e)
    }
}), cc.LayerGradientLoader.loader = function() {
    return new cc.LayerGradientLoader
}, cc.MenuLoader = cc.LayerLoader.extend({
    _createCCNode: function() {
        var a = cc.Menu.create();
        return a.setContentSize(0, 0), a
    }
}), cc.MenuLoader.loader = function() {
    return new cc.MenuLoader
};
var PROPERTY_BLOCK = "block",
    PROPERTY_ISENABLED = "isEnabled";
cc.MenuItemLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        return null
    },
    onHandlePropTypeBlock: function(a, b, c, d, e) {
        c === PROPERTY_BLOCK ? null != d && a.setTarget(d.selMenuHander, d.target) : cc.NodeLoader.prototype.onHandlePropTypeBlock.call(this, a, b, c, d, e)
    },
    onHandlePropTypeCheck: function(a, b, c, d, e) {
        c === PROPERTY_ISENABLED ? a.setEnabled(d) : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, a, b, c, d, e)
    }
});
var PROPERTY_NORMALDISPLAYFRAME = "normalSpriteFrame",
    PROPERTY_SELECTEDDISPLAYFRAME = "selectedSpriteFrame",
    PROPERTY_DISABLEDDISPLAYFRAME = "disabledSpriteFrame";
cc.MenuItemImageLoader = cc.MenuItemLoader.extend({
    _createCCNode: function() {
        return cc.MenuItemImage.create()
    },
    onHandlePropTypeSpriteFrame: function(a, b, c, d, e) {
        c === PROPERTY_NORMALDISPLAYFRAME ? null != d && a.setNormalSpriteFrame(d) : c === PROPERTY_SELECTEDDISPLAYFRAME ? null != d && a.setSelectedSpriteFrame(d) : c === PROPERTY_DISABLEDDISPLAYFRAME ? null != d && a.setDisabledSpriteFrame(d) : cc.MenuItemLoader.prototype.onHandlePropTypeSpriteFrame.call(this, a, b, c, d, e)
    }
}), cc.MenuItemImageLoader.loader = function() {
    return new cc.MenuItemImageLoader
};
var PROPERTY_FONTNAME = "fontName",
    PROPERTY_FONTSIZE = "fontSize",
    PROPERTY_HORIZONTALALIGNMENT = "horizontalAlignment",
    PROPERTY_VERTICALALIGNMENT = "verticalAlignment",
    PROPERTY_STRING = "string",
    PROPERTY_DIMENSIONS = "dimensions";
cc.LabelTTFLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        return cc.LabelTTF.create()
    },
    onHandlePropTypeColor3: function(a, b, c, d, e) {
        c === PROPERTY_COLOR ? (255 !== d.r || 255 !== d.g || 255 !== d.b) && a.setColor(d) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, a, b, c, d, e)
    },
    onHandlePropTypeByte: function(a, b, c, d, e) {
        c === PROPERTY_OPACITY ? a.setOpacity(d) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, a, b, c, d, e)
    },
    onHandlePropTypeBlendFunc: function(a, b, c, d, e) {
        c === PROPERTY_BLENDFUNC ? a.setBlendFunc(d) : cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFontTTF: function(a, b, c, d, e) {
        c === PROPERTY_FONTNAME ? a.setFontName(d) : cc.NodeLoader.prototype.onHandlePropTypeFontTTF.call(this, a, b, c, d, e)
    },
    onHandlePropTypeText: function(a, b, c, d, e) {
        c === PROPERTY_STRING ? a.setString(d) : cc.NodeLoader.prototype.onHandlePropTypeText.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFloatScale: function(a, b, c, d, e) {
        c === PROPERTY_FONTSIZE ? a.setFontSize(d) : cc.NodeLoader.prototype.onHandlePropTypeFloatScale.call(this, a, b, c, d, e)
    },
    onHandlePropTypeIntegerLabeled: function(a, b, c, d, e) {
        c === PROPERTY_HORIZONTALALIGNMENT ? a.setHorizontalAlignment(d) : c === PROPERTY_VERTICALALIGNMENT ? a.setVerticalAlignment(d) : cc.NodeLoader.prototype.onHandlePropTypeIntegerLabeled.call(this, a, b, c, d, e)
    },
    onHandlePropTypeSize: function(a, b, c, d, e) {
        c === PROPERTY_DIMENSIONS ? a.setDimensions(d) : cc.NodeLoader.prototype.onHandlePropTypeSize.call(this, a, b, c, d, e)
    }
}), cc.LabelTTFLoader.loader = function() {
    return new cc.LabelTTFLoader
};
var PROPERTY_FNTFILE = "fntFile";
cc.LabelBMFontLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        return cc.LabelBMFont.create()
    },
    onHandlePropTypeColor3: function(a, b, c, d, e) {
        c === PROPERTY_COLOR ? (255 !== d.r || 255 !== d.g || 255 !== d.b) && a.setColor(d) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, a, b, c, d, e)
    },
    onHandlePropTypeByte: function(a, b, c, d, e) {
        c === PROPERTY_OPACITY ? a.setOpacity(d) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, a, b, c, d, e)
    },
    onHandlePropTypeBlendFunc: function(a, b, c, d, e) {
        c === PROPERTY_BLENDFUNC ? a.setBlendFunc(d) : cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFntFile: function(a, b, c, d, e) {
        c === PROPERTY_FNTFILE ? a.setFntFile(d) : cc.NodeLoader.prototype.onHandlePropTypeFntFile.call(this, a, b, c, d, e)
    },
    onHandlePropTypeText: function(a, b, c, d, e) {
        c === PROPERTY_STRING ? a.setString(d) : cc.NodeLoader.prototype.onHandlePropTypeText.call(this, a, b, c, d, e)
    }
}), cc.LabelBMFontLoader.loader = function() {
    return new cc.LabelBMFontLoader
};
var PROPERTY_EMITERMODE = "emitterMode",
    PROPERTY_POSVAR = "posVar",
    PROPERTY_EMISSIONRATE = "emissionRate",
    PROPERTY_DURATION = "duration",
    PROPERTY_TOTALPARTICLES = "totalParticles",
    PROPERTY_LIFE = "life",
    PROPERTY_STARTSIZE = "startSize",
    PROPERTY_ENDSIZE = "endSize",
    PROPERTY_STARTSPIN = "startSpin",
    PROPERTY_ENDSPIN = "endSpin",
    PROPERTY_ANGLE = "angle",
    PROPERTY_GRAVITY = "gravity",
    PROPERTY_SPEED = "speed",
    PROPERTY_TANGENTIALACCEL = "tangentialAccel",
    PROPERTY_RADIALACCEL = "radialAccel",
    PROPERTY_TEXTURE = "texture",
    PROPERTY_STARTRADIUS = "startRadius",
    PROPERTY_ENDRADIUS = "endRadius",
    PROPERTY_ROTATEPERSECOND = "rotatePerSecond";
cc.ParticleSystemLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        return cc.ParticleSystem.create()
    },
    onHandlePropTypeIntegerLabeled: function(a, b, c, d, e) {
        c === PROPERTY_EMITERMODE ? a.setEmitterMode(d) : cc.NodeLoader.prototype.onHandlePropTypeIntegerLabeled.call(this, a, b, c, d, e)
    },
    onHandlePropTypePoint: function(a, b, c, d, e) {
        c === PROPERTY_POSVAR ? a.setPosVar(d) : c === PROPERTY_GRAVITY ? a.setGravity(d) : cc.NodeLoader.prototype.onHandlePropTypePoint.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFloat: function(a, b, c, d, e) {
        c === PROPERTY_EMISSIONRATE ? a.setEmissionRate(d) : c === PROPERTY_DURATION ? a.setDuration(d) : cc.NodeLoader.prototype.onHandlePropTypeFloat.call(this, a, b, c, d, e)
    },
    onHandlePropTypeInteger: function(a, b, c, d, e) {
        c === PROPERTY_TOTALPARTICLES ? a.setTotalParticles(d) : cc.NodeLoader.prototype.onHandlePropTypeInteger.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFloatVar: function(a, b, c, d, e) {
        c === PROPERTY_LIFE ? (a.setLife(d[0]), a.setLifeVar(d[1])) : c === PROPERTY_STARTSIZE ? (a.setStartSize(d[0]), a.setStartSizeVar(d[1])) : c === PROPERTY_ENDSIZE ? (a.setEndSize(d[0]), a.setEndSizeVar(d[1])) : c === PROPERTY_STARTSPIN ? (a.setStartSpin(d[0]), a.setStartSpinVar(d[1])) : c === PROPERTY_ENDSPIN ? (a.setEndSpin(d[0]), a.setEndSpinVar(d[1])) : c === PROPERTY_ANGLE ? (a.setAngle(d[0]), a.setAngleVar(d[1])) : c === PROPERTY_SPEED ? (a.setSpeed(d[0]), a.setSpeedVar(d[1])) : c === PROPERTY_TANGENTIALACCEL ? (a.setTangentialAccel(d[0]), a.setTangentialAccelVar(d[1])) : c === PROPERTY_RADIALACCEL ? (a.setRadialAccel(d[0]), a.setRadialAccelVar(d[1])) : c === PROPERTY_STARTRADIUS ? (a.setStartRadius(d[0]), a.setStartRadiusVar(d[1])) : c === PROPERTY_ENDRADIUS ? (a.setEndRadius(d[0]), a.setEndRadiusVar(d[1])) : c === PROPERTY_ROTATEPERSECOND ? (a.setRotatePerSecond(d[0]), a.setRotatePerSecondVar(d[1])) : cc.NodeLoader.prototype.onHandlePropTypeFloatVar.call(this, a, b, c, d, e)
    },
    onHandlePropTypeColor4FVar: function(a, b, c, d, e) {
        c === PROPERTY_STARTCOLOR ? (a.setStartColor(d[0]), a.setStartColorVar(d[1])) : c === PROPERTY_ENDCOLOR ? (a.setEndColor(d[0]), a.setEndColorVar(d[1])) : cc.NodeLoader.prototype.onHandlePropTypeColor4FVar.call(this, a, b, c, d, e)
    },
    onHandlePropTypeBlendFunc: function(a, b, c, d, e) {
        c === PROPERTY_BLENDFUNC ? a.setBlendFunc(d) : cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, c, d, e)
    },
    onHandlePropTypeTexture: function(a, b, c, d, e) {
        c === PROPERTY_TEXTURE ? a.setTexture(d) : cc.NodeLoader.prototype.onHandlePropTypeTexture.call(this, a, b, c, d, e)
    }
}), cc.ParticleSystemLoader.loader = function() {
    return new cc.ParticleSystemLoader
}, cc.NodeLoaderLibrary = cc.Class.extend({
    _ccNodeLoaders: null,
    ctor: function() {
        this._ccNodeLoaders = {}
    },
    registerDefaultCCNodeLoaders: function() {
        this.registerCCNodeLoader("CCNode", cc.NodeLoader.loader()), this.registerCCNodeLoader("CCLayer", cc.LayerLoader.loader()), this.registerCCNodeLoader("CCLayerColor", cc.LayerColorLoader.loader()), this.registerCCNodeLoader("CCLayerGradient", cc.LayerGradientLoader.loader()), this.registerCCNodeLoader("CCSprite", cc.SpriteLoader.loader()), this.registerCCNodeLoader("CCLabelBMFont", cc.LabelBMFontLoader.loader()), this.registerCCNodeLoader("CCLabelTTF", cc.LabelTTFLoader.loader()), this.registerCCNodeLoader("CCScale9Sprite", cc.Scale9SpriteLoader.loader()), this.registerCCNodeLoader("CCScrollView", cc.ScrollViewLoader.loader()), this.registerCCNodeLoader("CCBFile", cc.BuilderFileLoader.loader()), this.registerCCNodeLoader("CCMenu", cc.MenuLoader.loader()), this.registerCCNodeLoader("CCMenuItemImage", cc.MenuItemImageLoader.loader()), this.registerCCNodeLoader("CCControlButton", cc.ControlButtonLoader.loader()), this.registerCCNodeLoader("CCParticleSystemQuad", cc.ParticleSystemLoader.loader())
    },
    registerCCNodeLoader: function(a, b) {
        this._ccNodeLoaders[a] = b
    },
    unregisterCCNodeLoader: function(a) {
        this._ccNodeLoaders[a] && delete this._ccNodeLoaders[a]
    },
    getCCNodeLoader: function(a) {
        return this._ccNodeLoaders[a] ? this._ccNodeLoaders[a] : null
    },
    purge: function(a) {
        if (a)
            for (var b in this._ccNodeLoaders) delete this._ccNodeLoaders[b];
        this._ccNodeLoaders = {}
    }
}), cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = null, cc.NodeLoaderLibrary.library = function() {
    return new cc.NodeLoaderLibrary
}, cc.NodeLoaderLibrary.sharedCCNodeLoaderLibrary = function() {
    return null == cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary && (cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = new cc.NodeLoaderLibrary, cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary.registerDefaultCCNodeLoaders()), cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary
}, cc.NodeLoaderLibrary.purgeSharedCCNodeLoaderLibrary = function() {
    cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = null
}, cc.NodeLoaderLibrary.newDefaultCCNodeLoaderLibrary = function() {
    var a = cc.NodeLoaderLibrary.library();
    return a.registerDefaultCCNodeLoaders(), a
};
var CCB_VERSION = 5,
    CCB_PROPTYPE_POSITION = 0,
    CCB_PROPTYPE_SIZE = 1,
    CCB_PROPTYPE_POINT = 2,
    CCB_PROPTYPE_POINTLOCK = 3,
    CCB_PROPTYPE_SCALELOCK = 4,
    CCB_PROPTYPE_DEGREES = 5,
    CCB_PROPTYPE_INTEGER = 6,
    CCB_PROPTYPE_FLOAT = 7,
    CCB_PROPTYPE_FLOATVAR = 8,
    CCB_PROPTYPE_CHECK = 9,
    CCB_PROPTYPE_SPRITEFRAME = 10,
    CCB_PROPTYPE_TEXTURE = 11,
    CCB_PROPTYPE_BYTE = 12,
    CCB_PROPTYPE_COLOR3 = 13,
    CCB_PROPTYPE_COLOR4VAR = 14,
    CCB_PROPTYPE_FLIP = 15,
    CCB_PROPTYPE_BLENDMODE = 16,
    CCB_PROPTYPE_FNTFILE = 17,
    CCB_PROPTYPE_TEXT = 18,
    CCB_PROPTYPE_FONTTTF = 19,
    CCB_PROPTYPE_INTEGERLABELED = 20,
    CCB_PROPTYPE_BLOCK = 21,
    CCB_PROPTYPE_ANIMATION = 22,
    CCB_PROPTYPE_CCBFILE = 23,
    CCB_PROPTYPE_STRING = 24,
    CCB_PROPTYPE_BLOCKCCCONTROL = 25,
    CCB_PROPTYPE_FLOATSCALE = 26,
    CCB_PROPTYPE_FLOATXY = 27,
    CCB_FLOAT0 = 0,
    CCB_FLOAT1 = 1,
    CCB_FLOAT_MINUS1 = 2,
    CCB_FLOAT05 = 3,
    CCB_FLOAT_INTEGER = 4,
    CCB_FLOAT_FULL = 5,
    CCB_PLATFORM_ALL = 0,
    CCB_PLATFORM_IOS = 1,
    CCB_PLATFORM_MAC = 2,
    CCB_TARGETTYPE_NONE = 0,
    CCB_TARGETTYPE_DOCUMENTROOT = 1,
    CCB_TARGETTYPE_OWNER = 2,
    CCB_KEYFRAME_EASING_INSTANT = 0,
    CCB_KEYFRAME_EASING_LINEAR = 1,
    CCB_KEYFRAME_EASING_CUBIC_IN = 2,
    CCB_KEYFRAME_EASING_CUBIC_OUT = 3,
    CCB_KEYFRAME_EASING_CUBIC_INOUT = 4,
    CCB_KEYFRAME_EASING_ELASTIC_IN = 5,
    CCB_KEYFRAME_EASING_ELASTIC_OUT = 6,
    CCB_KEYFRAME_EASING_ELASTIC_INOUT = 7,
    CCB_KEYFRAME_EASING_BOUNCE_IN = 8,
    CCB_KEYFRAME_EASING_BOUNCE_OUT = 9,
    CCB_KEYFRAME_EASING_BOUNCE_INOUT = 10,
    CCB_KEYFRAME_EASING_BACK_IN = 11,
    CCB_KEYFRAME_EASING_BACK_OUT = 12,
    CCB_KEYFRAME_EASING_BACK_INOUT = 13,
    CCB_POSITIONTYPE_RELATIVE_BOTTOM_LEFT = 0,
    CCB_POSITIONTYPE_RELATIVE_TOP_LEFT = 1,
    CCB_POSITIONTYPE_RELATIVE_TOP_RIGHT = 2,
    CCB_POSITIONTYPE_RELATIVE_BOTTOM_RIGHT = 3,
    CCB_POSITIONTYPE_PERCENT = 4,
    CCB_POSITIONTYPE_MULTIPLY_RESOLUTION = 5,
    CCB_SIZETYPE_ABSOLUTE = 0,
    CCB_SIZETYPE_PERCENT = 1,
    CCB_SIZETYPE_RELATIVE_CONTAINER = 2,
    CCB_SIZETYPE_HORIZONTAL_PERCENT = 3,
    CCB_SIZETYPE_VERTICAL_PERCENT = 4,
    CCB_SIZETYPE_MULTIPLY_RESOLUTION = 5,
    CCB_SCALETYPE_ABSOLUTE = 0,
    CCB_SCALETYPE_MULTIPLY_RESOLUTION = 1;
cc.BuilderFile = cc.Node.extend({
    _ccbFileNode: null,
    getCCBFileNode: function() {
        return this._ccbFileNode
    },
    setCCBFileNode: function(a) {
        this._ccbFileNode = a
    }
}), cc.BuilderFile.create = function() {
    return new cc.BuilderFile
}, cc.BuilderReader = cc.Class.extend({
    _jsControlled: !1,
    _data: null,
    _ccbRootPath: "",
    _bytes: 0,
    _currentByte: 0,
    _currentBit: 0,
    _stringCache: null,
    _loadedSpriteSheets: null,
    _owner: null,
    _animationManager: null,
    _animationManagers: null,
    _animatedProps: null,
    _ccNodeLoaderLibrary: null,
    _ccNodeLoaderListener: null,
    _ccbMemberVariableAssigner: null,
    _ccbSelectorResolver: null,
    _ownerOutletNames: null,
    _ownerOutletNodes: null,
    _nodesWithAnimationManagers: null,
    _animationManagerForNodes: null,
    _ownerCallbackNames: null,
    _ownerCallbackNodes: null,
    _ownerCallbackEvents: null,
    _readNodeGraphFromData: !1,
    ctor: function(a, b, c, d) {
        this._stringCache = [], this._loadedSpriteSheets = [], this._currentByte = this._currentBit = -1, 0 != arguments.length && (a instanceof cc.BuilderReader ? (this._loadedSpriteSheets = a._loadedSpriteSheets, this._ccNodeLoaderLibrary = a._ccNodeLoaderLibrary, this._ccbMemberVariableAssigner = a._ccbMemberVariableAssigner, this._ccbSelectorResolver = a._ccbSelectorResolver, this._ccNodeLoaderListener = a._ccNodeLoaderListener, this._ownerCallbackNames = a._ownerCallbackNames, this._ownerCallbackNodes = a._ownerCallbackNodes, this._ownerCallbackEvents = a._ownerCallbackEvents, this._ownerOutletNames = a._ownerOutletNames, this._ownerOutletNodes = a._ownerOutletNodes, this._ccbRootPath = a._ccbRootPath) : (this._ccNodeLoaderLibrary = a, this._ccbMemberVariableAssigner = b, this._ccbSelectorResolver = c, this._ccNodeLoaderListener = d))
    },
    getCCBRootPath: function() {
        return this._ccbRootPath
    },
    setCCBRootPath: function(a) {
        this._ccbRootPath = a
    },
    initWithData: function(a, b) {
        return this._animationManager = new cc.BuilderAnimationManager, this._data = a, this._bytes = a.length, this._currentByte = this._currentBit = 0, this._owner = b, this._animationManager.setRootContainerSize(cc.director.getWinSize()), !0
    },
    _loadBinarySync: function(a) {
        var b = this.getXMLHttpRequest(),
            c = "load " + a + " failed!";
        b.open("GET", a, !1);
        var d = null;
        if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
            if (b.setRequestHeader("Accept-Charset", "x-user-defined"), b.send(null), 200 != b.status) return cc.log(c), null;
            (b = cc._convertResponseBodyToText(b.responseBody)) && (d = this._stringConvertToArray(b), this._fileDataCache[a] = d)
        } else {
            if (b.overrideMimeType && b.overrideMimeType("text/plain; charset=x-user-defined"), b.send(null), 200 != b.status) return cc.log(c), null;
            d = this._stringConvertToArray(b.responseText), this._fileDataCache[a] = d
        }
        return d
    },
    readNodeGraphFromFile: function(a, b, c, d) {
        null == c ? c = cc.director.getWinSize() : c instanceof cc.BuilderAnimationManager && (d = c, c = cc.director.getWinSize());
        var e = cc.loader.getRes(a);
        return e || (e = cc.loader.getUrl(a), e = cc.loader.loadBinarySync(e), cc.loader.cache[a] = e), this.readNodeGraphFromData(e, b, c, d)
    },
    readNodeGraphFromData: function(a, b, c) {
        if (this.initWithData(a, b), a = this._animationManager, a.setRootContainerSize(c), a.setOwner(b), this._ownerOutletNames = [], this._ownerOutletNodes = [], this._ownerCallbackNames = [], this._ownerCallbackNodes = [], this._ownerCallbackEvents = [], this._animationManagers = new cc._Dictionary, (b = this.readFileWithCleanUp(!0)) && -1 != a.getAutoPlaySequenceId() && a.runAnimations(a.getAutoPlaySequenceId(), 0), this._jsControlled) {
            c = [], a = [];
            for (var d = this._animationManagers, e = d.allKeys(), f = 0; f < e.length; f++) c.push(e[f]), a.push(d.objectForKey(e[f]));
            this._nodesWithAnimationManagers = c, this._animationManagerForNodes = a
        }
        return b
    },
    createSceneWithNodeGraphFromFile: function(a, b, c, d) {
        return a = this.readNodeGraphFromFile(a, b, c, d), b = cc.Scene.create(), b.addChild(a), b
    },
    getCCBMemberVariableAssigner: function() {
        return this._ccbMemberVariableAssigner
    },
    getCCBSelectorResolver: function() {
        return this._ccbSelectorResolver
    },
    getAnimationManager: function() {
        return this._animationManager
    },
    setAnimationManager: function(a) {
        this._animationManager = a
    },
    getAnimatedProperties: function() {
        return this._animatedProps
    },
    getLoadedSpriteSheet: function() {
        return this._loadedSpriteSheets
    },
    getOwner: function() {
        return this._owner
    },
    readInt: function(a) {
        for (var b = 0; !this._getBit();) b++;
        for (var c = 0, d = b - 1; d >= 0; d--) this._getBit() && (c |= 1 << d);
        return c |= 1 << b, a = a ? c % 2 ? 0 | c / 2 : 0 | -c / 2 : c - 1, this._alignBits(), a
    },
    readByte: function() {
        var a = this._data[this._currentByte];
        return this._currentByte++, a
    },
    readBool: function() {
        return 0 != this.readByte()
    },
    readFloat: function() {
        switch (this.readByte()) {
            case CCB_FLOAT0:
                return 0;
            case CCB_FLOAT1:
                return 1;
            case CCB_FLOAT_MINUS1:
                return -1;
            case CCB_FLOAT05:
                return .5;
            case CCB_FLOAT_INTEGER:
                return this.readInt(!0);
            default:
                return this._decodeFloat(23, 8)
        }
    },
    _decodeFloat: function(a, b) {
        var c = a + b + 1,
            d = c >> 3;
        this._checkSize(c);
        var c = Math.pow(2, b - 1) - 1,
            e = this._readBitsOnly(a + b, 1, d),
            f = this._readBitsOnly(a, b, d),
            g = 0,
            h = 2,
            i = 0;
        do
            for (var j = this._readByteOnly(++i, d), k = a % 8 || 8, l = 1 << k; l >>= 1;) j & l && (g += 1 / h), h *= 2; while (a -= k);
        return this._currentByte += d, f == (c << 1) + 1 ? g ? 0 / 0 : e ? -1 / 0 : 1 / 0 : (1 + -2 * e) * (f || g ? f ? Math.pow(2, f - c) * (1 + g) : Math.pow(2, -c + 1) * g : 0)
    },
    _readBitsOnly: function(a, b, c) {
        var d = (a + b) % 8,
            e = a % 8,
            f = c - (a >> 3) - 1;
        a = c + (-(a + b) >> 3);
        var g = f - a;
        for (b = this._readByteOnly(f, c) >> e & (1 << (g ? 8 - e : b)) - 1, g && d && (b += (this._readByteOnly(a++, c) & (1 << d) - 1) << (g-- << 3) - e); g;) b += this._shl(this._readByteOnly(a++, c), (g-- << 3) - e);
        return b
    },
    _readByteOnly: function(a, b) {
        return this._data[this._currentByte + b - a - 1]
    },
    _shl: function(a, b) {
        for (++b; --b; a = 1073741824 == (1073741824 & (a %= 2147483648)) ? 2 * a : 2 * (a - 1073741824) + 2147483648);
        return a
    },
    _checkSize: function(a) {
        if (!(this._currentByte + Math.ceil(a / 8) < this._data.length)) throw Error("Index out of bound")
    },
    readCachedString: function() {
        return this._stringCache[this.readInt(!1)]
    },
    isJSControlled: function() {
        return this._jsControlled
    },
    getOwnerCallbackNames: function() {
        return this._ownerCallbackNames
    },
    getOwnerCallbackNodes: function() {
        return this._ownerCallbackNodes
    },
    getOwnerCallbackControlEvents: function() {
        return this._ownerCallbackEvents
    },
    getOwnerOutletNames: function() {
        return this._ownerOutletNames
    },
    getOwnerOutletNodes: function() {
        return this._ownerOutletNodes
    },
    getNodesWithAnimationManagers: function() {
        return this._nodesWithAnimationManagers
    },
    getAnimationManagersForNodes: function() {
        return this._animationManagerForNodes
    },
    getAnimationManagers: function() {
        return this._animationManagers
    },
    setAnimationManagers: function(a) {
        this._animationManagers = a
    },
    addOwnerCallbackName: function(a) {
        this._ownerCallbackNames.push(a)
    },
    addOwnerCallbackNode: function(a) {
        this._ownerCallbackNodes.push(a)
    },
    addOwnerCallbackControlEvents: function(a) {
        this._ownerCallbackEvents.push(a)
    },
    addDocumentCallbackName: function(a) {
        this._animationManager.addDocumentCallbackName(a)
    },
    addDocumentCallbackNode: function(a) {
        this._animationManager.addDocumentCallbackNode(a)
    },
    addDocumentCallbackControlEvents: function(a) {
        this._animationManager.addDocumentCallbackControlEvents(a)
    },
    readFileWithCleanUp: function(a) {
        if (!this._readHeader() || !this._readStringCache() || !this._readSequences()) return null;
        var b = this._readNodeGraph();
        return this._animationManagers.setObject(this._animationManager, b), a && this._cleanUpNodeGraph(b), b
    },
    addOwnerOutletName: function(a) {
        this._ownerOutletNames.push(a)
    },
    addOwnerOutletNode: function(a) {
        null != a && this._ownerOutletNodes.push(a)
    },
    _cleanUpNodeGraph: function(a) {
        a.userObject = null, a = a.getChildren();
        for (var b = 0, c = a.length; c > b; b++) this._cleanUpNodeGraph(a[b])
    },
    _readCallbackKeyframesForSeq: function(a) {
        var b = this.readInt(!1);
        if (!b) return !0;
        for (var c = new cc.BuilderSequenceProperty, d = this._jsControlled, e = this._animationManager, f = c.getKeyframes(), g = 0; b > g; g++) {
            var h = this.readFloat(),
                i = this.readCachedString(),
                j = this.readInt(!1),
                k = [i, j],
                l = new cc.BuilderKeyframe;
            l.setTime(h), l.setValue(k), d && e.getKeyframeCallbacks().push(j + ":" + i), f.push(l)
        }
        return a.setCallbackChannel(c), !0
    },
    _readSoundKeyframesForSeq: function(a) {
        var b = this.readInt(!1);
        if (!b) return !0;
        for (var c = new cc.BuilderSequenceProperty, d = c.getKeyframes(), e = 0; b > e; e++) {
            var f = this.readFloat(),
                g = this.readCachedString(),
                h = this.readFloat(),
                i = this.readFloat(),
                j = this.readFloat(),
                g = [g, h, i, j],
                h = new cc.BuilderKeyframe;
            h.setTime(f), h.setValue(g), d.push(h)
        }
        return a.setSoundChannel(c), !0
    },
    _readSequences: function() {
        for (var a = this._animationManager.getSequences(), b = this.readInt(!1), c = 0; b > c; c++) {
            var d = new cc.BuilderSequence;
            if (d.setDuration(this.readFloat()), d.setName(this.readCachedString()), d.setSequenceId(this.readInt(!1)), d.setChainedSequenceId(this.readInt(!0)), !this._readCallbackKeyframesForSeq(d) || !this._readSoundKeyframesForSeq(d)) return !1;
            a.push(d)
        }
        return this._animationManager.setAutoPlaySequenceId(this.readInt(!0)), !0
    },
    readKeyframe: function(a) {
        var b = new cc.BuilderKeyframe;
        b.setTime(this.readFloat());
        var c = this.readInt(!1),
            d = 0,
            e = null;
        return (c === CCB_KEYFRAME_EASING_CUBIC_IN || c === CCB_KEYFRAME_EASING_CUBIC_OUT || c === CCB_KEYFRAME_EASING_CUBIC_INOUT || c === CCB_KEYFRAME_EASING_ELASTIC_IN || c === CCB_KEYFRAME_EASING_ELASTIC_OUT || c === CCB_KEYFRAME_EASING_ELASTIC_INOUT) && (d = this.readFloat()), b.setEasingType(c), b.setEasingOpt(d), a == CCB_PROPTYPE_CHECK ? e = this.readBool() : a == CCB_PROPTYPE_BYTE ? e = this.readByte() : a == CCB_PROPTYPE_COLOR3 ? (a = cc.color(this.readByte(), this.readByte(), this.readByte()), e = cc.Color3BWapper.create(a)) : a == CCB_PROPTYPE_FLOATXY ? e = [this.readFloat(), this.readFloat()] : a == CCB_PROPTYPE_DEGREES ? e = this.readFloat() : a == CCB_PROPTYPE_SCALELOCK || a == CCB_PROPTYPE_POSITION || a == CCB_PROPTYPE_FLOATXY ? e = [this.readFloat(), this.readFloat()] : a == CCB_PROPTYPE_SPRITEFRAME && (a = this.readCachedString(), c = this.readCachedString(), "" == a ? (c = this._ccbRootPath + c, a = cc.textureCache.addImage(c), c = a.getContentSize(), c = cc.rect(0, 0, c.width, c.height), e = cc.SpriteFrame.create(a, c)) : (a = this._ccbRootPath + a, d = cc.spriteFrameCache, -1 == this._loadedSpriteSheets.indexOf(a) && (d.addSpriteFrames(a), this._loadedSpriteSheets.push(a)), e = d.getSpriteFrame(c))), b.setValue(e), b
    },
    _readHeader: function() {
        if (null == this._data) return !1;
        var a = this._readStringFromBytes(this._currentByte, 4, !0);
        return this._currentByte += 4, "ccbi" != a ? !1 : (a = this.readInt(!1), a != CCB_VERSION ? (cc.log("WARNING! Incompatible ccbi file version (file: " + a + " reader: " + CCB_VERSION + ")"), !1) : (this._jsControlled = this.readBool(), this._animationManager._jsControlled = this._jsControlled, !0))
    },
    _readStringFromBytes: function(a, b, c) {
        a = "";
        var d = this._data,
            e = this._currentByte;
        if (c)
            for (c = b - 1; c >= 0; c--) a += String.fromCharCode(d[e + c]);
        else
            for (c = 0; b > c; c++) a += String.fromCharCode(d[e + c]);
        return a
    },
    _readStringCache: function() {
        for (var a = this.readInt(!1), b = 0; a > b; b++) this._readStringCacheEntry();
        return !0
    },
    _readStringCacheEntry: function() {
        for (var a = this.readByte(), b = this.readByte(), a = a << 8 | b, b = "", c = this._data, d = this._currentByte, e = 0; a > e; e++) var f = c[d + e].toString("16").toUpperCase(),
        f = 1 < f.length ? f : "0" + f, b = b + ("%" + f);
        b = decodeURIComponent(b), this._currentByte += a, this._stringCache.push(b)
    },
    _readNodeGraph: function(a) {
        var b, c = this.readCachedString(),
            d = this._jsControlled,
            e = this._animationManager;
        d && (b = this.readCachedString());
        var f, g = this.readInt(!1);
        g != CCB_TARGETTYPE_NONE && (f = this.readCachedString()), (c = this._ccNodeLoaderLibrary.getCCNodeLoader(c)) || (c = this._ccNodeLoaderLibrary.getCCNodeLoader("CCNode"));
        var h = c.loadCCNode(a, this);
        e.getRootNode() || e.setRootNode(h), d && h == e.getRootNode() && e.setDocumentControllerName(b);
        var i = new cc._Dictionary,
            j = this._animatedProps = [],
            k = this.readInt(!1);
        for (b = 0; k > b; ++b) {
            for (var l = this.readInt(!1), m = new cc._Dictionary, n = this.readInt(!1), o = 0; n > o; ++o) {
                var p = new cc.BuilderSequenceProperty;
                p.setName(this.readCachedString()), p.setType(this.readInt(!1)), j.push(p.getName());
                for (var q = this.readInt(!1), r = p.getKeyframes(), s = 0; q > s; ++s) {
                    var t = this.readKeyframe(p.getType());
                    r.push(t)
                }
                m.setObject(p, p.getName())
            }
            i.setObject(m, l)
        }
        if (0 < i.count() && e.addNode(h, i), c.parseProperties(h, a, this), (a = h instanceof cc.BuilderFile) && (b = h.getCCBFileNode(), b.setPosition(h.getPosition()), b.setRotation(h.getRotation()), b.setScaleX(h.getScaleX()), b.setScaleY(h.getScaleY()), b.setTag(h.getTag()), b.setVisible(!0), e.moveAnimationsFromNode(h, b), h.setCCBFileNode(null), h = b), j = i = null, g != CCB_TARGETTYPE_NONE && (d ? g == CCB_TARGETTYPE_DOCUMENTROOT ? (e.addDocumentOutletName(f), e.addDocumentOutletNode(h)) : (this._ownerOutletNames.push(f), this._ownerOutletNodes.push(h)) : (g === CCB_TARGETTYPE_DOCUMENTROOT ? i = e.getRootNode() : g === CCB_TARGETTYPE_OWNER && (i = this._owner), null != i && (b = !1, null != i && i.onAssignCCBMemberVariable && (b = i.onAssignCCBMemberVariable(i, f, h)), j = this._ccbMemberVariableAssigner, !b && null != j && j.onAssignCCBMemberVariable) && j.onAssignCCBMemberVariable(i, f, h))), 0 < c.getCustomProperties().length && (f = !1, !d && (i = h, null != i && null != i.onAssignCCBCustomProperty)))
            for (d = c.getCustomProperties(), e = d.allKeys(), b = 0; b < e.length; b++) g = d.objectForKey(e[b]), f = i.onAssignCCBCustomProperty(i, e[b], g), j = this._ccbMemberVariableAssigner, f || null == j || null == j.onAssignCCBCustomProperty || j.onAssignCCBCustomProperty(i, e[b], g);
        for (this._animatedProps = null, d = this.readInt(!1), b = 0; d > b; b++) f = this._readNodeGraph(h), h.addChild(f);
        return a || (null != h && h.onNodeLoaded ? h.onNodeLoaded(h, c) : null != this._ccNodeLoaderListener && this._ccNodeLoaderListener.onNodeLoaded(h, c)), h
    },
    _getBit: function() {
        var a = 0 != (this._data[this._currentByte] & 1 << this._currentBit);
        if (this._currentBit++, 8 <= this._currentBit && (this._currentBit = 0, this._currentByte++, this._currentByte > this._data.length)) throw "out of the data bound";
        return a
    },
    _alignBits: function() {
        this._currentBit && (this._currentBit = 0, this._currentByte++)
    },
    _readUTF8: function() {}
}), cc.BuilderReader._ccbResolutionScale = 1, cc.BuilderReader.setResolutionScale = function(a) {
    cc.BuilderReader._ccbResolutionScale = a
}, cc.BuilderReader.getResolutionScale = function() {
    return cc.BuilderReader._ccbResolutionScale
}, cc.BuilderReader.loadAsScene = function(a, b, c, d) {
    return d = d || cc.BuilderReader.getResourcePath(), a = cc.BuilderReader.load(a, b, c, d), b = cc.Scene.create(), b.addChild(a), b
}, cc.BuilderReader._controllerClassCache = {}, cc.BuilderReader.registerController = function(a, b) {
    cc.BuilderReader._controllerClassCache[a] = cc.Class.extend(b)
}, cc.BuilderReader.load = function(a, b, c, d) {
    d = d || cc.BuilderReader.getResourcePath();
    var e = new cc.BuilderReader(cc.NodeLoaderLibrary.newDefaultCCNodeLoaderLibrary());
    e.setCCBRootPath(d), (5 > a.length || a.toLowerCase().lastIndexOf(".ccbi") != a.length - 5) && (a += ".ccbi"), a = e.readNodeGraphFromFile(a, b, c);
    var f, g, h;
    if (b) {
        d = e.getOwnerCallbackNames();
        var i = e.getOwnerCallbackNodes(),
            j = e.getOwnerCallbackControlEvents();
        for (c = 0; c < d.length; c++) f = d[c], g = i[c], h = j[c], g instanceof cc.ControlButton ? g.addTargetWithActionForControlEvents(b, b[f], h) : g.setCallback(b[f], b);
        for (d = e.getOwnerOutletNames(), i = e.getOwnerOutletNodes(), c = 0; c < d.length; c++) f = d[c], g = i[c], b[f] = g
    }
    if (d = e.getNodesWithAnimationManagers(), e = e.getAnimationManagersForNodes(), !d || !e) return a;
    for (i = cc.BuilderReader._controllerClassCache, c = 0; c < d.length; c++) {
        var k = d[c],
            j = e[c];
        if (k.animationManager = j, f = j.getDocumentControllerName()) {
            var l = i[f];
            if (!l) throw "Can not find controller : " + f;
            l = new l, l.controllerName = f, k.controller = l, l.rootNode = k;
            for (var m = j.getDocumentCallbackNames(), n = j.getDocumentCallbackNodes(), o = j.getDocumentCallbackControlEvents(), k = 0; k < m.length; k++) f = m[k], g = n[k], h = o[k], g instanceof cc.ControlButton ? g.addTargetWithActionForControlEvents(l, l[f], h) : g.setCallback(l[f], l);
            for (h = j.getDocumentOutletNames(), m = j.getDocumentOutletNodes(), k = 0; k < h.length; k++) f = h[k], g = m[k], l[f] = g;
            for (l.onDidLoadFromCCB && "function" == typeof l.onDidLoadFromCCB && l.onDidLoadFromCCB(), f = j.getKeyframeCallbacks(), k = 0; k < f.length; k++) h = f[k].split(":"), g = h[0], h = h[1], 1 == g ? j.setCallFunc(cc.CallFunc.create(l[h], l), f[k]) : 2 == g && b && j.setCallFunc(cc.CallFunc.create(b[h], b), f[k])
        }
    }
    return a
}, cc.BuilderReader._resourcePath = "", cc.BuilderReader.setResourcePath = function(a) {
    cc.BuilderReader._resourcePath = a
}, cc.BuilderReader.getResourcePath = function() {
    return cc.BuilderReader._resourcePath
}, cc.BuilderReader.lastPathComponent = function(a) {
    var b = a.lastIndexOf("/");
    return -1 != b ? a.substring(b + 1, a.length - b) : a
}, cc.BuilderReader.deletePathExtension = function(a) {
    var b = a.lastIndexOf(".");
    return -1 != b ? a.substring(0, b) : a
}, cc.BuilderReader.toLowerCase = function(a) {
    return a.toLowerCase()
}, cc.BuilderReader.endsWith = function(a, b) {
    return a.length >= b.length ? 0 == a.lastIndexOf(b) : !1
}, cc.BuilderReader.concat = function(a, b) {
    return a + b
}, cc.loader.register(["ccbi"], cc._binaryLoader), cc.INT_VALUE = 0, cc.FLOAT_VALUE = 1, cc.POINTER_VALUE = 2, cc.BOOL_VALUE = 3, cc.UNSIGNEDCHAR_VALUE = 4, cc.Color3BWapper = cc.Class.extend({
    _color: null,
    ctor: function() {
        this._color = cc.color(0, 0, 0)
    },
    getColor: function() {
        return this._color
    }
}), cc.Color3BWapper.create = function(a) {
    var b = new cc.Color3BWapper;
    return b && (b._color.r = a.r, b._color.g = a.g, b._color.b = a.b), b
}, cc.BuilderValue = cc.Class.extend({
    _value: null,
    _type: 0,
    getIntValue: function() {},
    getFloatValue: function() {},
    getBoolValue: function() {},
    getByteValue: function() {},
    getPointer: function() {},
    getValue: function() {
        return this._value
    }
}), cc.BuilderValue.create = function() {
    return new cc.BuilderValue
}, cc.BuilderKeyframe = cc.Class.extend({
    _value: null,
    _time: 0,
    _easingType: 0,
    _easingOpt: 0,
    getValue: function() {
        return this._value
    },
    setValue: function(a) {
        this._value = a
    },
    getTime: function() {
        return this._time
    },
    setTime: function(a) {
        this._time = a
    },
    getEasingType: function() {
        return this._easingType
    },
    setEasingType: function(a) {
        this._easingType = a
    },
    getEasingOpt: function() {
        return this._easingOpt
    },
    setEasingOpt: function(a) {
        this._easingOpt = a
    }
}), cc.BuilderSequence = cc.Class.extend({
    _duration: 0,
    _name: "",
    _sequenceId: 0,
    _chainedSequenceId: 0,
    _callbackChannel: null,
    _soundChannel: null,
    ctor: function() {
        this._name = ""
    },
    getDuration: function() {
        return this._duration
    },
    setDuration: function(a) {
        this._duration = a
    },
    getName: function() {
        return this._name
    },
    setName: function(a) {
        this._name = a
    },
    getSequenceId: function() {
        return this._sequenceId
    },
    setSequenceId: function(a) {
        this._sequenceId = a
    },
    getChainedSequenceId: function() {
        return this._chainedSequenceId
    },
    setChainedSequenceId: function(a) {
        this._chainedSequenceId = a
    },
    getCallbackChannel: function() {
        return this._callbackChannel
    },
    setCallbackChannel: function(a) {
        this._callbackChannel = a
    },
    getSoundChannel: function() {
        return this._soundChannel
    },
    setSoundChannel: function(a) {
        this._soundChannel = a
    }
}), cc.BuilderSequenceProperty = cc.Class.extend({
    _name: null,
    _type: 0,
    _keyFrames: null,
    ctor: function() {
        this.init()
    },
    init: function() {
        this._keyFrames = [], this._name = ""
    },
    getName: function() {
        return this._name
    },
    setName: function(a) {
        this._name = a
    },
    getType: function() {
        return this._type
    },
    setType: function(a) {
        this._type = a
    },
    getKeyframes: function() {
        return this._keyFrames
    }
}), cc.getAbsolutePosition = function(a, b, c, d) {
    return d = cc.p(0, 0), b === CCB_POSITIONTYPE_RELATIVE_BOTTOM_LEFT ? d = a : b === CCB_POSITIONTYPE_RELATIVE_TOP_LEFT ? (d.x = a.x, d.y = c.height - a.y) : b === CCB_POSITIONTYPE_RELATIVE_TOP_RIGHT ? (d.x = c.width - a.x, d.y = c.height - a.y) : b === CCB_POSITIONTYPE_RELATIVE_BOTTOM_RIGHT ? (d.x = c.width - a.x, d.y = a.y) : b === CCB_POSITIONTYPE_PERCENT ? (d.x = c.width * a.x / 100, d.y = c.height * a.y / 100) : b === CCB_POSITIONTYPE_MULTIPLY_RESOLUTION && (b = cc.BuilderReader.getResolutionScale(), d.x = a.x * b, d.y = a.y * b), d
}, cc._getAbsolutePosition = function(a, b, c, d, e) {
    return e = cc.p(0, 0), c === CCB_POSITIONTYPE_RELATIVE_BOTTOM_LEFT ? (e.x = a, e.y = b) : c === CCB_POSITIONTYPE_RELATIVE_TOP_LEFT ? (e.x = a, e.y = d.height - b) : c === CCB_POSITIONTYPE_RELATIVE_TOP_RIGHT ? (e.x = d.width - a, e.y = d.height - b) : c === CCB_POSITIONTYPE_RELATIVE_BOTTOM_RIGHT ? (e.x = d.width - a, e.y = b) : c === CCB_POSITIONTYPE_PERCENT ? (e.x = d.width * a / 100, e.y = d.height * b / 100) : c === CCB_POSITIONTYPE_MULTIPLY_RESOLUTION && (c = cc.BuilderReader.getResolutionScale(), e.x = a * c, e.y = b * c), e
}, cc.setRelativeScale = function(a, b, c, d) {
    if (!a) throw "cc.setRelativeScale(): node should be non-null";
    d === CCB_POSITIONTYPE_MULTIPLY_RESOLUTION && (d = cc.BuilderReader.getResolutionScale(), b *= d, c *= d), a.setScaleX(b), a.setScaleY(c)
}, cc.BuilderAnimationManagerDelegate = cc.Class.extend({
    completedAnimationSequenceNamed: function() {}
}), cc.BuilderAnimationManager = cc.Class.extend({
    _sequences: null,
    _nodeSequences: null,
    _baseValues: null,
    _autoPlaySequenceId: 0,
    _rootNode: null,
    _owner: null,
    _rootContainerSize: null,
    _delegate: null,
    _runningSequence: null,
    _documentOutletNames: null,
    _documentOutletNodes: null,
    _documentCallbackNames: null,
    _documentCallbackNodes: null,
    _documentCallbackControlEvents: null,
    _documentControllerName: "",
    _lastCompletedSequenceName: "",
    _keyframeCallbacks: null,
    _keyframeCallFuncs: null,
    _animationCompleteCallbackFunc: null,
    _target: null,
    _jsControlled: !1,
    ctor: function() {
        this._rootContainerSize = cc.size(0, 0), this.init()
    },
    init: function() {
        return this._sequences = [], this._nodeSequences = new cc._Dictionary, this._baseValues = new cc._Dictionary, this._documentOutletNames = [], this._documentOutletNodes = [], this._documentCallbackNames = [], this._documentCallbackNodes = [], this._documentCallbackControlEvents = [], this._keyframeCallbacks = [], this._keyframeCallFuncs = {}, !0
    },
    getSequences: function() {
        return this._sequences
    },
    setSequences: function(a) {
        this._sequences = a
    },
    getAutoPlaySequenceId: function() {
        return this._autoPlaySequenceId
    },
    setAutoPlaySequenceId: function(a) {
        this._autoPlaySequenceId = a
    },
    getRootNode: function() {
        return this._rootNode
    },
    setRootNode: function(a) {
        this._rootNode = a
    },
    getOwner: function() {
        return this._owner
    },
    setOwner: function(a) {
        this._owner = a
    },
    addDocumentCallbackNode: function(a) {
        this._documentCallbackNodes.push(a)
    },
    addDocumentCallbackName: function(a) {
        this._documentCallbackNames.push(a)
    },
    addDocumentCallbackControlEvents: function(a) {
        this._documentCallbackControlEvents.push(a)
    },
    addDocumentOutletNode: function(a) {
        this._documentOutletNodes.push(a)
    },
    addDocumentOutletName: function(a) {
        this._documentOutletNames.push(a)
    },
    setDocumentControllerName: function(a) {
        this._documentControllerName = a
    },
    getDocumentControllerName: function() {
        return this._documentControllerName
    },
    getDocumentCallbackNames: function() {
        return this._documentCallbackNames
    },
    getDocumentCallbackNodes: function() {
        return this._documentCallbackNodes
    },
    getDocumentCallbackControlEvents: function() {
        return this._documentCallbackControlEvents
    },
    getDocumentOutletNames: function() {
        return this._documentOutletNames
    },
    getDocumentOutletNodes: function() {
        return this._documentOutletNodes
    },
    getLastCompletedSequenceName: function() {
        return this._lastCompletedSequenceName
    },
    getKeyframeCallbacks: function() {
        return this._keyframeCallbacks
    },
    getRootContainerSize: function() {
        return this._rootContainerSize
    },
    setRootContainerSize: function(a) {
        this._rootContainerSize = cc.size(a.width, a.height)
    },
    getDelegate: function() {
        return this._delegate
    },
    setDelegate: function(a) {
        this._delegate = a
    },
    getRunningSequenceName: function() {
        return this._runningSequence ? this._runningSequence.getName() : null
    },
    getContainerSize: function(a) {
        return a ? a.getContentSize() : this._rootContainerSize
    },
    addNode: function(a, b) {
        this._nodeSequences.setObject(b, a)
    },
    setBaseValue: function(a, b, c) {
        var d = this._baseValues.objectForKey(b);
        d || (d = new cc._Dictionary, this._baseValues.setObject(d, b)), d.setObject(a, c)
    },
    moveAnimationsFromNode: function(a, b) {
        var c = this._baseValues,
            d = c.objectForKey(a);
        null != d && (c.setObject(d, b), c.removeObjectForKey(a)), c = this._nodeSequences, d = c.objectForKey(a), null != d && (c.setObject(d, b), c.removeObjectForKey(a))
    },
    getActionForCallbackChannel: function(a) {
        var b = 0,
            c = [];
        a = a.getKeyframes();
        for (var d = a.length, e = 0; d > e; ++e) {
            var f = a[e],
                g = f.getTime() - b,
                b = f.getTime();
            if (g > 0 && c.push(cc.DelayTime.create(g)), g = f.getValue(), f = g[0], g = g[1], this._jsControlled) f = this._keyframeCallFuncs[g + ":" + f], null != f && c.push(f);
            else {
                var h;
                if (g == CCB_TARGETTYPE_DOCUMENTROOT ? h = this._rootNode : g == CCB_TARGETTYPE_OWNER && (h = this._owner), null != h)
                    if (0 < f.length) {
                        var g = 0,
                            i = h;
                        null != h.onResolveCCBCCCallFuncSelector && (g = i.onResolveCCBCCCallFuncSelector(h, f)), 0 == g ? cc.log("Skipping selector '" + f + "' since no CCBSelectorResolver is present.") : c.push(cc.CallFunc.create(g, h))
                    } else cc.log("Unexpected empty selector.")
            }
        }
        return 1 > c.length ? null : cc.Sequence.create(c)
    },
    getActionForSoundChannel: function(a) {
        var b = 0,
            c = [];
        a = a.getKeyframes();
        for (var d = a.length, e = 0; d > e; ++e) {
            var f = a[e],
                g = f.getTime() - b,
                b = f.getTime();
            g > 0 && c.push(cc.DelayTime.create(g));
            var h = f.getValue(),
                f = cc.BuilderReader.getResourcePath() + h[0],
                g = parseFloat(h[1]),
                i = parseFloat(h[2]),
                h = parseFloat(h[3]);
            c.push(cc.BuilderSoundEffect.create(f, g, i, h))
        }
        return 1 > c.length ? null : cc.Sequence.create(c)
    },
    runAnimationsForSequenceNamed: function(a) {
        this.runAnimationsForSequenceIdTweenDuration(this._getSequenceId(a), 0)
    },
    runAnimationsForSequenceNamedTweenDuration: function(a, b) {
        this.runAnimationsForSequenceIdTweenDuration(this._getSequenceId(a), b)
    },
    runAnimationsForSequenceIdTweenDuration: function(a, b) {
        if (-1 === a) throw "cc.BuilderAnimationManager.runAnimationsForSequenceIdTweenDuration(): Sequence id should not be -1";
        b = b || 0, this._rootNode.stopAllActions();
        for (var c = this._nodeSequences.allKeys(), d = 0, e = c.length; e > d; d++) {
            var f = c[d];
            f.stopAllActions();
            var g, h = this._nodeSequences.objectForKey(f).objectForKey(a),
                i = [];
            if (h) {
                var j = h.allKeys();
                for (g = 0; g < j.length; g++) {
                    var k = j[g],
                        l = h.objectForKey(k);
                    i.push(k), this._setFirstFrame(f, l, b), this._runAction(f, l, b)
                }
            }
            if (h = this._baseValues.objectForKey(f))
                for (j = h.allKeys(), g = 0; g < j.length; g++) k = j[g], -1 == i.indexOf(k) && (l = h.objectForKey(k), null != l && this._setAnimatedProperty(k, f, l, b))
        }
        c = this._getSequence(a), d = cc.Sequence.create(cc.DelayTime.create(c.getDuration() + b), cc.CallFunc.create(this._sequenceCompleted, this)), this._rootNode.runAction(d), c.getCallbackChannel() && (d = this.getActionForCallbackChannel(c.getCallbackChannel())) && this._rootNode.runAction(d), c.getSoundChannel() && (d = this.getActionForSoundChannel(c.getSoundChannel())) && this._rootNode.runAction(d), this._runningSequence = this._getSequence(a)
    },
    runAnimations: function(a, b) {
        b = b || 0;
        var c;
        c = "string" == typeof a ? this._getSequenceId(a) : a, this.runAnimationsForSequenceIdTweenDuration(c, b)
    },
    setAnimationCompletedCallback: function(a, b) {
        this._target = a, this._animationCompleteCallbackFunc = b
    },
    setCompletedAnimationCallback: function(a, b) {
        this.setAnimationCompletedCallback(a, b)
    },
    setCallFunc: function(a, b) {
        this._keyframeCallFuncs[b] = a
    },
    debug: function() {},
    _getBaseValue: function(a, b) {
        var c = this._baseValues.objectForKey(a);
        return c ? c.objectForKey(b) : null
    },
    _getSequenceId: function(a) {
        for (var b = null, c = this._sequences, d = 0, e = c.length; e > d; d++)
            if ((b = c[d]) && b.getName() === a) return b.getSequenceId();
        return -1
    },
    _getSequence: function(a) {
        for (var b = null, c = this._sequences, d = 0, e = c.length; e > d; d++)
            if ((b = c[d]) && b.getSequenceId() === a) return b;
        return null
    },
    _getAction: function(a, b, c, d) {
        a = b.getTime() - (a ? a.getTime() : 0);
        var e, f;
        return "rotation" === c ? cc.BuilderRotateTo.create(a, b.getValue()) : "rotationX" === c ? cc.BuilderRotateXTo.create(a, b.getValue()) : "rotationY" === c ? cc.BuilderRotateYTo.create(a, b.getValue()) : "opacity" === c ? cc.FadeTo.create(a, b.getValue()) : "color" === c ? (c = b.getValue().getColor(), cc.TintTo.create(a, c.r, c.g, c.b)) : "visible" === c ? b.getValue() ? cc.Sequence.create(cc.DelayTime.create(a), cc.Show.create()) : cc.Sequence.create(cc.DelayTime.create(a), cc.Hide.create()) : "displayFrame" === c ? cc.Sequence.create(cc.DelayTime.create(a), cc.BuilderSetSpriteFrame.create(b.getValue())) : "position" === c ? (e = this._getBaseValue(d, c), e = e[2], f = b.getValue(), b = f[0], f = f[1], d = this.getContainerSize(d.getParent()), c = cc._getAbsolutePosition(b, f, e, d, c), cc.MoveTo.create(a, c)) : "scale" === c ? (e = this._getBaseValue(d, c), e = e[2], f = b.getValue(), b = f[0], f = f[1], e === CCB_SCALETYPE_MULTIPLY_RESOLUTION && (c = cc.BuilderReader.getResolutionScale(), b *= c, f *= c), cc.ScaleTo.create(a, b, f)) : "skew" === c ? (f = b.getValue(), b = f[0], f = f[1], cc.SkewTo.create(a, b, f)) : (cc.log("BuilderReader: Failed to create animation for property: " + c), null)
    },
    _setAnimatedProperty: function(a, b, c, d) {
        if (d > 0) {
            var e = new cc.BuilderKeyframe;
            e.setValue(c), e.setTime(d), e.setEasingType(CCB_KEYFRAME_EASING_LINEAR), a = this._getAction(null, e, a, b), b.runAction(a)
        } else "position" === a ? (d = this._getBaseValue(b, a), d = d[2], e = c[0], c = c[1], b.setPosition(cc._getAbsolutePosition(e, c, d, this.getContainerSize(b.getParent()), a))) : "scale" === a ? (d = this._getBaseValue(b, a), d = d[2], e = c[0], c = c[1], cc.setRelativeScale(b, e, c, d, a)) : "skew" === a ? (e = c[0], c = c[1], b.setSkewX(e), b.setSkewY(c)) : "rotation" === a ? b.setRotation(c) : "rotationX" == a ? b.setRotationSkewX(c) : "rotationY" == a ? b.setRotationSkewY(c) : "opacity" === a ? b.setOpacity(c) : "displayFrame" === a ? b.setSpriteFrame(c) : "color" === a ? (a = c.getColor(), (255 !== a.r || 255 !== a.g || 255 !== a.b) && b.setColor(a)) : "visible" === a ? b.setVisible(c || !1) : cc.log("unsupported property name is " + a)
    },
    _setFirstFrame: function(a, b, c) {
        var d = b.getKeyframes();
        0 === d.length ? ((d = this._getBaseValue(a, b.getName())) || cc.log("cc.BuilderAnimationManager._setFirstFrame(): No baseValue found for property"), this._setAnimatedProperty(b.getName(), a, d, c)) : (d = d[0], this._setAnimatedProperty(b.getName(), a, d.getValue(), c))
    },
    _getEaseAction: function(a, b, c) {
        return b === CCB_KEYFRAME_EASING_LINEAR || b === CCB_KEYFRAME_EASING_INSTANT ? a : b === CCB_KEYFRAME_EASING_CUBIC_IN ? cc.EaseIn.create(a, c) : b === CCB_KEYFRAME_EASING_CUBIC_OUT ? cc.EaseOut.create(a, c) : b === CCB_KEYFRAME_EASING_CUBIC_INOUT ? cc.EaseInOut.create(a, c) : b === CCB_KEYFRAME_EASING_BACK_IN ? cc.EaseBackIn.create(a) : b === CCB_KEYFRAME_EASING_BACK_OUT ? cc.EaseBackOut.create(a) : b === CCB_KEYFRAME_EASING_BACK_INOUT ? cc.EaseBackInOut.create(a) : b === CCB_KEYFRAME_EASING_BOUNCE_IN ? cc.EaseBounceIn.create(a) : b === CCB_KEYFRAME_EASING_BOUNCE_OUT ? cc.EaseBounceOut.create(a) : b === CCB_KEYFRAME_EASING_BOUNCE_INOUT ? cc.EaseBounceInOut.create(a) : b === CCB_KEYFRAME_EASING_ELASTIC_IN ? cc.EaseElasticIn.create(a, c) : b === CCB_KEYFRAME_EASING_ELASTIC_OUT ? cc.EaseElasticOut.create(a, c) : b === CCB_KEYFRAME_EASING_ELASTIC_INOUT ? cc.EaseElasticInOut.create(a, c) : (cc.log("BuilderReader: Unkown easing type " + b), a)
    },
    _runAction: function(a, b, c) {
        var d = b.getKeyframes(),
            e = d.length;
        if (e > 1) {
            var f = [];
            for (c = d[0].getTime() + c, c > 0 && f.push(cc.DelayTime.create(c)), c = 0; e - 1 > c; ++c) {
                var g = d[c],
                    h = this._getAction(g, d[c + 1], b.getName(), a);
                h && (h = this._getEaseAction(h, g.getEasingType(), g.getEasingOpt()), f.push(h))
            }
            b = cc.Sequence.create(f), a.runAction(b)
        }
    },
    _sequenceCompleted: function() {
        var a = this._runningSequence,
            b = a.getName();
        this._lastCompletedSequenceName != a.getName() && (this._lastCompletedSequenceName = a.getName()), a = a.getChainedSequenceId(), this._runningSequence = null, -1 != a && this.runAnimations(a, 0), this._delegate && this._delegate.completedAnimationSequenceNamed(b), this._target && this._animationCompleteCallbackFunc && this._animationCompleteCallbackFunc.call(this._target)
    }
}), cc.BuilderSetSpriteFrame = cc.ActionInstant.extend({
    _spriteFrame: null,
    initWithSpriteFrame: function(a) {
        return this._spriteFrame = a, !0
    },
    update: function() {
        this.target.setSpriteFrame(this._spriteFrame)
    }
}), cc.BuilderSetSpriteFrame.create = function(a) {
    var b = new cc.BuilderSetSpriteFrame;
    return b && b.initWithSpriteFrame(a) ? b : null
}, cc.BuilderRotateTo = cc.ActionInterval.extend({
    _startAngle: 0,
    _dstAngle: 0,
    _diffAngle: 0,
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._dstAngle = b, !0) : !1
    },
    update: function(a) {
        this.target.setRotation(this._startAngle + this._diffAngle * a)
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._startAngle = this.target.getRotation(), this._diffAngle = this._dstAngle - this._startAngle
    }
}), cc.BuilderRotateTo.create = function(a, b) {
    var c = new cc.BuilderRotateTo;
    return c && c.initWithDuration(a, b) ? c : null
}, cc.BuilderRotateXTo = cc.ActionInterval.extend({}), cc.BuilderRotateXTo.create = function() {
    throw "rotationX has not been implemented in cocos2d-html5"
}, cc.BuilderRotateYTo = cc.ActionInterval.extend({}), cc.BuilderRotateYTo.create = function() {
    throw "rotationY has not been implemented in cocos2d-html5"
}, cc.BuilderSoundEffect = cc.ActionInstant.extend({
    init: function(a) {
        return this._file = a, !0
    },
    update: function() {
        cc.audioEngine.playEffect(this._file)
    }
}), cc.BuilderSoundEffect.create = function(a, b) {
    return (b = new cc.BuilderSoundEffect) && b.init(a) ? b : null
}, cc.DOM = {}, cc.DOM._addMethods = function(a) {
    for (var b in cc.DOM.methods) a[b] = cc.DOM.methods[b];
    cc.defineGetterSetter(a, "x", a.getPositionX, a.setPositionX), cc.defineGetterSetter(a, "y", a.getPositionY, a.setPositionY), cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth), cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight), cc.defineGetterSetter(a, "anchorX", a._getAnchorX, a._setAnchorX), cc.defineGetterSetter(a, "anchorY", a._getAnchorY, a._setAnchorY), cc.defineGetterSetter(a, "scale", a.getScale, a.setScale), cc.defineGetterSetter(a, "scaleX", a.getScaleX, a.setScaleX), cc.defineGetterSetter(a, "scaleY", a.getScaleY, a.getScaleY), cc.defineGetterSetter(a, "rotation", a.getRotation, a.setRotation), cc.defineGetterSetter(a, "skewX", a.getSkewX, a.setSkewX), cc.defineGetterSetter(a, "skewY", a.getSkewY, a.setSkewY), cc.defineGetterSetter(a, "visible", a.isVisible, a.setVisible), cc.defineGetterSetter(a, "parent", a.getParent, a.setParent), cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity)
}, cc.DOM.methods = {
    setPosition: function(a, b) {
        void 0 === b ? (this._position.x = a.x, this._position.y = a.y) : (this._position.x = a, this._position.y = b), this.setNodeDirty(), this.dom.translates(this._position.x, -this._position.y)
    },
    setPositionY: function(a) {
        this._position.y = a, this.setNodeDirty(), this.dom.translates(this._position.x, -this._position.y)
    },
    setPositionX: function(a) {
        this._position.x = a, this.setNodeDirty(), this.dom.translates(this._position.x, -this._position.y)
    },
    setScale: function(a, b) {
        this._scaleX = a, this._scaleY = b || a, this.setNodeDirty(), this.dom.resize(this._scaleX, this._scaleY)
    },
    setScaleX: function(a) {
        this._scaleX = a, this.setNodeDirty(), this.dom.resize(this._scaleX, this._scaleY)
    },
    setScaleY: function(a) {
        this._scaleY = a, this.setNodeDirty(), this.dom.resize(this._scaleX, this._scaleY)
    },
    setAnchorPoint: function(a, b) {
        var c = this._anchorPoint;
        void 0 === b ? (c.x = a.x, c.y = a.y) : (c.x = a, c.y = b);
        var d = this._anchorPointInPoints,
            e = this._contentSize;
        d.x = e.width * c.x, d.y = e.height * c.y, this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + d.x + "px " + -d.y + "px", this.ignoreAnchor ? (this.dom.style.marginLeft = 0, this.dom.style.marginBottom = 0) : (this.dom.style.marginLeft = this.isToggler ? 0 : -d.x + "px", this.dom.style.marginBottom = -d.y + "px"), this.setNodeDirty()
    },
    _setAnchorX: function(a) {
        var b = this._anchorPoint;
        a !== b.x && (b.x = a, a = this._anchorPointInPoints, a.x = this._contentSize.width * b.x, this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + a.x + "px " + -a.y + "px", this.ignoreAnchor ? (this.dom.style.marginLeft = 0, this.dom.style.marginBottom = 0) : this.dom.style.marginLeft = this.isToggler ? 0 : -a.x + "px", this.setNodeDirty())
    },
    _setAnchorY: function(a) {
        var b = this._anchorPoint;
        a !== b.y && (b.y = a, a = this._anchorPointInPoints, a.y = this._contentSize.height * b.y, this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + a.x + "px " + -a.y + "px", this.ignoreAnchor ? (this.dom.style.marginLeft = 0, this.dom.style.marginBottom = 0) : this.dom.style.marginBottom = -a.y + "px", this.setNodeDirty())
    },
    setContentSize: function(a, b) {
        var c = this._contentSize;
        void 0 === b ? (c.width = a.width, c.height = a.height) : (c.width = a, c.height = b);
        var d = this._anchorPointInPoints,
            e = this._anchorPoint;
        d.x = c.width * e.x, d.y = c.height * e.y, this.dom.width = c.width, this.dom.height = c.height, this.setAnchorPoint(this.getAnchorPoint()), this.canvas && (this.canvas.width = c.width, this.canvas.height = c.height), this.setNodeDirty(), this.redraw()
    },
    _setWidth: function(a) {
        var b = this._contentSize;
        a !== b.width && (b.width = a, a = this._anchorPoint, this._anchorPointInPoints.x = b.width * a.x, this.dom.width = b.width, this.anchorX = a.x, this.canvas && (this.canvas.width = b.width), this.setNodeDirty(), this.redraw())
    },
    _setHeight: function(a) {
        var b = this._contentSize;
        a !== b.height && (b.height = a, a = this._anchorPoint, this._anchorPointInPoints.y = b.height * a.y, this.dom.height = b.height, this.anchorY = a.y, this.canvas && (this.canvas.height = b.height), this.setNodeDirty(), this.redraw())
    },
    setRotation: function(a) {
        this._rotation != a && (this._rotationX = this._rotationY = a, this._rotationRadiansX = this._rotationX * (Math.PI / 180), this._rotationRadiansY = this._rotationY * (Math.PI / 180), this.setNodeDirty(), this.dom.rotate(a))
    },
    setSkewX: function(a) {
        this._skewX = a, this.setNodeDirty(), this.dom.setSkew(this._skewX, this._skewY)
    },
    setSkewY: function(a) {
        this._skewY = a, this.setNodeDirty(), this.dom.setSkew(this._skewX, this._skewY)
    },
    setVisible: function(a) {
        this._visible = a, this.setNodeDirty(), this.dom && (this.dom.style.display = a ? "block" : "none")
    },
    _setLocalZOrder: function(a) {
        this._localZOrder = a, this.setNodeDirty(), this.dom && (this.dom.zIndex = a)
    },
    setParent: function(a) {
        this._parent = a, null !== a && (a.setAnchorPoint(a.getAnchorPoint()), this.setNodeDirty(), cc.DOM.parentDOM(this))
    },
    resume: function() {
        this.getScheduler().resumeTarget(this), this.getActionManager().resumeTarget(this), cc.eventManager.resumeTarget(this), this.dom && !this.dom.parentNode && (this.getParent() ? cc.DOM.parentDOM(this) : "" == this.dom.id ? cc.DOM._createEGLViewDiv(this) : this.dom.appendTo(cc.container)), this.dom && (this.dom.style.visibility = "visible")
    },
    pause: function() {
        this.getScheduler().pauseTarget(this), this.getActionManager().pauseTarget(this), cc.eventManager.pauseTarget(this), this.dom && (this.dom.style.visibility = "hidden")
    },
    cleanup: function() {
        this.stopAllActions(), this.unscheduleAllCallbacks(), this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.cleanup), this.dom && this.dom.remove()
    },
    removeFromParentAndCleanup: function() {
        this.dom.remove()
    },
    setOpacity: function(a) {
        this._opacity = a, this.dom.style.opacity = a / 255
    },
    redraw: function() {
        if (this.isSprite) {
            var a = this._children;
            this._children = [], cc.Sprite.prototype.visit.call(this, this.ctx), this._children = a
        } else cc.Sprite.prototype.visit.call(this, this.ctx)
    }
}, cc.DOM._resetEGLViewDiv = function() {
    var a = cc.$("#EGLViewDiv");
    if (a) {
        var b = cc.view,
            c = b.getDesignResolutionSize(),
            d = b.getViewPortRect(),
            e = b.getFrameSize(),
            f = b.getDevicePixelRatio(),
            g = c.width,
            h = c.height;
        0 === c.width && 0 === c.height && (g = e.width, h = e.height), c = d.width / f, 0 === d.width && 0 === d.height && (c = e.width), a.style.position = "absolute", a.style.width = g + "px", a.style.maxHeight = h + "px", a.style.margin = 0, a.resize(b.getScaleX() / f, b.getScaleY() / f), a.style.left = (c - g) / 2 + "px", a.style.bottom = "0px"
    }
}, cc.DOM.parentDOM = function(a) {
    var b = a.getParent();
    return b && a.dom ? (b.dom || (cc.DOM.placeHolder(b), b.setParent = cc.DOM.methods.setParent), a.dom.appendTo(b.dom), b.setAnchorPoint(b.getAnchorPoint()), b.getParent() ? cc.DOM.parentDOM(b) : b.isRunning() && ((a = cc.$("#EGLViewDiv")) ? b.dom.appendTo(a) : cc.DOM._createEGLViewDiv(b)), !0) : !1
}, cc.DOM._createEGLViewDiv = function(a) {
    var b = cc.$("#EGLViewDiv");
    b || (b = cc.$new("div"), b.id = "EGLViewDiv");
    var c = cc.view,
        d = c.getDesignResolutionSize(),
        e = c.getViewPortRect(),
        f = c.getFrameSize(),
        g = c.getDevicePixelRatio(),
        h = d.width,
        i = d.height;
    0 === d.width && 0 === d.height && (h = f.width, i = f.height), d = e.width / g, 0 === e.width && 0 === e.height && (d = f.width), b.style.position = "absolute", b.style.width = h + "px", b.style.maxHeight = i + "px", b.style.margin = 0, b.resize(c.getScaleX() / g, c.getScaleY() / g), b.style.left = (d - h) / 2 + "px", b.style.bottom = "0px", a.dom.appendTo(b), b.appendTo(cc.container)
}, cc.DOM.setTransform = function(a) {
    if (a.ctx)
        if (a.ctx.translate(a.getAnchorPointInPoints().x, a.getAnchorPointInPoints().y), a.isSprite) {
            var b = a._children;
            a._children = [], cc.Sprite.prototype.visit.call(a, a.ctx), a._children = b
        } else cc.Sprite.prototype.visit.call(a, a.ctx);
    a.dom && (a.dom.position.x = a.getPositionX(), a.dom.position.y = -a.getPositionY(), a.dom.rotation = a.getRotation(), a.dom.scale = {
        x: a.getScaleX(),
        y: a.getScaleY()
    }, a.dom.skew = {
        x: a.getSkewX(),
        y: a.getSkewY()
    }, a.setAnchorPoint && a.setAnchorPoint(a.getAnchorPoint()), a.dom.transforms())
}, cc.DOM.forSprite = function(a) {
    a.dom = cc.$new("div"), a.canvas = cc.$new("canvas");
    var b = a.getContentSize();
    a.canvas.width = b.width, a.canvas.height = b.height, a.dom.style.position = "absolute", a.dom.style.bottom = 0, a.ctx = a.canvas.getContext("2d"), a.dom.appendChild(a.canvas), a.getParent() && cc.DOM.parentDOM(a), a.isSprite = !0
}, cc.DOM.placeHolder = function(a) {
    a.dom = cc.$new("div"), a.placeholder = !0, a.dom.style.position = "absolute", a.dom.style.bottom = 0, a.dom.style.width = (a.getContentSize().width || cc.director.getWinSize().width) + "px", a.dom.style.maxHeight = (a.getContentSize().height || cc.director.getWinSize().height) + "px", a.dom.style.margin = 0, cc.DOM.setTransform(a), a.dom.transforms(), cc.DOM._addMethods(a)
}, cc.DOM.convert = function() {
    if (1 < arguments.length) cc.DOM.convert(arguments);
    else if (1 != arguments.length || arguments[0].length)
        for (var a = arguments[0], b = 0; b < a.length; b++) a[b] instanceof cc.Sprite ? a[b].dom || cc.DOM.forSprite(a[b]) : cc.log("DOM converter only supports sprite and menuitems yet"), cc.DOM._addMethods(a[b]), a[b].visit = function() {}, a[b].transform = function() {}, cc.DOM.setTransform(a[b]), a[b].setVisible(a[b].isVisible());
    else cc.DOM.convert([arguments[0]])
}, cc.KEYBOARD_RETURNTYPE_DEFAULT = 0, cc.KEYBOARD_RETURNTYPE_DONE = 1, cc.KEYBOARD_RETURNTYPE_SEND = 2, cc.KEYBOARD_RETURNTYPE_SEARCH = 3, cc.KEYBOARD_RETURNTYPE_GO = 4, cc.EDITBOX_INPUT_MODE_ANY = 0, cc.EDITBOX_INPUT_MODE_EMAILADDR = 1, cc.EDITBOX_INPUT_MODE_NUMERIC = 2, cc.EDITBOX_INPUT_MODE_PHONENUMBER = 3, cc.EDITBOX_INPUT_MODE_URL = 4, cc.EDITBOX_INPUT_MODE_DECIMAL = 5, cc.EDITBOX_INPUT_MODE_SINGLELINE = 6, cc.EDITBOX_INPUT_FLAG_PASSWORD = 0, cc.EDITBOX_INPUT_FLAG_SENSITIVE = 1, cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_WORD = 2, cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_SENTENCE = 3, cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_ALL_CHARACTERS = 4, cc.EditBoxDelegate = cc.Class.extend({
    editBoxEditingDidBegin: function() {},
    editBoxEditingDidEnd: function() {},
    editBoxTextChanged: function() {},
    editBoxReturn: function() {}
}), cc.EditBox = cc.ControlButton.extend({
    _domInputSprite: null,
    _delegate: null,
    _editBoxInputMode: cc.EDITBOX_INPUT_MODE_ANY,
    _editBoxInputFlag: cc.EDITBOX_INPUT_FLAG_SENSITIVE,
    _keyboardReturnType: cc.KEYBOARD_RETURNTYPE_DEFAULT,
    _text: "",
    _placeholderText: "",
    _textColor: null,
    _placeholderColor: null,
    _maxLength: 50,
    _adjustHeight: 18,
    _edTxt: null,
    _edFontSize: 14,
    _edFontName: "Arial",
    _placeholderFontName: "",
    _placeholderFontSize: 14,
    _tooltip: !1,
    _className: "EditBox",
    ctor: function(a, b, c, d) {
        cc.ControlButton.prototype.ctor.call(this), this._textColor = cc.color.WHITE, this._placeholderColor = cc.color.GRAY, this.setContentSize(a);
        var e = this._domInputSprite = new cc.Sprite;
        e.draw = function() {}, this.addChild(e);
        var f = this,
            g = this._edTxt = cc.newElement("input");
        g.type = "text", g.style.fontSize = this._edFontSize + "px", g.style.color = "#000000", g.style.border = 0, g.style.background = "transparent", g.style.width = "100%", g.style.height = "100%", g.style.active = 0, g.style.outline = "medium", g.style.padding = "0";
        var h = function() {
            g.blur()
        };
        cc._addEventListener(g, "input", function() {
            f._delegate && f._delegate.editBoxTextChanged && f._delegate.editBoxTextChanged(f, this.value)
        }), cc._addEventListener(g, "keypress", function(a) {
            a.keyCode === cc.KEY.enter && (a.stopPropagation(), a.preventDefault(), cc._canvas.focus())
        }), cc._addEventListener(g, "focus", function() {
            this.value == f._placeholderText && (this.value = "", this.style.fontSize = f._edFontSize + "px", this.style.color = cc.colorToHex(f._textColor)), f._delegate && f._delegate.editBoxEditingDidBegin && f._delegate.editBoxEditingDidBegin(f), cc._addEventListener(cc._canvas, "click", h)
        }), cc._addEventListener(g, "blur", function() {
            "" == this.value && (this.value = f._placeholderText, this.style.fontSize = f._placeholderFontSize + "px", this.style.color = cc.colorToHex(f._placeholderColor)), f._delegate && f._delegate.editBoxEditingDidEnd && f._delegate.editBoxEditingDidEnd(f), f._delegate && f._delegate.editBoxReturn && f._delegate.editBoxReturn(f), cc._canvas.removeEventListener("click", h)
        }), cc.DOM.convert(e), e.dom.appendChild(g), e.dom.showTooltipDiv = !1, e.dom.style.width = a.width - 6 + "px", e.dom.style.height = a.height - 6 + "px", e.canvas.remove(), this.initWithSizeAndBackgroundSprite(a, b) && (c && this.setBackgroundSpriteForState(c, cc.CONTROL_STATE_HIGHLIGHTED), d && this.setBackgroundSpriteForState(d, cc.CONTROL_STATE_DISABLED))
    },
    setFont: function(a, b) {
        this._edFontSize = b, this._edFontName = a, this._setFontToEditBox()
    },
    _setFont: function(a) {
        (a = cc.LabelTTF._fontStyleRE.exec(a)) && (this._edFontSize = parseInt(a[1]), this._edFontName = a[2], this._setFontToEditBox())
    },
    setFontName: function(a) {
        this._edFontName = a, this._setFontToEditBox()
    },
    setFontSize: function(a) {
        this._edFontSize = a, this._setFontToEditBox()
    },
    _setFontToEditBox: function() {
        this._edTxt.value != this._placeholderText && (this._edTxt.style.fontFamily = this._edFontName, this._edTxt.style.fontSize = this._edFontSize + "px")
    },
    setText: function(a) {
        cc.log("Please use the setString"), null != a && ("" == a ? (this._edTxt.value = this._placeholderText, this._edTxt.style.color = cc.colorToHex(this._placeholderColor)) : (this._edTxt.value = a, this._edTxt.style.color = cc.colorToHex(this._textColor)))
    },
    setString: function(a) {
        null != a && ("" == a ? (this._edTxt.value = this._placeholderText, this._edTxt.style.color = cc.colorToHex(this._placeholderColor)) : (this._edTxt.value = a, this._edTxt.style.color = cc.colorToHex(this._textColor)))
    },
    setFontColor: function(a) {
        this._textColor = a, this._edTxt.value != this._placeholderText && (this._edTxt.style.color = cc.colorToHex(a))
    },
    setMaxLength: function(a) {
        !isNaN(a) && a > 0 && (this._maxLength = a, this._edTxt.maxLength = a)
    },
    getMaxLength: function() {
        return this._maxLength
    },
    setPlaceHolder: function(a) {
        if (null != a) {
            var b = this._placeholderText;
            this._placeholderText = a, this._edTxt.value == b && (this._edTxt.value = a, this._edTxt.style.color = cc.colorToHex(this._placeholderColor), this._setPlaceholderFontToEditText())
        }
    },
    setPlaceholderFont: function(a, b) {
        this._placeholderFontName = a, this._placeholderFontSize = b, this._setPlaceholderFontToEditText()
    },
    _setPlaceholderFont: function(a) {
        (a = cc.LabelTTF._fontStyleRE.exec(a)) && (this._placeholderFontName = a[2], this._placeholderFontSize = parseInt(a[1]), this._setPlaceholderFontToEditText())
    },
    setPlaceholderFontName: function(a) {
        this._placeholderFontName = a, this._setPlaceholderFontToEditText()
    },
    setPlaceholderFontSize: function(a) {
        this._placeholderFontSize = a, this._setPlaceholderFontToEditText()
    },
    _setPlaceholderFontToEditText: function() {
        this._edTxt.value == this._placeholderText && (this._edTxt.style.fontFamily = this._placeholderFontName, this._edTxt.style.fontSize = this._placeholderFontSize + "px")
    },
    setPlaceholderFontColor: function(a) {
        this._placeholderColor = a, this._edTxt.value == this._placeholderText && (this._edTxt.style.color = cc.colorToHex(a))
    },
    setInputFlag: function(a) {
        this._editBoxInputFlag = a, this._edTxt.type = a == cc.EDITBOX_INPUT_FLAG_PASSWORD ? "password" : "text"
    },
    getText: function() {
        return cc.log("Please use the getString"), this._edTxt.value
    },
    getString: function() {
        return this._edTxt.value
    },
    initWithSizeAndBackgroundSprite: function(a, b) {

        return this.initWithBackgroundSprite(b) ? (this._domInputSprite.x = 3, this._domInputSprite.y = 3, this.setZoomOnTouchDown(!1), this.setPreferredSize(a), this.y = this.x = 0, this._addTargetWithActionForControlEvent(this, this.touchDownAction, cc.CONTROL_EVENT_TOUCH_UP_INSIDE), !0) : !1
    },
    setDelegate: function(a) {
        this._delegate = a
    },
    getPlaceHolder: function() {
        return this._placeholderText
    },
    setInputMode: function(a) {
        this._editBoxInputMode = a
    },
    setReturnType: function(a) {
        this._keyboardReturnType = a
    },
    keyboardWillShow: function(a) {
        var b = cc.EditBox.getRect(this);
        b.y -= 4, b.intersectsRect(a.end) ? this._adjustHeight = a.end.getMaxY() - b.getMinY() : cc.log("needn't to adjust view layout.")
    },
    keyboardDidShow: function() {},
    keyboardWillHide: function() {},
    keyboardDidHide: function() {},
    touchDownAction: function() {},
    initWithBackgroundColor: function(a, b) {
        this._edWidth = a.width, this.dom.style.width = this._edWidth.toString() + "px", this._edHeight = a.height, this.dom.style.height = this._edHeight.toString() + "px", this.dom.style.backgroundColor = cc.colorToHex(b)
    }
}), _p = cc.EditBox.prototype, cc.defineGetterSetter(_p, "font", null, _p._setFont), cc.defineGetterSetter(_p, "fontName", null, _p.setFontName), cc.defineGetterSetter(_p, "fontSize", null, _p.setFontSize), cc.defineGetterSetter(_p, "fontColor", null, _p.setFontColor), cc.defineGetterSetter(_p, "string", _p.getString, _p.setString), cc.defineGetterSetter(_p, "maxLength", _p.getMaxLength, _p.setMaxLength), cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder), cc.defineGetterSetter(_p, "placeHolderFont", null, _p._setPlaceholderFont), cc.defineGetterSetter(_p, "placeHolderFontName", null, _p.setPlaceholderFontName), cc.defineGetterSetter(_p, "placeHolderFontSize", null, _p.setPlaceholderFontSize), cc.defineGetterSetter(_p, "placeHolderFontColor", null, _p.setPlaceholderFontColor), cc.defineGetterSetter(_p, "inputFlag", null, _p.setInputFlag), cc.defineGetterSetter(_p, "delegate", null, _p.setDelegate), cc.defineGetterSetter(_p, "inputMode", null, _p.setInputMode), cc.defineGetterSetter(_p, "returnType", null, _p.setReturnType), _p = null, cc.EditBox.getRect = function(a) {
    var b = a.getContentSize(),
        b = cc.rect(0, 0, b.width, b.height);
    return cc.rectApplyAffineTransform(b, a.nodeToWorldTransform())
}, cc.EditBox.create = function(a, b, c, d) {
    return new cc.EditBox(a, b, c, d)
}, cc.ProtectedNode = cc.Node.extend({
    _protectedChildren: null,
    _reorderProtectedChildDirty: !1,
    _insertProtectedChild: function(a, b) {
        this._reorderProtectedChildDirty = !0, this._protectedChildren.push(a), a._setLocalZOrder(b)
    },
    ctor: function() {
        cc.Node.prototype.ctor.call(this), this._protectedChildren = []
    },
    addProtectedChild: function(a, b, c) {
        cc.assert(null != a, "child must be non-nil"), cc.assert(!a.parent, "child already added. It can't be added again"), b = b || a.getLocalZOrder(), c && a.setTag(c), this._insertProtectedChild(a, b), a.setParent(this), a.setOrderOfArrival(cc.s_globalOrderOfArrival), this._running && (a.onEnter(), this._isTransitionFinished) && a.onEnterTransitionDidFinish(), this._cascadeColorEnabled && this._enableCascadeColor(), this._cascadeOpacityEnabled && this._enableCascadeOpacity()
    },
    getProtectedChildByTag: function(a) {
        cc.assert(a != cc.NODE_TAG_INVALID, "Invalid tag");
        for (var b = this._protectedChildren, c = 0, d = b.length; d > c; c++)
            if (b.getTag() == a) return b[c];
        return null
    },
    removeProtectedChild: function(a, b) {
        null == b && (b = !0);
        var c = this._protectedChildren;
        if (0 !== c.length) {
            var d = c.indexOf(a);
            d > -1 && (this._running && (a.onExitTransitionDidStart(), a.onExit()), b && a.cleanup(), a.setParent(null), c.splice(d, 1))
        }
    },
    removeProtectedChildByTag: function(a, b) {
        cc.assert(a != cc.NODE_TAG_INVALID, "Invalid tag"), null == b && (b = !0);
        var c = this.getProtectedChildByTag(a);
        null == c ? cc.log("cocos2d: removeChildByTag(tag = %d): child not found!", a) : this.removeProtectedChild(c, b)
    },
    removeAllProtectedChildren: function() {
        this.removeAllProtectedChildrenWithCleanup(!0)
    },
    removeAllProtectedChildrenWithCleanup: function(a) {
        null == a && (a = !0);
        for (var b = this._protectedChildren, c = 0, d = b.length; d > c; c++) {
            var e = b[c];
            this._running && (e.onExitTransitionDidStart(), e.onExit()), a && e.cleanup(), e.setParent(null)
        }
        b.length = 0
    },
    reorderProtectedChild: function(a, b) {
        cc.assert(null != a, "Child must be non-nil"), this._reorderProtectedChildDirty = !0, a.setOrderOfArrival(cc.s_globalOrderOfArrival++), a._setLocalZOrder(b)
    },
    sortAllProtectedChildren: function() {
        if (this._reorderProtectedChildDirty) {
            var a, b, c, d = this._protectedChildren,
                e = d.length;
            for (a = 1; e > a; a++) {
                for (c = d[a], b = a - 1; b >= 0;) {
                    if (c._localZOrder < d[b]._localZOrder) d[b + 1] = d[b];
                    else {
                        if (!(c._localZOrder === d[b]._localZOrder && c.arrivalOrder < d[b].arrivalOrder)) break;
                        d[b + 1] = d[b]
                    }
                    b--
                }
                d[b + 1] = c
            }
            this._reorderProtectedChildDirty = !1
        }
    },
    visit: null,
    _visitForCanvas: function(a) {
        if (this._visible) {
            a = a || cc._renderContext;
            var b, c, d, e = this._children,
                f = this._protectedChildren,
                g = this._children.length,
                h = f.length;
            for (a.save(), this.transform(a), this.sortAllChildren(), this.sortAllProtectedChildren(), b = 0; g > b && (d = e[b], 0 > d._localZOrder); b++) d.visit(a);
            for (c = 0; h > c && (d = f[c], 0 > d._localZOrder); c++) d.visit(a);
            for (this.draw(a); g > b; b++) e[b] && e[b].visit(a);
            for (; h > c; c++) f[c] && f[c].visit(a);
            this._cacheDirty = !1, this.arrivalOrder = 0, a.restore()
        }
    },
    _visitForWebGL: function() {
        if (this._visible) {
            var a, b, c = cc._renderContext,
                d = cc.current_stack;
            d.stack.push(d.top), cc.kmMat4Assign(this._stackMatrix, d.top), d.top = this._stackMatrix;
            var e = this.grid;
            e && e._active && e.beforeDraw(), this.transform();
            var f = this._children,
                g = this._protectedChildren,
                h = f.length,
                i = g.length;
            for (this.sortAllChildren(), this.sortAllProtectedChildren(), a = 0; h > a && (f[a] && 0 > f[a]._localZOrder); a++) f[a].visit();
            for (b = 0; i > b && (g[b] && 0 > g[b]._localZOrder); b++) g[b].visit();
            for (this.draw(c); h > a; a++) f[a] && f[a].visit();
            for (; i > b; b++) g[b] && g[b].visit();
            this.arrivalOrder = 0, e && e._active && e.afterDraw(this), d.top = d.stack.pop()
        }
    },
    cleanup: function() {
        cc.Node.prototype.cleanup.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; c > b; b++) a[b].cleanup()
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; c > b; b++) a[b].onEnter()
    },
    onEnterTransitionDidFinish: function() {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; c > b; b++) a[b].onEnterTransitionDidFinish()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; c > b; b++) a[b].onExit()
    },
    onExitTransitionDidStart: function() {
        cc.Node.prototype.onExitTransitionDidStart.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; c > b; b++) a[b].onExitTransitionDidStart()
    },
    updateDisplayedOpacity: function(a) {
        this._displayedOpacity = this._realOpacity * a / 255, this._updateColor();
        var b, c, d = this._displayedOpacity;
        if (this._cascadeOpacityEnabled)
            for (c = this._children, a = 0, b = c.length; b > a; a++) c[a].updateDisplayedOpacity && c[a].updateDisplayedOpacity(d);
        for (c = this._protectedChildren, a = 0, b = c.length; b > a; a++) c[a] && c[a].updateDisplayedOpacity(d)
    },
    updateDisplayedColor: function(a) {
        var b = this._displayedColor,
            c = this._realColor;
        b.r = c.r * a.r / 255, b.g = c.g * a.g / 255, b.b = c.b * a.b / 255, this._updateColor();
        var d;
        if (this._cascadeColorEnabled)
            for (d = this._children, a = 0, c = d.length; c > a; a++) d[a].updateDisplayedColor && d[a].updateDisplayedColor(b);
        for (d = this._protectedChildren, a = 0, c = d.length; c > a; a++) d[a] && d[a].updateDisplayedColor(b)
    },
    _disableCascadeOpacity: function() {
        this._displayedOpacity = this._realOpacity;
        var a, b, c = this._children;
        for (a = 0; a < c.length; a++)(b = c[a]) && b.updateDisplayedOpacity(255);
        for (c = this._protectedChildren, a = 0; a < c.length; a++)(b = c[a]) && b.updateDisplayedOpacity(255)
    },
    _disableCascadeColor: function() {
        var a, b, c = cc.color.WHITE,
            d = this._children;
        for (a = 0, b = d.length; b > a; a++) d[a].updateDisplayedColor(c);
        for (d = this._protectedChildren, a = 0, b = d.length; b > a; a++) d[a].setColor(c)
    }
}), cc.ProtectedNode.prototype.visit = cc._renderType === cc._RENDER_TYPE_CANVAS ? cc.ProtectedNode.prototype._visitForCanvas : cc.ProtectedNode.prototype._visitForWebGL, cc.ProtectedNode.create = function() {
    return new cc.ProtectedNode
};
var ccui = ccui || {};
ccui.Class = ccui.Class || cc.Class, ccui.Class.extend = ccui.Class.extend || cc.Class.extend, ccui.Node = ccui.Node || cc.Node, ccui.Node.extend = ccui.Node.extend || cc.Node.extend, ccui.ProtectedNode = ccui.ProtectedNode || cc.ProtectedNode, ccui.ProtectedNode.extend = ccui.ProtectedNode.extend || cc.ProtectedNode.extend, ccui.cocosGUIVersion = "CocosGUI v1.0.0.0", ccui.Widget = ccui.ProtectedNode.extend({
    _enabled: !0,
    _bright: !0,
    _touchEnabled: !1,
    _brightStyle: null,
    _touchBeganPosition: null,
    _touchMovePosition: null,
    _touchEndPosition: null,
    _touchEventListener: null,
    _touchEventSelector: null,
    _name: "default",
    _widgetType: null,
    _actionTag: 0,
    _customSize: null,
    _layoutParameterDictionary: null,
    _layoutParameterType: 0,
    _focused: !1,
    _focusEnabled: !0,
    _ignoreSize: !1,
    _affectByClipping: !1,
    _sizeType: null,
    _sizePercent: null,
    _positionType: null,
    _positionPercent: null,
    _reorderWidgetChildDirty: !1,
    _hit: !1,
    _nodes: null,
    _touchListener: null,
    _className: "Widget",
    _flippedX: !1,
    _flippedY: !1,
    _opacity: 255,
    _highlight: !1,
    _touchEventCallback: null,
    ctor: function() {
        cc.ProtectedNode.prototype.ctor.call(this), this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this._touchBeganPosition = cc.p(0, 0), this._touchMovePosition = cc.p(0, 0), this._touchEndPosition = cc.p(0, 0), this._widgetType = ccui.Widget.TYPE_WIDGET, this._customSize = cc.size(0, 0), this._layoutParameterDictionary = {}, this._sizeType = ccui.Widget.SIZE_ABSOLUTE, this._sizePercent = cc.p(0, 0), this._positionType = ccui.Widget.POSITION_ABSOLUTE, this._positionPercent = cc.p(0, 0), this._nodes = [], this._layoutParameterType = ccui.LayoutParameter.NONE, this.init()
    },

    init: function() {
        return cc.ProtectedNode.prototype.init.call(this) ? (this._layoutParameterDictionary = {}, this._initRenderer(), this.setBright(!0), this.onFocusChanged = this.onFocusChange.bind(this), this.onNextFocusedWidget = null, this.setAnchorPoint(cc.p(.5, .5)), this.ignoreContentAdaptWithSize(!0), !0) : !1
    },
    onEnter: function() {
        this.updateSizeAndPosition(), cc.ProtectedNode.prototype.onEnter.call(this)
    },
    onExit: function() {
        this.unscheduleUpdate(), cc.ProtectedNode.prototype.onExit.call(this)
    },
    visit: function(a) {
        this._visible && (this._adaptRenderers(), cc.ProtectedNode.prototype.visit.call(this, a))
    },
    getWidgetParent: function() {
        var a = this.getParent();
        return a instanceof ccui.Widget ? a : null
    },
    _updateContentSizeWithTextureSize: function(a) {
        this.setContentSize(this._ignoreSize ? a : this._customSize)
    },
    _isAncestorsEnabled: function() {
        var a = this._getAncensterWidget(this);
        return null == a ? !0 : a && !a.isEnabled() ? !1 : a._isAncestorsEnabled()
    },
    _getAncensterWidget: function(a) {
        return null == a ? null : (a = a.getParent(), null == a ? null : a instanceof ccui.Widget ? a : this._getAncensterWidget(a.getParent()))
    },
    _isAncestorsVisible: function(a) {
        return null == a ? !0 : (a = a.getParent()) && !a.isVisible() ? !1 : this._isAncestorsVisible(a)
    },
    _cleanupWidget: function() {
        this._eventDispatcher.removeEventListener(this._touchListener), ccui.Widget._focusedWidget == this && (ccui.Widget._focusedWidget = null)
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    _initRenderer: function() {},
    setContentSize: function(a, b) {
        var c = void 0 === b ? a.width : a,
            d = void 0 === b ? a.height : b;
        if (cc.Node.prototype.setContentSize.call(this, c, d), this._customSize.width = c, this._customSize.height = d, this._ignoreSize && (this._contentSize = this.getVirtualRendererSize()), this._running) {
            var e = this.getWidgetParent(),
                e = e ? e.getContentSize() : this._parent.getContentSize();
            this._sizePercent.x = 0 < e.width ? c / e.width : 0, this._sizePercent.y = 0 < e.height ? d / e.height : 0
        }
        this._onSizeChanged()
    },
    _setWidth: function(a) {
        cc.Node.prototype._setWidth.call(this, a), this._customSize.width = a, this._ignoreSize && (this._contentSize = this.getVirtualRendererSize()), this._running && (a = (a = this.getWidgetParent()) ? a.width : this._parent.width, this._sizePercent.x = a > 0 ? this._customSize.width / a : 0), this._onSizeChanged()
    },
    _setHeight: function(a) {
        cc.Node.prototype._setHeight.call(this, a), this._customSize.height = a, this._ignoreSize && (this._contentSize = this.getVirtualRendererSize()), this._running && (a = (a = this.getWidgetParent()) ? a.height : this._parent.height, this._sizePercent.y = a > 0 ? this._customSize.height / a : 0), this._onSizeChanged()
    },
    setSizePercent: function(a) {
        this._sizePercent.x = a.x, this._sizePercent.y = a.y;
        var b = this._customSize.width,
            c = this._customSize.height;
        this._running && ((c = this.getWidgetParent()) ? (b = c.width * a.x, c = c.height * a.y) : (b = this._parent.width * a.x, c = this._parent.height * a.y)), this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(b, c), this._customSize.width = b, this._customSize.height = c
    },
    _setWidthPercent: function(a) {
        this._sizePercent.x = a;
        var b = this._customSize.width;
        this._running && (b = this.getWidgetParent(), b = (b ? b.width : this._parent.width) * a), this._setWidth(this._ignoreSize ? this.getVirtualRendererSize().width : b), this._customSize.width = b
    },
    _setHeightPercent: function(a) {
        this._sizePercent.y = a;
        var b = this._customSize.height;
        this._running && (b = this.getWidgetParent(), b = (b ? b.height : this._parent.height) * a), this._setHeight(this._ignoreSize ? this.getVirtualRendererSize().height : b), this._customSize.height = b
    },
    updateSizeAndPosition: function(a) {
        switch (a || (a = (a = this.getWidgetParent()) ? a.getLayoutSize() : this._parent.getContentSize()), this._sizeType) {
            case ccui.Widget.SIZE_ABSOLUTE:
                this.setContentSize(this._ignoreSize ? this.getVirtualRendererSize() : this._customSize), this._sizePercent.x = 0 < a.width ? this._customSize.width / a.width : 0, this._sizePercent.y = 0 < a.height ? this._customSize.height / a.height : 0;
                break;
            case ccui.Widget.SIZE_PERCENT:
                var b = cc.size(a.width * this._sizePercent.x, a.height * this._sizePercent.y);
                this.setContentSize(this._ignoreSize ? this.getVirtualRendererSize() : b), this._customSize.width = b.width, this._customSize.height = b.height
        }
        switch (this._onSizeChanged(), b = this.getPosition(), this._positionType) {
            case ccui.Widget.POSITION_ABSOLUTE:
                0 >= a.width || 0 >= a.height ? this._positionPercent.x = this._positionPercent.y = 0 : (this._positionPercent.x = b.x / a.width, this._positionPercent.y = b.y / a.height);
                break;
            case ccui.Widget.POSITION_PERCENT:
                b = cc.p(a.width * this._positionPercent.x, a.height * this._positionPercent.y)
        }
        this._parent instanceof ccui.ImageView && (a = this._parent._imageRenderer) && !a._textureLoaded || this.setPosition(b)
    },
    setSizeType: function(a) {
        this._sizeType = a
    },
    getSizeType: function() {
        return this._sizeType
    },
    ignoreContentAdaptWithSize: function(a) {
        this._ignoreSize != a && (this._ignoreSize = a, this.setContentSize(a ? this.getVirtualRendererSize() : this._customSize), this._onSizeChanged())
    },
    isIgnoreContentAdaptWithSize: function() {
        return this._ignoreSize
    },
    getCustomSize: function() {
        return cc.size(this._customSize)
    },
    getLayoutSize: function() {
        return cc.size(this._contentSize)
    },
    getSizePercent: function() {
        return cc.p(this._sizePercent)
    },
    _getWidthPercent: function() {
        return this._sizePercent.x
    },
    _getHeightPercent: function() {
        return this._sizePercent.y
    },
    getWorldPosition: function() {
        return this.convertToWorldSpace(cc.p(this._anchorPoint.x * this._contentSize.width, this._anchorPoint.y * this._contentSize.height))
    },
    getVirtualRenderer: function() {
        return this
    },
    getVirtualRendererSize: function() {
        return cc.size(this._contentSize)
    },
    _onSizeChanged: function() {
        for (var a = this.getChildren(), b = 0, c = a.length; c > b; b++) {
            var d = a[b];
            d instanceof ccui.Widget && d.updateSizeAndPosition()
        }
    },
    setTouchEnabled: function(a) {
        this._touchEnabled !== a && ((this._touchEnabled = a) ? (this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this.onTouchBegan.bind(this),
            onTouchMoved: this.onTouchMoved.bind(this),
            onTouchEnded: this.onTouchEnded.bind(this)
        }), cc.eventManager.addListener(this._touchListener, this)) : cc.eventManager.removeListener(this._touchListener))
    },
    isTouchEnabled: function() {
        return this._touchEnabled
    },
    isHighlighted: function() {
        return this._highlight
    },
    setHighlighted: function(a) {
        a != this._highlight && (this._highlight = a, this._bright ? this.setBrightStyle(this._highlight ? ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT : ccui.Widget.BRIGHT_STYLE_NORMAL) : this._onPressStateChangedToDisabled())
    },
    isFocused: function() {
        return this._focused
    },
    setFocused: function(a) {
        (this._focused = a) && (ccui.Widget._focusedWidget = this)
    },
    isFocusEnabled: function() {
        return this._focusEnabled
    },
    setFocusEnabled: function(a) {
        this._focused = a
    },
    findNextFocusedWidget: function(a, b) {
        if (null == this.onNextFocusedWidget || null == this.onNextFocusedWidget(a)) {
            var c = b instanceof ccui.Layout;
            if (this.isFocused() || c) {
                var d = this.getParent();
                return null == d ? c ? b.findNextFocusedWidget(a, b) : b : d.findNextFocusedWidget(a, b)
            }
            return b
        }
        return c = this.onNextFocusedWidget(a), this.dispatchFocusEvent(this, c), c
    },
    requestFocus: function() {
        this != ccui.Widget._focusedWidget && this.dispatchFocusEvent(ccui.Widget._focusedWidget, this)
    },
    getCurrentFocusedWidget: function() {
        return ccui.Widget._focusedWidget
    },
    enableDpadNavigation: function() {},
    onFocusChanged: null,
    onNextFocusedWidget: null,
    interceptTouchEvent: function(a, b, c) {
        var d = this.getWidgetParent();
        d && d.interceptTouchEvent(a, b, c)
    },
    onFocusChange: function(a, b) {
        a && a.setFocused(!1), b && b.setFocused(!0)
    },
    dispatchFocusEvent: function(a, b) {
        a && !a.isFocused() && (a = ccui.Widget._focusedWidget), b != a && (b && b.onFocusChanged && b.onFocusChanged(a, b), a && b.onFocusChanged && a.onFocusChanged(a, b), cc.eventManager.dispatchEvent(new cc.EventFocus(a, b)))
    },
    setBright: function(a) {
        (this._bright = a) ? (this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL)) : this._onPressStateChangedToDisabled()
    },
    setBrightStyle: function(a) {
        if (this._brightStyle != a) switch (this._brightStyle = a = a || ccui.Widget.BRIGHT_STYLE_NORMAL, this._brightStyle) {
            case ccui.Widget.BRIGHT_STYLE_NORMAL:
                this._onPressStateChangedToNormal();
                break;
            case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
                this._onPressStateChangedToPressed()
        }
    },
    _onPressStateChangedToNormal: function() {},
    _onPressStateChangedToPressed: function() {},
    _onPressStateChangedToDisabled: function() {},
    didNotSelectSelf: function() {},
    onTouchBegan: function(a) {
        if (this._hit = !1, this.isVisible() && this.isEnabled() && this._isAncestorsEnabled() && this._isAncestorsVisible(this)) {
            var b = a.getLocation();
            this._touchBeganPosition.x = b.x, this._touchBeganPosition.y = b.y, this.hitTest(this._touchBeganPosition) && this.isClippingParentContainsPoint(this._touchBeganPosition) && (this._hit = !0)
        }
        return this._hit ? (this.setHighlighted(!0), (b = this.getWidgetParent()) && b.interceptTouchEvent(ccui.Widget.TOUCH_BEGAN, this, a), this._pushDownEvent(), !0) : !1
    },
    onTouchMoved: function(a) {
        var b = a.getLocation();
        this._touchMovePosition.x = b.x, this._touchMovePosition.y = b.y, this.setHighlighted(this.hitTest(b)), (b = this.getWidgetParent()) && b.interceptTouchEvent(ccui.Widget.TOUCH_MOVED, this, a), this._moveEvent()
    },
    onTouchEnded: function(a) {
        var b = a.getLocation();
        this._touchEndPosition.x = b.x, this._touchEndPosition.y = b.y, (b = this.getWidgetParent()) && b.interceptTouchEvent(ccui.Widget.TOUCH_ENDED, this, a), b = this._highlight, this.setHighlighted(!1), b ? this._releaseUpEvent() : this._cancelUpEvent()
    },
    onTouchCancelled: function() {
        this.setHighlighted(!1), this._cancelUpEvent()
    },
    onTouchLongClicked: function() {
        this.longClickEvent()
    },
    _pushDownEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_BEGAN), this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_BEGAN)
    },
    _moveEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_MOVED), this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_MOVED)
    },
    _releaseUpEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_ENDED), this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_ENDED)
    },
    _cancelUpEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_CANCELED), this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_CANCELED)
    },
    longClickEvent: function() {},
    addTouchEventListener: function(a, b) {
        void 0 === b ? this._touchEventCallback = a : (this._touchEventSelector = a, this._touchEventListener = b)
    },
    hitTest: function(a) {
        var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc.rectContainsPoint(b, this.convertToNodeSpace(a))
    },
    isClippingParentContainsPoint: function(a) {
        this._affectByClipping = !1;
        for (var b = this.getParent(), c = null; b;) {
            if (b instanceof ccui.Layout && b.isClippingEnabled()) {
                this._affectByClipping = !0, c = b;
                break
            }
            b = b.getParent()
        }
        return this._affectByClipping && c ? c.hitTest(a) ? c.isClippingParentContainsPoint(a) : !1 : !0
    },
    checkChildInfo: function(a, b, c) {
        var d = this.getWidgetParent();
        d && d.checkChildInfo(a, b, c)
    },
    setPosition: function(a, b) {
        if (this._running) {
            var c = this.getWidgetParent();
            c && (c = c.getContentSize(), 0 >= c.width || 0 >= c.height ? (this._positionPercent.x = 0, this._positionPercent.y = 0) : void 0 == b ? (this._positionPercent.x = a / c.width, this._positionPercent.y = b / c.height) : (this._positionPercent.x = a.x / c.width, this._positionPercent.y = a.y / c.height))
        }
        cc.Node.prototype.setPosition.call(this, a, b)
    },
    setPositionX: function(a) {
        if (this._running) {
            var b = this.getWidgetParent();
            b && (b = b.width, this._positionPercent.x = 0 >= b ? 0 : a / b)
        }
        cc.Node.prototype.setPositionX.call(this, a)
    },
    setPositionY: function(a) {
        if (this._running) {
            var b = this.getWidgetParent();
            b && (b = b.height, this._positionPercent.y = 0 >= b ? 0 : a / b)
        }
        cc.Node.prototype.setPositionY.call(this, a)
    },
    setPositionPercent: function(a) {
        this._positionPercent = a, this._running && (a = this.getWidgetParent()) && (a = a.getSize(), this.setPosition(a.width * this._positionPercent.x, a.height * this._positionPercent.y))
    },
    _setXPercent: function(a) {
        if (this._positionPercent.x = a, this._running) {
            var b = this.getWidgetParent();
            b && this.setPositionX(b.width * a)
        }
    },
    _setYPercent: function(a) {
        if (this._positionPercent.y = a, this._running) {
            var b = this.getWidgetParent();
            b && this.setPositionY(b.height * a)
        }
    },
    getPositionPercent: function() {
        return cc.p(this._positionPercent)
    },
    _getXPercent: function() {
        return this._positionPercent.x
    },
    _getYPercent: function() {
        return this._positionPercent.y
    },
    setPositionType: function(a) {
        this._positionType = a
    },
    getPositionType: function() {
        return this._positionType
    },
    setFlippedX: function(a) {
        this._flippedX = a, this._updateFlippedX()
    },
    isFlippedX: function() {
        return this._flippedX
    },
    setFlippedY: function(a) {
        this._flippedY = a, this._updateFlippedY()
    },
    isFlippedY: function() {
        return this._flippedY
    },
    _updateFlippedX: function() {},
    _updateFlippedY: function() {},
    _adaptRenderers: function() {},
    isBright: function() {
        return this._bright
    },
    isEnabled: function() {
        return this._enabled
    },
    getLeftBoundary: function() {
        return this.getPositionX() - this._getAnchorX() * this._contentSize.width
    },
    getBottomBoundary: function() {
        return this.getPositionY() - this._getAnchorY() * this._contentSize.height
    },
    getRightBoundary: function() {
        return this.getLeftBoundary() + this._contentSize.width
    },
    getTopBoundary: function() {
        return this.getBottomBoundary() + this._contentSize.height
    },
    getTouchBeganPosition: function() {
        return cc.p(this._touchBeganPosition)
    },
    getTouchMovePosition: function() {
        return cc.p(this._touchMovePosition)
    },
    getTouchEndPosition: function() {
        return cc.p(this._touchEndPosition)
    },
    getWidgetType: function() {
        return this._widgetType
    },
    setLayoutParameter: function(a) {
        a && (this._layoutParameterDictionary[a.getLayoutType()] = a, this._layoutParameterType = a.getLayoutType())
    },
    getLayoutParameter: function(a) {
        return a = a || this._layoutParameterType, this._layoutParameterDictionary[a]
    },
    getDescription: function() {
        return "Widget"
    },
    clone: function() {
        var a = this._createCloneInstance();
        return a._copyProperties(this), a._copyClonedWidgetChildren(this), a
    },
    _createCloneInstance: function() {
        return ccui.Widget.create()
    },
    _copyClonedWidgetChildren: function(a) {
        a = a.getChildren();
        for (var b = 0; b < a.length; b++) {
            var c = a[b];
            c instanceof ccui.Widget && this.addChild(c.clone())
        }
    },
    _copySpecialProperties: function() {},
    _copyProperties: function(a) {
        this.setEnabled(a.isEnabled()), this.setVisible(a.isVisible()), this.setBright(a.isBright()), this.setTouchEnabled(a.isTouchEnabled()), this.setLocalZOrder(a.getLocalZOrder()), this.setTag(a.getTag()), this.setName(a.getName()), this.setActionTag(a.getActionTag()), this._ignoreSize = a._ignoreSize, this.setContentSize(a._contentSize), this._customSize.width = a._customSize.width, this._customSize.height = a._customSize.height, this._copySpecialProperties(a), this._sizeType = a.getSizeType(), this._sizePercent.x = a._sizePercent.x, this._sizePercent.y = a._sizePercent.y, this._positionType = a._positionType, this._positionPercent.x = a._positionPercent.x, this._positionPercent.y = a._positionPercent.y, this.setPosition(a.getPosition()), this.setAnchorPoint(a.getAnchorPoint()), this.setScaleX(a.getScaleX()), this.setScaleY(a.getScaleY()), this.setRotation(a.getRotation()), this.setRotationX(a.getRotationX()), this.setRotationY(a.getRotationY()), this.setFlippedX(a.isFlippedX()), this.setFlippedY(a.isFlippedY()), this.setColor(a.getColor()), this.setOpacity(a.getOpacity()), this._touchEventCallback = a._touchEventCallback, this._touchEventListener = a._touchEventListener, this._touchEventSelector = a._touchEventSelector, this._focused = a._focused, this._focusEnabled = a._focusEnabled;
        for (var b in a._layoutParameterDictionary) {
            var c = a._layoutParameterDictionary[b];
            c && this.setLayoutParameter(c.clone())
        }
        this._onSizeChanged()
    },
    setActionTag: function(a) {
        this._actionTag = a
    },
    getActionTag: function() {
        return this._actionTag
    },
    getLeftInParent: function() {
        return cc.log("getLeftInParent is deprecated. Please use getLeftBoundary instead."), this.getLeftBoundary()
    },
    getBottomInParent: function() {
        return cc.log("getBottomInParent is deprecated. Please use getBottomBoundary instead."), this.getBottomBoundary()
    },
    getRightInParent: function() {
        return cc.log("getRightInParent is deprecated. Please use getRightBoundary instead."), this.getRightBoundary()
    },
    getTopInParent: function() {
        return cc.log("getTopInParent is deprecated. Please use getTopBoundary instead."), this.getTopBoundary()
    },
    getTouchEndPos: function() {
        return cc.log("getTouchEndPos is deprecated. Please use getTouchEndPosition instead."), this.getTouchEndPosition()
    },
    getTouchMovePos: function() {
        return cc.log("getTouchMovePos is deprecated. Please use getTouchMovePosition instead."), this.getTouchMovePosition()
    },
    clippingParentAreaContainPoint: function(a) {
        cc.log("clippingParentAreaContainPoint is deprecated. Please use isClippingParentContainsPoint instead."), this.isClippingParentContainsPoint(a)
    },
    getTouchStartPos: function() {
        return cc.log("getTouchStartPos is deprecated. Please use getTouchBeganPosition instead."), this.getTouchBeganPosition()
    },
    setSize: function(a) {
        this.setContentSize(a)
    },
    getSize: function() {
        return this.getContentSize()
    },
    addNode: function(a, b, c) {
        a instanceof ccui.Widget ? cc.log("Please use addChild to add a Widget.") : (cc.Node.prototype.addChild.call(this, a, b, c), this._nodes.push(a))
    },
    getNodeByTag: function(a) {
        for (var b = this._nodes, c = 0; c < b.length; c++) {
            var d = b[c];
            if (d && d.getTag() == a) return d
        }
        return null
    },
    getNodes: function() {
        return this._nodes
    },
    removeNode: function(a, b) {
        cc.Node.prototype.removeChild.call(this, a, b), cc.arrayRemoveObject(this._nodes, a)
    },
    removeNodeByTag: function(a) {
        var b = this.getNodeByTag(a);
        b ? this.removeNode(b) : cc.log("cocos2d: removeNodeByTag(tag = %d): child not found!", a)
    },
    removeAllNodes: function() {
        for (var a = 0; a < this._nodes.length; a++) cc.Node.prototype.removeChild.call(this, this._nodes[a]);
        this._nodes.length = 0
    },
    _findLayout: function() {
        for (var a = this._parent; a;) {
            if (a._doLayout) {
                a._doLayoutDirty = !0;
                break
            }
            a = a._parent
        }
    },
    _updateChildrenDisplayedRGBA: function() {
        this.setColor(this.getColor()), this.setOpacity(this.getOpacity())
    }
}), _p = ccui.Widget.prototype, cc.defineGetterSetter(_p, "xPercent", _p._getXPercent, _p._setXPercent), cc.defineGetterSetter(_p, "yPercent", _p._getYPercent, _p._setYPercent), cc.defineGetterSetter(_p, "widthPercent", _p._getWidthPercent, _p._setWidthPercent), cc.defineGetterSetter(_p, "heightPercent", _p._getHeightPercent, _p._setHeightPercent), cc.defineGetterSetter(_p, "widgetParent", _p.getWidgetParent), cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled), cc.defineGetterSetter(_p, "focused", _p.isFocused, _p.setFocused), cc.defineGetterSetter(_p, "sizeType", _p.getSizeType, _p.setSizeType), cc.defineGetterSetter(_p, "widgetType", _p.getWidgetType), cc.defineGetterSetter(_p, "touchEnabled", _p.isTouchEnabled, _p.setTouchEnabled), cc.defineGetterSetter(_p, "updateEnabled", _p.isUpdateEnabled, _p.setUpdateEnabled), cc.defineGetterSetter(_p, "bright", _p.isBright, _p.setBright), cc.defineGetterSetter(_p, "name", _p.getName, _p.setName), cc.defineGetterSetter(_p, "actionTag", _p.getActionTag, _p.setActionTag), cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity), _p = null, ccui.Widget.create = function() {
    return new ccui.Widget
}, ccui.Widget._focusedWidget = null, ccui.Widget.getCurrentFocusedWidget = function() {
    return ccui.Widget._focusedWidget
}, ccui.Widget.BRIGHT_STYLE_NONE = -1, ccui.Widget.BRIGHT_STYLE_NORMAL = 0, ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT = 1, ccui.Widget.TYPE_WIDGET = 0, ccui.Widget.TYPE_CONTAINER = 1, ccui.Widget.LEFT = 0, ccui.Widget.RIGHT = 1, ccui.Widget.UP = 0, ccui.Widget.DOWN = 1, ccui.Widget.LOCAL_TEXTURE = 0, ccui.Widget.PLIST_TEXTURE = 1, ccui.Widget.TOUCH_BEGAN = 0, ccui.Widget.TOUCH_MOVED = 1, ccui.Widget.TOUCH_ENDED = 2, ccui.Widget.TOUCH_CANCELED = 3, ccui.Widget.SIZE_ABSOLUTE = 0, ccui.Widget.SIZE_PERCENT = 1, ccui.Widget.POSITION_ABSOLUTE = 0, ccui.Widget.POSITION_PERCENT = 1, cc.EventFocus = cc.Event.extend({
    _widgetGetFocus: null,
    _widgetLoseFocus: null,
    ctor: function(a, b) {
        this._widgetGetFocus = b, this._widgetLoseFocus = a
    }
}), ccui.Scale9Sprite = cc.Node.extend({
    _spriteRect: null,
    _capInsetsInternal: null,
    _positionsAreDirty: !1,
    _scale9Image: null,
    _topLeft: null,
    _top: null,
    _topRight: null,
    _left: null,
    _centre: null,
    _right: null,
    _bottomLeft: null,
    _bottom: null,
    _bottomRight: null,
    _cacheSprite: null,
    _cacheCanvas: null,
    _cacheContext: null,
    _cacheTexture: null,
    _scale9Dirty: !0,
    _opacityModifyRGB: !1,
    _originalSize: null,
    _preferredSize: null,
    _opacity: 0,
    _color: null,
    _capInsets: null,
    _insetLeft: 0,
    _insetTop: 0,
    _insetRight: 0,
    _insetBottom: 0,
    _spritesGenerated: !1,
    _spriteFrameRotated: !1,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _className: "Scale9Sprite",
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: b
        })
    },
    _callLoadedEventCallbacks: function() {
        this._textureLoaded = !0;
        for (var a = this._loadedEventListeners, b = 0, c = a.length; c > b; b++) {
            var d = a[b];
            d.eventCallback.call(d.eventTarget, this)
        }
        a.length = 0
    },
    _updateCapInset: function() {
        var a;
        a = this._insetLeft;
        var b = this._insetTop,
            c = this._insetRight,
            d = this._spriteRect,
            e = this._insetBottom;
        a = 0 === a && 0 === b && 0 === c && 0 === e ? cc.rect(0, 0, 0, 0) : this._spriteFrameRotated ? cc.rect(e, a, d.width - c - a, d.height - b - e) : cc.rect(a, b, d.width - a - c, d.height - b - e), this.setCapInsets(a)
    },
    _updatePositions: function() {
        if (this._topLeft && this._topRight && this._bottomRight && this._bottomLeft && this._centre) {
            var a = this._contentSize,
                b = this._topLeft,
                c = this._topRight,
                d = this._bottomRight,
                e = this._bottomLeft,
                f = this._centre,
                g = this._centre.getContentSize(),
                h = b.getContentSize(),
                i = e.getContentSize(),
                j = a.width - h.width - c.getContentSize().width,
                a = a.height - h.height - d.getContentSize().height,
                j = j / g.width,
                a = a / g.height,
                h = g.width * j,
                k = g.height * a,
                l = i.width,
                i = i.height;
            if (cc._renderType == cc._RENDER_TYPE_WEBGL) {
                var m = Math.round(h);
                h != m && (h = m, j = h / g.width), m = Math.round(k), k != m && (k = m, a = k / g.height)
            }
            f.setScaleX(j), f.setScaleY(a);
            var g = this._left,
                m = this._right,
                n = this._top,
                o = this._bottom,
                p = cc.p(0, 0);
            e.setAnchorPoint(p), d.setAnchorPoint(p), b.setAnchorPoint(p), c.setAnchorPoint(p), g.setAnchorPoint(p), m.setAnchorPoint(p), n.setAnchorPoint(p), o.setAnchorPoint(p), f.setAnchorPoint(p), e.setPosition(0, 0), d.setPosition(l + h, 0), b.setPosition(0, i + k), c.setPosition(l + h, i + k), g.setPosition(0, i), g.setScaleY(a), m.setPosition(l + h, i), m.setScaleY(a), o.setPosition(l, 0), o.setScaleX(j), n.setPosition(l, i + k), n.setScaleX(j), f.setPosition(l, i)
        }
    },
    _cacheScale9Sprite: function() {
        if (this._scale9Image) {
            var a = this._contentSize,
                b = this._cacheCanvas,
                c = !1;
            (b.width != a.width || b.height != a.height) && (b.width = a.width, b.height = a.height, this._cacheContext.translate(0, a.height), c = !0), cc.view._setScaleXYForRenderTexture(), this._scale9Image.visit(this._cacheContext), cc.view._resetScale(), c && this._cacheSprite.setTextureRect(cc.rect(0, 0, a.width, a.height)), this._cacheSprite.getParent() || this.addChild(this._cacheSprite)
        }
    },
    ctor: function(a, b, c) {
        if (cc.Node.prototype.ctor.call(this), this._spriteRect = cc.rect(0, 0, 0, 0), this._capInsetsInternal = cc.rect(0, 0, 0, 0), this._originalSize = cc.size(0, 0), this._preferredSize = cc.size(0, 0), this._capInsets = cc.rect(0, 0, 0, 0), this._loadedEventListeners = [], cc._renderType === cc._RENDER_TYPE_CANVAS) {
            var d = this._cacheCanvas = cc.newElement("canvas");
            d.width = 1, d.height = 1, this._cacheContext = d.getContext("2d");
            var e = this._cacheTexture = new cc.Texture2D;
            e.initWithElement(d), e.handleLoadedTexture(), this._cacheSprite = new cc.Sprite(e), this._cacheSprite.setAnchorPoint(0, 0), this.addChild(this._cacheSprite)
        }
        void 0 != a ? a instanceof cc.SpriteFrame ? this.initWithSpriteFrame(a, b) : (d = cc.spriteFrameCache.getSpriteFrame(a), null != d ? this.initWithSpriteFrame(d, b) : this.initWithFile(a, b, c)) : this.init()
    },
    getOriginalSize: function() {
        return cc.size(this._originalSize)
    },
    getPreferredSize: function() {
        return cc.size(this._preferredSize)
    },
    _getPreferredWidth: function() {
        return this._preferredSize.width
    },
    _getPreferredHeight: function() {
        return this._preferredSize.height
    },
    setPreferredSize: function(a) {
        this.setContentSize(a), this._preferredSize = a
    },
    _setPreferredWidth: function(a) {
        this._setWidth(a), this._preferredSize.width = a
    },
    _setPreferredHeight: function(a) {
        this._setHeight(a), this._preferredSize.height = a
    },
    setOpacity: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.setOpacity.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                d && d.setOpacity(a)
            }
            this._scale9Dirty = !0
        }
    },
    updateDisplayedOpacity: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.updateDisplayedOpacity.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                d && d.updateDisplayedOpacity(a)
            }
            this._scale9Dirty = !0
        }
    },
    setColor: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.setColor.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                d && d.setColor(a)
            }
            this._scale9Dirty = !0
        }
    },
    updateDisplayedColor: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.updateDisplayedColor.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                d && (cc._renderType === cc._RENDER_TYPE_CANVAS ? (cc.Node.prototype.updateDisplayedColor.call(d, a), (255 !== a.r || 255 !== a.g || 255 !== a.b) && (d._changeTextureColor(), d._setNodeDirtyForCache())) : d.updateDisplayedColor(a))
            }
            this._scale9Dirty = !0
        }
    },
    getCapInsets: function() {
        return cc.rect(this._capInsets)
    },
    setCapInsets: function(a) {
        if (this._scale9Image) {
            var b = this._contentSize,
                c = b.width,
                b = b.height;
            this.updateWithBatchNode(this._scale9Image, this._spriteRect, this._spriteFrameRotated, a), this.setContentSize(c, b)
        }
    },
    getInsetLeft: function() {
        return this._insetLeft
    },
    setInsetLeft: function(a) {
        this._insetLeft = a, this._updateCapInset()
    },
    getInsetTop: function() {
        return this._insetTop
    },
    setInsetTop: function(a) {
        this._insetTop = a, this._updateCapInset()
    },
    getInsetRight: function() {
        return this._insetRight
    },
    setInsetRight: function(a) {
        this._insetRight = a, this._updateCapInset()
    },
    getInsetBottom: function() {
        return this._insetBottom
    },
    setInsetBottom: function(a) {
        this._insetBottom = a, this._updateCapInset()
    },
    setContentSize: function(a, b) {
        cc.Node.prototype.setContentSize.call(this, a, b), this._positionsAreDirty = !0
    },
    _setWidth: function(a) {
        cc.Node.prototype._setWidth.call(this, a), this._positionsAreDirty = !0
    },
    _setHeight: function(a) {
        cc.Node.prototype._setHeight.call(this, a), this._positionsAreDirty = !0
    },
    visit: function(a) {
        this._positionsAreDirty && (this._updatePositions(), this._positionsAreDirty = !1, this._scale9Dirty = !0), this._scale9Dirty && cc._renderType === cc._RENDER_TYPE_CANVAS && (this._scale9Dirty = !1, this._cacheScale9Sprite()), cc.Node.prototype.visit.call(this, a)
    },
    init: function() {
        return this.initWithBatchNode(null, cc.rect(0, 0, 0, 0), !1, cc.rect(0, 0, 0, 0))
    },
    initWithBatchNode: function(a, b, c, d) {
        return void 0 === d && (d = c, c = !1), a && this.updateWithBatchNode(a, b, c, d), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0), this.setAnchorPoint(.5, .5), this._positionsAreDirty = !0
    },
    initWithFile: function(a, b, c) {
        if (a instanceof cc.Rect ? (c = a = b, b = cc.rect(0, 0, 0, 0)) : (b = b || cc.rect(0, 0, 0, 0), c = c || cc.rect(0, 0, 0, 0)), !a) throw "ccui.Scale9Sprite.initWithFile(): file should be non-null";
        var d = cc.textureCache.getTextureForKey(a);
        d || (d = cc.textureCache.addImage(a));
        var e = d.isLoaded();
        return (this._textureLoaded = e) || d.addLoadedEventListener(function(a) {
            var b = this._preferredSize,
                b = cc.size(b.width, b.height);
            a = a.getContentSize(), this.updateWithBatchNode(this._scale9Image, cc.rect(0, 0, a.width, a.height), !1, this._capInsets), this.setPreferredSize(b), this._positionsAreDirty = !0, this._callLoadedEventCallbacks()
        }, this), this.initWithBatchNode(cc.SpriteBatchNode.create(a, 9), b, !1, c)
    },
    initWithSpriteFrame: function(a, b) {
        if (!a || !a.getTexture()) throw "ccui.Scale9Sprite.initWithSpriteFrame(): spriteFrame should be non-null and its texture should be non-null";
        b = b || cc.rect(0, 0, 0, 0);
        var c = a.textureLoaded();
        return (this._textureLoaded = c) || a.addLoadedEventListener(function(a) {
            var b = this._preferredSize,
                b = cc.size(b.width, b.height);
            this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets), this.setPreferredSize(b), this._positionsAreDirty = !0, this._callLoadedEventCallbacks()
        }, this), c = cc.SpriteBatchNode.create(a.getTexture(), 9), this.initWithBatchNode(c, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), b)
    },
    initWithSpriteFrameName: function(a, b) {
        if (!a) throw "ccui.Scale9Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null";
        b = b || cc.rect(0, 0, 0, 0);
        var c = cc.spriteFrameCache.getSpriteFrame(a);
        return null == c ? (cc.log("ccui.Scale9Sprite.initWithSpriteFrameName(): can't find the sprite frame by spriteFrameName"), !1) : this.initWithSpriteFrame(c, b)
    },
    resizableSpriteWithCapInsets: function(a) {
        var b = new ccui.Scale9Sprite;
        return b && b.initWithBatchNode(this._scale9Image, this._spriteRect, !1, a) ? b : null
    },
    setOpacityModifyRGB: function(a) {
        if (this._scale9Image) {
            this._opacityModifyRGB = a;
            var b = this._scale9Image.getChildren();
            if (b)
                for (var c = 0, d = b.length; d > c; c++) b[c].setOpacityModifyRGB(a)
        }
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    updateWithBatchNode: function(a, b, c, d) {
        var e = this.getOpacity(),
            f = this.getColor();
        if (b = cc.rect(b.x, b.y, b.width, b.height), this.removeAllChildren(!0), this._scale9Image != a && (this._scale9Image = a), !this._scale9Image) return !1;
        a = a.getTexture();
        var g = a.isLoaded();
        if (this._textureLoaded = g, !g) return a.addLoadedEventListener(function() {
            this._positionsAreDirty = !0, this._callLoadedEventCallbacks()
        }, this), !0;
        a = this._scale9Image, a.removeAllChildren(!0), g = this._capInsets, g.x = d.x, g.y = d.y, g.width = d.width, g.height = d.height, this._spriteFrameRotated = c, g = a.getTexture(), cc._rectEqualToZero(b) && (b = g.getContentSize(), b = cc.rect(0, 0, b.width, b.height));
        var h = this._spriteRect = b;
        h.x = b.x, h.y = b.y, h.width = b.width, h.height = b.height, this._originalSize.width = b.width, this._originalSize.height = b.height, h = this._preferredSize, 0 === h.width && 0 === h.height && (h.width = b.width, h.height = b.height), h = this._capInsetsInternal, d && (h.x = d.x, h.y = d.y, h.width = d.width, h.height = d.height);
        var i = b.width;
        d = b.height, cc._rectEqualToZero(h) && (h.x = i / 3, h.y = d / 3, h.width = i / 3, h.height = d / 3);
        var j = h.x,
            k = h.width,
            l = i - (j + k),
            m = h.y,
            n = h.height,
            o = d - (m + n),
            p = 0,
            q = 0;
        d = cc.rect(p + .5 | 0, q + .5 | 0, j + .5 | 0, m + .5 | 0);
        var p = p + j,
            h = cc.rect(p + .5 | 0, q + .5 | 0, k + .5 | 0, m + .5 | 0),
            i = cc.rect(p + k + .5 | 0, q + .5 | 0, l + .5 | 0, m + .5 | 0),
            p = 0,
            q = 0 + m,
            r = cc.rect(p + .5 | 0, q + .5 | 0, j + .5 | 0, n + .5 | 0),
            p = p + j,
            s = cc.rect(p + .5 | 0, q + .5 | 0, k + .5 | 0, n + .5 | 0),
            p = p + k,
            t = cc.rect(p + .5 | 0, q + .5 | 0, l + .5 | 0, n + .5 | 0),
            p = 0,
            q = 0 + m + n,
            m = cc.rect(p + .5 | 0, q + .5 | 0, j + .5 | 0, o + .5 | 0),
            p = p + j,
            j = cc.rect(p + .5 | 0, q + .5 | 0, k + .5 | 0, o + .5 | 0),
            p = p + k,
            k = cc.rect(p + .5 | 0, q + .5 | 0, l + .5 | 0, o + .5 | 0),
            l = cc.affineTransformMakeIdentity();
        if (c) {
            c = s;
            var o = k,
                p = m,
                q = i,
                n = d,
                u = t,
                v = r,
                w = j,
                x = h,
                l = cc.affineTransformTranslate(l, b.height + b.x, b.y),
                l = cc.affineTransformRotate(l, 1.57079633),
                s = cc.rectApplyAffineTransform(s, l),
                k = cc.rectApplyAffineTransform(k, l),
                m = cc.rectApplyAffineTransform(m, l),
                i = cc.rectApplyAffineTransform(i, l);
            d = cc.rectApplyAffineTransform(d, l), t = cc.rectApplyAffineTransform(t, l), r = cc.rectApplyAffineTransform(r, l), j = cc.rectApplyAffineTransform(j, l), h = cc.rectApplyAffineTransform(h, l), c.x = s.x, c.y = s.y, o.x = k.x, o.y = k.y, p.x = m.x, p.y = m.y, q.x = i.x, q.y = i.y, n.x = d.x, n.y = d.y, u.x = t.x, u.y = t.y, v.x = r.x, v.y = r.y, w.x = j.x, w.y = j.y, x.x = h.x, x.y = h.y, this._centre = new cc.Sprite, this._centre.initWithTexture(g, c, !0), a.addChild(this._centre, 0, ccui.Scale9Sprite.POSITIONS_CENTRE), this._top = new cc.Sprite, this._top.initWithTexture(g, x, !0), a.addChild(this._top, 1, ccui.Scale9Sprite.POSITIONS_TOP), this._bottom = new cc.Sprite, this._bottom.initWithTexture(g, w, !0), a.addChild(this._bottom, 1, ccui.Scale9Sprite.POSITIONS_BOTTOM), this._left = new cc.Sprite, this._left.initWithTexture(g, v, !0), a.addChild(this._left, 1, ccui.Scale9Sprite.POSITIONS_LEFT), this._right = new cc.Sprite, this._right.initWithTexture(g, u, !0), a.addChild(this._right, 1, ccui.Scale9Sprite.POSITIONS_RIGHT), this._topLeft = new cc.Sprite, this._topLeft.initWithTexture(g, n, !0), a.addChild(this._topLeft, 2, ccui.Scale9Sprite.POSITIONS_TOPLEFT), this._topRight = new cc.Sprite, this._topRight.initWithTexture(g, q, !0), a.addChild(this._topRight, 2, ccui.Scale9Sprite.POSITIONS_TOPRIGHT), this._bottomLeft = new cc.Sprite, this._bottomLeft.initWithTexture(g, p, !0), a.addChild(this._bottomLeft, 2, ccui.Scale9Sprite.POSITIONS_BOTTOMLEFT), this._bottomRight = new cc.Sprite, this._bottomRight.initWithTexture(g, o, !0)
        } else l = cc.affineTransformTranslate(l, b.x, b.y), cc._rectApplyAffineTransformIn(s, l), cc._rectApplyAffineTransformIn(k, l), cc._rectApplyAffineTransformIn(m, l), cc._rectApplyAffineTransformIn(i, l), cc._rectApplyAffineTransformIn(d, l), cc._rectApplyAffineTransformIn(t, l), cc._rectApplyAffineTransformIn(r, l), cc._rectApplyAffineTransformIn(j, l), cc._rectApplyAffineTransformIn(h, l), this._centre = new cc.Sprite, this._centre.initWithTexture(g, s), a.addChild(this._centre, 0, ccui.Scale9Sprite.POSITIONS_CENTRE), this._top = new cc.Sprite, this._top.initWithTexture(g, h), a.addChild(this._top, 1, ccui.Scale9Sprite.POSITIONS_TOP), this._bottom = new cc.Sprite, this._bottom.initWithTexture(g, j), a.addChild(this._bottom, 1, ccui.Scale9Sprite.POSITIONS_BOTTOM), this._left = new cc.Sprite, this._left.initWithTexture(g, r), a.addChild(this._left, 1, ccui.Scale9Sprite.POSITIONS_LEFT), this._right = new cc.Sprite, this._right.initWithTexture(g, t), a.addChild(this._right, 1, ccui.Scale9Sprite.POSITIONS_RIGHT), this._topLeft = new cc.Sprite, this._topLeft.initWithTexture(g, d), a.addChild(this._topLeft, 2, ccui.Scale9Sprite.POSITIONS_TOPLEFT), this._topRight = new cc.Sprite, this._topRight.initWithTexture(g, i), a.addChild(this._topRight, 2, ccui.Scale9Sprite.POSITIONS_TOPRIGHT), this._bottomLeft = new cc.Sprite, this._bottomLeft.initWithTexture(g, m), a.addChild(this._bottomLeft, 2, ccui.Scale9Sprite.POSITIONS_BOTTOMLEFT), this._bottomRight = new cc.Sprite, this._bottomRight.initWithTexture(g, k);
        return a.addChild(this._bottomRight, 2, ccui.Scale9Sprite.POSITIONS_BOTTOMRIGHT), this.setContentSize(b.width, b.height), cc._renderType === cc._RENDER_TYPE_WEBGL && this.addChild(a), this._spritesGenerated && (this.setOpacity(e), this.setColor(f)), this._spritesGenerated = !0
    },
    setSpriteFrame: function(a) {
        var b = cc.SpriteBatchNode.create(a.getTexture(), 9),
            c = a.textureLoaded();
        (this._textureLoaded = c) || a.addLoadedEventListener(function(a) {
                var b = this._preferredSize,
                    b = cc.size(b.width, b.height);
                this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets), this.setPreferredSize(b), this._positionsAreDirty = !0, this._callLoadedEventCallbacks()
            }, this), this.updateWithBatchNode(b, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), cc.rect(0, 0, 0, 0)), this._insetBottom = this._insetRight = this._insetTop = this._insetLeft = 0
    }
}), _p = ccui.Scale9Sprite.prototype, cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize), cc.defineGetterSetter(_p, "capInsets", _p.getCapInsets, _p.setCapInsets), cc.defineGetterSetter(_p, "insetLeft", _p.getInsetLeft, _p.setInsetLeft), cc.defineGetterSetter(_p, "insetTop", _p.getInsetTop, _p.setInsetTop), cc.defineGetterSetter(_p, "insetRight", _p.getInsetRight, _p.setInsetRight), cc.defineGetterSetter(_p, "insetBottom", _p.getInsetBottom, _p.setInsetBottom), _p = null, ccui.Scale9Sprite.create = function(a, b, c) {
    return new ccui.Scale9Sprite(a, b, c)
}, ccui.Scale9Sprite.createWithSpriteFrame = function(a, b) {
    return new ccui.Scale9Sprite(a, b)
}, ccui.Scale9Sprite.createWithSpriteFrameName = function(a, b) {
    return new ccui.Scale9Sprite(a, b)
}, ccui.Scale9Sprite.POSITIONS_CENTRE = 0, ccui.Scale9Sprite.POSITIONS_TOP = 1, ccui.Scale9Sprite.POSITIONS_LEFT = 2, ccui.Scale9Sprite.POSITIONS_RIGHT = 3, ccui.Scale9Sprite.POSITIONS_BOTTOM = 4, ccui.Scale9Sprite.POSITIONS_TOPRIGHT = 5, ccui.Scale9Sprite.POSITIONS_TOPLEFT = 6, ccui.Scale9Sprite.POSITIONS_BOTTOMRIGHT = 7, ccui.Layout = ccui.Widget.extend({
    _clippingEnabled: !1,
    _backGroundScale9Enabled: null,
    _backGroundImage: null,
    _backGroundImageFileName: null,
    _backGroundImageCapInsets: null,
    _colorType: null,
    _bgImageTexType: ccui.Widget.LOCAL_TEXTURE,
    _colorRender: null,
    _gradientRender: null,
    _color: null,
    _startColor: null,
    _endColor: null,
    _alongVector: null,
    _opacity: 255,
    _backGroundImageTextureSize: null,
    _layoutType: null,
    _doLayoutDirty: !0,
    _clippingRectDirty: !0,
    _clippingType: null,
    _clippingStencil: null,
    _handleScissor: !1,
    _scissorRectDirty: !1,
    _clippingRect: null,
    _clippingParent: null,
    _className: "Layout",
    _backGroundImageColor: null,
    _finalPositionX: 0,
    _finalPositionY: 0,
    _currentStencilEnabled: 0,
    _currentStencilWriteMask: 0,
    _currentStencilFunc: 0,
    _currentStencilRef: 0,
    _currentStencilValueMask: 0,
    _currentStencilFail: 0,
    _currentStencilPassDepthFail: 0,
    _currentStencilPassDepthPass: 0,
    _currentDepthWriteMask: 0,
    _currentAlphaTestEnabled: 0,
    _currentAlphaTestFunc: 0,
    _currentAlphaTestRef: 0,
    _backGroundImageOpacity: 0,
    _mask_layer_le: 0,
    _loopFocus: !1,
    __passFocusToChild: !1,
    _isFocusPassing: !1,
    ctor: function() {
        this._layoutType = ccui.Layout.ABSOLUTE, this._widgetType = ccui.Widget.TYPE_CONTAINER, this._clippingType = ccui.Layout.CLIPPING_STENCIL, this._colorType = ccui.Layout.BG_COLOR_NONE, ccui.Widget.prototype.ctor.call(this), this._backGroundImageCapInsets = cc.rect(0, 0, 0, 0), this._color = cc.color(255, 255, 255, 255), this._startColor = cc.color(255, 255, 255, 255), this._endColor = cc.color(255, 255, 255, 255), this._alongVector = cc.p(0, -1), this._backGroundImageTextureSize = cc.size(0, 0), this._clippingRect = cc.rect(0, 0, 0, 0), this._backGroundImageColor = cc.color(255, 255, 255, 255)
    },
    onEnter: function() {
        ccui.Widget.prototype.onEnter.call(this), this._clippingStencil && this._clippingStencil.onEnter(), this._clippingRectDirty = this._doLayoutDirty = !0
    },
    onExit: function() {
        ccui.Widget.prototype.onExit.call(this), this._clippingStencil && this._clippingStencil.onExit()
    },
    setLoopFocus: function(a) {
        this._loopFocus = a
    },
    isLoopFocus: function() {
        return this._loopFocus
    },
    setPassFocusToChild: function(a) {
        this.__passFocusToChild = a
    },
    isPassFocusToChild: function() {
        return this.__passFocusToChild
    },
    findNextFocusedWidget: function(a, b) {
        if (this._isFocusPassing || this.isFocused()) {
            var c = this.getParent();
            if (this._isFocusPassing = !1, this.__passFocusToChild) {
                var d = this._passFocusToChild(a, b);
                return d instanceof ccui.Layout && c ? (c._isFocusPassing = !0, c.findNextFocusedWidget(a, this)) : d
            }
            return null == c ? this : (c._isFocusPassing = !0, c.findNextFocusedWidget(a, this))
        }
        if (!(b.isFocused() || b instanceof ccui.Layout)) return b;
        if (this._layoutType == ccui.Layout.LINEAR_HORIZONTAL) switch (a) {
            case ccui.Widget.LEFT:
                return this._getPreviousFocusedWidget(a, b);
            case ccui.Widget.RIGHT:
                return this._getNextFocusedWidget(a, b);
            case ccui.Widget.DOWN:
            case ccui.Widget.UP:
                return this._isLastWidgetInContainer(this, a) ? this._isWidgetAncestorSupportLoopFocus(b, a) ? this.findNextFocusedWidget(a, this) : b : this.findNextFocusedWidget(a, this);
            default:
                return cc.assert(0, "Invalid Focus Direction"), b
        } else {
            if (this._layoutType != ccui.Layout.LINEAR_VERTICAL) return cc.assert(0, "Un Supported Layout type, please use VBox and HBox instead!!!"), b;
            switch (a) {
                case ccui.Widget.LEFT:
                case ccui.Widget.RIGHT:
                    return this._isLastWidgetInContainer(this, a) ? this._isWidgetAncestorSupportLoopFocus(b, a) ? this.findNextFocusedWidget(a, this) : b : this.findNextFocusedWidget(a, this);
                case ccui.Widget.DOWN:
                    return this._getNextFocusedWidget(a, b);
                case ccui.Widget.UP:
                    return this._getPreviousFocusedWidget(a, b);
                default:
                    return cc.assert(0, "Invalid Focus Direction"), b
            }
        }
    },
    onPassFocusToChild: null,
    init: function() {
        return ccui.Widget.prototype.init.call(this) ? (this.ignoreContentAdaptWithSize(!1), this.setContentSize(cc.size(0, 0)), this.setAnchorPoint(0, 0), this.onPassFocusToChild = this._findNearestChildWidgetIndex.bind(this), !0) : !1
    },
    __stencilDraw: function(a) {
        a = a || cc._renderContext;
        for (var b = this._clippingStencil, c = cc.view.getScaleX(), d = cc.view.getScaleY(), e = 0; e < b._buffer.length; e++) {
            var f = b._buffer[e].verts,
                g = f[0];
            a.beginPath(), a.moveTo(g.x * c, -g.y * d);
            for (var g = 1, h = f.length; h > g; g++) a.lineTo(f[g].x * c, -f[g].y * d)
        }
    },
    addChild: function(a, b, c) {
        a instanceof ccui.Widget && this._supplyTheLayoutParameterLackToChild(a), ccui.Widget.prototype.addChild.call(this, a, b, c), this._doLayoutDirty = !0
    },
    removeChild: function(a, b) {
        ccui.Widget.prototype.removeChild.call(this, a, b), this._doLayoutDirty = !0
    },
    removeAllChildren: function(a) {
        ccui.Widget.prototype.removeAllChildren.call(this, a), this._doLayoutDirty = !0
    },
    removeAllChildrenWithCleanup: function(a) {
        ccui.Widget.prototype.removeAllChildrenWithCleanup.call(this, a), this._doLayoutDirty = !0
    },
    isClippingEnabled: function() {
        return this._clippingEnabled
    },
    visit: function(a) {
        if (this._visible)
            if (this._adaptRenderers(), this._doLayout(), this._clippingEnabled) switch (this._clippingType) {
                case ccui.Layout.CLIPPING_STENCIL:
                    this._stencilClippingVisit(a);
                    break;
                case ccui.Layout.CLIPPING_SCISSOR:
                    this._scissorClippingVisit(a)
            } else ccui.Widget.prototype.visit.call(this, a)
    },
    _stencilClippingVisit: null,
    _stencilClippingVisitForWebGL: function(a) {
        var b = a || cc._renderContext;
        if (this._clippingStencil && this._clippingStencil.isVisible())
            if (ccui.Layout._layer + 1 == cc.stencilBits) ccui.Layout._visit_once = !0, ccui.Layout._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs."), ccui.Layout._visit_once = !1), cc.Node.prototype.visit.call(this, a);
            else {
                ccui.Layout._layer++;
                var c = 1 << ccui.Layout._layer,
                    d = c | c - 1;
                a = b.isEnabled(b.STENCIL_TEST);
                var e = b.getParameter(b.STENCIL_WRITEMASK),
                    f = b.getParameter(b.STENCIL_FUNC),
                    g = b.getParameter(b.STENCIL_REF),
                    h = b.getParameter(b.STENCIL_VALUE_MASK),
                    i = b.getParameter(b.STENCIL_FAIL),
                    j = b.getParameter(b.STENCIL_PASS_DEPTH_FAIL),
                    k = b.getParameter(b.STENCIL_PASS_DEPTH_PASS);
                b.enable(b.STENCIL_TEST), b.stencilMask(c);
                var l = b.getParameter(b.DEPTH_WRITEMASK);
                b.depthMask(!1), b.stencilFunc(b.NEVER, c, c), b.stencilOp(b.ZERO, b.KEEP, b.KEEP), cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLPushMatrix(), cc.kmGLLoadIdentity(), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPushMatrix(), cc.kmGLLoadIdentity(), cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255)), cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLPopMatrix(), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPopMatrix(), b.stencilFunc(b.NEVER, c, c), b.stencilOp(b.REPLACE, b.KEEP, b.KEEP), cc.kmGLPushMatrix(), this.transform(), this._clippingStencil.visit(), b.depthMask(l), b.stencilFunc(b.EQUAL, d, d), b.stencilOp(b.KEEP, b.KEEP, b.KEEP), d = c = 0, this.sortAllChildren(), this.sortAllProtectedChildren();
                for (var m, l = this._children, n = this._protectedChildren, o = l.length, p = n.length; o > c && ((m = l[c]) && 0 > m.getLocalZOrder()); c++) m.visit();
                for (; p > d && ((m = n[d]) && 0 > m.getLocalZOrder()); d++) m.visit();
                for (this.draw(); o > c; c++) l[c].visit();
                for (; p > d; d++) n[d].visit();
                b.stencilFunc(f, g, h), b.stencilOp(i, j, k), b.stencilMask(e), a || b.disable(b.STENCIL_TEST), ccui.Layout._layer--, cc.kmGLPopMatrix()
            }
    },
    _stencilClippingVisitForCanvas: function(a) {
        if (this._clippingStencil && this._clippingStencil.isVisible()) {
            if (a = a || cc._renderContext, this._clippingStencil instanceof cc.Sprite) {
                var b = a.canvas,
                    c = ccui.Layout._getSharedCache();
                c.width = b.width, c.height = b.height, c.getContext("2d").drawImage(b, 0, 0), a.save(), cc.ProtectedNode.prototype.visit.call(this, a), a.globalCompositeOperation = "destination-in", this.transform(a), this._clippingStencil.visit(), a.restore(), a.save(), a.setTransform(1, 0, 0, 1, 0, 0), a.globalCompositeOperation = "destination-over", a.drawImage(c, 0, 0)
            } else {
                var d, c = this._children;
                a.save(), this.transform(a), this._clippingStencil.visit(a), a.clip(), this.sortAllChildren(), this.sortAllProtectedChildren();
                for (var e, f = this._protectedChildren, g = c.length, h = f.length, b = 0; g > b && ((d = c[b]) && 0 > d._localZOrder); b++) d.visit(a);
                for (e = 0; h > e && ((d = f[e]) && 0 > d._localZOrder); e++) d.visit(a);
                for (; g > b; b++) c[b].visit(a);
                for (; h > e; e++) f[e].visit(a)
            }
            a.restore()
        }
    },
    _scissorClippingVisit: null,
    _scissorClippingVisitForWebGL: function(a) {
        var b = this._getClippingRect();
        a = a || cc._renderContext, this._handleScissor && a.enable(a.SCISSOR_TEST), cc.view.setScissorInPoints(b.x, b.y, b.width, b.height), cc.Node.prototype.visit.call(this), this._handleScissor && a.disable(a.SCISSOR_TEST)
    },
    setClippingEnabled: function(a) {
        if (a != this._clippingEnabled) switch (this._clippingEnabled = a, this._clippingType) {
            case ccui.Layout.CLIPPING_STENCIL:
                a ? (this._clippingStencil = cc.DrawNode.create(), cc._renderType === cc._RENDER_TYPE_CANVAS && (this._clippingStencil.draw = this.__stencilDraw.bind(this)), this._running && this._clippingStencil.onEnter(), this._setStencilClippingSize(this._contentSize)) : (this._running && this._clippingStencil && this._clippingStencil.onExit(), this._clippingStencil = null)
        }
    },
    setClippingType: function(a) {
        if (a != this._clippingType) {
            var b = this.isClippingEnabled();
            this.setClippingEnabled(!1), this._clippingType = a, this.setClippingEnabled(b)
        }
    },
    getClippingType: function() {
        return this._clippingType
    },
    _setStencilClippingSize: function(a) {
        if (this._clippingEnabled && this._clippingType == ccui.Layout.CLIPPING_STENCIL) {
            var b = [];
            b[0] = cc.p(0, 0), b[1] = cc.p(a.width, 0), b[2] = cc.p(a.width, a.height), b[3] = cc.p(0, a.height), a = cc.color.GREEN, this._clippingStencil.clear(), this._clippingStencil.drawPoly(b, 4, a, 0, a)
        }
    },
    _getClippingRect: function() {
        if (this._clippingRectDirty) {
            for (var a = this.convertToWorldSpace(cc.p(0, 0)), b = this.nodeToWorldTransform(), c = this._contentSize.width * b.a, d = this._contentSize.height * b.d, b = this; b;)
                if ((b = b.getParent()) && b instanceof ccui.Layout && b.isClippingEnabled()) {
                    this._clippingParent = b;
                    break
                }
            if (this._clippingParent) {
                var b = this._clippingParent._getClippingRect(),
                    e = a.x - c * this._anchorPoint.x,
                    f = a.y - d * this._anchorPoint.y,
                    g = c,
                    h = d,
                    i = a.x - b.x;
                0 > i && (e = b.x, g += i), c = a.x + c - (b.x + b.width), c > 0 && (g -= c), c = a.y + d - (b.y + b.height), c > 0 && (h -= c), a = a.y - b.y, 0 > a && (f = b.x, h += a), 0 > g && (g = 0), 0 > h && (h = 0), this._clippingRect.x = e, this._clippingRect.y = f, this._clippingRect.width = g, this._clippingRect.height = h
            } else this._clippingRect.x = a.x - c * this._anchorPoint.x, this._clippingRect.y = a.y - d * this._anchorPoint.y, this._clippingRect.width = c, this._clippingRect.height = d;
            this._clippingRectDirty = !1
        }
        return this._clippingRect
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        var a = this._contentSize;
        this._setStencilClippingSize(a), this._clippingRectDirty = this._doLayoutDirty = !0, this._backGroundImage && (this._backGroundImage.setPosition(.5 * a.width, .5 * a.height), this._backGroundScale9Enabled && this._backGroundImage instanceof ccui.Scale9Sprite && this._backGroundImage.setPreferredSize(a)), this._colorRender && this._colorRender.setContentSize(a), this._gradientRender && this._gradientRender.setContentSize(a)
    },
    setBackGroundImageScale9Enabled: function(a) {
        this._backGroundScale9Enabled != a && (this.removeProtectedChild(this._backGroundImage), this._backGroundImage = null, this._backGroundScale9Enabled = a, this._addBackGroundImage(), this.setBackGroundImage(this._backGroundImageFileName, this._bgImageTexType), this.setBackGroundImageCapInsets(this._backGroundImageCapInsets))
    },
    isBackGroundImageScale9Enabled: function() {
        return this._backGroundScale9Enabled
    },
    setBackGroundImage: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, null == this._backGroundImage && this._addBackGroundImage(), this._backGroundImageFileName = a, this._bgImageTexType = b;
            var c = this._backGroundImage;
            if (this._backGroundScale9Enabled) {
                switch (this._bgImageTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        c.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        c.initWithSpriteFrameName(a)
                }
                c.setPreferredSize(this._contentSize)
            } else switch (this._bgImageTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._backGroundImageTextureSize = c.getContentSize(), c.setPosition(.5 * this._contentSize.width, .5 * this._contentSize.height), this._updateBackGroundImageColor()
        }
    },
    setBackGroundImageCapInsets: function(a) {
        if (a) {
            var b = this._backGroundImageCapInsets;
            b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height, this._backGroundScale9Enabled && this._backGroundImage.setCapInsets(a)
        }
    },
    getBackGroundImageCapInsets: function() {
        return cc.rect(this._backGroundImageCapInsets)
    },
    _supplyTheLayoutParameterLackToChild: function(a) {
        if (a) switch (this._layoutType) {
            case ccui.Layout.LINEAR_HORIZONTAL:
            case ccui.Layout.LINEAR_VERTICAL:
                var b = a.getLayoutParameter(ccui.LayoutParameter.LINEAR);
                b || a.setLayoutParameter(ccui.LinearLayoutParameter.create());
                break;
            case ccui.Layout.RELATIVE:
                (b = a.getLayoutParameter(ccui.LayoutParameter.RELATIVE)) || a.setLayoutParameter(ccui.RelativeLayoutParameter.create())
        }
    },
    _addBackGroundImage: function() {
        this._backGroundScale9Enabled ? (this._backGroundImage = ccui.Scale9Sprite.create(), this._backGroundImage.setPreferredSize(this._contentSize)) : this._backGroundImage = cc.Sprite.create(), this.addProtectedChild(this._backGroundImage, ccui.Layout.BACKGROUND_IMAGE_ZORDER, -1), this._backGroundImage.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    removeBackGroundImage: function() {
        this._backGroundImage && (this.removeProtectedChild(this._backGroundImage), this._backGroundImage = null, this._backGroundImageFileName = "", this._backGroundImageTextureSize.width = 0, this._backGroundImageTextureSize.height = 0)
    },
    setBackGroundColorType: function(a) {
        if (this._colorType != a) {
            switch (this._colorType) {
                case ccui.Layout.BG_COLOR_NONE:
                    this._colorRender && (this.removeProtectedChild(this._colorRender), this._colorRender = null), this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null);
                    break;
                case ccui.Layout.BG_COLOR_SOLID:
                    this._colorRender && (this.removeProtectedChild(this._colorRender), this._colorRender = null);
                    break;
                case ccui.Layout.BG_COLOR_GRADIENT:
                    this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null)
            }
            switch (this._colorType = a, this._colorType) {
                case ccui.Layout.BG_COLOR_SOLID:
                    this._colorRender = new cc.LayerColor, this._colorRender.setContentSize(this._contentSize), this._colorRender.setOpacity(this._opacity), this._colorRender.setColor(this._color), this.addProtectedChild(this._colorRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1);
                    break;
                case ccui.Layout.BG_COLOR_GRADIENT:
                    this._gradientRender = new cc.LayerGradient(cc.color(255, 0, 0, 255), cc.color(0, 255, 0, 255)), this._gradientRender.setContentSize(this._contentSize), this._gradientRender.setOpacity(this._opacity), this._gradientRender.setStartColor(this._startColor), this._gradientRender.setEndColor(this._endColor), this._gradientRender.setVector(this._alongVector), this.addProtectedChild(this._gradientRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1)
            }
        }
    },
    getBackGroundColorType: function() {
        return this._colorType
    },
    setBackGroundColor: function(a, b) {
        b ? (this._startColor.r = a.r, this._startColor.g = a.g, this._startColor.b = a.b, this._gradientRender && this._gradientRender.setStartColor(a), this._endColor.r = b.r, this._endColor.g = b.g, this._endColor.b = b.b, this._gradientRender && this._gradientRender.setEndColor(b)) : (this._color.r = a.r, this._color.g = a.g, this._color.b = a.b, this._colorRender && this._colorRender.setColor(a))
    },
    getBackGroundColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundStartColor: function() {
        var a = this._startColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundEndColor: function() {
        var a = this._endColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setBackGroundColorOpacity: function(a) {
        switch (this._opacity = a, this._colorType) {
            case ccui.Layout.BG_COLOR_SOLID:
                this._colorRender.setOpacity(a);
                break;
            case ccui.Layout.BG_COLOR_GRADIENT:
                this._gradientRender.setOpacity(a)
        }
    },
    getBackGroundColorOpacity: function() {
        return this._opacity
    },
    setBackGroundColorVector: function(a) {
        this._alongVector.x = a.x, this._alongVector.y = a.y, this._gradientRender && this._gradientRender.setVector(a)
    },
    getBackGroundColorVector: function() {
        return this._alongVector
    },
    setBackGroundImageColor: function(a) {
        this._backGroundImageColor.r = a.r, this._backGroundImageColor.g = a.g, this._backGroundImageColor.b = a.b, this._updateBackGroundImageColor()
    },
    setBackGroundImageOpacity: function(a) {
        this._backGroundImageColor.a = a, this.getBackGroundImageColor()
    },
    getBackGroundImageColor: function() {
        var a = this._backGroundImageColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundImageOpacity: function() {
        return this._backGroundImageColor.a
    },
    _updateBackGroundImageColor: function() {
        this._backGroundImage && this._backGroundImage.setColor(this._backGroundImageColor)
    },
    getBackGroundImageTextureSize: function() {
        return this._backGroundImageTextureSize
    },
    setLayoutType: function(a) {
        this._layoutType = a, a = this._children;
        for (var b = null, c = 0; c < a.length; c++) b = a[c], b instanceof ccui.Widget && this._supplyTheLayoutParameterLackToChild(b);
        this._doLayoutDirty = !0
    },
    getLayoutType: function() {
        return this._layoutType
    },
    requestDoLayout: function() {
        this._doLayoutDirty = !0
    },
    _doLayout: function() {
        if (this._doLayoutDirty) {
            this.sortAllChildren();
            var a = ccui.getLayoutManager(this._layoutType);
            a && a._doLayout(this), this._doLayoutDirty = !1
        }
    },
    _getLayoutContentSize: function() {
        return this.getContentSize()
    },
    _getLayoutElements: function() {
        return this.getChildren()
    },
    _onBeforeVisitStencil: function() {},
    _drawFullScreenQuadClearStencil: function() {},
    _onAfterDrawStencil: function() {},
    _onAfterVisitStencil: function() {},
    _onAfterVisitScissor: function() {},
    _onAfterVisitScissor: function() {},
    _updateBackGroundImageOpacity: function() {
        this._backGroundImage && this._backGroundImage.setOpacity(this._backGroundImageOpacity)
    },
    _updateBackGroundImageRGBA: function() {
        this._backGroundImage && (this._backGroundImage.setColor(this._backGroundImageColor), this._backGroundImage.setOpacity(this._backGroundImageOpacity))
    },
    _getLayoutAccumulatedSize: function() {
        for (var a, b = this.getChildren(), c = cc.size(0, 0), d = 0, e = 0, f = b.length; f > e; e++)
            if (a = b[e], null != a && a instanceof ccui.Layout) a = a._getLayoutAccumulatedSize(), c.width += a.width, c.height += a.height;
            else if (a instanceof ccui.Widget) {
            d++;
            var g = a.getLayoutParameter().getMargin();
            a = a.getContentSize(), c.width += a.width + .5 * (g.right + g.left), c.height += a.height + .5 * (g.top + g.bottom)
        }
        return b = this.getLayoutType(), b == ccui.Layout.LINEAR_HORIZONTAL && (c.height -= c.height / d * (d - 1)), b == ccui.Layout.LINEAR_VERTICAL && (c.width -= c.width / d * (d - 1)), c
    },
    _findNearestChildWidgetIndex: function(a, b) {
        if (null == b || b == this) return this._findFirstFocusEnabledWidgetIndex();
        var c, d = 0,
            e = this.getChildren(),
            f = e.length,
            g = cc.FLT_MAX,
            h = 0;
        if (a == ccui.Widget.LEFT || a == ccui.Widget.RIGHT || a == ccui.Widget.DOWN || a == ccui.Widget.UP) {
            for (c = this._getWorldCenterPoint(b); f > d;) {
                var i = e[d];
                i && i instanceof ccui.Widget && i.isFocusEnabled() && (i = i instanceof ccui.Layout ? i._calculateNearestDistance(b) : cc.pLength(cc.pSub(this._getWorldCenterPoint(i), c)), g > i && (h = d, g = i)), d++
            }
            return h
        }
        return cc.log("invalid focus direction!"), 0
    },
    _findFarthestChildWidgetIndex: function(a, b) {
        if (null == b || b == this) return this._findFirstFocusEnabledWidgetIndex();
        var c = 0,
            d = this.getChildren(),
            e = d.length,
            f = -cc.FLT_MAX,
            g = 0;
        if (a == ccui.Widget.LEFT || a == ccui.Widget.RIGHT || a == ccui.Widget.DOWN || a == ccui.Widget.UP) {
            for (var h = this._getWorldCenterPoint(b); e > c;) {
                var i = d[c];
                i && i instanceof ccui.Widget && i.isFocusEnabled() && (i = i instanceof ccui.Layout ? i._calculateFarthestDistance(b) : cc.pLength(cc.pSub(this._getWorldCenterPoint(i), h)), i > f && (g = c, f = i)), c++
            }
            return g
        }
        return cc.log("invalid focus direction!!!"), 0
    },
    _calculateNearestDistance: function(a) {
        for (var b = cc.FLT_MAX, c = this._getWorldCenterPoint(a), d = this._children, e = 0, f = d.length; f > e; e++) {
            var g = d[e];
            if (g instanceof ccui.Layout) g = g._calculateNearestDistance(a);
            else {
                if (!(g instanceof ccui.Widget && g.isFocusEnabled())) continue;
                g = cc.pLength(cc.pSub(this._getWorldCenterPoint(g), c))
            }
            b > g && (b = g)
        }
        return b
    },
    _calculateFarthestDistance: function(a) {
        for (var b = -cc.FLT_MAX, c = this._getWorldCenterPoint(a), d = this._children, e = 0, f = d.length; f > e; e++) {
            var g = d[e];
            if (g instanceof ccui.Layout) g = g._calculateFarthestDistance(a);
            else {
                if (!(g instanceof ccui.Widget && g.isFocusEnabled())) continue;
                g = this._getWorldCenterPoint(g), g = cc.pLength(cc.pSub(g, c))
            }
            g > b && (b = g)
        }
        return b
    },
    _findProperSearchingFunctor: function(a, b) {
        if (null != b) {
            var c = this._getWorldCenterPoint(b),
                d = this._getWorldCenterPoint(this._findFirstNonLayoutWidget());
            a == ccui.Widget.LEFT ? this.onPassFocusToChild = c.x > d.x ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : a == ccui.Widget.RIGHT ? this.onPassFocusToChild = c.x > d.x ? this._findFarthestChildWidgetIndex.bind(this) : this._findNearestChildWidgetIndex.bind(this) : a == ccui.Widget.DOWN ? this.onPassFocusToChild = c.y > d.y ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : a == ccui.Widget.UP ? this.onPassFocusToChild = c.y < d.y ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : cc.log("invalid direction!")
        }
    },
    _findFirstNonLayoutWidget: function() {
        for (var a = this._children, b = 0, c = a.length; c > b; b++) {
            var d = a[b];
            if (d instanceof ccui.Layout) {
                if (d = d._findFirstNonLayoutWidget()) return d
            } else if (d instanceof cc.Widget) return d
        }
        return null
    },
    _findFirstFocusEnabledWidgetIndex: function() {
        for (var a = 0, b = this.getChildren(), c = b.length; c > a;) {
            var d = b[a];
            if (d && d instanceof ccui.Widget && d.isFocusEnabled()) return a;
            a++
        }
        return 0
    },
    _findFocusEnabledChildWidgetByIndex: function(a) {
        var b = this._getChildWidgetByIndex(a);
        return b ? b.isFocusEnabled() ? b : this._findFocusEnabledChildWidgetByIndex(a + 1) : null
    },
    _getWorldCenterPoint: function(a) {
        var b = a instanceof ccui.Layout ? a._getLayoutAccumulatedSize() : a.getContentSize();
        return a.convertToWorldSpace(cc.p(b.width / 2, b.height / 2))
    },
    _getNextFocusedWidget: function(a, b) {
        var c = null,
            c = this._children,
            d = c.indexOf(b),
            d = d + 1;
        return d < c.length ? (c = this._getChildWidgetByIndex(d)) ? c.isFocusEnabled() ? c instanceof ccui.Layout ? (c._isFocusPassing = !0, c.findNextFocusedWidget(a, c)) : (this.dispatchFocusEvent(b, c), c) : this._getNextFocusedWidget(a, c) : b : this._loopFocus ? this._checkFocusEnabledChild() ? (c = this._getChildWidgetByIndex(0), c.isFocusEnabled() ? c instanceof ccui.Layout ? (c._isFocusPassing = !0, c.findNextFocusedWidget(a, c)) : (this.dispatchFocusEvent(b, c), c) : this._getNextFocusedWidget(a, c)) : b instanceof ccui.Layout ? b : this._focusedWidget : this._isLastWidgetInContainer(b, a) ? this._isWidgetAncestorSupportLoopFocus(this, a) ? this.findNextFocusedWidget(a, this) : b instanceof ccui.Layout ? b : this._focusedWidget : this.findNextFocusedWidget(a, this)
    },
    _getPreviousFocusedWidget: function(a, b) {
        var c = null,
            c = this._children,
            d = c.indexOf(b),
            d = d - 1;
        return d >= 0 ? (c = this._getChildWidgetByIndex(d), c.isFocusEnabled() ? c instanceof ccui.Layout ? (c._isFocusPassing = !0, c.findNextFocusedWidget(a, c)) : (this.dispatchFocusEvent(b, c), c) : this._getPreviousFocusedWidget(a, c)) : this._loopFocus ? this._checkFocusEnabledChild() ? (d = c.length - 1, c = this._getChildWidgetByIndex(d), c.isFocusEnabled() ? c instanceof ccui.Layout ? (c._isFocusPassing = !0, c.findNextFocusedWidget(a, c)) : (this.dispatchFocusEvent(b, c), c) : this._getPreviousFocusedWidget(a, c)) : b instanceof ccui.Layout ? b : this._focusedWidget : this._isLastWidgetInContainer(b, a) ? this._isWidgetAncestorSupportLoopFocus(this, a) ? this.findNextFocusedWidget(a, this) : b instanceof ccui.Layout ? b : this._focusedWidget : this.findNextFocusedWidget(a, this)
    },
    _getChildWidgetByIndex: function(a) {
        for (var b = this._children, c = b.length, d = 0, e = a; c > a;) {
            var f = b[a];
            if (f && f instanceof ccui.Widget) return f;
            d++, a++
        }
        for (a = 0; e > a;) {
            if ((c = b[a]) && c instanceof ccui.Widget) return c;
            d++, a++
        }
        return null
    },
    _isLastWidgetInContainer: function(a, b) {
        var c = a.getParent();
        if (c instanceof ccui.Layout) return !0;
        var d = c.getChildren(),
            e = d.indexOf(a);
        if (c.getLayoutType() == ccui.Layout.LINEAR_HORIZONTAL) {
            if (b == ccui.Widget.LEFT) return 0 == e ? this._isLastWidgetInContainer(c, b) : !1;
            if (b == ccui.Widget.RIGHT) return e == d.length - 1 ? this._isLastWidgetInContainer(c, b) : !1;
            if (b == ccui.Widget.DOWN || b == ccui.Widget.UP) return this._isLastWidgetInContainer(c, b)
        } else {
            if (c.getLayoutType() != ccui.Layout.LINEAR_VERTICAL) return cc.log("invalid layout Type"), !1;
            if (b == ccui.Widget.UP) return 0 == e ? this._isLastWidgetInContainer(c, b) : !1;
            if (b == ccui.Widget.DOWN) return e == d.length - 1 ? this._isLastWidgetInContainer(c, b) : !1;
            if (b == ccui.Widget.LEFT || b == ccui.Widget.RIGHT) return this._isLastWidgetInContainer(c, b)
        }
    },
    _isWidgetAncestorSupportLoopFocus: function(a, b) {
        var c = a.getParent();
        if (null == c) return !1;
        if (!c.isLoopFocus()) return this._isWidgetAncestorSupportLoopFocus(c, b);
        var d = c.getLayoutType();
        return d == ccui.Layout.LINEAR_HORIZONTAL ? b == ccui.Widget.LEFT || b == ccui.Widget.RIGHT ? !0 : this._isWidgetAncestorSupportLoopFocus(c, b) : d == ccui.Layout.LINEAR_VERTICAL ? b == ccui.Widget.DOWN || b == ccui.Widget.UP ? !0 : this._isWidgetAncestorSupportLoopFocus(c, b) : void cc.assert(0, "invalid layout type")
    },
    _passFocusToChild: function(a, b) {
        if (this._checkFocusEnabledChild()) {
            var c = ccui.Widget.getCurrentFocusedWidget();
            return this._findProperSearchingFunctor(a, c), c = this.onPassFocusToChild(a, c), c = this._getChildWidgetByIndex(c), c instanceof ccui.Layout ? (c._isFocusPassing = !0, c.findNextFocusedWidget(a, c)) : (this.dispatchFocusEvent(b, c), c)
        }
        return this
    },
    _checkFocusEnabledChild: function() {
        for (var a = this._children, b = 0, c = a.length; c > b; b++) {
            var d = a[b];
            if (d && d instanceof ccui.Widget && d.isFocusEnabled()) return !0
        }
        return !1
    },
    getDescription: function() {
        return "Layout"
    },
    _createCloneInstance: function() {
        return ccui.Layout.create()
    },
    _copyClonedWidgetChildren: function(a) {
        ccui.Widget.prototype._copyClonedWidgetChildren.call(this, a)
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.Layout && (this.setBackGroundImageScale9Enabled(a._backGroundScale9Enabled), this.setBackGroundImage(a._backGroundImageFileName, a._bgImageTexType), this.setBackGroundImageCapInsets(a._backGroundImageCapInsets), this.setBackGroundColorType(a._colorType), this.setBackGroundColor(a._color), this.setBackGroundColor(a._startColor, a._endColor), this.setBackGroundColorOpacity(a._opacity), this.setBackGroundColorVector(a._alongVector), this.setLayoutType(a._layoutType), this.setClippingEnabled(a._clippingEnabled), this.setClippingType(a._clippingType), this._loopFocus = a._loopFocus, this.__passFocusToChild = a.__passFocusToChild)
    }
}), ccui.Layout._init_once = null, ccui.Layout._visit_once = null, ccui.Layout._layer = -1, ccui.Layout._sharedCache = null, cc._renderType == cc._RENDER_TYPE_WEBGL ? (ccui.Layout.prototype._stencilClippingVisit = ccui.Layout.prototype._stencilClippingVisitForWebGL, ccui.Layout.prototype._scissorClippingVisit = ccui.Layout.prototype._scissorClippingVisitForWebGL) : (ccui.Layout.prototype._stencilClippingVisit = ccui.Layout.prototype._stencilClippingVisitForCanvas, ccui.Layout.prototype._scissorClippingVisit = ccui.Layout.prototype._stencilClippingVisitForCanvas), ccui.Layout._getSharedCache = function() {
    return cc.ClippingNode._sharedCache || (cc.ClippingNode._sharedCache = cc.newElement("canvas"))
}, _p = ccui.Layout.prototype, cc.defineGetterSetter(_p, "clippingEnabled", _p.isClippingEnabled, _p.setClippingEnabled), cc.defineGetterSetter(_p, "clippingType", null, _p.setClippingType), cc.defineGetterSetter(_p, "layoutType", _p.getLayoutType, _p.setLayoutType), _p = null, ccui.Layout.create = function() {
    return new ccui.Layout
}, ccui.Layout.BG_COLOR_NONE = 0, ccui.Layout.BG_COLOR_SOLID = 1, ccui.Layout.BG_COLOR_GRADIENT = 2, ccui.Layout.ABSOLUTE = 0, ccui.Layout.LINEAR_VERTICAL = 1, ccui.Layout.LINEAR_HORIZONTAL = 2, ccui.Layout.RELATIVE = 3, ccui.Layout.CLIPPING_STENCIL = 0, ccui.Layout.CLIPPING_SCISSOR = 1, ccui.Layout.BACKGROUND_IMAGE_ZORDER = -2, ccui.Layout.BACKGROUND_RENDERER_ZORDER = -2, ccui.Margin = ccui.Class.extend({
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    ctor: function(a, b, c, d) {
        a && void 0 === b && (this.left = a.left, this.top = a.top, this.right = a.right, this.bottom = a.bottom), void 0 !== d && (this.left = a, this.top = b, this.right = c, this.bottom = d)
    },
    setMargin: function(a, b, c, d) {
        this.left = a, this.top = b, this.right = c, this.bottom = d
    },
    equals: function(a) {
        return this.left == a.left && this.top == a.top && this.right == a.right && this.bottom == a.bottom
    }
}), ccui.MarginZero = function() {
    return new ccui.Margin(0, 0, 0, 0)
}, ccui.LayoutParameter = ccui.Class.extend({
    _margin: null,
    _layoutParameterType: null,
    ctor: function() {
        this._margin = new ccui.Margin, this._layoutParameterType = ccui.LayoutParameter.NONE
    },
    setMargin: function(a, b, c, d) {
        "object" == typeof a ? (this._margin.left = a.left, this._margin.top = a.top, this._margin.right = a.right, this._margin.bottom = a.bottom) : (this._margin.left = a, this._margin.top = b, this._margin.right = c, this._margin.bottom = d)
    },
    getMargin: function() {
        return this._margin
    },
    getLayoutType: function() {
        return this._layoutParameterType
    },
    clone: function() {
        var a = this._createCloneInstance();
        return a._copyProperties(this), a
    },
    _createCloneInstance: function() {
        return new ccui.LayoutParameter
    },
    _copyProperties: function(a) {
        this._margin.bottom = a._margin.bottom, this._margin.left = a._margin.left, this._margin.right = a._margin.right, this._margin.top = a._margin.top
    }
}), ccui.LayoutParameter.create = function() {
    return new ccui.LayoutParameter
}, ccui.LayoutParameter.NONE = 0, ccui.LayoutParameter.LINEAR = 1, ccui.LayoutParameter.RELATIVE = 2, ccui.LinearLayoutParameter = ccui.LayoutParameter.extend({
    _linearGravity: null,
    ctor: function() {
        ccui.LayoutParameter.prototype.ctor.call(this), this._linearGravity = ccui.LinearLayoutParameter.NONE, this._layoutParameterType = ccui.LayoutParameter.LINEAR
    },
    setGravity: function(a) {
        this._linearGravity = a
    },
    getGravity: function() {
        return this._linearGravity
    },
    _createCloneInstance: function() {
        return ccui.LinearLayoutParameter.create()
    },
    _copyProperties: function(a) {
        ccui.LayoutParameter.prototype._copyProperties.call(this, a), a instanceof ccui.LinearLayoutParameter && this.setGravity(a._linearGravity)
    }
}), ccui.LinearLayoutParameter.create = function() {
    return new ccui.LinearLayoutParameter
}, ccui.LinearLayoutParameter.NONE = 0, ccui.LinearLayoutParameter.LEFT = 1, ccui.LinearLayoutParameter.TOP = 2, ccui.LinearLayoutParameter.RIGHT = 3, ccui.LinearLayoutParameter.BOTTOM = 4, ccui.LinearLayoutParameter.CENTER_VERTICAL = 5, ccui.LinearLayoutParameter.CENTER_HORIZONTAL = 6, ccui.RelativeLayoutParameter = ccui.LayoutParameter.extend({
    _relativeAlign: null,
    _relativeWidgetName: "",
    _relativeLayoutName: "",
    _put: !1,
    ctor: function() {
        ccui.LayoutParameter.prototype.ctor.call(this), this._relativeAlign = ccui.RelativeLayoutParameter.NONE, this._relativeLayoutName = this._relativeWidgetName = "", this._put = !1, this._layoutParameterType = ccui.LayoutParameter.RELATIVE
    },
    setAlign: function(a) {
        this._relativeAlign = a
    },
    getAlign: function() {
        return this._relativeAlign
    },
    setRelativeToWidgetName: function(a) {
        this._relativeWidgetName = a
    },
    getRelativeToWidgetName: function() {
        return this._relativeWidgetName
    },
    setRelativeName: function(a) {
        this._relativeLayoutName = a
    },
    getRelativeName: function() {
        return this._relativeLayoutName
    },
    _createCloneInstance: function() {
        return ccui.RelativeLayoutParameter.create()
    },
    _copyProperties: function(a) {
        ccui.LayoutParameter.prototype._copyProperties.call(this, a), a instanceof ccui.RelativeLayoutParameter && (this.setAlign(a._relativeAlign), this.setRelativeToWidgetName(a._relativeWidgetName), this.setRelativeName(a._relativeLayoutName))
    }
}), ccui.RelativeLayoutParameter.create = function() {
    return new ccui.RelativeLayoutParameter
}, ccui.RelativeLayoutParameter.NONE = 0, ccui.RelativeLayoutParameter.PARENT_TOP_LEFT = 1, ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL = 2, ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT = 3, ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL = 4, ccui.RelativeLayoutParameter.CENTER_IN_PARENT = 5, ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL = 6, ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM = 7, ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL = 8, ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM = 9, ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN = 10, ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER = 11, ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN = 12, ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN = 13, ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER = 14, ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN = 15, ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN = 16, ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER = 17, ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN = 18, ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN = 19, ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER = 20, ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN = 21, ccui.LINEAR_GRAVITY_NONE = 0, ccui.LINEAR_GRAVITY_LEFT = 1, ccui.LINEAR_GRAVITY_TOP = 2, ccui.LINEAR_GRAVITY_RIGHT = 3, ccui.LINEAR_GRAVITY_BOTTOM = 4, ccui.LINEAR_GRAVITY_CENTER_VERTICAL = 5, ccui.LINEAR_GRAVITY_CENTER_HORIZONTAL = 6, ccui.RELATIVE_ALIGN_NONE = 0, ccui.RELATIVE_ALIGN_PARENT_TOP_LEFT = 1, ccui.RELATIVE_ALIGN_PARENT_TOP_CENTER_HORIZONTAL = 2, ccui.RELATIVE_ALIGN_PARENT_TOP_RIGHT = 3, ccui.RELATIVE_ALIGN_PARENT_LEFT_CENTER_VERTICAL = 4, ccui.RELATIVE_ALIGN_PARENT_CENTER = 5, ccui.RELATIVE_ALIGN_PARENT_RIGHT_CENTER_VERTICAL = 6, ccui.RELATIVE_ALIGN_PARENT_LEFT_BOTTOM = 7, ccui.RELATIVE_ALIGN_PARENT_BOTTOM_CENTER_HORIZONTAL = 8, ccui.RELATIVE_ALIGN_PARENT_RIGHT_BOTTOM = 9, ccui.RELATIVE_ALIGN_LOCATION_ABOVE_LEFT = 10, ccui.RELATIVE_ALIGN_LOCATION_ABOVE_CENTER = 11, ccui.RELATIVE_ALIGN_LOCATION_ABOVE_RIGHT = 12, ccui.RELATIVE_ALIGN_LOCATION_LEFT_TOP = 13, ccui.RELATIVE_ALIGN_LOCATION_LEFT_CENTER = 14, ccui.RELATIVE_ALIGN_LOCATION_LEFT_BOTTOM = 15, ccui.RELATIVE_ALIGN_LOCATION_RIGHT_TOP = 16, ccui.RELATIVE_ALIGN_LOCATION_RIGHT_CENTER = 17, ccui.RELATIVE_ALIGN_LOCATION_RIGHT_BOTTOM = 18, ccui.RELATIVE_ALIGN_LOCATION_BELOW_TOP = 19, ccui.RELATIVE_ALIGN_LOCATION_BELOW_CENTER = 20, ccui.RELATIVE_ALIGN_LOCATION_BELOW_BOTTOM = 21, ccui.getLayoutManager = function(a) {
    switch (a) {
        case ccui.Layout.LINEAR_VERTICAL:
            return ccui.linearVerticalLayoutManager;
        case ccui.Layout.LINEAR_HORIZONTAL:
            return ccui.linearHorizontalLayoutManager;
        case ccui.Layout.RELATIVE:
            return ccui.relativeLayoutManager
    }
    return null
}, ccui.linearVerticalLayoutManager = {
    _doLayout: function(a) {
        var b = a._getLayoutContentSize();
        a = a._getLayoutElements();
        for (var c = b.height, d = 0, e = a.length; e > d; d++) {
            var f = a[d];
            if (f) {
                var g = f.getLayoutParameter();
                if (g) {
                    var h = g.getGravity(),
                        i = f.getAnchorPoint(),
                        j = f.getContentSize(),
                        k = i.x * j.width,
                        c = c - (1 - i.y) * j.height;
                    switch (h) {
                        case ccui.LinearLayoutParameter.RIGHT:
                            k = b.width - (1 - i.x) * j.width;
                            break;
                        case ccui.LinearLayoutParameter.CENTER_HORIZONTAL:
                            k = b.width / 2 - j.width * (.5 - i.x)
                    }
                    g = g.getMargin(), k += g.left, c -= g.top, f.setPosition(k, c), c = f.getPositionY() - f.getAnchorPoint().y * f.getContentSize().height - g.bottom
                }
            }
        }
    }
}, ccui.linearHorizontalLayoutManager = {
    _doLayout: function(a) {
        var b = a._getLayoutContentSize();
        a = a._getLayoutElements();
        for (var c = 0, d = 0, e = a.length; e > d; d++) {
            var f = a[d];
            if (f) {
                var g = f.getLayoutParameter();
                if (g) {
                    var h = g.getGravity(),
                        i = f.getAnchorPoint(),
                        j = f.getSize(),
                        c = c + i.x * j.width,
                        k = b.height - (1 - i.y) * j.height;
                    switch (h) {
                        case ccui.LinearLayoutParameter.BOTTOM:
                            k = i.y * j.height;
                            break;
                        case ccui.LinearLayoutParameter.CENTER_VERTICAL:
                            k = b.height / 2 - j.height * (.5 - i.y)
                    }
                    g = g.getMargin(), c += g.left, k -= g.top, f.setPosition(c, k), c = f.getRightBoundary() + g.right
                }
            }
        }
    }
}, ccui.relativeLayoutManager = {
    _unlayoutChildCount: 0,
    _widgetChildren: [],
    _widget: null,
    _finalPositionX: 0,
    _finalPositionY: 0,
    _relativeWidgetLP: null,
    _doLayout: function(a) {
        for (var b = this._widgetChildren = this._getAllWidgets(a); 0 < this._unlayoutChildCount;) {
            for (var c = 0, d = b.length; d > c; c++) {
                this._widget = b[c];
                var e = this._widget.getLayoutParameter();
                e && !e._put && this._calculateFinalPositionWithRelativeWidget(a) && (this._calculateFinalPositionWithRelativeAlign(), this._widget.setPosition(this._finalPositionX, this._finalPositionY), e._put = !0)
            }
            this._unlayoutChildCount--
        }
        this._widgetChildren.length = 0
    },
    _getAllWidgets: function(a) {
        a = a._getLayoutElements();
        for (var b = this._widgetChildren, c = b.length = 0, d = a.length; d > c; c++) {
            var e = a[c];
            e && (e.getLayoutParameter()._put = !1, this._unlayoutChildCount++, b.push(e))
        }
        return b
    },
    _getRelativeWidget: function(a) {
        var b = null;
        if ((a = a.getLayoutParameter().getRelativeToWidgetName()) && 0 != a.length)
            for (var c = this._widgetChildren, d = 0, e = c.length; e > d; d++) {
                var f = c[d];
                if (f) {
                    var g = f.getLayoutParameter();
                    if (g && g.getRelativeName() == a) {
                        b = f, this._relativeWidgetLP = g;
                        break
                    }
                }
            }
        return b
    },
    _calculateFinalPositionWithRelativeWidget: function(a) {
        var b = this._widget,
            c = b.getAnchorPoint(),
            d = b.getContentSize();
        this._finalPositionY = this._finalPositionX = 0;
        var e = this._getRelativeWidget(b),
            b = b.getLayoutParameter().getAlign();
        switch (a = a._getLayoutContentSize(), b) {
            case ccui.RelativeLayoutParameter.NONE:
            case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
                this._finalPositionX = c.x * d.width, this._finalPositionY = a.height - (1 - c.y) * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
                this._finalPositionX = .5 * a.width - d.width * (.5 - c.x), this._finalPositionY = a.height - (1 - c.y) * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
                this._finalPositionX = a.width - (1 - c.x) * d.width, this._finalPositionY = a.height - (1 - c.y) * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
                this._finalPositionX = c.x * d.width, this._finalPositionY = .5 * a.height - d.height * (.5 - c.y);
                break;
            case ccui.RelativeLayoutParameter.CENTER_IN_PARENT:
                this._finalPositionX = .5 * a.width - d.width * (.5 - c.x), this._finalPositionY = .5 * a.height - d.height * (.5 - c.y);
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
                this._finalPositionX = a.width - (1 - c.x) * d.width, this._finalPositionY = .5 * a.height - d.height * (.5 - c.y);
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
                this._finalPositionX = c.x * d.width, this._finalPositionY = c.y * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
                this._finalPositionX = .5 * a.width - d.width * (.5 - c.x), this._finalPositionY = c.y * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
                this._finalPositionX = a.width - (1 - c.x) * d.width, this._finalPositionY = c.y * d.height;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getTopBoundary() + c.y * d.height, this._finalPositionX = e.getLeftBoundary() + c.x * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = e.getContentSize(), this._finalPositionY = e.getTopBoundary() + c.y * d.height, this._finalPositionX = e.getLeftBoundary() + .5 * a.width + c.x * d.width - .5 * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getTopBoundary() + c.y * d.height, this._finalPositionX = e.getRightBoundary() - (1 - c.x) * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getTopBoundary() - (1 - c.y) * d.height, this._finalPositionX = e.getLeftBoundary() - (1 - c.x) * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = e.getContentSize(), this._finalPositionX = e.getLeftBoundary() - (1 - c.x) * d.width, this._finalPositionY = e.getBottomBoundary() + .5 * a.height + c.y * d.height - .5 * d.height
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getBottomBoundary() + c.y * d.height, this._finalPositionX = e.getLeftBoundary() - (1 - c.x) * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getTopBoundary() - (1 - c.y) * d.height, this._finalPositionX = e.getRightBoundary() + c.x * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = e.getContentSize(), this._finalPositionX = e.getRightBoundary() + c.x * d.width, this._finalPositionY = e.getBottomBoundary() + .5 * a.height + c.y * d.height - .5 * d.height
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getBottomBoundary() + c.y * d.height, this._finalPositionX = e.getRightBoundary() + c.x * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getBottomBoundary() - (1 - c.y) * d.height, this._finalPositionX = e.getLeftBoundary() + c.x * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = e.getContentSize(), this._finalPositionY = e.getBottomBoundary() - (1 - c.y) * d.height, this._finalPositionX = e.getLeftBoundary() + .5 * a.width + c.x * d.width - .5 * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getBottomBoundary() - (1 - c.y) * d.height, this._finalPositionX = e.getRightBoundary() - (1 - c.x) * d.width
                }
        }
        return !0
    },
    _calculateFinalPositionWithRelativeAlign: function() {
        var a = this._widget.getLayoutParameter(),
            b = a.getMargin();
        switch (a.getAlign()) {
            case ccui.RelativeLayoutParameter.NONE:
            case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
                this._finalPositionX += b.left, this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
                this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
                this._finalPositionX -= b.right, this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
                this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
                this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
                this._finalPositionX += b.left, this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
                this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
                this._finalPositionX -= b.right, this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
                this._finalPositionY += b.bottom, this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
                this._finalPositionY += b.bottom, this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
                this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
                this._finalPositionX -= b.right, this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
                this._finalPositionX -= b.right, this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
                this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
                this._finalPositionX += b.left, this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
                this._finalPositionX += b.left, this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
                this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
                this._finalPositionY -= b.top, this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
                this._finalPositionY -= b.top, this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
                this._finalPositionY -= b.top
        }
    }
}, ccui.HBox = ccui.Layout.extend({
    ctor: function(a) {
        a ? this.initWithSize(a) : this.init()
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL), !0) : !1
    },
    initWithSize: function(a) {
        return this.init() ? (this.setContentSize(a), !0) : !1
    }
}), ccui.HBox.create = function(a) {
    return new ccui.HBox(a)
}, ccui.RelativeBox = ccui.Layout.extend({
    ctor: function(a) {
        a ? this.initWithSize(a) : this.init()
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.RELATIVE), !0) : !1
    },
    initWithSize: function(a) {
        return this.init() ? (this.setContentSize(a), !0) : !1
    }
}), ccui.RelativeBox.create = function(a) {
    return new ccui.RelativeBox(a)
}, ccui.VBox = ccui.Layout.extend({
    ctor: function(a) {
        a ? this.initWithSize(a) : this.init()
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_VERTICAL), !0) : !1
    },
    initWithSize: function(a) {
        return this.init() ? (this.setContentSize(a), !0) : !1
    }
}), ccui.VBox.create = function(a) {
    return new ccui.VBox(a)
}, ccui.helper = {
    seekWidgetByTag: function(a, b) {
        if (!a) return null;
        if (a.getTag() == b) return a;
        for (var c = a.getChildren(), d = c.length, e = 0; d > e; e++) {
            var f = ccui.helper.seekWidgetByTag(c[e], b);
            if (null != f) return f
        }
        return null
    },
    seekWidgetByName: function(a, b) {
        if (!a) return null;
        if (a.getName() == b) return a;
        for (var c = a.getChildren(), d = c.length, e = 0; d > e; e++) {
            var f = ccui.helper.seekWidgetByName(c[e], b);
            if (null != f) return f
        }
        return null
    },
    seekWidgetByRelativeName: function(a, b) {
        if (!a) return null;
        for (var c = a.getChildren(), d = c.length, e = 0; d > e; e++) {
            var f = c[e],
                g = f.getLayoutParameter(ccui.LayoutParameter.RELATIVE);
            if (g && g.getRelativeName() == b) return f
        }
        return null
    },
    seekActionWidgetByActionTag: function(a, b) {
        if (!a) return null;
        if (a.getActionTag() == b) return a;
        for (var c = a.getChildren(), d = 0; d < c.length; d++) {
            var e = ccui.helper.seekActionWidgetByActionTag(c[d], b);
            if (null != e) return e
        }
        return null
    }
}, ccui.Button = ccui.Widget.extend({
    _buttonNormalRenderer: null,
    _buttonClickedRenderer: null,
    _buttonDisableRenderer: null,
    _titleRenderer: null,
    _normalFileName: "",
    _clickedFileName: "",
    _disabledFileName: "",
    _prevIgnoreSize: !0,
    _scale9Enabled: !1,
    _capInsetsNormal: null,

    _capInsetsPressed: null,
    _capInsetsDisabled: null,
    _normalTexType: ccui.Widget.LOCAL_TEXTURE,
    _pressedTexType: ccui.Widget.LOCAL_TEXTURE,
    _disabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _normalTextureSize: null,
    _pressedTextureSize: null,
    _disabledTextureSize: null,
    pressedActionEnabled: !1,
    _titleColor: null,
    _normalTextureScaleXInSize: 1,
    _normalTextureScaleYInSize: 1,
    _pressedTextureScaleXInSize: 1,
    _pressedTextureScaleYInSize: 1,
    _normalTextureLoaded: !1,
    _pressedTextureLoaded: !1,
    _disabledTextureLoaded: !1,
    _className: "Button",
    _normalTextureAdaptDirty: !0,
    _pressedTextureAdaptDirty: !0,
    _disabledTextureAdaptDirty: !0,
    _fontName: "Thonburi",
    _fontSize: 12,
    _type: 0,
    ctor: function(a, b, c, d) {
        this._capInsetsNormal = cc.rect(0, 0, 0, 0), this._capInsetsPressed = cc.rect(0, 0, 0, 0), this._capInsetsDisabled = cc.rect(0, 0, 0, 0), this._normalTextureSize = cc.size(0, 0), this._pressedTextureSize = cc.size(0, 0), this._disabledTextureSize = cc.size(0, 0), this._titleColor = cc.color.WHITE, ccui.Widget.prototype.ctor.call(this), this.setTouchEnabled(!0), d && this.init(a, b, c, d)
    },
    init: function(a, b, c, d) {
        if (ccui.Widget.prototype.init.call(this)) {
            if (void 0 === a) return !0;
            this.loadTextures(a, b, c, d)
        }
        return !1
    },
    _initRenderer: function() {
        this._buttonNormalRenderer = cc.Sprite.create(), this._buttonClickedRenderer = cc.Sprite.create(), this._buttonDisableRenderer = cc.Sprite.create(), this._titleRenderer = new cc.LabelTTF(""), this._titleRenderer.setAnchorPoint(.5, .5), this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonDisableRenderer, ccui.Button.DISABLED_RENDERER_ZORDER, -1), this.addProtectedChild(this._titleRenderer, ccui.Button.TITLE_RENDERER_ZORDER, -1)
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled != a && (this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this._scale9Enabled = a, this.removeProtectedChild(this._buttonNormalRenderer), this.removeProtectedChild(this._buttonClickedRenderer), this.removeProtectedChild(this._buttonDisableRenderer), this._scale9Enabled ? (this._buttonNormalRenderer = new ccui.Scale9Sprite, this._buttonClickedRenderer = new ccui.Scale9Sprite, this._buttonDisableRenderer = new ccui.Scale9Sprite) : (this._buttonNormalRenderer = cc.Sprite.create(), this._buttonClickedRenderer = cc.Sprite.create(), this._buttonDisableRenderer = cc.Sprite.create()), this.loadTextureNormal(this._normalFileName, this._normalTexType), this.loadTexturePressed(this._clickedFileName, this._pressedTexType), this.loadTextureDisabled(this._disabledFileName, this._disabledTexType), this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonDisableRenderer, ccui.Button.DISABLED_RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsetsNormalRenderer(this._capInsetsNormal), this.setCapInsetsPressedRenderer(this._capInsetsPressed), this.setCapInsetsDisabledRenderer(this._capInsetsDisabled), this.setBright(this._bright))
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function(a) {
        (!this._scale9Enabled || this._scale9Enabled && !a) && (ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a)
    },
    getVirtualRendererSize: function() {
        return cc.size(this._normalTextureSize)
    },
    loadTextures: function(a, b, c, d) {
        this.loadTextureNormal(a, d), this.loadTexturePressed(b, d), this.loadTextureDisabled(c, d)
    },
    loadTextureNormal: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._normalFileName = a, this._normalTexType = b;
            var c = this;
            if ((!this._buttonNormalRenderer.texture || !this._buttonNormalRenderer.texture.isLoaded()) && this._buttonNormalRenderer.addLoadedEventListener(function() {
                c._findLayout(), c._normalTextureSize = c._buttonNormalRenderer.getContentSize(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._buttonNormalRenderer.setColor(c.getColor()), c._buttonNormalRenderer.setOpacity(c.getOpacity()), c._updateContentSizeWithTextureSize(c._normalTextureSize), c._normalTextureLoaded = !0, c._normalTextureAdaptDirty = !0
            }), this._scale9Enabled) {
                var d = this._buttonNormalRenderer;
                switch (this._normalTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        d.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        d.initWithSpriteFrameName(a)
                }
                d.setCapInsets(this._capInsetsNormal)
            } else switch (d = this._buttonNormalRenderer, this._normalTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._normalTextureSize = this._buttonNormalRenderer.getContentSize(), this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._updateContentSizeWithTextureSize(this._normalTextureSize), this._normalTextureAdaptDirty = this._normalTextureLoaded = !0
        }
    },
    loadTexturePressed: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._clickedFileName = a, this._pressedTexType = b;
            var c = this;
            if ((!this._buttonClickedRenderer.texture || !this._buttonClickedRenderer.texture.isLoaded()) && this._buttonClickedRenderer.addLoadedEventListener(function() {
                c._findLayout(), c._pressedTextureSize = c._buttonClickedRenderer.getContentSize(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._pressedTextureLoaded = !0, c._pressedTextureAdaptDirty = !0
            }), this._scale9Enabled) {
                var d = this._buttonClickedRenderer;
                switch (this._pressedTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        d.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        d.initWithSpriteFrameName(a)
                }
                d.setCapInsets(this._capInsetsPressed)
            } else switch (d = this._buttonClickedRenderer, this._pressedTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._pressedTextureSize = this._buttonClickedRenderer.getContentSize(), this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._pressedTextureAdaptDirty = this._pressedTextureLoaded = !0
        }
    },
    loadTextureDisabled: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._disabledFileName = a, this._disabledTexType = b;
            var c = this;
            if ((!this._buttonDisableRenderer.texture || !this._buttonDisableRenderer.texture.isLoaded()) && this._buttonDisableRenderer.addLoadedEventListener(function() {
                c._findLayout(), c._disabledTextureSize = c._buttonDisableRenderer.getContentSize(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._disabledTextureLoaded = !0, c._disabledTextureAdaptDirty = !0
            }), this._scale9Enabled) {
                var d = this._buttonDisableRenderer;
                switch (this._disabledTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        d.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        d.initWithSpriteFrameName(a)
                }
                d.setCapInsets(this._capInsetsDisabled)
            } else switch (d = this._buttonDisableRenderer, this._disabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._disabledTextureSize = this._buttonDisableRenderer.getContentSize(), this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._disabledTextureAdaptDirty = this._disabledTextureLoaded = !0
        }
    },
    setCapInsets: function(a) {
        this.setCapInsetsNormalRenderer(a), this.setCapInsetsPressedRenderer(a), this.setCapInsetsDisabledRenderer(a)
    },
    setCapInsetsNormalRenderer: function(a) {
        if (a) {
            var b = this._capInsetsNormal;
            b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height, this._scale9Enabled && this._buttonNormalRenderer.setCapInsets(a)
        }
    },
    getCapInsetsNormalRenderer: function() {
        return cc.rect(this._capInsetsNormal)
    },
    setCapInsetsPressedRenderer: function(a) {
        if (a) {
            var b = this._capInsetsPressed;
            b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height, this._scale9Enabled && this._buttonClickedRenderer.setCapInsets(a)
        }
    },
    getCapInsetsPressedRenderer: function() {
        return cc.rect(this._capInsetsPressed)
    },
    setCapInsetsDisabledRenderer: function(a) {
        if (a) {
            var b = this._capInsetsDisabled;
            b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height, this._scale9Enabled && this._buttonDisableRenderer.setCapInsets(a)
        }
    },
    getCapInsetsDisabledRenderer: function() {
        return cc.rect(this._capInsetsDisabled)
    },
    _onPressStateChangedToNormal: function() {
        if (this._buttonNormalRenderer.setVisible(!0), this._buttonClickedRenderer.setVisible(!1), this._buttonDisableRenderer.setVisible(!1), this._pressedTextureLoaded) {
            if (this.pressedActionEnabled) {
                this._buttonNormalRenderer.stopAllActions(), this._buttonClickedRenderer.stopAllActions();
                var a = cc.scaleTo(.05, this._normalTextureScaleXInSize, this._normalTextureScaleYInSize);
                this._buttonNormalRenderer.runAction(a), this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize)
            }
        } else this._scale9Enabled ? this._updateTexturesRGBA() : (this._buttonNormalRenderer.stopAllActions(), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize))
    },
    _onPressStateChangedToPressed: function() {
        var a = this._buttonNormalRenderer;
        if (this._pressedTextureLoaded) {
            if (a.setVisible(!1), this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1), this.pressedActionEnabled) {
                a.stopAllActions(), this._buttonClickedRenderer.stopAllActions();
                var b = cc.scaleTo(.05, this._pressedTextureScaleXInSize + .1, this._pressedTextureScaleYInSize + .1);
                this._buttonClickedRenderer.runAction(b), a.setScale(this._pressedTextureScaleXInSize + .1, this._pressedTextureScaleYInSize + .1)
            }
        } else a.setVisible(!0), this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1), this._scale9Enabled ? a.setColor(cc.color.GRAY) : (a.stopAllActions(), a.setScale(this._normalTextureScaleXInSize + .1, this._normalTextureScaleYInSize + .1))
    },
    _onPressStateChangedToDisabled: function() {
        this._buttonNormalRenderer.setVisible(!1), this._buttonClickedRenderer.setVisible(!1), this._buttonDisableRenderer.setVisible(!0), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize), this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize)
    },
    _updateFlippedX: function() {
        var a = this._flippedX ? -1 : 1;
        this._titleRenderer.setScaleX(a), this._scale9Enabled ? (this._buttonNormalRenderer.setScaleX(a), this._buttonClickedRenderer.setScaleX(a), this._buttonDisableRenderer.setScaleX(a)) : (this._buttonNormalRenderer.setFlippedX(this._flippedX), this._buttonClickedRenderer.setFlippedX(this._flippedX), this._buttonDisableRenderer.setFlippedX(this._flippedX))
    },
    _updateFlippedY: function() {
        var a = this._flippedY ? -1 : 1;
        this._titleRenderer.setScaleY(a), this._scale9Enabled ? (this._buttonNormalRenderer.setScaleY(a), this._buttonClickedRenderer.setScaleY(a), this._buttonDisableRenderer.setScaleY(a)) : (this._buttonNormalRenderer.setFlippedY(this._flippedY), this._buttonClickedRenderer.setFlippedY(this._flippedY), this._buttonDisableRenderer.setFlippedY(this._flippedY))
    },
    _updateTexturesRGBA: function() {
        this._buttonNormalRenderer.setColor(this.getColor()), this._buttonClickedRenderer.setColor(this.getColor()), this._buttonDisableRenderer.setColor(this.getColor()), this._buttonNormalRenderer.setOpacity(this.getOpacity()), this._buttonClickedRenderer.setOpacity(this.getOpacity()), this._buttonDisableRenderer.setOpacity(this.getOpacity())
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._updateTitleLocation(), this._disabledTextureAdaptDirty = this._pressedTextureAdaptDirty = this._normalTextureAdaptDirty = !0
    },
    getVirtualRenderer: function() {
        if (!this._bright) return this._buttonDisableRenderer;
        switch (this._brightStyle) {
            case ccui.Widget.BRIGHT_STYLE_NORMAL:
                return this._buttonNormalRenderer;
            case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
                return this._buttonClickedRenderer;
            default:
                return null
        }
    },
    _normalTextureScaleChangedWithSize: function() {
        if (this._ignoreSize) this._scale9Enabled || (this._buttonNormalRenderer.setScale(1), this._normalTextureScaleXInSize = this._normalTextureScaleYInSize = 1);
        else if (this._scale9Enabled) this._buttonNormalRenderer.setPreferredSize(this._contentSize), this._normalTextureScaleXInSize = this._normalTextureScaleYInSize = 1;
        else {
            var a = this._normalTextureSize;
            if (0 >= a.width || 0 >= a.height) return void this._buttonNormalRenderer.setScale(1);
            var b = this._contentSize.width / a.width,
                a = this._contentSize.height / a.height;
            this._buttonNormalRenderer.setScaleX(b), this._buttonNormalRenderer.setScaleY(a), this._normalTextureScaleXInSize = b, this._normalTextureScaleYInSize = a
        }
        this._buttonNormalRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    _pressedTextureScaleChangedWithSize: function() {
        if (this._ignoreSize) this._scale9Enabled || (this._buttonClickedRenderer.setScale(1), this._pressedTextureScaleXInSize = this._pressedTextureScaleYInSize = 1);
        else if (this._scale9Enabled) this._buttonClickedRenderer.setPreferredSize(this._contentSize), this._pressedTextureScaleXInSize = this._pressedTextureScaleYInSize = 1;
        else {
            var a = this._pressedTextureSize;
            if (0 >= a.width || 0 >= a.height) return void this._buttonClickedRenderer.setScale(1);
            var b = this._contentSize.width / a.width,
                a = this._contentSize.height / a.height;
            this._buttonClickedRenderer.setScaleX(b), this._buttonClickedRenderer.setScaleY(a), this._pressedTextureScaleXInSize = b, this._pressedTextureScaleYInSize = a
        }
        this._buttonClickedRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    _disabledTextureScaleChangedWithSize: function() {
        if (this._ignoreSize) this._scale9Enabled || this._buttonDisableRenderer.setScale(1);
        else if (this._scale9Enabled) this._buttonDisableRenderer.setPreferredSize(this._contentSize);
        else {
            var a = this._disabledTextureSize;
            if (0 >= a.width || 0 >= a.height) return void this._buttonDisableRenderer.setScale(1);
            var b = this._contentSize.height / a.height;
            this._buttonDisableRenderer.setScaleX(this._contentSize.width / a.width), this._buttonDisableRenderer.setScaleY(b)
        }
        this._buttonDisableRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    _adaptRenderers: function() {
        this._normalTextureAdaptDirty && (this._normalTextureScaleChangedWithSize(), this._normalTextureAdaptDirty = !1), this._pressedTextureAdaptDirty && (this._pressedTextureScaleChangedWithSize(), this._pressedTextureAdaptDirty = !1), this._disabledTextureAdaptDirty && (this._disabledTextureScaleChangedWithSize(), this._disabledTextureAdaptDirty = !1)
    },
    _updateTitleLocation: function() {
        this._titleRenderer.setPosition(.5 * this._contentSize.width, .5 * this._contentSize.height)
    },
    setPressedActionEnabled: function(a) {
        this.pressedActionEnabled = a
    },
    setTitleText: function(a) {
        this._titleRenderer.setString(a)
    },
    getTitleText: function() {
        return this._titleRenderer.getString()
    },
    setTitleColor: function(a) {
        this._titleColor.r = a.r, this._titleColor.g = a.g, this._titleColor.b = a.b, this._titleRenderer.updateDisplayedColor(a)
    },
    getTitleColor: function() {
        return this._titleRenderer.getColor()
    },
    setTitleFontSize: function(a) {
        this._titleRenderer.setFontSize(a)
    },
    getTitleFontSize: function() {
        return this._titleRenderer.getFontSize()
    },
    setTitleFontName: function(a) {
        this._titleRenderer.setFontName(a), this._fontName = a
    },
    getTitleFontName: function() {
        return this._titleRenderer.getFontName()
    },
    _setTitleFont: function(a) {
        this._titleRenderer.font = a
    },
    _getTitleFont: function() {
        return this._titleRenderer.font
    },
    getDescription: function() {
        return "Button"
    },
    _createCloneInstance: function() {
        return ccui.Button.create()
    },
    _copySpecialProperties: function(a) {
        this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTextureNormal(a._normalFileName, a._normalTexType), this.loadTexturePressed(a._clickedFileName, a._pressedTexType), this.loadTextureDisabled(a._disabledFileName, a._disabledTexType), this.setCapInsetsNormalRenderer(a._capInsetsNormal), this.setCapInsetsPressedRenderer(a._capInsetsPressed), this.setCapInsetsDisabledRenderer(a._capInsetsDisabled), this.setTitleText(a.getTitleText()), this.setTitleFontName(a.getTitleFontName()), this.setTitleFontSize(a.getTitleFontSize()), this.setTitleColor(a.getTitleColor()), this.setPressedActionEnabled(a.pressedActionEnabled)
    }
}), _p = ccui.Button.prototype, cc.defineGetterSetter(_p, "titleText", _p.getTitleText, _p.setTitleText), cc.defineGetterSetter(_p, "titleFont", _p._getTitleFont, _p._setTitleFont), cc.defineGetterSetter(_p, "titleFontSize", _p.getTitleFontSize, _p.setTitleFontSize), cc.defineGetterSetter(_p, "titleFontName", _p.getTitleFontName, _p.setTitleFontName), cc.defineGetterSetter(_p, "titleColor", _p.getTitleColor, _p.setTitleColor), _p = null, ccui.Button.create = function(a, b, c, d) {
    return new ccui.Button(a, b, c, d)
}, ccui.Button.NORMAL_RENDERER_ZORDER = -2, ccui.Button.PRESSED_RENDERER_ZORDER = -2, ccui.Button.DISABLED_RENDERER_ZORDER = -2, ccui.Button.TITLE_RENDERER_ZORDER = -1, ccui.Button.SYSTEM = 0, ccui.Button.TTF = 1, ccui.CheckBox = ccui.Widget.extend({
    _backGroundBoxRenderer: null,
    _backGroundSelectedBoxRenderer: null,
    _frontCrossRenderer: null,
    _backGroundBoxDisabledRenderer: null,
    _frontCrossDisabledRenderer: null,
    _isSelected: !0,
    _checkBoxEventListener: null,
    _checkBoxEventSelector: null,
    _checkBoxEventCallback: null,
    _backGroundTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundSelectedTexType: ccui.Widget.LOCAL_TEXTURE,
    _frontCrossTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _frontCrossDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundFileName: "",
    _backGroundSelectedFileName: "",
    _frontCrossFileName: "",
    _backGroundDisabledFileName: "",
    _frontCrossDisabledFileName: "",
    _className: "CheckBox",
    _backGroundBoxRendererAdaptDirty: !0,
    _backGroundSelectedBoxRendererAdaptDirty: !0,
    _frontCrossRendererAdaptDirty: !0,
    _backGroundBoxDisabledRendererAdaptDirty: !0,
    _frontCrossDisabledRendererAdaptDirty: !0,
    ctor: function(a, b, c, d, e, f) {
        ccui.Widget.prototype.ctor.call(this), this.setTouchEnabled(!0), f && this.init(a, b, c, d, e, f)
    },
    init: function(a, b, c, d, e, f) {
        return ccui.Widget.prototype.init.call(this) ? (this._isSelected = !0, this.setSelectedState(!1), void 0 === a && this.loadTextures(a, b, c, d, e, f), !0) : !1
    },
    _initRenderer: function() {
        this._backGroundBoxRenderer = cc.Sprite.create(), this._backGroundSelectedBoxRenderer = cc.Sprite.create(), this._frontCrossRenderer = cc.Sprite.create(), this._backGroundBoxDisabledRenderer = cc.Sprite.create(), this._frontCrossDisabledRenderer = cc.Sprite.create(), this.addProtectedChild(this._backGroundBoxRenderer, ccui.CheckBox.BOX_RENDERER_ZORDER, -1), this.addProtectedChild(this._backGroundSelectedBoxRenderer, ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER, -1), this.addProtectedChild(this._frontCrossRenderer, ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER, -1), this.addProtectedChild(this._backGroundBoxDisabledRenderer, ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER, -1), this.addProtectedChild(this._frontCrossDisabledRenderer, ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER, -1)
    },
    loadTextures: function(a, b, c, d, e, f) {
        this.loadTextureBackGround(a, f), this.loadTextureBackGroundSelected(b, f), this.loadTextureFrontCross(c, f), this.loadTextureBackGroundDisabled(d, f), this.loadTextureFrontCrossDisabled(e, f)
    },
    loadTextureBackGround: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._backGroundFileName = a, this._backGroundTexType = b;
            var c = this._backGroundBoxRenderer,
                d = this;
            switch ((!c.texture || !c.texture.isLoaded()) && c.addLoadedEventListener(function() {
                d._findLayout(), d._updateFlippedX(), d._updateFlippedY(), d._updateChildrenDisplayedRGBA(), d._updateContentSizeWithTextureSize(d._backGroundBoxRenderer.getContentSize()), d._backGroundBoxRendererAdaptDirty = !0
            }), this._backGroundTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            c.textureLoaded() || (this._backGroundBoxRenderer.setContentSize(this._customSize), c.addLoadedEventListener(function() {
                this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize())
            }, this)), this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize()), this._backGroundBoxRendererAdaptDirty = !0
        }
    },
    loadTextureBackGroundSelected: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._backGroundSelectedFileName = a, this._backGroundSelectedTexType = b;
            var c = this;
            switch ((!this._backGroundSelectedBoxRenderer.texture || !this._backGroundSelectedBoxRenderer.texture.isLoaded()) && this._backGroundSelectedBoxRenderer.addLoadedEventListener(function() {
                c._findLayout(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._backGroundSelectedBoxRendererAdaptDirty = !0
            }), this._backGroundSelectedTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._backGroundSelectedBoxRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._backGroundSelectedBoxRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._backGroundSelectedBoxRendererAdaptDirty = !0
        }
    },
    loadTextureFrontCross: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._frontCrossFileName = a, this._frontCrossTexType = b;
            var c = this;
            switch ((!this._frontCrossRenderer.texture || !this._frontCrossRenderer.texture.isLoaded()) && this._frontCrossRenderer.addLoadedEventListener(function() {
                c._findLayout(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._frontCrossRendererAdaptDirty = !0
            }), this._frontCrossTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._frontCrossRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._frontCrossRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._frontCrossRendererAdaptDirty = !0
        }
    },
    loadTextureBackGroundDisabled: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._backGroundDisabledFileName = a, this._backGroundDisabledTexType = b;
            var c = this;
            switch ((!this._backGroundBoxDisabledRenderer.texture || !this._backGroundBoxDisabledRenderer.texture.isLoaded()) && this._backGroundBoxDisabledRenderer.addLoadedEventListener(function() {
                c._findLayout(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._backGroundBoxDisabledRendererAdaptDirty = !0
            }), this._backGroundDisabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._backGroundBoxDisabledRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._backGroundBoxDisabledRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._backGroundBoxDisabledRendererAdaptDirty = !0
        }
    },
    loadTextureFrontCrossDisabled: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._frontCrossDisabledFileName = a, this._frontCrossDisabledTexType = b;
            var c = this;
            switch ((!this._frontCrossDisabledRenderer.texture || !this._frontCrossDisabledRenderer.texture.isLoaded()) && this._frontCrossDisabledRenderer.addLoadedEventListener(function() {
                c._findLayout(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._frontCrossDisabledRendererAdaptDirty = !0
            }), this._frontCrossDisabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._frontCrossDisabledRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._frontCrossDisabledRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._frontCrossDisabledRendererAdaptDirty = !0
        }
    },
    _onPressStateChangedToNormal: function() {
        this._backGroundBoxRenderer.setVisible(!0), this._backGroundSelectedBoxRenderer.setVisible(!1), this._backGroundBoxDisabledRenderer.setVisible(!1), this._frontCrossDisabledRenderer.setVisible(!1)
    },
    _onPressStateChangedToPressed: function() {
        this._backGroundBoxRenderer.setVisible(!1), this._backGroundSelectedBoxRenderer.setVisible(!0), this._backGroundBoxDisabledRenderer.setVisible(!1), this._frontCrossDisabledRenderer.setVisible(!1)
    },
    _onPressStateChangedToDisabled: function() {
        this._backGroundBoxRenderer.setVisible(!1), this._backGroundSelectedBoxRenderer.setVisible(!1), this._backGroundBoxDisabledRenderer.setVisible(!0), this._frontCrossRenderer.setVisible(!1), this._isSelected && this._frontCrossDisabledRenderer.setVisible(!0)
    },
    setSelectedState: function(a) {
        a != this._isSelected && (this._isSelected = a, this._frontCrossRenderer.setVisible(this._isSelected))
    },
    getSelectedState: function() {
        return this._isSelected
    },
    _selectedEvent: function() {
        this._checkBoxEventCallback && this._checkBoxEventCallback(this, ccui.CheckBox.EVENT_SELECTED), this._checkBoxEventListener && this._checkBoxEventSelector && this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_SELECTED)
    },
    _unSelectedEvent: function() {
        this._checkBoxEventCallback && this._checkBoxEventCallback(this, ccui.CheckBox.EVENT_UNSELECTED), this._checkBoxEventListener && this._checkBoxEventSelector && this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_UNSELECTED)
    },
    _releaseUpEvent: function() {
        ccui.Widget.prototype._releaseUpEvent.call(this), this._isSelected ? (this.setSelectedState(!1), this._unSelectedEvent()) : (this.setSelectedState(!0), this._selectedEvent())
    },
    addEventListenerCheckBox: function(a, b) {
        this._checkBoxEventSelector = a, this._checkBoxEventListener = b
    },
    addEventListener: function(a) {
        this._checkBoxEventCallback = a
    },
    getVirtualRendererSize: function() {
        return this._backGroundBoxRenderer.getContentSize()
    },
    _updateFlippedX: function() {
        this._backGroundBoxRenderer.setFlippedX(this._flippedX), this._backGroundSelectedBoxRenderer.setFlippedX(this._flippedX), this._frontCrossRenderer.setFlippedX(this._flippedX), this._backGroundBoxDisabledRenderer.setFlippedX(this._flippedX), this._frontCrossDisabledRenderer.setFlippedX(this._flippedX)
    },
    _updateFlippedY: function() {
        this._backGroundBoxRenderer.setFlippedY(this._flippedY), this._backGroundSelectedBoxRenderer.setFlippedY(this._flippedY), this._frontCrossRenderer.setFlippedY(this._flippedY), this._backGroundBoxDisabledRenderer.setFlippedY(this._flippedY), this._frontCrossDisabledRenderer.setFlippedY(this._flippedY)
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._frontCrossDisabledRendererAdaptDirty = this._backGroundBoxDisabledRendererAdaptDirty = this._frontCrossRendererAdaptDirty = this._backGroundSelectedBoxRendererAdaptDirty = this._backGroundBoxRendererAdaptDirty = !0
    },
    getVirtualRenderer: function() {
        return this._backGroundBoxRenderer
    },
    _backGroundTextureScaleChangedWithSize: function() {
        var a = this._backGroundBoxRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) return void a.setScale(1);
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width), a.setScaleY(d)
        }
        a.setPosition(.5 * b.width, .5 * b.height)
    },
    _backGroundSelectedTextureScaleChangedWithSize: function() {
        var a = this._backGroundSelectedBoxRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) return void a.setScale(1);
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width), a.setScaleY(d)
        }
        a.setPosition(.5 * b.width, .5 * b.height)
    },
    _frontCrossTextureScaleChangedWithSize: function() {
        var a = this._frontCrossRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) return void a.setScale(1);
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width), a.setScaleY(d)
        }
        a.setPosition(.5 * b.width, .5 * b.height)
    },
    _backGroundDisabledTextureScaleChangedWithSize: function() {
        var a = this._backGroundBoxDisabledRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) return void a.setScale(1);
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width), a.setScaleY(d)
        }
        a.setPosition(.5 * b.width, .5 * b.height)
    },
    _frontCrossDisabledTextureScaleChangedWithSize: function() {
        var a = this._frontCrossDisabledRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) return void a.setScale(1);
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width), a.setScaleY(d)
        }
        a.setPosition(.5 * b.width, .5 * b.height)
    },
    getDescription: function() {
        return "CheckBox"
    },
    _createCloneInstance: function() {
        return ccui.CheckBox.create()
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.CheckBox && (this.loadTextureBackGround(a._backGroundFileName, a._backGroundTexType), this.loadTextureBackGroundSelected(a._backGroundSelectedFileName, a._backGroundSelectedTexType), this.loadTextureFrontCross(a._frontCrossFileName, a._frontCrossTexType), this.loadTextureBackGroundDisabled(a._backGroundDisabledFileName, a._backGroundDisabledTexType), this.loadTextureFrontCrossDisabled(a._frontCrossDisabledFileName, a._frontCrossDisabledTexType), this.setSelectedState(a._isSelected), this._checkBoxEventListener = a._checkBoxEventListener, this._checkBoxEventSelector = a._checkBoxEventSelector, this._checkBoxEventCallback = a._checkBoxEventCallback)
    },
    _adaptRenderers: function() {
        this._backGroundBoxRendererAdaptDirty && (this._backGroundTextureScaleChangedWithSize(), this._backGroundBoxRendererAdaptDirty = !1), this._backGroundSelectedBoxRendererAdaptDirty && (this._backGroundSelectedTextureScaleChangedWithSize(), this._backGroundSelectedBoxRendererAdaptDirty = !1), this._frontCrossRendererAdaptDirty && (this._frontCrossTextureScaleChangedWithSize(), this._frontCrossRendererAdaptDirty = !1), this._backGroundBoxDisabledRendererAdaptDirty && (this._backGroundDisabledTextureScaleChangedWithSize(), this._backGroundBoxDisabledRendererAdaptDirty = !1), this._frontCrossDisabledRendererAdaptDirty && (this._frontCrossDisabledTextureScaleChangedWithSize(), this._frontCrossDisabledRendererAdaptDirty = !1)
    }
}), _p = ccui.CheckBox.prototype, cc.defineGetterSetter(_p, "selected", _p.getSelectedState, _p.setSelectedState), _p = null, ccui.CheckBox.create = function(a, b, c, d, e, f) {
    return new ccui.CheckBox(a, b, c, d, e, f)
}, ccui.CheckBox.EVENT_SELECTED = 0, ccui.CheckBox.EVENT_UNSELECTED = 1, ccui.CheckBox.BOX_RENDERER_ZORDER = -1, ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER = -1, ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER = -1, ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER = -1, ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER = -1, ccui.ImageView = ccui.Widget.extend({
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _capInsets: null,
    _imageRenderer: null,
    _textureFile: "",
    _imageTexType: ccui.Widget.LOCAL_TEXTURE,
    _imageTextureSize: null,
    _className: "ImageView",
    _imageRendererAdaptDirty: !0,
    ctor: function(a, b) {
        this._capInsets = cc.rect(0, 0, 0, 0), this._imageTextureSize = cc.size(this._capInsets.width, this._capInsets.height), ccui.Widget.prototype.ctor.call(this), b && this.init(a, b)
    },
    init: function(a, b) {
        return ccui.Widget.prototype.init.call(this) ? (void 0 === a ? this._imageTexType = ccui.Widget.LOCAL_TEXTURE : this.loadTexture(a, b), !0) : !1
    },
    _initRenderer: function() {
        this._imageRenderer = cc.Sprite.create(), this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1)
    },
    loadTexture: function(a, b) {
        if (a) {
            var c = this;
            b = b || ccui.Widget.LOCAL_TEXTURE, this._textureFile = a, this._imageTexType = b;
            var d = c._imageRenderer;
            switch (c._imageTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c._scale9Enabled ? (d.initWithFile(a), d.setCapInsets(c._capInsets)) : d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c._scale9Enabled ? (d.initWithSpriteFrameName(a), d.setCapInsets(c._capInsets)) : d.initWithSpriteFrameName(a)
            }(!d.texture || !d.texture.isLoaded()) && d.addLoadedEventListener(function() {
                c._findLayout(), c._imageTextureSize = d.getContentSize(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._updateContentSizeWithTextureSize(c._imageTextureSize), c._imageRendererAdaptDirty = !0
            }), c._imageTextureSize = d.getContentSize(), c._updateFlippedX(), c._updateFlippedY(), this._updateChildrenDisplayedRGBA(), c._updateContentSizeWithTextureSize(c._imageTextureSize), c._imageRendererAdaptDirty = !0
        }
    },
    setTextureRect: function(a) {
        this._scale9Enabled || this._imageRenderer.setTextureRect(a)
    },
    _updateFlippedX: function() {
        this._scale9Enabled ? this._imageRenderer.setScaleX(this._flippedX ? -1 : 1) : this._imageRenderer.setFlippedX(this._flippedX)
    },
    _updateFlippedY: function() {
        this._scale9Enabled ? this._imageRenderer.setScaleY(this._flippedY ? -1 : 1) : this._imageRenderer.setFlippedY(this._flippedY)
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled != a && (this._scale9Enabled = a, this.removeProtectedChild(this._imageRenderer), this._imageRenderer = null, this._imageRenderer = this._scale9Enabled ? new ccui.Scale9Sprite : cc.Sprite.create(), this.loadTexture(this._textureFile, this._imageTexType), this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsets(this._capInsets))
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function(a) {
        (!this._scale9Enabled || this._scale9Enabled && !a) && (ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a)
    },
    setCapInsets: function(a) {
        if (a) {
            var b = this._capInsets;
            b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height, this._scale9Enabled && this._imageRenderer.setCapInsets(a)
        }
    },
    getCapInsets: function() {
        return cc.rect(this._capInsets)
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._imageRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._imageRendererAdaptDirty && (this._imageTextureScaleChangedWithSize(), this._imageRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return cc.size(this._imageTextureSize)
    },
    getVirtualRenderer: function() {
        return this._imageRenderer
    },
    _imageTextureScaleChangedWithSize: function() {
        if (this._ignoreSize) this._scale9Enabled || this._imageRenderer.setScale(1);
        else if (this._scale9Enabled) this._imageRenderer.setPreferredSize(this._contentSize);
        else {
            var a = this._imageRenderer.getContentSize();
            if (0 >= a.width || 0 >= a.height) return void this._imageRenderer.setScale(1);
            this._imageRenderer.setScaleX(this._contentSize.width / a.width), this._imageRenderer.setScaleY(this._contentSize.height / a.height)
        }
        this._imageRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "ImageView"
    },
    _createCloneInstance: function() {
        return ccui.ImageView.create()
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ImageView && (this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTexture(a._textureFile, a._imageTexType), this.setCapInsets(a._capInsets))
    }
}), ccui.ImageView.create = function(a, b) {
    return new ccui.ImageView(a, b)
}, ccui.ImageView.RENDERER_ZORDER = -1, ccui.LoadingBar = ccui.Widget.extend({
    _direction: null,
    _percent: 100,
    _totalLength: 0,
    _barRenderer: null,
    _renderBarTexType: ccui.Widget.LOCAL_TEXTURE,
    _barRendererTextureSize: null,
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _capInsets: null,
    _textureFile: "",
    _isTextureLoaded: !1,
    _className: "LoadingBar",
    _barRendererAdaptDirty: !0,
    ctor: function(a, b) {
        this._direction = ccui.LoadingBar.TYPE_LEFT, this._barRendererTextureSize = cc.size(0, 0), this._capInsets = cc.rect(0, 0, 0, 0), ccui.Widget.prototype.ctor.call(this), void 0 !== a && this.loadTexture(a), void 0 !== b && this.setPercent(b)
    },
    _initRenderer: function() {
        this._barRenderer = cc.Sprite.create(), cc.Node.prototype.addChild.call(this, this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1), this._barRenderer.setAnchorPoint(0, .5)
    },
    setDirection: function(a) {
        if (this._direction != a) switch (this._direction = a, this._direction) {
            case ccui.LoadingBar.TYPE_LEFT:
                this._barRenderer.setAnchorPoint(0, .5), this._barRenderer.setPosition(.5 * -this._totalLength, 0), this._scale9Enabled || this._barRenderer.setFlippedX(!1);
                break;
            case ccui.LoadingBar.TYPE_RIGHT:
                this._barRenderer.setAnchorPoint(1, .5), this._barRenderer.setPosition(.5 * this._totalLength, 0), this._scale9Enabled || this._barRenderer.setFlippedX(!0)
        }
    },
    getDirection: function() {
        return this._direction
    },
    loadTexture: function(a, b) {
        if (a) {
            this._renderBarTexType = b = b || ccui.Widget.LOCAL_TEXTURE, this._textureFile = a;
            var c = this._barRenderer,
                d = this;
            switch ((!c.texture || !c.texture.isLoaded()) && c.addLoadedEventListener(function() {
                d._findLayout();
                var a = c.getContentSize();
                switch (d._barRendererTextureSize.width = a.width, d._barRendererTextureSize.height = a.height, d._direction) {
                    case ccui.LoadingBar.TYPE_LEFT:
                        c.setAnchorPoint(0, .5), d._scale9Enabled || c.setFlippedX(!1);
                        break;
                    case ccui.LoadingBar.TYPE_RIGHT:
                        c.setAnchorPoint(1, .5), d._scale9Enabled || c.setFlippedX(!0)
                }
                d._updateChildrenDisplayedRGBA(), d._barRendererScaleChangedWithSize(), d._updateContentSizeWithTextureSize(d._barRendererTextureSize), d._barRendererAdaptDirty = !0
            }), this._renderBarTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._scale9Enabled ? (c.initWithFile(a), c.setCapInsets(this._capInsets)) : c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._scale9Enabled ? (c.initWithSpriteFrameName(a), c.setCapInsets(this._capInsets)) : c.initWithSpriteFrameName(a)
            }
            var e = c.getContentSize();
            switch (this._barRendererTextureSize.width = e.width, this._barRendererTextureSize.height = e.height, this._direction) {
                case ccui.LoadingBar.TYPE_LEFT:
                    c.setAnchorPoint(0, .5), this._scale9Enabled || c.setFlippedX(!1);
                    break;
                case ccui.LoadingBar.TYPE_RIGHT:
                    c.setAnchorPoint(1, .5), this._scale9Enabled || c.setFlippedX(!0)
            }
            this._updateChildrenDisplayedRGBA(), this._barRendererScaleChangedWithSize(), this._updateContentSizeWithTextureSize(this._barRendererTextureSize), this._barRendererAdaptDirty = !0
        }
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled != a && (this._scale9Enabled = a, this.removeProtectedChild(this._barRenderer), this._barRenderer = this._scale9Enabled ? new ccui.Scale9Sprite : cc.Sprite.create(), this.loadTexture(this._textureFile, this._renderBarTexType), this.addProtectedChild(this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsets(this._capInsets), this.setPercent(this._percent))
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    setCapInsets: function(a) {
        if (a) {
            var b = this._capInsets;
            b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height, this._scale9Enabled && this._barRenderer.setCapInsets(a)
        }
    },
    getCapInsets: function() {
        return cc.rect(this._capInsets)
    },
    setPercent: function(a) {
        if (!(0 > a || a > 100 || (this._percent = a, 0 >= this._totalLength)))
            if (a = this._percent / 100, this._scale9Enabled) this._setScale9Scale();
            else {
                var b = this._barRenderer.getTextureRect();
                b.width = this._barRendererTextureSize.width * a, this._barRenderer.setTextureRect(cc.rect(b.x, b.y, this._barRendererTextureSize.width * a, this._barRendererTextureSize.height))
            }
    },
    setContentSize: function(a, b) {
        ccui.Widget.prototype.setContentSize.call(this, a, b), this._totalLength = void 0 === b ? a.width : a
    },
    getPercent: function() {
        return this._percent
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._barRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._barRendererAdaptDirty && (this._barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1)
    },
    ignoreContentAdaptWithSize: function(a) {
        (!this._scale9Enabled || this._scale9Enabled && !a) && (ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a)
    },
    getVirtualRendererSize: function() {
        return cc.size(this._barRendererTextureSize)
    },
    getVirtualRenderer: function() {
        return this._barRenderer
    },
    _barRendererScaleChangedWithSize: function() {
        var a = this._barRenderer,
            b = this._contentSize;
        if (this._ignoreSize) this._scale9Enabled || (this._totalLength = this._barRendererTextureSize.width, a.setScale(1));
        else if (this._totalLength = b.width, this._scale9Enabled) this._setScale9Scale();
        else {
            var c = this._barRendererTextureSize;
            if (0 >= c.width || 0 >= c.height) return void a.setScale(1);
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width), a.setScaleY(d)

        }
        switch (this._direction) {
            case ccui.LoadingBar.TYPE_LEFT:
                a.setPosition(0, .5 * b.height);
                break;
            case ccui.LoadingBar.TYPE_RIGHT:
                a.setPosition(this._totalLength, .5 * b.height)
        }
    },
    _setScale9Scale: function() {
        this._barRenderer.setPreferredSize(cc.size(this._percent / 100 * this._totalLength, this._contentSize.height))
    },
    getDescription: function() {
        return "LoadingBar"
    },
    _createCloneInstance: function() {
        return ccui.LoadingBar.create()
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.LoadingBar && (this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTexture(a._textureFile, a._renderBarTexType), this.setCapInsets(a._capInsets), this.setPercent(a._percent), this.setDirection(a._direction))
    }
}), _p = ccui.LoadingBar.prototype, cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection), cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent), _p = null, ccui.LoadingBar.create = function(a, b) {
    return new ccui.LoadingBar(a, b)
}, ccui.LoadingBar.TYPE_LEFT = 0, ccui.LoadingBar.TYPE_RIGHT = 1, ccui.LoadingBar.RENDERER_ZORDER = -1, ccui.Slider = ccui.Widget.extend({
    _barRenderer: null,
    _progressBarRenderer: null,
    _progressBarTextureSize: null,
    _slidBallNormalRenderer: null,
    _slidBallPressedRenderer: null,
    _slidBallDisabledRenderer: null,
    _slidBallRenderer: null,
    _barLength: 0,
    _percent: 0,
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _textureFile: "",
    _progressBarTextureFile: "",
    _slidBallNormalTextureFile: "",
    _slidBallPressedTextureFile: "",
    _slidBallDisabledTextureFile: "",
    _capInsetsBarRenderer: null,
    _capInsetsProgressBarRenderer: null,
    _sliderEventListener: null,
    _sliderEventSelector: null,
    _barTexType: ccui.Widget.LOCAL_TEXTURE,
    _progressBarTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballNTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballPTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballDTexType: ccui.Widget.LOCAL_TEXTURE,
    _isTextureLoaded: !1,
    _className: "Slider",
    _barRendererAdaptDirty: !0,
    _progressBarRendererDirty: !0,
    ctor: function() {
        this._progressBarTextureSize = cc.size(0, 0), this._capInsetsBarRenderer = cc.rect(0, 0, 0, 0), this._capInsetsProgressBarRenderer = cc.rect(0, 0, 0, 0), ccui.Widget.prototype.ctor.call(this)
    },
    init: function() {
        return ccui.Widget.prototype.init.call(this)
    },
    _initRenderer: function() {
        this._barRenderer = cc.Sprite.create(), this._progressBarRenderer = cc.Sprite.create(), this._progressBarRenderer.setAnchorPoint(0, .5), this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1), this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1), this._slidBallNormalRenderer = cc.Sprite.create(), this._slidBallPressedRenderer = cc.Sprite.create(), this._slidBallPressedRenderer.setVisible(!1), this._slidBallDisabledRenderer = cc.Sprite.create(), this._slidBallDisabledRenderer.setVisible(!1), this._slidBallRenderer = new cc.Node, this._slidBallRenderer.addChild(this._slidBallNormalRenderer), this._slidBallRenderer.addChild(this._slidBallPressedRenderer), this._slidBallRenderer.addChild(this._slidBallDisabledRenderer), this.addProtectedChild(this._slidBallRenderer, ccui.Slider.BALL_RENDERER_ZORDER, -1)
    },
    loadBarTexture: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._textureFile = a, this._barTexType = b;
            var c = this._barRenderer,
                d = this;
            switch ((!c.texture || !c.texture.isLoaded()) && c.addLoadedEventListener(function() {
                d._findLayout(), d._updateChildrenDisplayedRGBA(), d._barRendererAdaptDirty = !0, d._progressBarRendererDirty = !0, d._updateContentSizeWithTextureSize(d._barRenderer.getContentSize())
            }), this._barTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA(), this._progressBarRendererDirty = this._barRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._barRenderer.getContentSize())
        }
    },
    loadProgressBarTexture: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._progressBarTextureFile = a, this._progressBarTexType = b;
            var c = this._progressBarRenderer,
                d = this;
            switch ((!c.texture || !c.texture.isLoaded()) && c.addLoadedEventListener(function() {
                d._findLayout(), d._updateChildrenDisplayedRGBA(), d._progressBarRenderer.setAnchorPoint(cc.p(0, .5));
                var a = d._progressBarRenderer.getContentSize();
                d._progressBarTextureSize = {
                    width: a.width,
                    height: a.height
                }, d._progressBarRendererDirty = !0
            }), this._progressBarTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA(), this._progressBarRenderer.setAnchorPoint(cc.p(0, .5)), c = this._progressBarRenderer.getContentSize(), this._progressBarTextureSize = {
                width: c.width,
                height: c.height
            }, this._progressBarRendererDirty = !0
        }
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled != a && (this._scale9Enabled = a, this.removeProtectedChild(this._barRenderer, !0), this.removeProtectedChild(this._progressBarRenderer, !0), this._progressBarRenderer = this._barRenderer = null, this._scale9Enabled ? (this._barRenderer = new ccui.Scale9Sprite, this._progressBarRenderer = new ccui.Scale9Sprite) : (this._barRenderer = cc.Sprite.create(), this._progressBarRenderer = cc.Sprite.create()), this.loadBarTexture(this._textureFile, this._barTexType), this.loadProgressBarTexture(this._progressBarTextureFile, this._progressBarTexType), this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1), this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsetsBarRenderer(this._capInsetsBarRenderer), this.setCapInsetProgressBarRenderer(this._capInsetsProgressBarRenderer))
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function(a) {
        (!this._scale9Enabled || this._scale9Enabled && !a) && (ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a)
    },
    setCapInsets: function(a) {
        this.setCapInsetsBarRenderer(a), this.setCapInsetProgressBarRenderer(a)
    },
    setCapInsetsBarRenderer: function(a) {
        if (a) {
            var b = this._capInsetsBarRenderer;
            b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height, this._scale9Enabled && this._barRenderer.setCapInsets(a)
        }
    },
    getCapInsetsBarRenderer: function() {
        return cc.rect(this._capInsetsBarRenderer)
    },
    setCapInsetProgressBarRenderer: function(a) {
        if (a) {
            var b = this._capInsetsProgressBarRenderer;
            b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height, this._scale9Enabled && this._progressBarRenderer.setCapInsets(a)
        }
    },
    getCapInsetsProgressBarRenderer: function() {
        return cc.rect(this._capInsetsProgressBarRenderer)
    },

    loadSlidBallTextures: function(a, b, c, d) {
        this.loadSlidBallTextureNormal(a, d), this.loadSlidBallTexturePressed(b, d), this.loadSlidBallTextureDisabled(c, d)
    },
    loadSlidBallTextureNormal: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._slidBallNormalTextureFile = a, this._ballNTexType = b;
            var c = this;
            switch ((!this._slidBallNormalRenderer.texture || !this._slidBallNormalRenderer.texture.isLoaded()) && this._slidBallNormalRenderer.addLoadedEventListener(function() {
                c._updateChildrenDisplayedRGBA()
            }), this._ballNTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallNormalRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallNormalRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA()
        }
    },
    loadSlidBallTexturePressed: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._slidBallPressedTextureFile = a, this._ballPTexType = b;
            var c = this;
            switch ((!this._slidBallPressedRenderer.texture || !this._slidBallPressedRenderer.texture.isLoaded()) && this._slidBallPressedRenderer.addLoadedEventListener(function() {
                c._updateChildrenDisplayedRGBA()
            }), this._ballPTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallPressedRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallPressedRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA()
        }
    },
    loadSlidBallTextureDisabled: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._slidBallDisabledTextureFile = a, this._ballDTexType = b;
            var c = this;
            switch ((!this._slidBallDisabledRenderer.texture || !this._slidBallDisabledRenderer.texture.isLoaded()) && this._slidBallDisabledRenderer.addLoadedEventListener(function() {
                c._updateChildrenDisplayedRGBA()
            }), this._ballDTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallDisabledRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallDisabledRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA()
        }
    },
    setPercent: function(a) {
        if (a > 100 && (a = 100), 0 > a && (a = 0), this._percent = a, a = this._barLength * (a / 100), this._slidBallRenderer.setPosition(cc.p(a, this._contentSize.height / 2)), this._scale9Enabled) this._progressBarRenderer.setPreferredSize(cc.size(a, this._progressBarTextureSize.height));
        else {
            var b = this._progressBarRenderer,
                c = b.getTextureRect();
            b.setTextureRect(cc.rect(c.x, c.y, a, c.height), b.isTextureRectRotated())
        }
    },
    hitTest: function(a) {
        a = this._slidBallNormalRenderer.convertToNodeSpace(a);
        var b = this._slidBallNormalRenderer.getContentSize(),
            b = cc.rect(0, 0, b.width, b.height);
        return a.x >= b.x && a.x <= b.x + b.width && a.y >= b.y && a.y <= b.y + b.height
    },
    onTouchBegan: function(a, b) {
        var c = ccui.Widget.prototype.onTouchBegan.call(this, a, b);
        if (this._hit) {
            var d = this.convertToNodeSpace(this._touchBeganPosition);
            this.setPercent(this._getPercentWithBallPos(d.x)), this._percentChangedEvent()
        }
        return c
    },
    onTouchMoved: function(a) {
        var b = a.getLocation(),
            b = this.convertToNodeSpace(b);
        this.setPercent(this._getPercentWithBallPos(b.x)), this._percentChangedEvent()
    },
    onTouchEnded: function(a, b) {
        ccui.Widget.prototype.onTouchEnded.call(this, a, b)
    },
    onTouchCancelled: function(a, b) {
        ccui.Widget.prototype.onTouchCancelled.call(this, a, b)
    },
    _getPercentWithBallPos: function(a) {
        return 100 * (a / this._barLength)
    },
    addEventListenerSlider: function(a, b) {
        this._sliderEventSelector = a, this._sliderEventListener = b
    },
    addEventListener: function(a) {
        this._eventCallback = a
    },
    _percentChangedEvent: function() {
        this._sliderEventListener && this._sliderEventSelector && this._sliderEventSelector.call(this._sliderEventListener, this, ccui.Slider.EVENT_PERCENT_CHANGED), this._eventCallback && this._eventCallback(ccui.Slider.EVENT_PERCENT_CHANGED)
    },
    getPercent: function() {
        return this._percent
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._progressBarRendererDirty = this._barRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._barRendererAdaptDirty && (this._barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1), this._progressBarRendererDirty && (this._progressBarRendererScaleChangedWithSize(), this._progressBarRendererDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._barRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._barRenderer
    },
    _barRendererScaleChangedWithSize: function() {
        if (this._ignoreSize) this._barRenderer.setScale(1), this._barLength = this._contentSize.width;
        else if (this._barLength = this._contentSize.width, this._scale9Enabled) this._barRenderer.setPreferredSize(this._contentSize);
        else {
            var a = this._barRenderer.getContentSize();
            if (0 >= a.width || 0 >= a.height) return void this._barRenderer.setScale(1);
            var b = this._contentSize.height / a.height;
            this._barRenderer.setScaleX(this._contentSize.width / a.width), this._barRenderer.setScaleY(b)
        }
        this._barRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2), this.setPercent(this._percent)
    },
    _progressBarRendererScaleChangedWithSize: function() {
        if (this._ignoreSize) {
            if (!this._scale9Enabled) {
                var a = this._progressBarTextureSize,
                    b = this._contentSize.width / a.width,
                    a = this._contentSize.height / a.height;
                this._progressBarRenderer.setScaleX(b), this._progressBarRenderer.setScaleY(a)
            }
        } else if (this._scale9Enabled) this._progressBarRenderer.setPreferredSize(this._contentSize), this._progressBarTextureSize = this._progressBarRenderer.getContentSize();
        else {
            if (a = this._progressBarTextureSize, 0 >= a.width || 0 >= a.height) return void this._progressBarRenderer.setScale(1);
            b = this._contentSize.width / a.width, a = this._contentSize.height / a.height, this._progressBarRenderer.setScaleX(b), this._progressBarRenderer.setScaleY(a)
        }
        this._progressBarRenderer.setPosition(0, this._contentSize.height / 2), this.setPercent(this._percent)
    },
    _onPressStateChangedToNormal: function() {
        this._slidBallNormalRenderer.setVisible(!0), this._slidBallPressedRenderer.setVisible(!1), this._slidBallDisabledRenderer.setVisible(!1)
    },
    _onPressStateChangedToPressed: function() {
        this._slidBallNormalRenderer.setVisible(!1), this._slidBallPressedRenderer.setVisible(!0), this._slidBallDisabledRenderer.setVisible(!1)
    },
    _onPressStateChangedToDisabled: function() {
        this._slidBallNormalRenderer.setVisible(!1), this._slidBallPressedRenderer.setVisible(!1), this._slidBallDisabledRenderer.setVisible(!0)
    },
    getDescription: function() {
        return "Slider"
    },
    _createCloneInstance: function() {
        return ccui.Slider.create()
    },
    _copySpecialProperties: function(a) {
        this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadBarTexture(a._textureFile, a._barTexType), this.loadProgressBarTexture(a._progressBarTextureFile, a._progressBarTexType), this.loadSlidBallTextureNormal(a._slidBallNormalTextureFile, a._ballNTexType), this.loadSlidBallTexturePressed(a._slidBallPressedTextureFile, a._ballPTexType), this.loadSlidBallTextureDisabled(a._slidBallDisabledTextureFile, a._ballDTexType), this.setPercent(a.getPercent()), this._sliderEventListener = a._sliderEventListener, this._sliderEventSelector = a._sliderEventSelector, this._eventCallback = a._eventCallback
    }
}), _p = ccui.Slider.prototype, cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent), _p = null, ccui.Slider.create = function() {
    return new ccui.Slider
}, ccui.Slider.EVENT_PERCENT_CHANGED = 0, ccui.Slider.BASEBAR_RENDERER_ZORDER = -3, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER = -2, ccui.Slider.BALL_RENDERER_ZORDER = -1, ccui.Text = ccui.Widget.extend({
    _touchScaleChangeEnabled: !1,
    _normalScaleValueX: 1,
    _normalScaleValueY: 1,
    _fontName: "Thonburi",
    _fontSize: 10,
    _onSelectedScaleOffset: .5,
    _labelRenderer: "",
    _textAreaSize: null,
    _textVerticalAlignment: 0,
    _textHorizontalAlignment: 0,
    _className: "Text",
    _type: null,
    _labelRendererAdaptDirty: !0,
    ctor: function(a, b, c) {
        this._type = ccui.Text.Type.SYSTEM, this._textAreaSize = cc.size(0, 0), ccui.Widget.prototype.ctor.call(this), c && this.init(a, b, c)
    },
    init: function(a, b, c) {
        return ccui.Widget.prototype.init.call(this) ? (0 < arguments.length && (this.setString(a), this.setFontName(b), this.setFontSize(c)), !0) : !1
    },
    _initRenderer: function() {
        this._labelRenderer = new cc.LabelTTF, this.addProtectedChild(this._labelRenderer, ccui.Text.RENDERER_ZORDER, -1)
    },
    setText: function(a) {
        cc.log("Please use the setString"), this.setString(a)
    },
    setString: function(a) {
        this._labelRenderer.setString(a), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0
    },
    getStringValue: function() {
        return cc.log("Please use the getString"), this._labelRenderer.getString()
    },
    getString: function() {
        return this._labelRenderer.getString()
    },
    getStringLength: function() {
        return this._labelRenderer.getStringLength()
    },
    setFontSize: function(a) {
        this._labelRenderer.setFontSize(a), this._fontSize = a, this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._fontName = a, this._labelRenderer.setFontName(a), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0
    },
    getFontName: function() {
        return this._fontName
    },
    _setFont: function(a) {
        var b = cc.LabelTTF._fontStyleRE.exec(a);
        b && (this._fontSize = parseInt(b[1]), this._fontName = b[2], this._labelRenderer._setFont(a), this._labelScaleChangedWithSize())
    },
    _getFont: function() {
        return this._labelRenderer._getFont()
    },
    getType: function() {
        return this._type
    },
    setTextAreaSize: function(a) {
        this._labelRenderer.setDimensions(a), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0
    },
    getTextAreaSize: function() {
        return this._labelRenderer.getDimensions()
    },
    setTextHorizontalAlignment: function(a) {
        this._labelRenderer.setHorizontalAlignment(a), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0
    },
    getTextHorizontalAlignment: function() {
        return this._labelRenderer.getHorizontalAlignment()
    },
    setTextVerticalAlignment: function(a) {
        this._labelRenderer.setVerticalAlignment(a), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0
    },
    getTextVerticalAlignment: function() {
        return this._labelRenderer.getVerticalAlignment()
    },
    setTouchScaleChangeEnabled: function(a) {
        this._touchScaleChangeEnabled = a
    },
    isTouchScaleChangeEnabled: function() {
        return this._touchScaleChangeEnabled
    },
    _onPressStateChangedToNormal: function() {
        this._touchScaleChangeEnabled && (this._labelRenderer.setScaleX(this._normalScaleValueX), this._labelRenderer.setScaleY(this._normalScaleValueY))
    },
    _onPressStateChangedToPressed: function() {
        this._touchScaleChangeEnabled && (this._labelRenderer.setScaleX(this._normalScaleValueX + this._onSelectedScaleOffset), this._labelRenderer.setScaleY(this._normalScaleValueY + this._onSelectedScaleOffset))
    },
    _onPressStateChangedToDisabled: function() {},
    _updateFlippedX: function() {
        this._labelRenderer.setScaleX(this._flippedX ? -1 : 1)
    },
    _updateFlippedY: function() {
        this._labelRenderer.setScaleY(this._flippedY ? -1 : 1)
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._labelRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelRendererAdaptDirty && (this._labelScaleChangedWithSize(), this._labelRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelRenderer
    },
    _labelScaleChangedWithSize: function() {
        var a = this._contentSize;
        if (this._ignoreSize) this._labelRenderer.setScale(1), this._normalScaleValueX = this._normalScaleValueY = 1;
        else {
            this._labelRenderer.setDimensions(cc.size(a.width, a.height));
            var b = this._labelRenderer.getContentSize();
            if (0 >= b.width || 0 >= b.height) return void this._labelRenderer.setScale(1);
            var c = a.width / b.width,
                b = a.height / b.height;
            this._labelRenderer.setScaleX(c), this._labelRenderer.setScaleY(b), this._normalScaleValueX = c, this._normalScaleValueY = b
        }
        this._labelRenderer.setPosition(a.width / 2, a.height / 2)
    },
    getDescription: function() {
        return "Label"
    },
    enableShadow: function(a, b, c) {
        this._labelRenderer.enableShadow(a, b, c)
    },
    enableOutline: function(a, b) {
        this._labelRenderer.enableOutline(a, b)
    },
    enableGlow: function(a) {
        this._type == ccui.Text.Type.TTF && this._labelRenderer.enableGlow(a)
    },
    disableEffect: function() {
        this._labelRenderer.disableEffect && this._labelRenderer.disableEffect()
    },
    _createCloneInstance: function() {
        return ccui.Text.create()
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.Text && (this.setFontName(a._fontName), this.setFontSize(a.getFontSize()), this.setString(a.getString()), this.setTouchScaleChangeEnabled(a.touchScaleEnabled), this.setTextAreaSize(a._textAreaSize), this.setTextHorizontalAlignment(a._labelRenderer.getHorizontalAlignment()), this.setTextVerticalAlignment(a._labelRenderer.getVerticalAlignment()))
    },
    _setBoundingWidth: function(a) {
        this._textAreaSize.width = a, this._labelRenderer._setBoundingWidth(a), this._labelScaleChangedWithSize()
    },
    _setBoundingHeight: function(a) {
        this._textAreaSize.height = a, this._labelRenderer._setBoundingHeight(a), this._labelScaleChangedWithSize()
    },
    _getBoundingWidth: function() {
        return this._textAreaSize.width
    },
    _getBoundingHeight: function() {
        return this._textAreaSize.height
    }
}), _p = ccui.Text.prototype, cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p._setBoundingWidth), cc.defineGetterSetter(_p, "boundingHeight", _p._getBoundingHeight, _p._setBoundingHeight), cc.defineGetterSetter(_p, "string", _p.getString, _p.setString), cc.defineGetterSetter(_p, "stringLength", _p.getStringLength), cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont), cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize), cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName), cc.defineGetterSetter(_p, "textAlign", _p.getTextHorizontalAlignment, _p.setTextHorizontalAlignment), cc.defineGetterSetter(_p, "verticalAlign", _p.getTextVerticalAlignment, _p.setTextVerticalAlignment), _p = null, ccui.Label = ccui.Text.create = function(a, b, c) {
    return new ccui.Text(a, b, c)
}, ccui.Text.RENDERER_ZORDER = -1, ccui.Text.Type = {
    SYSTEM: 0,
    TTF: 1
}, ccui.TextAtlas = ccui.Widget.extend({
    _labelAtlasRenderer: null,
    _stringValue: "",
    _charMapFileName: "",
    _itemWidth: 0,
    _itemHeight: 0,
    _startCharMap: "",
    _className: "TextAtlas",
    _labelAtlasRendererAdaptDirty: null,
    ctor: function(a, b, c, d, e) {
        ccui.Widget.prototype.ctor.call(this), e && this.setProperty(a, b, c, d, e)
    },
    _initRenderer: function() {
        this._labelAtlasRenderer = new cc.LabelAtlas, this._labelAtlasRenderer.setAnchorPoint(cc.p(.5, .5)), this.addProtectedChild(this._labelAtlasRenderer, ccui.TextAtlas.RENDERER_ZORDER, -1)
    },
    setProperty: function(a, b, c, d, e) {
        this._stringValue = a, this._charMapFileName = b, this._itemWidth = c, this._itemHeight = d, this._startCharMap = e, this._labelAtlasRenderer.initWithString(a, this._charMapFileName, this._itemWidth, this._itemHeight, this._startCharMap[0]), this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize()), this._labelAtlasRendererAdaptDirty = !0
    },
    setString: function(a) {
        this._stringValue = a, this._labelAtlasRenderer.setString(a), this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize()), this._labelAtlasRendererAdaptDirty = !0
    },
    setStringValue: function(a) {
        cc.log("Please use the setString"), this.setString(a)
    },
    getStringValue: function() {
        return cc.log("Please use the getString"), this.getString()
    },
    getString: function() {
        return this._labelAtlasRenderer.getString()
    },
    getStringLength: function() {
        return this._labelAtlasRenderer.getStringLength()
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._labelAtlasRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelAtlasRendererAdaptDirty && (this._labelAtlasScaleChangedWithSize(), this._labelAtlasRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelAtlasRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelAtlasRenderer
    },
    _labelAtlasScaleChangedWithSize: function() {
        var a = this._labelAtlasRenderer;
        if (this._ignoreSize) a.setScale(1);
        else {
            var b = a.getContentSize();
            if (0 >= b.width || 0 >= b.height) return void a.setScale(1);
            a.setScaleX(this._contentSize.width / b.width), a.setScaleY(this._contentSize.height / b.height)
        }
        a.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "LabelAtlas"
    },
    _copySpecialProperties: function(a) {
        a && this.setProperty(a._stringValue, a._charMapFileName, a._itemWidth, a._itemHeight, a._startCharMap)
    },
    _createCloneInstance: function() {
        return ccui.TextAtlas.create()
    }
}), _p = ccui.TextAtlas.prototype, cc.defineGetterSetter(_p, "string", _p.getString, _p.setString), _p = null, ccui.TextAtlas.create = function(a, b, c, d, e) {
    return new ccui.TextAtlas(a, b, c, d, e)
}, ccui.TextAtlas.RENDERER_ZORDER = -1, ccui.LabelBMFont = ccui.TextBMFont = ccui.Widget.extend({
    _labelBMFontRenderer: null,
    _fntFileHasInit: !1,
    _fntFileName: "",
    _stringValue: "",
    _className: "TextBMFont",
    _labelBMFontRendererAdaptDirty: !0,
    ctor: function(a, b) {
        ccui.Widget.prototype.ctor.call(this), void 0 != b && (this.setFntFile(b), this.setString(a))
    },
    _initRenderer: function() {
        this._labelBMFontRenderer = new cc.LabelBMFont, this.addProtectedChild(this._labelBMFontRenderer, ccui.TextBMFont.RENDERER_ZORDER, -1)
    },
    setFntFile: function(a) {
        if (a) {
            var b = this;
            b._fntFileName = a, b._fntFileHasInit = !0, b._labelBMFontRenderer.initWithString(this._stringValue, a), a = b._labelBMFontRenderer, a._textureLoaded || a.addLoadedEventListener(function() {
                b.updateSizeAndPosition()
            })
        }
    },
    setText: function(a) {
        cc.log("Please use the setString"), this.setString(a)
    },
    setString: function(a) {
        this._stringValue = a, this._fntFileHasInit && (this._labelBMFontRenderer.setString(a), this._updateContentSizeWithTextureSize(this._labelBMFontRenderer.getContentSize()), this._labelBMFontRendererAdaptDirty = !0)
    },
    getString: function() {
        return this._stringValue
    },
    getStringLength: function() {
        return this._labelBMFontRenderer.getStringLength()
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._labelBMFontRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelBMFontRendererAdaptDirty && (this._labelBMFontScaleChangedWithSize(), this._labelBMFontRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelBMFontRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelBMFontRenderer
    },
    _labelBMFontScaleChangedWithSize: function() {
        var a = this._labelBMFontRenderer;
        if (this._ignoreSize) a.setScale(1);
        else {
            var b = a.getContentSize();
            if (0 >= b.width || 0 >= b.height) return void a.setScale(1);
            a.setScaleX(this._contentSize.width / b.width), a.setScaleY(this._contentSize.height / b.height)
        }
        a.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "TextBMFont"
    },
    _createCloneInstance: function() {
        return new ccui.TextBMFont
    },
    _copySpecialProperties: function(a) {
        this.setFntFile(a._fntFileName), this.setString(a._stringValue)
    }
}), _p = ccui.TextBMFont.prototype, cc.defineGetterSetter(_p, "string", _p.getString, _p.setStringValue), _p = null, ccui.TextBMFont.create = function(a, b) {
    return new ccui.TextBMFont(a, b)
}, ccui.TextBMFont.RENDERER_ZORDER = -1, ccui._TextFieldRenderer = cc.TextFieldTTF.extend({
    _maxLengthEnabled: !1,
    _maxLength: 0,
    _passwordEnabled: !1,
    _passwordStyleText: "",
    _attachWithIME: !1,
    _detachWithIME: !1,
    _insertText: !1,
    _deleteBackward: !1,
    _className: "_TextFieldRenderer",
    _textFieldRendererAdaptDirty: !0,
    ctor: function() {
        cc.TextFieldTTF.prototype.ctor.call(this), this._maxLengthEnabled = !1, this._maxLength = 0, this._passwordEnabled = !1, this._passwordStyleText = "*", this._deleteBackward = this._insertText = this._detachWithIME = this._attachWithIME = !1
    },
    onEnter: function() {
        cc.TextFieldTTF.prototype.onEnter.call(this), cc.TextFieldTTF.prototype.setDelegate.call(this, this)
    },
    onTextFieldAttachWithIME: function() {
        return this.setAttachWithIME(!0), !1
    },
    onTextFieldInsertText: function(a, b, c) {
        return 1 == c && "\n" == b ? !1 : (this.setInsertText(!0), this._maxLengthEnabled && cc.TextFieldTTF.prototype.getCharCount.call(this) >= this._maxLength)
    },
    onTextFieldDeleteBackward: function() {
        return this.setDeleteBackward(!0), !1
    },
    onTextFieldDetachWithIME: function() {
        return this.setDetachWithIME(!0), !1
    },
    insertText: function(a, b) {
        "\n" != a && this._maxLengthEnabled && this.getString().length >= this._maxLength ? this._passwordEnabled && this.setPasswordText(this.getString()) : (cc.TextFieldTTF.prototype.insertText.call(this, a, b), this._passwordEnabled && 0 < cc.TextFieldTTF.prototype.getCharCount.call(this) && this.setPasswordText(this.getString()))
    },
    deleteBackward: function() {
        cc.TextFieldTTF.prototype.deleteBackward.call(this), 0 < cc.TextFieldTTF.prototype.getCharCount.call(this) && this._passwordEnabled && this.setPasswordText(this._inputText)
    },
    openIME: function() {
        cc.TextFieldTTF.prototype.attachWithIME.call(this)
    },
    closeIME: function() {
        cc.TextFieldTTF.prototype.detachWithIME.call(this)
    },
    setMaxLengthEnabled: function(a) {
        this._maxLengthEnabled = a
    },
    isMaxLengthEnabled: function() {
        return this._maxLengthEnabled
    },
    setMaxLength: function(a) {
        this._maxLength = a
    },
    getMaxLength: function() {
        return this._maxLength
    },
    getCharCount: function() {
        return cc.TextFieldTTF.prototype.getCharCount.call(this)
    },
    setPasswordEnabled: function(a) {
        this._passwordEnabled = a
    },
    isPasswordEnabled: function() {
        return this._passwordEnabled
    },
    setPasswordStyleText: function(a) {
        if (!(1 < a.length)) {
            var b = a.charCodeAt(0);
            33 > b || b > 126 || (this._passwordStyleText = a)
        }
    },
    setPasswordText: function(a) {
        var b = "",
            c = a.length;
        for (a = c, this._maxLengthEnabled && c > this._maxLength && (a = this._maxLength), c = 0; a > c; ++c) b += this._passwordStyleText;
        cc.LabelTTF.prototype.setString.call(this, b)
    },
    setAttachWithIME: function(a) {
        this._attachWithIME = a
    },
    getAttachWithIME: function() {
        return this._attachWithIME
    },
    setDetachWithIME: function(a) {
        this._detachWithIME = a
    },
    getDetachWithIME: function() {
        return this._detachWithIME
    },
    setInsertText: function(a) {
        this._insertText = a
    },
    getInsertText: function() {
        return this._insertText
    },
    setDeleteBackward: function(a) {
        this._deleteBackward = a
    },
    getDeleteBackward: function() {
        return this._deleteBackward
    },
    onDraw: function() {
        return !1
    }
}), ccui._TextFieldRenderer.create = function(a, b, c) {
    var d = new ccui._TextFieldRenderer;
    return d && d.initWithString("", b, c) ? (a && d.setPlaceHolder(a), d) : null
}, ccui.TextField = ccui.Widget.extend({
    _textFieldRenderer: null,
    _touchWidth: 0,
    _touchHeight: 0,
    _useTouchArea: !1,
    _textFieldEventListener: null,
    _textFieldEventSelector: null,
    _passwordStyleText: "",
    _textFieldRendererAdaptDirty: !0,
    _fontName: "",
    _fontSize: 12,
    ctor: function(a, b, c) {
        ccui.Widget.prototype.ctor.call(this), a && this.setPlaceHolder(a), b && this.setFontName(b), c && this.setFontSize(c)
    },
    init: function() {
        return ccui.Widget.prototype.init.call(this) ? (this.setTouchEnabled(!0), !0) : !1
    },
    onEnter: function() {
        ccui.Widget.prototype.onEnter.call(this), this.scheduleUpdate()
    },
    _initRenderer: function() {
        this._textFieldRenderer = ccui._TextFieldRenderer.create("input words here", "Thonburi", 20), this.addProtectedChild(this._textFieldRenderer, ccui.TextField.RENDERER_ZORDER, -1)
    },
    setTouchSize: function(a) {
        this._touchWidth = a.width, this._touchHeight = a.height
    },
    setTouchAreaEnabled: function(a) {
        this._useTouchArea = a
    },
    hitTest: function(a) {
        if (this._useTouchArea) {
            a = this.convertToNodeSpace(a);
            var b = cc.rect(-this._touchWidth * this._anchorPoint.x, -this._touchHeight * this._anchorPoint.y, this._touchWidth, this._touchHeight);
            return a.x >= b.x && a.x <= b.x + b.width && a.y >= b.y && a.y <= b.y + b.height
        }
        return ccui.Widget.prototype.hitTest.call(this, a)
    },
    getTouchSize: function() {
        return cc.size(this._touchWidth, this._touchHeight)
    },
    setText: function(a) {
        cc.log("Please use the setString"), this.setString(a)
    },
    setString: function(a) {
        a && (a = String(a), this.isMaxLengthEnabled() && (a = a.substr(0, this.getMaxLength())), this.isPasswordEnabled() ? (this._textFieldRenderer.setPasswordText(a), this._textFieldRenderer.setString(""), this._textFieldRenderer.insertText(a, a.length)) : this._textFieldRenderer.setString(a), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()))
    },
    setPlaceHolder: function(a) {
        this._textFieldRenderer.setPlaceHolder(a), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getPlaceHolder: function() {
        return this._textFieldRenderer.getPlaceHolder()
    },
    setFontSize: function(a) {
        this._textFieldRenderer.setFontSize(a), this._fontSize = a, this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._textFieldRenderer.setFontName(a), this._fontName = a, this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getFontName: function() {
        return this._fontName
    },
    didNotSelectSelf: function() {
        this._textFieldRenderer.detachWithIME()
    },
    getStringValue: function() {
        return cc.log("Please use the getString"), this.getString()
    },
    getString: function() {
        return this._textFieldRenderer.getString()
    },
    getStringLength: function() {
        return this._textFieldRenderer.getStringLength()
    },
    onTouchBegan: function(a, b) {
        var c = this,
            d = ccui.Widget.prototype.onTouchBegan.call(c, a, b);
        return c._hit && setTimeout(function() {
            c._textFieldRenderer.attachWithIME()
        }, 0), d
    },
    setMaxLengthEnabled: function(a) {
        this._textFieldRenderer.setMaxLengthEnabled(a)
    },
    isMaxLengthEnabled: function() {
        return this._textFieldRenderer.isMaxLengthEnabled()
    },
    setMaxLength: function(a) {
        this._textFieldRenderer.setMaxLength(a), this.setString(this.getString())
    },
    getMaxLength: function() {
        return this._textFieldRenderer.getMaxLength()
    },
    setPasswordEnabled: function(a) {
        this._textFieldRenderer.setPasswordEnabled(a)
    },
    isPasswordEnabled: function() {
        return this._textFieldRenderer.isPasswordEnabled()
    },
    setPasswordStyleText: function(a) {
        this._textFieldRenderer.setPasswordStyleText(a), this._passwordStyleText = a, this.setString(this.getString())
    },
    getPasswordStyleText: function() {
        return this._passwordStyleText
    },
    update: function() {
        this.getAttachWithIME() && (this._attachWithIMEEvent(), this.setAttachWithIME(!1)), this.getDetachWithIME() && (this._detachWithIMEEvent(), this.setDetachWithIME(!1)), this.getInsertText() && (this._insertTextEvent(), this.setInsertText(!1), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())), this.getDeleteBackward() && (this._deleteBackwardEvent(), this.setDeleteBackward(!1), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()))
    },

    getAttachWithIME: function() {
        return this._textFieldRenderer.getAttachWithIME()
    },
    setAttachWithIME: function(a) {
        this._textFieldRenderer.setAttachWithIME(a)
    },
    getDetachWithIME: function() {
        return this._textFieldRenderer.getDetachWithIME()
    },
    setDetachWithIME: function(a) {
        this._textFieldRenderer.setDetachWithIME(a)
    },
    getInsertText: function() {
        return this._textFieldRenderer.getInsertText()
    },
    setInsertText: function(a) {
        this._textFieldRenderer.setInsertText(a)
    },
    getDeleteBackward: function() {
        return this._textFieldRenderer.getDeleteBackward()
    },
    setDeleteBackward: function(a) {
        this._textFieldRenderer.setDeleteBackward(a)
    },
    _attachWithIMEEvent: function() {
        this._textFieldEventListener && this._textFieldEventSelector && this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_ATTACH_WITH_IME), this._eventCallback && this._eventCallback(this, ccui.TextField.EVENT_ATTACH_WITH_IME)
    },
    _detachWithIMEEvent: function() {
        this._textFieldEventListener && this._textFieldEventSelector && this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_DETACH_WITH_IME), this._eventCallback && this._eventCallback(this, ccui.TextField.EVENT_DETACH_WITH_IME)
    },
    _insertTextEvent: function() {
        this._textFieldEventListener && this._textFieldEventSelector && this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_INSERT_TEXT), this._eventCallback && this._eventCallback(this, ccui.TextField.EVENT_INSERT_TEXT)
    },
    _deleteBackwardEvent: function() {
        this._textFieldEventListener && this._textFieldEventSelector && this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_DELETE_BACKWARD), this._eventCallback && this._eventCallback(this, ccui.TextField.EVENT_DELETE_BACKWARD)
    },
    addEventListenerTextField: function(a, b) {
        this._textFieldEventSelector = a, this._textFieldEventListener = b
    },
    addEventListener: function(a) {
        this._eventCallback = a
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._textFieldRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._textFieldRendererAdaptDirty && (this._textfieldRendererScaleChangedWithSize(), this._textFieldRendererAdaptDirty = !1)
    },
    _textfieldRendererScaleChangedWithSize: function() {
        this._ignoreSize || this._textFieldRenderer.setDimensions(this._contentSize), this._textFieldRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getVirtualRendererSize: function() {
        return this._textFieldRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._textFieldRenderer
    },
    getDescription: function() {
        return "TextField"
    },
    attachWithIME: function() {
        this._textFieldRenderer.attachWithIME()
    },
    _createCloneInstance: function() {
        return ccui.TextField.create()
    },
    _copySpecialProperties: function(a) {
        this.setString(a._textFieldRenderer.getString()), this.setPlaceHolder(a.getString()), this.setFontSize(a._textFieldRenderer.getFontSize()), this.setFontName(a._textFieldRenderer.getFontName()), this.setMaxLengthEnabled(a.isMaxLengthEnabled()), this.setMaxLength(a.getMaxLength()), this.setPasswordEnabled(a.isPasswordEnabled()), this.setPasswordStyleText(a._passwordStyleText), this.setAttachWithIME(a.getAttachWithIME()), this.setDetachWithIME(a.getDetachWithIME()), this.setInsertText(a.getInsertText()), this.setDeleteBackward(a.getDeleteBackward())
    },
    setTextAreaSize: function(a) {
        this.setContentSize(a)
    },
    setTextHorizontalAlignment: function(a) {
        this._textFieldRenderer.setHorizontalAlignment(a)
    },
    setTextVerticalAlignment: function(a) {
        this._textFieldRenderer.setVerticalAlignment(a)
    },
    _setFont: function(a) {
        this._textFieldRender._setFont(a), this._textFieldRendererAdaptDirty = !0
    },
    _getFont: function() {
        return this._textFieldRender._getFont()
    }
}), ccui.TextField.create = function(a, b, c) {
    return new ccui.TextField(a, b, c)
}, _p = ccui.TextField.prototype, cc.defineGetterSetter(_p, "string", _p.getString, _p.setString), cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder), cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont), cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize), cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName), cc.defineGetterSetter(_p, "maxLengthEnabled", _p.isMaxLengthEnabled, _p.setMaxLengthEnabled), cc.defineGetterSetter(_p, "maxLength", _p.getMaxLength, _p.setMaxLength), cc.defineGetterSetter(_p, "passwordEnabled", _p.isPasswordEnabled, _p.setPasswordEnabled), _p = null, ccui.TextField.EVENT_ATTACH_WITH_IME = 0, ccui.TextField.EVENT_DETACH_WITH_IME = 1, ccui.TextField.EVENT_INSERT_TEXT = 2, ccui.TextField.EVENT_DELETE_BACKWARD = 3, ccui.TextField.RENDERER_ZORDER = -1, ccui.RichElement = ccui.Class.extend({
    _type: 0,
    _tag: 0,
    _color: null,
    _opacity: 0,
    ctor: function() {
        this._tag = this._type = 0, this._color = cc.color(255, 255, 255, 255)
    },
    init: function(a, b, c) {
        this._tag = a, this._color.r = b.r, this._color.g = b.g, this._color.b = b.b, this._opacity = c, this._color.a = void 0 === c ? b.a : c
    }
}), ccui.RichElementText = ccui.RichElement.extend({
    _text: "",
    _fontName: "",
    _fontSize: 0,
    ctor: function(a, b, c, d, e, f) {
        ccui.RichElement.prototype.ctor.call(this), this._type = ccui.RichElement.TEXT, this._fontName = this._text = "", this._fontSize = 0, f && this.init(a, b, c, d, e, f)
    },
    init: function(a, b, c, d, e, f) {
        ccui.RichElement.prototype.init.call(this, a, b, c), this._text = d, this._fontName = e, this._fontSize = f
    }
}), ccui.RichElementText.create = function(a, b, c, d, e, f) {
    return new ccui.RichElementText(a, b, c, d, e, f)
}, ccui.RichElementImage = ccui.RichElement.extend({
    _filePath: "",
    _textureRect: null,
    _textureType: 0,
    ctor: function(a, b, c, d) {
        ccui.RichElement.prototype.ctor.call(this), this._type = ccui.RichElement.IMAGE, this._filePath = "", this._textureRect = cc.rect(0, 0, 0, 0), this._textureType = 0, d && this.init(a, b, c, d)
    },
    init: function(a, b, c, d) {
        ccui.RichElement.prototype.init.call(this, a, b, c), this._filePath = d
    }
}), ccui.RichElementImage.create = function(a, b, c, d) {
    return new ccui.RichElementImage(a, b, c, d)
}, ccui.RichElementCustomNode = ccui.RichElement.extend({
    _customNode: null,
    ctor: function(a, b, c, d) {
        ccui.RichElement.prototype.ctor.call(this), this._type = ccui.RichElement.CUSTOM, this._customNode = null, d && this.init(a, b, c, d)
    },
    init: function(a, b, c, d) {
        ccui.RichElement.prototype.init.call(this, a, b, c), this._customNode = d
    }
}), ccui.RichElementCustomNode.create = function(a, b, c, d) {
    return new ccui.RichElementCustomNode(a, b, c, d)
}, ccui.RichText = ccui.Widget.extend({
    _formatTextDirty: !1,
    _richElements: null,
    _elementRenders: null,
    _leftSpaceWidth: 0,
    _verticalSpace: 0,
    _elementRenderersContainer: null,
    ctor: function() {
        ccui.Widget.prototype.ctor.call(this), this._formatTextDirty = !1, this._richElements = [], this._elementRenders = [], this._verticalSpace = this._leftSpaceWidth = 0
    },
    _initRenderer: function() {
        this._elementRenderersContainer = new cc.Node, this._elementRenderersContainer.setAnchorPoint(.5, .5), this.addProtectedChild(this._elementRenderersContainer, 0, -1)
    },
    insertElement: function(a, b) {
        this._richElements.splice(b, 0, a), this._formatTextDirty = !0
    },
    pushBackElement: function(a) {
        this._richElements.push(a), this._formatTextDirty = !0
    },
    removeElement: function(a) {
        "number" == typeof a ? this._richElements.splice(a, 1) : cc.arrayRemoveObject(this._richElements, a), this._formatTextDirty = !0
    },
    formatText: function() {
        if (this._formatTextDirty) {
            this._elementRenderersContainer.removeAllChildren(), this._elementRenders.length = 0;
            var a, b, c = this._richElements;
            if (this._ignoreSize)
                for (this._addNewLine(), a = 0; a < c.length; a++) {
                    b = c[a];
                    var d = null;
                    switch (b._type) {
                        case ccui.RichElement.TEXT:
                            d = new cc.LabelTTF(b._text, b._fontName, b._fontSize);
                            break;
                        case ccui.RichElement.IMAGE:
                            d = cc.Sprite.create(b._filePath);
                            break;
                        case ccui.RichElement.CUSTOM:
                            d = b._customNode
                    }
                    d.setColor(b._color), d.setOpacity(b._color.a), this._pushToContainer(d)
                } else
                    for (this._addNewLine(), a = 0; a < c.length; a++) switch (b = c[a], b._type) {
                        case ccui.RichElement.TEXT:
                            this._handleTextRenderer(b._text, b._fontName, b._fontSize, b._color);
                            break;
                        case ccui.RichElement.IMAGE:
                            this._handleImageRenderer(b._filePath, b._color, b._color.a);
                            break;
                        case ccui.RichElement.CUSTOM:
                            this._handleCustomRenderer(b._customNode)
                    }
            this.formatRenderers(), this._formatTextDirty = !1
        }
    },
    _handleTextRenderer: function(a, b, c, d) {
        var e = new cc.LabelTTF(a, b, c),
            f = e.getContentSize().width;
        this._leftSpaceWidth -= f, 0 > this._leftSpaceWidth ? (e = a.length * (1 - -this._leftSpaceWidth / f), f = a.substr(0, e), a = a.substr(e, a.length - 1), e > 0 && (e = new cc.LabelTTF(f.substr(0, e), b, c), e.setColor(d), e.setOpacity(d.a), this._pushToContainer(e)), this._addNewLine(), this._handleTextRenderer(a, b, c, d)) : (e.setColor(d), e.setOpacity(d.a), this._pushToContainer(e))
    },
    _handleImageRenderer: function(a) {
        a = cc.Sprite.create(a), this._handleCustomRenderer(a)
    },
    _handleCustomRenderer: function(a) {
        var b = a.getContentSize();
        this._leftSpaceWidth -= b.width, 0 > this._leftSpaceWidth ? (this._addNewLine(), this._pushToContainer(a), this._leftSpaceWidth -= b.width) : this._pushToContainer(a)
    },
    _addNewLine: function() {
        this._leftSpaceWidth = this._customSize.width, this._elementRenders.push([])
    },
    formatRenderers: function() {
        var a, b, c, d, e, f = 0,
            g = this._elementRenderersContainer,
            h = this._elementRenders;
        if (this._ignoreSize) {
            for (a = 0, c = h[0], b = d = 0; b < c.length; b++) e = c[b], e.setAnchorPoint(cc.p(0, 0)), e.setPosition(cc.p(d, 0)), g.addChild(e, 1, b), e = e.getContentSize(), a += e.width, f = Math.max(f, e.height), d += e.width;
            g.setContentSize(a, f)
        } else {
            var i = [];
            for (a = 0; a < h.length; a++) {
                for (c = h[a], b = d = 0; b < c.length; b++) e = c[b], d = Math.max(e.getContentSize().height, d);
                i[a] = d, f += i[a]
            }
            for (f = this._customSize.height, a = 0; a < h.length; a++)
                for (c = h[a], d = 0, f -= i[a] + this._verticalSpace, b = 0; b < c.length; b++) e = c[b], e.setAnchorPoint(cc.p(0, 0)), e.setPosition(cc.p(d, f)), g.addChild(e, 1), d += e.getContentSize().width;
            g.setContentSize(this._contentSize)
        }
        for (b = h.length, a = 0; b > a; a++) h[a].length = 0;
        this._elementRenders.length = 0, this.setContentSize(this._ignoreSize ? this.getVirtualRendererSize() : this._customSize), this._updateContentSizeWithTextureSize(this._contentSize), g.setPosition(.5 * this._contentSize.width, .5 * this._contentSize.height)
    },
    _pushToContainer: function(a) {
        0 >= this._elementRenders.length || this._elementRenders[this._elementRenders.length - 1].push(a)
    },
    visit: function(a) {
        this._enabled && (this.formatText(), ccui.Widget.prototype.visit.call(this, a))
    },
    setVerticalSpace: function(a) {
        this._verticalSpace = a
    },
    setAnchorPoint: function(a) {
        ccui.Widget.prototype.setAnchorPoint.call(this, a), this._elementRenderersContainer.setAnchorPoint(a)
    },
    _setAnchorX: function(a) {
        ccui.Widget.prototype._setAnchorX.call(this, a), this._elementRenderersContainer._setAnchorX(a)
    },
    _setAnchorY: function(a) {
        ccui.Widget.prototype._setAnchorY.call(this, a), this._elementRenderersContainer._setAnchorY(a)
    },
    getVirtualRendererSize: function() {
        return this._elementRenderersContainer.getContentSize()
    },
    ignoreContentAdaptWithSize: function(a) {
        this._ignoreSize != a && (this._formatTextDirty = !0, ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a))
    },
    getContentSize: function() {
        return this.formatText(), cc.Node.prototype.getContentSize.call(this)
    },
    _getWidth: function() {
        return this.formatText(), cc.Node.prototype._getWidth.call(this)
    },
    _getHeight: function() {
        return this.formatText(), cc.Node.prototype._getHeight.call(this)
    },
    getDescription: function() {
        return "RichText"
    }
}), ccui.RichText.create = function() {
    return new ccui.RichText
}, ccui.RichElement.TEXT = 0, ccui.RichElement.IMAGE = 1, ccui.RichElement.CUSTOM = 2, ccui.ScrollView = ccui.Layout.extend({
    _innerContainer: null,
    direction: null,
    _autoScrollDir: null,
    _topBoundary: 0,
    _bottomBoundary: 0,
    _leftBoundary: 0,
    _rightBoundary: 0,
    _bounceTopBoundary: 0,
    _bounceBottomBoundary: 0,
    _bounceLeftBoundary: 0,
    _bounceRightBoundary: 0,
    _autoScroll: !1,
    _autoScrollAddUpTime: 0,
    _autoScrollOriginalSpeed: 0,
    _autoScrollAcceleration: 0,
    _isAutoScrollSpeedAttenuated: !1,
    _needCheckAutoScrollDestination: !1,
    _autoScrollDestination: null,
    _bePressed: !1,
    _slidTime: 0,
    _moveChildPoint: null,
    _childFocusCancelOffset: 0,
    _leftBounceNeeded: !1,
    _topBounceNeeded: !1,
    _rightBounceNeeded: !1,
    _bottomBounceNeeded: !1,
    bounceEnabled: !1,
    _bouncing: !1,
    _bounceDir: null,
    _bounceOriginalSpeed: 0,
    inertiaScrollEnabled: !1,
    _scrollViewEventListener: null,
    _scrollViewEventSelector: null,
    _className: "ScrollView",
    _eventCallback: null,
    ctor: function() {
        ccui.Layout.prototype.ctor.call(this), this.direction = ccui.ScrollView.DIR_NONE, this._autoScrollDir = cc.p(0, 0), this._autoScrollAcceleration = -1e3, this._autoScrollDestination = cc.p(0, 0), this._slidTime = 0, this._moveChildPoint = cc.p(0, 0), this._childFocusCancelOffset = 5, this._bounceDir = cc.p(0, 0), this._bounceOriginalSpeed = 0, this.inertiaScrollEnabled = !0, this.setTouchEnabled(!0)
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setClippingEnabled(!0), this._innerContainer.setTouchEnabled(!1), !0) : !1
    },
    onEnter: function() {
        ccui.Layout.prototype.onEnter.call(this), this.scheduleUpdate(!0)
    },
    findNextFocusedWidget: function(a, b) {
        return this.getLayoutType() == ccui.Layout.LINEAR_VERTICAL || this.getLayoutType() == ccui.Layout.LINEAR_HORIZONTAL ? this._innerContainer.findNextFocusedWidget(a, b) : ccui.Widget.prototype.findNextFocusedWidget.call(this, a, b)
    },
    _initRenderer: function() {
        ccui.Layout.prototype._initRenderer.call(this), this._innerContainer = ccui.Layout.create(), this.addProtectedChild(this._innerContainer, 1, 1)
    },
    _onSizeChanged: function() {
        ccui.Layout.prototype._onSizeChanged.call(this);
        var a = this._contentSize;
        this._topBoundary = a.height, this._rightBoundary = a.width;
        var b = a.width / 3,
            c = a.height / 3;
        this._bounceTopBoundary = a.height - c, this._bounceBottomBoundary = c, this._bounceLeftBoundary = b, this._bounceRightBoundary = a.width - b, b = this._innerContainer.getContentSize(), this._innerContainer.setContentSize(cc.size(Math.max(b.width, a.width), Math.max(b.height, a.height))), this._innerContainer.setPosition(0, a.height - this._innerContainer.getContentSize().height)
    },
    setInnerContainerSize: function(a) {
        var b = this._innerContainer,
            c = this._contentSize,
            d = c.width,
            e = c.height,
            f = b.getContentSize();
        switch (a.width < c.width ? cc.log("Inner width <= ScrollView width, it will be force sized!") : d = a.width, a.height < c.height ? cc.log("Inner height <= ScrollView height, it will be force sized!") : e = a.height, b.setContentSize(cc.size(d, e)), this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                d = b.getContentSize(), f = f.height - d.height, this._scrollChildren(0, f);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                b.getRightBoundary() <= c.width && (d = b.getContentSize(), f = f.width - d.width, this._scrollChildren(f, 0));
                break;
            case ccui.ScrollView.DIR_BOTH:
                d = b.getContentSize(), a = f.height - d.height, f = b.getRightBoundary() <= c.width ? f.width - d.width : 0, this._scrollChildren(f, a)
        }
        f = b.getContentSize(), a = b.getPosition(), d = b.getAnchorPoint(), 0 < b.getLeftBoundary() && b.setPosition(d.x * f.width, a.y), b.getRightBoundary() < c.width && b.setPosition(c.width - (1 - d.x) * f.width, a.y), 0 < a.y && b.setPosition(a.x, d.y * f.height), b.getTopBoundary() < c.height && b.setPosition(a.x, c.height - (1 - d.y) * f.height)
    },
    _setInnerWidth: function(a) {
        var b = this._contentSize.width,
            c = b,
            d = this._innerContainer,
            e = d.width;
        switch (b > a ? cc.log("Inner width <= scrollview width, it will be force sized!") : c = a, d.width = c, this.direction) {
            case ccui.ScrollView.DIR_HORIZONTAL:
            case ccui.ScrollView.DIR_BOTH:
                d.getRightBoundary() <= b && this._scrollChildren(e - d.width, 0)
        }
        a = d.anchorX, 0 < d.getLeftBoundary() && (d.x = a * c), d.getRightBoundary() < b && (d.x = b - (1 - a) * c)
    },
    _setInnerHeight: function(a) {
        var b = this._contentSize.height,
            c = b,
            d = this._innerContainer,
            e = d.height;
        switch (b > a ? cc.log("Inner height <= scrollview height, it will be force sized!") : c = a, d.height = c, this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
            case ccui.ScrollView.DIR_BOTH:
                this._scrollChildren(0, e - c)
        }
        a = d.anchorY, 0 < d.getLeftBoundary() && (d.y = a * c), d.getRightBoundary() < b && (d.y = b - (1 - a) * c)
    },
    getInnerContainerSize: function() {
        return this._innerContainer.getContentSize()
    },
    _getInnerWidth: function() {
        return this._innerContainer.width
    },
    _getInnerHeight: function() {
        return this._innerContainer.height
    },
    addChild: function(a, b, c) {
        return a ? (b = b || a.getLocalZOrder(), c = c || a.getTag(), this._innerContainer.addChild(a, b, c)) : !1
    },
    removeAllChildren: function() {
        this.removeAllChildrenWithCleanup(!0)
    },
    removeAllChildrenWithCleanup: function(a) {
        this._innerContainer.removeAllChildrenWithCleanup(a)
    },
    removeChild: function(a, b) {
        return this._innerContainer.removeChild(a, b)
    },
    getChildren: function() {
        return this._innerContainer.getChildren()
    },
    getChildrenCount: function() {
        return this._innerContainer.getChildrenCount()
    },
    getChildByTag: function(a) {
        return this._innerContainer.getChildByTag(a)
    },
    getChildByName: function(a) {
        return this._innerContainer.getChildByName(a)
    },
    _moveChildren: function(a, b) {
        var c = this._innerContainer;
        this._moveChildPoint.x = c.x + a, this._moveChildPoint.y = c.y + b, this._innerContainer.setPosition(this._moveChildPoint)
    },
    _autoScrollChildren: function(a) {
        var b = this._autoScrollAddUpTime;
        if (this._autoScrollAddUpTime += a, this._isAutoScrollSpeedAttenuated) 0 >= this._autoScrollOriginalSpeed + this._autoScrollAcceleration * this._autoScrollAddUpTime ? (this._stopAutoScrollChildren(), this._checkNeedBounce()) : (b = (this._autoScrollOriginalSpeed + .5 * this._autoScrollAcceleration * (2 * b + a)) * a, this._scrollChildren(b * this._autoScrollDir.x, b * this._autoScrollDir.y) || (this._stopAutoScrollChildren(), this._checkNeedBounce()));
        else if (this._needCheckAutoScrollDestination) {
            var b = this._autoScrollDir.x * a * this._autoScrollOriginalSpeed,
                c = this._autoScrollDir.y * a * this._autoScrollOriginalSpeed;
            a = this._checkCustomScrollDestination(b, c), b = this._scrollChildren(b, c), a && b || (this._stopAutoScrollChildren(), this._checkNeedBounce())
        } else this._scrollChildren(this._autoScrollDir.x * a * this._autoScrollOriginalSpeed, this._autoScrollDir.y * a * this._autoScrollOriginalSpeed) || (this._stopAutoScrollChildren(), this._checkNeedBounce())
    },
    _bounceChildren: function(a) {
        var b = this._bounceOriginalSpeed,
            c = this._bounceDir;
        0 >= b && this._stopBounceChildren(), this._bounceScrollChildren(c.x * a * b, c.y * a * b) || this._stopBounceChildren()
    },
    _checkNeedBounce: function() {
        if (!this.bounceEnabled) return !1;
        this._checkBounceBoundary();
        var a = this._topBounceNeeded,
            b = this._bottomBounceNeeded,
            c = this._leftBounceNeeded,
            d = this._rightBounceNeeded;
        if (a || b || c || d) {
            var e = this._contentSize,
                f = this._innerContainer;
            return a && c ? (a = cc.pSub(cc.p(0, e.height), cc.p(f.getLeftBoundary(), f.getTopBoundary())), b = cc.pLength(a) / .2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : a && d ? (a = cc.pSub(cc.p(e.width, e.height), cc.p(f.getRightBoundary(), f.getTopBoundary())), b = cc.pLength(a) / .2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : b && c ? (a = cc.pSub(cc.p(0, 0), cc.p(f.getLeftBoundary(), f.getBottomBoundary())), b = cc.pLength(a) / .2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : b && d ? (a = cc.pSub(cc.p(e.width, 0), cc.p(f.getRightBoundary(), f.getBottomBoundary())), b = cc.pLength(a) / .2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : a ? (a = cc.pSub(cc.p(0, e.height), cc.p(0, f.getTopBoundary())), b = cc.pLength(a) / .2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : b ? (a = cc.pSub(cc.p(0, 0), cc.p(0, f.getBottomBoundary())), b = cc.pLength(a) / .2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : c ? (a = cc.pSub(cc.p(0, 0), cc.p(f.getLeftBoundary(), 0)), b = cc.pLength(a) / .2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : d && (a = cc.pSub(cc.p(e.width, 0), cc.p(f.getRightBoundary(), 0)), b = cc.pLength(a) / .2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)), !0
        }
        return !1
    },
    _checkBounceBoundary: function() {
        var a = this._innerContainer;
        a.getBottomBoundary() > this._bottomBoundary ? (this._scrollToBottomEvent(), this._bottomBounceNeeded = !0) : this._bottomBounceNeeded = !1, a.getTopBoundary() < this._topBoundary ? (this._scrollToTopEvent(), this._topBounceNeeded = !0) : this._topBounceNeeded = !1, a.getRightBoundary() < this._rightBoundary ? (this._scrollToRightEvent(), this._rightBounceNeeded = !0) : this._rightBounceNeeded = !1, a.getLeftBoundary() > this._leftBoundary ? (this._scrollToLeftEvent(), this._leftBounceNeeded = !0) : this._leftBounceNeeded = !1
    },
    _startBounceChildren: function(a) {
        this._bounceOriginalSpeed = a, this._bouncing = !0
    },
    _stopBounceChildren: function() {
        this._bouncing = !1, this._bounceOriginalSpeed = 0, this._bottomBounceNeeded = this._topBounceNeeded = this._rightBounceNeeded = this._leftBounceNeeded = !1
    },
    _startAutoScrollChildrenWithOriginalSpeed: function(a, b, c, d) {
        this._stopAutoScrollChildren(), this._autoScrollDir.x = a.x, this._autoScrollDir.y = a.y, this._isAutoScrollSpeedAttenuated = c, this._autoScrollOriginalSpeed = b, this._autoScroll = !0, this._autoScrollAcceleration = d
    },
    _startAutoScrollChildrenWithDestination: function(a, b, c) {
        this._needCheckAutoScrollDestination = !1, this._autoScrollDestination = a;
        var d = cc.pSub(a, this._innerContainer.getPosition());
        a = cc.pNormalize(d);
        var e = 0,
            f = -1e3,
            d = cc.pLength(d);
        c ? (f = -(2 * d) / (b * b), e = 2 * d / b) : (this._needCheckAutoScrollDestination = !0, e = d / b), this._startAutoScrollChildrenWithOriginalSpeed(a, e, c, f)
    },
    _jumpToDestination: function(a, b) {
        void 0 !== a.x && (b = a.y, a = a.x);
        var c = a,
            d = b;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                0 >= b && (d = Math.max(b, this._contentSize.height - this._innerContainer.getContentSize().height));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                0 >= a && (c = Math.max(a, this._contentSize.width - this._innerContainer.getContentSize().width));
                break;
            case ccui.ScrollView.DIR_BOTH:
                0 >= b && (d = Math.max(b, this._contentSize.height - this._innerContainer.getContentSize().height)), 0 >= a && (c = Math.max(a, this._contentSize.width - this._innerContainer.getContentSize().width))
        }
        this._innerContainer.setPosition(c, d)
    },
    _stopAutoScrollChildren: function() {
        this._autoScroll = !1, this._autoScrollAddUpTime = this._autoScrollOriginalSpeed = 0
    },
    _bounceScrollChildren: function(a, b) {
        var c, d, e, f, g = !0;
        return f = this._innerContainer, a > 0 && b > 0 ? (c = a, d = b, e = f.getRightBoundary(), e + c >= this._rightBoundary && (c = this._rightBoundary - e, this._bounceRightEvent(), g = !1), f = f.getTopBoundary(), f + b >= this._topBoundary && (d = this._topBoundary - f, this._bounceTopEvent(), g = !1), this._moveChildren(c, d)) : 0 > a && b > 0 ? (c = a, d = b, e = f.getLeftBoundary(), e + c <= this._leftBoundary && (c = this._leftBoundary - e, this._bounceLeftEvent(), g = !1), f = f.getTopBoundary(), f + b >= this._topBoundary && (d = this._topBoundary - f, this._bounceTopEvent(), g = !1), this._moveChildren(c, d)) : 0 > a && 0 > b ? (c = a, d = b, e = f.getLeftBoundary(), e + c <= this._leftBoundary && (c = this._leftBoundary - e, this._bounceLeftEvent(), g = !1), f = f.getBottomBoundary(), f + b <= this._bottomBoundary && (d = this._bottomBoundary - f, this._bounceBottomEvent(), g = !1), this._moveChildren(c, d)) : a > 0 && 0 > b ? (c = a, d = b, e = f.getRightBoundary(), e + c >= this._rightBoundary && (c = this._rightBoundary - e, this._bounceRightEvent(), g = !1), f = f.getBottomBoundary(), f + b <= this._bottomBoundary && (d = this._bottomBoundary - f, this._bounceBottomEvent(), g = !1), this._moveChildren(c, d)) : 0 == a && b > 0 ? (d = b, f = f.getTopBoundary(), f + b >= this._topBoundary && (d = this._topBoundary - f, this._bounceTopEvent(), g = !1), this._moveChildren(0, d)) : 0 == a && 0 > b ? (d = b, f = f.getBottomBoundary(), f + b <= this._bottomBoundary && (d = this._bottomBoundary - f, this._bounceBottomEvent(), g = !1), this._moveChildren(0, d)) : a > 0 && 0 == b ? (c = a, e = f.getRightBoundary(), e + c >= this._rightBoundary && (c = this._rightBoundary - e, this._bounceRightEvent(), g = !1), this._moveChildren(c, 0)) : 0 > a && 0 == b && (c = a, d = f.getLeftBoundary(), d + c <= this._leftBoundary && (c = this._leftBoundary - d, this._bounceLeftEvent(), g = !1), this._moveChildren(c, 0)), g
    },
    _checkCustomScrollDestination: function(a, b) {
        var c, d, e = !0;
        c = this._innerContainer;
        var f = this._autoScrollDestination;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                0 < this._autoScrollDir.y ? (c = c.getBottomBoundary(), c + b >= f.y && (e = !1)) : (c = c.getBottomBoundary(), c + b <= f.y && (e = !1));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                0 < this._autoScrollDir.x ? (d = c.getLeftBoundary(), d + a >= f.x && (e = !1)) : (d = c.getLeftBoundary(), d + a <= f.x && (e = !1));
                break;
            case ccui.ScrollView.DIR_BOTH:
                a > 0 && b > 0 ? (d = c.getLeftBoundary(), d + a >= f.x && (e = !1), c = c.getBottomBoundary(), c + b >= f.y && (e = !1)) : 0 > a && b > 0 ? (d = c.getRightBoundary(), d + a <= f.x && (e = !1), c = c.getBottomBoundary(), c + b >= f.y && (e = !1)) : 0 > a && 0 > b ? (d = c.getRightBoundary(), d + a <= f.x && (e = !1), c = c.getTopBoundary(), c + b <= f.y && (e = !1)) : a > 0 && 0 > b ? (d = c.getLeftBoundary(), d + a >= f.x && (e = !1), c = c.getTopBoundary(), c + b <= f.y && (e = !1)) : 0 == a && b > 0 ? (c = c.getBottomBoundary(), c + b >= f.y && (e = !1)) : 0 > a && 0 == b ? (d = c.getRightBoundary(), d + a <= f.x && (e = !1)) : 0 == a && 0 > b ? (c = c.getTopBoundary(), c + b <= f.y && (e = !1)) : a > 0 && 0 == b && (d = c.getLeftBoundary(), d + a >= f.x && (e = !1))
        }
        return e
    },
    _scrollChildren: function(a, b) {
        var c = !0;
        switch (this._scrollingEvent(), this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                c = this._scrollChildrenVertical(a, b);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                c = this._scrollChildrenHorizontal(a, b);
                break;
            case ccui.ScrollView.DIR_BOTH:
                c = this._scrollChildrenBoth(a, b)
        }
        return c
    },
    _scrollChildrenVertical: function(a, b) {
        var c, d = b,
            e = !0,
            f = this._innerContainer;
        return this.bounceEnabled ? (c = f.getBottomBoundary(), c + b >= this._bounceBottomBoundary && (d = this._bounceBottomBoundary - c, this._scrollToBottomEvent(), e = !1), c = f.getTopBoundary(), c + b <= this._bounceTopBoundary && (d = this._bounceTopBoundary - c, this._scrollToTopEvent(), e = !1)) : (c = f.getBottomBoundary(), c + b >= this._bottomBoundary && (d = this._bottomBoundary - c, this._scrollToBottomEvent(), e = !1), c = f.getTopBoundary(), c + b <= this._topBoundary && (d = this._topBoundary - c, this._scrollToTopEvent(), e = !1)), this._moveChildren(0, d), e
    },
    _scrollChildrenHorizontal: function(a) {
        var b, c = !0,
            d = a,
            e = this._innerContainer;
        return this.bounceEnabled ? (b = e.getRightBoundary(), b + a <= this._bounceRightBoundary && (d = this._bounceRightBoundary - b, this._scrollToRightEvent(), c = !1), b = e.getLeftBoundary(), b + a >= this._bounceLeftBoundary && (d = this._bounceLeftBoundary - b, this._scrollToLeftEvent(), c = !1)) : (b = e.getRightBoundary(), b + a <= this._rightBoundary && (d = this._rightBoundary - b, this._scrollToRightEvent(), c = !1), b = e.getLeftBoundary(), b + a >= this._leftBoundary && (d = this._leftBoundary - b, this._scrollToLeftEvent(), c = !1)), this._moveChildren(d, 0), c
    },
    _scrollChildrenBoth: function(a, b) {
        var c, d, e = !0,
            f = a,
            g = b;
        return d = this._innerContainer, this.bounceEnabled ? a > 0 && b > 0 ? (c = d.getLeftBoundary(), c + a >= this._bounceLeftBoundary && (f = this._bounceLeftBoundary - c, this._scrollToLeftEvent(), e = !1), d = d.getBottomBoundary(), d + b >= this._bounceBottomBoundary && (g = this._bounceBottomBoundary - d, this._scrollToBottomEvent(), e = !1)) : 0 > a && b > 0 ? (c = d.getRightBoundary(), c + a <= this._bounceRightBoundary && (f = this._bounceRightBoundary - c, this._scrollToRightEvent(), e = !1), d = d.getBottomBoundary(), d + b >= this._bounceBottomBoundary && (g = this._bounceBottomBoundary - d, this._scrollToBottomEvent(), e = !1)) : 0 > a && 0 > b ? (c = d.getRightBoundary(), c + a <= this._bounceRightBoundary && (f = this._bounceRightBoundary - c, this._scrollToRightEvent(), e = !1), d = d.getTopBoundary(), d + b <= this._bounceTopBoundary && (g = this._bounceTopBoundary - d, this._scrollToTopEvent(), e = !1)) : a > 0 && 0 > b ? (c = d.getLeftBoundary(), c + a >= this._bounceLeftBoundary && (f = this._bounceLeftBoundary - c, this._scrollToLeftEvent(), e = !1), d = d.getTopBoundary(), d + b <= this._bounceTopBoundary && (g = this._bounceTopBoundary - d, this._scrollToTopEvent(), e = !1)) : 0 == a && b > 0 ? (d = d.getBottomBoundary(), d + b >= this._bounceBottomBoundary && (g = this._bounceBottomBoundary - d, this._scrollToBottomEvent(), e = !1)) : 0 > a && 0 == b ? (c = d.getRightBoundary(), c + a <= this._bounceRightBoundary && (f = this._bounceRightBoundary - c, this._scrollToRightEvent(), e = !1)) : 0 == a && 0 > b ? (d = d.getTopBoundary(), d + b <= this._bounceTopBoundary && (g = this._bounceTopBoundary - d, this._scrollToTopEvent(), e = !1)) : a > 0 && 0 == b && (c = d.getLeftBoundary(), c + a >= this._bounceLeftBoundary && (f = this._bounceLeftBoundary - c, this._scrollToLeftEvent(), e = !1)) : a > 0 && b > 0 ? (c = d.getLeftBoundary(), c + a >= this._leftBoundary && (f = this._leftBoundary - c, this._scrollToLeftEvent(), e = !1), d = d.getBottomBoundary(), d + b >= this._bottomBoundary && (g = this._bottomBoundary - d, this._scrollToBottomEvent(), e = !1)) : 0 > a && b > 0 ? (c = d.getRightBoundary(), c + a <= this._rightBoundary && (f = this._rightBoundary - c, this._scrollToRightEvent(), e = !1), d = d.getBottomBoundary(), d + b >= this._bottomBoundary && (g = this._bottomBoundary - d, this._scrollToBottomEvent(), e = !1)) : 0 > a && 0 > b ? (c = d.getRightBoundary(), c + a <= this._rightBoundary && (f = this._rightBoundary - c, this._scrollToRightEvent(), e = !1), d = d.getTopBoundary(), d + b <= this._topBoundary && (g = this._topBoundary - d, this._scrollToTopEvent(), e = !1)) : a > 0 && 0 > b ? (c = d.getLeftBoundary(), c + a >= this._leftBoundary && (f = this._leftBoundary - c, this._scrollToLeftEvent(), e = !1), d = this._innerContainer.getTopBoundary(), d + b <= this._topBoundary && (g = this._topBoundary - d, this._scrollToTopEvent(), e = !1)) : 0 == a && b > 0 ? (d = this._innerContainer.getBottomBoundary(), d + b >= this._bottomBoundary && (g = this._bottomBoundary - d, this._scrollToBottomEvent(), e = !1)) : 0 > a && 0 == b ? (c = this._innerContainer.getRightBoundary(), c + a <= this._rightBoundary && (f = this._rightBoundary - c, this._scrollToRightEvent(), e = !1)) : 0 == a && 0 > b ? (d = this._innerContainer.getTopBoundary(), d + b <= this._topBoundary && (g = this._topBoundary - d, this._scrollToTopEvent(), e = !1)) : a > 0 && 0 == b && (c = this._innerContainer.getLeftBoundary(), c + a >= this._leftBoundary && (f = this._leftBoundary - c, this._scrollToLeftEvent(), e = !1)), this._moveChildren(f, g), e
    },
    scrollToBottom: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), 0), a, b)
    },
    scrollToTop: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), this._contentSize.height - this._innerContainer.getContentSize().height), a, b)
    },
    scrollToLeft: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(0, this._innerContainer.getPositionY()), a, b)
    },
    scrollToRight: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY()), a, b)
    },
    scrollToTopLeft: function(a, b) {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._startAutoScrollChildrenWithDestination(cc.p(0, this._contentSize.height - this._innerContainer.getContentSize().height), a, b)
    },
    scrollToTopRight: function(a, b) {
        if (this.direction != ccui.ScrollView.DIR_BOTH) cc.log("Scroll direction is not both!");
        else {
            var c = this._innerContainer.getContentSize();
            this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - c.width, this._contentSize.height - c.height), a, b)
        }
    },
    scrollToBottomLeft: function(a, b) {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._startAutoScrollChildrenWithDestination(cc.p(0, 0), a, b)
    },
    scrollToBottomRight: function(a, b) {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, 0), a, b)
    },
    scrollToPercentVertical: function(a, b, c) {
        var d = this._contentSize.height - this._innerContainer.getContentSize().height,
            e = -d;
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), d + a * e / 100), b, c)
    },
    scrollToPercentHorizontal: function(a, b, c) {
        var d = this._innerContainer.getContentSize().width - this._contentSize.width;
        this._startAutoScrollChildrenWithDestination(cc.p(-(a * d / 100), this._innerContainer.getPositionY()), b, c)
    },
    scrollToPercentBothDirection: function(a, b, c) {
        if (this.direction == ccui.ScrollView.DIR_BOTH) {
            var d = this._contentSize.height - this._innerContainer.getContentSize().height,
                e = -d,
                f = this._innerContainer.getContentSize().width - this._contentSize.width;
            this._startAutoScrollChildrenWithDestination(cc.p(-(a.x * f / 100), d + a.y * e / 100), b, c)
        }
    },
    jumpToBottom: function() {
        this._jumpToDestination(this._innerContainer.getPositionX(), 0)
    },
    jumpToTop: function() {
        this._jumpToDestination(this._innerContainer.getPositionX(), this._contentSize.height - this._innerContainer.getContentSize().height)
    },
    jumpToLeft: function() {
        this._jumpToDestination(0, this._innerContainer.getPositionY())
    },
    jumpToRight: function() {
        this._jumpToDestination(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY())
    },
    jumpToTopLeft: function() {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._jumpToDestination(0, this._contentSize.height - this._innerContainer.getContentSize().height)
    },
    jumpToTopRight: function() {
        if (this.direction != ccui.ScrollView.DIR_BOTH) cc.log("Scroll direction is not both!");
        else {
            var a = this._innerContainer.getContentSize();
            this._jumpToDestination(this._contentSize.width - a.width, this._contentSize.height - a.height)
        }
    },
    jumpToBottomLeft: function() {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._jumpToDestination(0, 0)
    },
    jumpToBottomRight: function() {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._jumpToDestination(this._contentSize.width - this._innerContainer.getContentSize().width, 0)
    },
    jumpToPercentVertical: function(a) {
        var b = this._contentSize.height - this._innerContainer.getContentSize().height,
            c = -b;
        this._jumpToDestination(this._innerContainer.getPositionX(), b + a * c / 100)
    },
    jumpToPercentHorizontal: function(a) {
        var b = this._innerContainer.getContentSize().width - this._contentSize.width;
        this._jumpToDestination(-(a * b / 100), this._innerContainer.getPositionY())
    },
    jumpToPercentBothDirection: function(a) {
        if (this.direction == ccui.ScrollView.DIR_BOTH) {
            var b = this._innerContainer.getContentSize(),
                c = this._contentSize.height - b.height;
            this._jumpToDestination(-(a.x * (b.width - this._contentSize.width) / 100), c + a.y * -c / 100)
        }
    },
    _startRecordSlidAction: function() {
        this._autoScroll && this._stopAutoScrollChildren(), this._bouncing && this._stopBounceChildren(), this._slidTime = 0
    },
    _endRecordSlidAction: function() {
        if (!this._checkNeedBounce() && this.inertiaScrollEnabled && !(.016 >= this._slidTime)) {
            var a, b = 0;
            switch (this.direction) {
                case ccui.ScrollView.DIR_VERTICAL:
                    b = this._touchEndPosition.y - this._touchBeganPosition.y, a = 0 > b ? ccui.ScrollView.SCROLLDIR_DOWN : ccui.ScrollView.SCROLLDIR_UP;
                    break;
                case ccui.ScrollView.DIR_HORIZONTAL:
                    b = this._touchEndPosition.x - this._touchBeganPosition.x, a = 0 > b ? ccui.ScrollView.SCROLLDIR_LEFT : ccui.ScrollView.SCROLLDIR_RIGHT;
                    break;
                case ccui.ScrollView.DIR_BOTH:
                    a = cc.pSub(this._touchEndPosition, this._touchBeganPosition), b = cc.pLength(a), a = cc.pNormalize(a)
            }
            b = Math.min(Math.abs(b) / this._slidTime, ccui.ScrollView.AUTO_SCROLL_MAX_SPEED), this._startAutoScrollChildrenWithOriginalSpeed(a, b, !0, -1e3), this._slidTime = 0
        }
    },
    _handlePressLogic: function() {
        this._startRecordSlidAction(), this._bePressed = !0
    },
    _handleMoveLogic: function(a) {
        switch (a = cc.pSub(a.getLocation(), a.getPreviousLocation()), this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                this._scrollChildren(0, a.y);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this._scrollChildren(a.x, 0);
                break;
            case ccui.ScrollView.DIR_BOTH:
                this._scrollChildren(a.x, a.y)
        }
    },
    _handleReleaseLogic: function() {
        this._endRecordSlidAction(), this._bePressed = !1
    },
    onTouchBegan: function(a, b) {
        var c = ccui.Layout.prototype.onTouchBegan.call(this, a, b);
        return this._hit && this._handlePressLogic(a), c
    },
    onTouchMoved: function(a, b) {
        ccui.Layout.prototype.onTouchMoved.call(this, a, b), this._handleMoveLogic(a)
    },
    onTouchEnded: function(a, b) {
        ccui.Layout.prototype.onTouchEnded.call(this, a, b), this._handleReleaseLogic(a)
    },
    onTouchCancelled: function(a, b) {
        ccui.Layout.prototype.onTouchCancelled.call(this, a, b)
    },
    update: function(a) {
        this._autoScroll && this._autoScrollChildren(a), this._bouncing && this._bounceChildren(a), this._recordSlidTime(a)
    },
    _recordSlidTime: function(a) {
        this._bePressed && (this._slidTime += a)
    },
    interceptTouchEvent: function(a, b, c) {
        var d = c.getLocation();
        switch (a) {
            case ccui.Widget.TOUCH_BEGAN:
                this._touchBeganPosition.x = d.x, this._touchBeganPosition.y = d.y, this._handlePressLogic(c);
                break;
            case ccui.Widget.TOUCH_MOVED:
                cc.pLength(cc.pSub(b.getTouchBeganPosition(), d)) > this._childFocusCancelOffset && (b.setHighlighted(!1), this._touchMovePosition.x = d.x, this._touchMovePosition.y = d.y, this._handleMoveLogic(c));
                break;
            case ccui.Widget.TOUCH_CANCELED:
            case ccui.Widget.TOUCH_ENDED:
                this._touchEndPosition.x = d.x, this._touchEndPosition.y = d.y, this._handleReleaseLogic(c)
        }
    },
    _scrollToTopEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_TOP), this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_TOP)
    },
    _scrollToBottomEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM), this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM)
    },
    _scrollToLeftEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_LEFT), this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_LEFT)
    },
    _scrollToRightEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT), this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT)
    },
    _scrollingEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLLING), this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLLING)
    },
    _bounceTopEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_TOP), this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_BOUNCE_TOP)
    },
    _bounceBottomEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_BOTTOM), this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_BOUNCE_BOTTOM)
    },
    _bounceLeftEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_LEFT), this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_BOUNCE_LEFT)
    },
    _bounceRightEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_RIGHT), this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_BOUNCE_RIGHT)
    },
    addEventListenerScrollView: function(a, b) {
        this._scrollViewEventSelector = a, this._scrollViewEventListener = b
    },
    addEventListener: function(a) {
        this._eventCallback = a
    },
    setDirection: function(a) {
        this.direction = a
    },
    getDirection: function() {
        return this.direction
    },
    setBounceEnabled: function(a) {
        this.bounceEnabled = a
    },
    isBounceEnabled: function() {
        return this.bounceEnabled
    },
    setInertiaScrollEnabled: function(a) {
        this.inertiaScrollEnabled = a
    },
    isInertiaScrollEnabled: function() {
        return this.inertiaScrollEnabled
    },
    getInnerContainer: function() {
        return this._innerContainer
    },
    setLayoutType: function(a) {
        this._innerContainer.setLayoutType(a)
    },
    getLayoutType: function() {
        return this._innerContainer.getLayoutType()
    },
    _doLayout: function() {
        this._doLayoutDirty && (this._doLayoutDirty = !1)
    },
    getDescription: function() {
        return "ScrollView"
    },
    _createCloneInstance: function() {
        return ccui.ScrollView.create()
    },
    _copyClonedWidgetChildren: function(a) {
        ccui.Layout.prototype._copyClonedWidgetChildren.call(this, a)
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ScrollView && (ccui.Layout.prototype._copySpecialProperties.call(this, a), this.setInnerContainerSize(a.getInnerContainerSize()), this.setDirection(a.direction), this.setBounceEnabled(a.bounceEnabled), this.setInertiaScrollEnabled(a.inertiaScrollEnabled), this._scrollViewEventListener = a._scrollViewEventListener, this._scrollViewEventSelector = a._scrollViewEventSelector, this._eventCallback = a._eventCallback)
    },
    getNodeByTag: function(a) {
        return this._innerContainer.getNodeByTag(a)
    },
    getNodes: function() {
        return this._innerContainer.getNodes()
    },
    removeNode: function(a) {
        this._innerContainer.removeNode(a)
    },
    removeNodeByTag: function(a) {
        this._innerContainer.removeNodeByTag(a)
    },
    removeAllNodes: function() {
        this._innerContainer.removeAllNodes()
    },
    addNode: function(a, b, c) {
        this._innerContainer.addNode(a, b, c)
    }
}), _p = ccui.ScrollView.prototype, cc.defineGetterSetter(_p, "innerWidth", _p._getInnerWidth, _p._setInnerWidth), cc.defineGetterSetter(_p, "innerHeight", _p._getInnerHeight, _p._setInnerHeight), _p = null, ccui.ScrollView.create = function() {
    return new ccui.ScrollView
}, ccui.ScrollView.DIR_NONE = 0, ccui.ScrollView.DIR_VERTICAL = 1, ccui.ScrollView.DIR_HORIZONTAL = 2, ccui.ScrollView.DIR_BOTH = 3, ccui.ScrollView.EVENT_SCROLL_TO_TOP = 0, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM = 1, ccui.ScrollView.EVENT_SCROLL_TO_LEFT = 2, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT = 3, ccui.ScrollView.EVENT_SCROLLING = 4, ccui.ScrollView.EVENT_BOUNCE_TOP = 5, ccui.ScrollView.EVENT_BOUNCE_BOTTOM = 6, ccui.ScrollView.EVENT_BOUNCE_LEFT = 7, ccui.ScrollView.EVENT_BOUNCE_RIGHT = 8, ccui.ScrollView.AUTO_SCROLL_MAX_SPEED = 1e3, ccui.ScrollView.SCROLLDIR_UP = cc.p(0, 1), ccui.ScrollView.SCROLLDIR_DOWN = cc.p(0, -1), ccui.ScrollView.SCROLLDIR_LEFT = cc.p(-1, 0), ccui.ScrollView.SCROLLDIR_RIGHT = cc.p(1, 0), ccui.ListView = ccui.ScrollView.extend({
    _model: null,
    _items: null,
    _gravity: null,
    _itemsMargin: 0,
    _curSelectedIndex: 0,
    _refreshViewDirty: !0,
    _listViewEventListener: null,
    _listViewEventSelector: null,
    _eventCallback: null,
    ctor: function() {
        ccui.ScrollView.prototype.ctor.call(this), this._items = [], this._gravity = ccui.ListView.GRAVITY_CENTER_HORIZONTAL, this.setTouchEnabled(!0), this.init()
    },
    init: function() {
        return ccui.ScrollView.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_VERTICAL), !0) : !1
    },
    setItemModel: function(a) {
        a && (this._model = a)
    },
    _updateInnerContainerSize: function() {
        var a, b, c = this._items;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                a = c.length;
                var d = (a - 1) * this._itemsMargin;
                for (b = 0; a > b; b++) d += c[b].getContentSize().height;
                this.setInnerContainerSize(cc.size(this._contentSize.width, d));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                for (a = c.length, d = (a - 1) * this._itemsMargin, b = 0; a > b; b++) d += c[b].getContentSize().width;
                this.setInnerContainerSize(cc.size(d, this._contentSize.height))
        }
    },
    _remedyLayoutParameter: function(a) {
        if (a) {
            var b;
            switch (this.direction) {
                case ccui.ScrollView.DIR_VERTICAL:
                    if (b = a.getLayoutParameter()) switch (b.setMargin(0 == this.getIndex(a) ? ccui.MarginZero() : new ccui.Margin(0, this._itemsMargin, 0, 0)), this._gravity) {
                        case ccui.ListView.GRAVITY_LEFT:
                            b.setGravity(ccui.LinearLayoutParameter.LEFT);
                            break;
                        case ccui.ListView.GRAVITY_RIGHT:
                            b.setGravity(ccui.LinearLayoutParameter.RIGHT);
                            break;
                        case ccui.ListView.GRAVITY_CENTER_HORIZONTAL:
                            b.setGravity(ccui.LinearLayoutParameter.CENTER_HORIZONTAL)
                    } else {
                        switch (b = ccui.LinearLayoutParameter.create(), this._gravity) {
                            case ccui.ListView.GRAVITY_LEFT:
                                b.setGravity(ccui.LinearLayoutParameter.LEFT);
                                break;
                            case ccui.ListView.GRAVITY_RIGHT:
                                b.setGravity(ccui.LinearLayoutParameter.RIGHT);
                                break;
                            case ccui.ListView.GRAVITY_CENTER_HORIZONTAL:
                                b.setGravity(ccui.LinearLayoutParameter.CENTER_HORIZONTAL)
                        }
                        b.setMargin(0 == this.getIndex(a) ? ccui.MarginZero() : new ccui.Margin(0, this._itemsMargin, 0, 0)), a.setLayoutParameter(b)
                    }
                    break;
                case ccui.ScrollView.DIR_HORIZONTAL:
                    if (b = a.getLayoutParameter()) switch (b.setMargin(0 == this.getIndex(a) ? ccui.MarginZero() : new ccui.Margin(this._itemsMargin, 0, 0, 0)), this._gravity) {
                        case ccui.ListView.GRAVITY_TOP:
                            b.setGravity(ccui.LinearLayoutParameter.TOP);
                            break;
                        case ccui.ListView.GRAVITY_BOTTOM:
                            b.setGravity(ccui.LinearLayoutParameter.BOTTOM);
                            break;
                        case ccui.ListView.GRAVITY_CENTER_VERTICAL:
                            b.setGravity(ccui.LinearLayoutParameter.CENTER_VERTICAL)
                    } else {
                        switch (b = ccui.LinearLayoutParameter.create(), this._gravity) {
                            case ccui.ListView.GRAVITY_TOP:
                                b.setGravity(ccui.LinearLayoutParameter.TOP);
                                break;
                            case ccui.ListView.GRAVITY_BOTTOM:
                                b.setGravity(ccui.LinearLayoutParameter.BOTTOM);
                                break;
                            case ccui.ListView.GRAVITY_CENTER_VERTICAL:
                                b.setGravity(ccui.LinearLayoutParameter.CENTER_VERTICAL)
                        }
                        b.setMargin(0 == this.getIndex(a) ? ccui.MarginZero() : new ccui.Margin(this._itemsMargin, 0, 0, 0)), a.setLayoutParameter(b)
                    }
            }
        }
    },
    pushBackDefaultItem: function() {
        if (this._model) {
            var a = this._model.clone();
            this._remedyLayoutParameter(a), this.addChild(a), this._refreshViewDirty = !0
        }
    },
    insertDefaultItem: function(a) {
        if (this._model) {
            var b = this._model.clone();
            this._items.splice(a, 0, b), ccui.ScrollView.prototype.addChild.call(this, b), this._remedyLayoutParameter(b), this._refreshViewDirty = !0
        }
    },
    pushBackCustomItem: function(a) {
        this._remedyLayoutParameter(a), this.addChild(a), this._refreshViewDirty = !0
    },
    addChild: function(a, b, c) {
        a && (b = b || a.getLocalZOrder(), c = c || a.getName(), ccui.ScrollView.prototype.addChild.call(this, a, b, c), a instanceof ccui.Widget && this._items.push(a))
    },
    removeChild: function(a, b) {
        if (a) {
            var c = this._items.indexOf(a);
            c > -1 && this._items.splice(c, 1), ccui.ScrollView.prototype.removeChild.call(this, a, b)
        }
    },
    removeAllChildren: function() {
        this.removeAllChildrenWithCleanup(!0)
    },
    removeAllChildrenWithCleanup: function(a) {
        ccui.ScrollView.prototype.removeAllChildrenWithCleanup.call(this, a), this._items = []
    },
    insertCustomItem: function(a, b) {
        this._items.splice(b, 0, a), ccui.ScrollView.prototype.addChild.call(this, a), this._remedyLayoutParameter(a), this._refreshViewDirty = !0
    },
    removeItem: function(a) {
        (a = this.getItem(a)) && (this.removeChild(a, !0), this._refreshViewDirty = !0)
    },
    removeLastItem: function() {
        this.removeItem(this._items.length - 1)
    },
    removeAllItems: function() {
        this.removeAllChildren()
    },
    getItem: function(a) {
        return 0 > a || a >= this._items.length ? null : this._items[a]
    },
    getItems: function() {
        return this._items
    },
    getIndex: function(a) {
        return this._items.indexOf(a)
    },
    setGravity: function(a) {
        this._gravity != a && (this._gravity = a, this._refreshViewDirty = !0)
    },
    setItemsMargin: function(a) {
        this._itemsMargin != a && (this._itemsMargin = a, this._refreshViewDirty = !0)
    },
    getItemsMargin: function() {
        return this._itemsMargin
    },
    setDirection: function(a) {
        switch (a) {
            case ccui.ScrollView.DIR_VERTICAL:
                this.setLayoutType(ccui.Layout.LINEAR_VERTICAL);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL);
                break;
            case ccui.ScrollView.DIR_BOTH:
                return;
            default:
                return
        }
        ccui.ScrollView.prototype.setDirection.call(this, a)
    },
    requestRefreshView: function() {
        this._refreshViewDirty = !0
    },
    refreshView: function() {
        for (var a = this._items, b = 0; b < a.length; b++) {
            var c = a[b];
            c.setLocalZOrder(b), this._remedyLayoutParameter(c)
        }
        this._updateInnerContainerSize()
    },
    doLayout: function() {
        this._doLayout()
    },
    _doLayout: function() {
        ccui.Layout.prototype._doLayout.call(this), this._refreshViewDirty && (this.refreshView(), this._refreshViewDirty = !1)
    },
    addEventListenerListView: function(a, b) {
        this._listViewEventListener = b, this._listViewEventSelector = a
    },
    addEventListener: function(a) {
        this._eventCallback = a
    },
    _selectedItemEvent: function(a) {
        a = a == ccui.Widget.TOUCH_BEGAN ? ccui.ListView.ON_SELECTED_ITEM_START : ccui.ListView.ON_SELECTED_ITEM_END, this._listViewEventListener && this._listViewEventSelector && this._listViewEventSelector.call(this._listViewEventListener, this, a), this._eventCallback && this._eventCallback(this, a)
    },
    interceptTouchEvent: function(a, b, c) {
        if (ccui.ScrollView.prototype.interceptTouchEvent.call(this, a, b, c), a != ccui.Widget.TOUCH_MOVED) {
            for (c = b; c;) {
                if (c && c.getParent() == this._innerContainer) {
                    this._curSelectedIndex = this.getIndex(c);
                    break
                }
                c = c.getParent()
            }
            b.isHighlighted() && this._selectedItemEvent(a)
        }
    },
    getCurSelectedIndex: function() {
        return this._curSelectedIndex
    },
    _onSizeChanged: function() {
        ccui.ScrollView.prototype._onSizeChanged.call(this), this._refreshViewDirty = !0
    },
    getDescription: function() {
        return "ListView"
    },
    _createCloneInstance: function() {
        return ccui.ListView.create()
    },
    _copyClonedWidgetChildren: function(a) {
        a = a.getItems();
        for (var b = 0; b < a.length; b++) this.pushBackCustomItem(a[b].clone())
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ListView && (ccui.ScrollView.prototype._copySpecialProperties.call(this, a), this.setItemModel(a._model), this.setItemsMargin(a._itemsMargin), this.setGravity(a._gravity), this._listViewEventListener = a._listViewEventListener, this._listViewEventSelector = a._listViewEventSelector, this._eventCallback = a._eventCallback)
    }
}), ccui.ListView.create = function() {
    return new ccui.ListView
}, ccui.ListView.EVENT_SELECTED_ITEM = 0, ccui.ListView.ON_SELECTED_ITEM_START = 0, ccui.ListView.ON_SELECTED_ITEM_END = 1, ccui.ListView.GRAVITY_LEFT = 0, ccui.ListView.GRAVITY_RIGHT = 1, ccui.ListView.GRAVITY_CENTER_HORIZONTAL = 2, ccui.ListView.GRAVITY_TOP = 3, ccui.ListView.GRAVITY_BOTTOM = 4, ccui.ListView.GRAVITY_CENTER_VERTICAL = 5, ccui.PageView = ccui.Layout.extend({
    _curPageIdx: 0,
    _pages: null,
    _touchMoveDirection: null,
    _touchStartLocation: 0,
    _touchMoveStartLocation: 0,
    _movePagePoint: null,
    _leftBoundaryChild: null,
    _rightBoundaryChild: null,
    _leftBoundary: 0,
    _rightBoundary: 0,
    _isAutoScrolling: !1,
    _autoScrollDistance: 0,
    _autoScrollSpeed: 0,
    _autoScrollDirection: 0,
    _childFocusCancelOffset: 0,
    _pageViewEventListener: null,
    _pageViewEventSelector: null,
    _className: "PageView",
    _eventCallback: null,
    ctor: function() {
        ccui.Layout.prototype.ctor.call(this), this._pages = [], this._touchMoveDirection = ccui.PageView.TOUCH_DIR_LEFT, this._rightBoundaryChild = this._leftBoundaryChild = this._movePagePoint = null, this._childFocusCancelOffset = 5, this._pageViewEventSelector = this._pageViewEventListener = null, this.setTouchEnabled(!0)
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setClippingEnabled(!0), !0) : !1
    },
    onEnter: function() {
        ccui.Layout.prototype.onEnter.call(this), this.scheduleUpdate(!0)
    },
    addWidgetToPage: function(a, b, c) {
        if (a && !(0 > b)) {
            var d = this._getPageCount();
            0 > b || b >= d ? c && (b > d && cc.log("pageIdx is %d, it will be added as page id [%d]", b, d), b = this._createPage(), b.addChild(a), this.addPage(b)) : (b = this._pages[b]) && b.addChild(a)
        }
    },
    _createPage: function() {
        var a = ccui.Layout.create();
        return a.setContentSize(this.getContentSize()), a
    },
    addPage: function(a) {
        a && -1 == this._pages.indexOf(a) && (this.addChild(a), this._pages.push(a), this._doLayoutDirty = !0)
    },
    insertPage: function(a, b) {
        if (!(0 > b) && a && -1 == this._pages.indexOf(a)) {
            var c = this._getPageCount();
            b >= c ? this.addPage(a) : (this._pages[b] = a, this.addChild(a)), this._doLayoutDirty = !0
        }
    },
    removePage: function(a) {
        a && (this.removeChild(a), a = this._pages.indexOf(a), a > -1 && this._pages.splice(a, 1), this._doLayoutDirty = !0)
    },
    removePageAtIndex: function(a) {
        0 > a || a >= this._pages.length || (a = this._pages[a]) && this.removePage(a)
    },
    removeAllPages: function() {
        for (var a = this._pages, b = 0, c = a.length; c > b; b++) this.removeChild(a[b]);
        this._pages.length = 0
    },
    _updateBoundaryPages: function() {
        var a = this._pages;
        0 >= a.length ? this._rightBoundaryChild = this._leftBoundaryChild = null : (this._leftBoundaryChild = a[0], this._rightBoundaryChild = a[a.length - 1])
    },
    _getPageCount: function() {
        return this._pages.length
    },
    _getPositionXByIndex: function(a) {
        return this.getContentSize().width * (a - this._curPageIdx)
    },
    _onSizeChanged: function() {
        ccui.Layout.prototype._onSizeChanged.call(this), this._rightBoundary = this.getContentSize().width, this._doLayoutDirty = !0
    },
    _updateAllPagesSize: function() {
        for (var a = this.getContentSize(), b = this._pages, c = 0, d = b.length; d > c; c++) b[c].setContentSize(a)
    },
    _updateAllPagesPosition: function() {
        var a = this._getPageCount();
        if (0 >= a) this._curPageIdx = 0;
        else {
            this._curPageIdx >= a && (this._curPageIdx = a - 1);
            for (var b = this.getContentSize().width, c = this._pages, d = 0; a > d; d++) c[d].setPosition(cc.p((d - this._curPageIdx) * b, 0))
        }
    },
    scrollToPage: function(a) {
        0 > a || a >= this._pages.length || (this._curPageIdx = a, this._autoScrollDistance = -this._pages[a].getPosition().x, this._autoScrollSpeed = Math.abs(this._autoScrollDistance) / .2, this._autoScrollDirection = 0 < this._autoScrollDistance ? ccui.PageView.DIRECTION_RIGHT : ccui.PageView.DIRECTION_LEFT, this._isAutoScrolling = !0)
    },
    update: function(a) {
        this._isAutoScrolling && this._autoScroll(a)
    },
    setLayoutType: function() {},
    getLayoutType: function() {
        return ccui.Layout.ABSOLUTE
    },
    _autoScroll: function(a) {
        switch (this._autoScrollDirection) {
            case ccui.PageView.DIRECTION_LEFT:
                a *= this._autoScrollSpeed, 0 <= this._autoScrollDistance + a ? (a = -this._autoScrollDistance, this._autoScrollDistance = 0, this._isAutoScrolling = !1) : this._autoScrollDistance += a, this._scrollPages(-a), this._isAutoScrolling || this._pageTurningEvent();
                break;
            case ccui.PageView.DIRECTION_RIGHT:
                a *= this._autoScrollSpeed, 0 >= this._autoScrollDistance - a ? (a = this._autoScrollDistance, this._autoScrollDistance = 0, this._isAutoScrolling = !1) : this._autoScrollDistance -= a, this._scrollPages(a), this._isAutoScrolling || this._pageTurningEvent()
        }
    },
    onTouchMoved: function(a) {
        this._handleMoveLogic(a);
        var b = this.getWidgetParent();
        b && b.interceptTouchEvent(ccui.Widget.TOUCH_MOVED, this, a), this._moveEvent()
    },
    onTouchEnded: function(a, b) {
        ccui.Layout.prototype.onTouchEnded.call(this, a, b), this._handleReleaseLogic(a)
    },
    onTouchCancelled: function(a, b) {
        ccui.Layout.prototype.onTouchCancelled.call(this, a, b), this._handleReleaseLogic(a)
    },
    _doLayout: function() {
        this._doLayoutDirty && (this._updateAllPagesPosition(), this._updateAllPagesSize(), this._updateBoundaryPages(), this._doLayoutDirty = !1)
    },
    _movePages: function(a) {
        for (var b = this._pages, c = b.length, d = 0; c > d; d++) {
            var e = b[d];
            e.setPositionX(e.getPositionX() + a)
        }
    },
    _scrollPages: function(a) {
        if (0 >= this._pages.length || !this._leftBoundaryChild || !this._rightBoundaryChild) return !1;
        var b = a;
        switch (this._touchMoveDirection) {
            case ccui.PageView.TOUCH_DIR_LEFT:
                var c = this._rightBoundaryChild.getRightBoundary();
                if (c + a <= this._rightBoundary) return b = this._rightBoundary - c, this._movePages(b), !1;
                break;
            case ccui.PageView.TOUCH_DIR_RIGHT:
                if (c = this._leftBoundaryChild.getLeftBoundary(), c + a >= this._leftBoundary) return b = this._leftBoundary - c, this._movePages(b), !1
        }
        return this._movePages(b), !0
    },
    _handleMoveLogic: function(a) {
        a = a.getLocation().x - a.getPreviousLocation().x, 0 > a ? this._touchMoveDirection = ccui.PageView.TOUCH_DIR_LEFT : a > 0 && (this._touchMoveDirection = ccui.PageView.TOUCH_DIR_RIGHT), this._scrollPages(a)
    },
    _handleReleaseLogic: function(a) {
        if (!(0 >= this._pages.length) && (a = this._pages[this._curPageIdx])) {
            var b = a.getPosition();
            a = this._pages.length;
            var b = b.x,
                c = this.getSize().width / 2; - c >= b ? this._curPageIdx >= a - 1 ? this._scrollPages(-b) : this.scrollToPage(this._curPageIdx + 1) : b >= c ? 0 >= this._curPageIdx ? this._scrollPages(-b) : this.scrollToPage(this._curPageIdx - 1) : this.scrollToPage(this._curPageIdx)
        }
    },
    interceptTouchEvent: function(a, b, c) {
        var d = c.getLocation();
        switch (a) {
            case ccui.Widget.TOUCH_BEGAN:
                this._touchBeganPosition.x = d.x, this._touchBeganPosition.y = d.y;
                break;
            case ccui.Widget.TOUCH_MOVED:
                this._touchMovePosition.x = d.x, this._touchMovePosition.y = d.y, a = 0, a = Math.abs(b.getTouchBeganPosition().x - d.x), a > this._childFocusCancelOffset && (b.setFocused(!1), this._handleMoveLogic(c));
                break;
            case ccui.Widget.TOUCH_ENDED:
                this._touchEndPosition.x = d.x, this._touchEndPosition.y = d.y;
                break;
            case ccui.Widget.TOUCH_CANCELED:
                this._handleReleaseLogic(c)
        }
    },
    _pageTurningEvent: function() {
        this._pageViewEventListener && this._pageViewEventSelector && this._pageViewEventSelector.call(this._pageViewEventListener, this, ccui.PageView.EVENT_TURNING), this._eventCallback && this._eventCallback(this, ccui.PageView.EVENT_TURNING)
    },
    addEventListenerPageView: function(a, b) {
        this._pageViewEventSelector = a, this._pageViewEventListener = b
    },
    addEventListener: function(a) {
        this._eventCallback = a
    },
    getCurPageIndex: function() {
        return this._curPageIdx
    },
    getPages: function() {
        return this._pages
    },
    getPage: function(a) {
        return 0 > a || a >= this.getPages().size() ? null : this._pages[a]
    },
    getDescription: function() {
        return "PageView"
    },
    _createCloneInstance: function() {
        return ccui.PageView.create()
    },
    _copyClonedWidgetChildren: function(a) {
        a = a.getPages();
        for (var b = 0; b < a.length; b++) this.addPage(a[b].clone())
    },
    _copySpecialProperties: function(a) {
        ccui.Layout.prototype._copySpecialProperties.call(this, a), this._eventCallback = a._eventCallback, this._pageViewEventListener = a._pageViewEventListener, this._pageViewEventSelector = a._pageViewEventSelector
    }
}), ccui.PageView.create = function() {
    return new ccui.PageView
}, ccui.PageView.EVENT_TURNING = 0, ccui.PageView.TOUCH_DIR_LEFT = 0, ccui.PageView.TOUCH_DIR_RIGHT = 1, ccui.PageView.DIRECTION_LEFT = 0, ccui.PageView.DIRECTION_RIGHT = 1, cc.Component = cc.Class.extend({
    _owner: null,
    _name: "",
    _enabled: !0,
    ctor: function() {
        this._owner = null, this._name = "", this._enabled = !0
    },
    init: function() {
        return !0
    },
    onEnter: function() {},
    onExit: function() {},
    update: function() {},
    serialize: function() {},
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    getName: function() {
        return this._name
    },
    setName: function(a) {
        this._name = a
    },
    setOwner: function(a) {
        this._owner = a
    },
    getOwner: function() {
        return this._owner
    }
}), cc.Component.create = function() {
    return new cc.Component
}, cc.ComponentContainer = cc.Class.extend({
    _components: null,
    _owner: null,
    ctor: function(a) {
        this._components = null, this._owner = a
    },
    getComponent: function(a) {
        if (!a) throw "cc.ComponentContainer.getComponent(): name should be non-null";
        return a = a.trim(), this._components[a]
    },
    add: function(a) {
        if (!a) throw "cc.ComponentContainer.add(): component should be non-null";
        return a.getOwner() ? (cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again"), !1) : (null == this._components && (this._components = {}, this._owner.scheduleUpdate()), this._components[a.getName()] ? (cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again"), !1) : (a.setOwner(this._owner), this._components[a.getName()] = a, a.onEnter(), !0))
    },
    remove: function(a) {
        if (!a) throw "cc.ComponentContainer.remove(): name should be non-null";
        return this._components ? a instanceof cc.Component ? this._removeByComponent(a) : (a = a.trim(), this._removeByComponent(this._components[a])) : !1
    },
    _removeByComponent: function(a) {
        return a ? !1 : (a.onExit(), a.setOwner(null), delete this._components[a.getName()], !0)
    },
    removeAll: function() {
        if (this._components) {
            var a, b = this._components;
            for (a in b) {
                var c = b[a];
                c.onExit(), c.setOwner(null), delete b[a]
            }
            this._owner.unscheduleUpdate(), this._components = null
        }
    },
    _alloc: function() {
        this._components = {}
    },
    visit: function(a) {
        if (this._components) {
            var b, c = this._components;
            for (b in c) c[b].update(a)
        }
    },
    isEmpty: function() {
        if (!this._components) return !0;
        for (var a in this._components) return !1;
        return !0
    }
});
var ccs = ccs || {};
ccs.Class = ccs.Class || cc.Class, ccs.Class.extend = ccs.Class.extend || cc.Class.extend, ccs.Node = ccs.Node || cc.Node, ccs.Node.extend = ccs.Node.extend || cc.Node.extend, ccs.Sprite = ccs.Sprite || cc.Sprite, ccs.Sprite.extend = ccs.Sprite.extend || cc.Sprite.extend, ccs.Component = ccs.Component || cc.Component, ccs.Component.extend = ccs.Component.extend || cc.Component.extend, ccs.cocostudioVersion = "v1.3.0.0", ccs.VERSION_COMBINED = .3, ccs.VERSION_CHANGE_ROTATION_RANGE = 1, ccs.VERSION_COLOR_READING = 1.1, ccs.MAX_VERTEXZ_VALUE = 5e6, ccs.ARMATURE_MAX_CHILD = 50, ccs.ARMATURE_MAX_ZORDER = 100, ccs.ARMATURE_MAX_COUNT = ccs.MAX_VERTEXZ_VALUE / ccs.ARMATURE_MAX_CHILD / ccs.ARMATURE_MAX_ZORDER, ccs.AUTO_ADD_SPRITE_FRAME_NAME_PREFIX = !1, ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT = !1, ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX = !1, ccs.armatureVersion = function() {
    return "v1.1.0.0"
}, ccs.CONST_VERSION = "version", ccs.CONST_VERSION_2_0 = 2, ccs.CONST_VERSION_COMBINED = .3, ccs.CONST_ARMATURES = "armatures", ccs.CONST_ARMATURE = "armature", ccs.CONST_BONE = "b", ccs.CONST_DISPLAY = "d", ccs.CONST_ANIMATIONS = "animations", ccs.CONST_ANIMATION = "animation", ccs.CONST_MOVEMENT = "mov", ccs.CONST_FRAME = "f", ccs.CONST_TEXTURE_ATLAS = "TextureAtlas", ccs.CONST_SUB_TEXTURE = "SubTexture", ccs.CONST_SKELETON = "skeleton", ccs.CONST_A_NAME = "name", ccs.CONST_A_DURATION = "dr", ccs.CONST_A_FRAME_INDEX = "fi", ccs.CONST_A_DURATION_TO = "to", ccs.CONST_A_DURATION_TWEEN = "drTW", ccs.CONST_A_LOOP = "lp", ccs.CONST_A_MOVEMENT_SCALE = "sc", ccs.CONST_A_MOVEMENT_DELAY = "dl", ccs.CONST_A_DISPLAY_INDEX = "dI", ccs.CONST_A_PLIST = "plist", ccs.CONST_A_PARENT = "parent", ccs.CONST_A_SKEW_X = "kX", ccs.CONST_A_SKEW_Y = "kY", ccs.CONST_A_SCALE_X = "cX", ccs.CONST_A_SCALE_Y = "cY", ccs.CONST_A_Z = "z", ccs.CONST_A_EVENT = "evt", ccs.CONST_A_SOUND = "sd", ccs.CONST_A_SOUND_EFFECT = "sdE", ccs.CONST_A_TWEEN_EASING = "twE", ccs.CONST_A_EASING_PARAM = "twEP", ccs.CONST_A_TWEEN_ROTATE = "twR", ccs.CONST_A_IS_ARMATURE = "isArmature", ccs.CONST_A_DISPLAY_TYPE = "displayType", ccs.CONST_A_MOVEMENT = "mov", ccs.CONST_A_X = "x", ccs.CONST_A_Y = "y", ccs.CONST_A_COCOS2DX_X = "cocos2d_x", ccs.CONST_A_COCOS2DX_Y = "cocos2d_y", ccs.CONST_A_WIDTH = "width", ccs.CONST_A_HEIGHT = "height", ccs.CONST_A_PIVOT_X = "pX", ccs.CONST_A_PIVOT_Y = "pY", ccs.CONST_A_COCOS2D_PIVOT_X = "cocos2d_pX", ccs.CONST_A_COCOS2D_PIVOT_Y = "cocos2d_pY", ccs.CONST_A_BLEND_TYPE = "bd", ccs.CONST_A_BLEND_SRC = "bd_src", ccs.CONST_A_BLEND_DST = "bd_dst", ccs.CONST_A_ALPHA = "a", ccs.CONST_A_RED = "r", ccs.CONST_A_GREEN = "g", ccs.CONST_A_BLUE = "b", ccs.CONST_A_ALPHA_OFFSET = "aM", ccs.CONST_A_RED_OFFSET = "rM", ccs.CONST_A_GREEN_OFFSET = "gM", ccs.CONST_A_BLUE_OFFSET = "bM", ccs.CONST_A_COLOR_TRANSFORM = "colorTransform", ccs.CONST_A_TWEEN_FRAME = "tweenFrame", ccs.CONST_CONTOUR = "con", ccs.CONST_CONTOUR_VERTEX = "con_vt", ccs.CONST_FL_NAN = "NaN", ccs.CONST_FRAME_DATA = "frame_data", ccs.CONST_MOVEMENT_BONE_DATA = "mov_bone_data", ccs.CONST_MOVEMENT_DATA = "mov_data", ccs.CONST_ANIMATION_DATA = "animation_data", ccs.CONST_DISPLAY_DATA = "display_data", ccs.CONST_SKIN_DATA = "skin_data", ccs.CONST_BONE_DATA = "bone_data", ccs.CONST_ARMATURE_DATA = "armature_data", ccs.CONST_CONTOUR_DATA = "contour_data", ccs.CONST_TEXTURE_DATA = "texture_data", ccs.CONST_VERTEX_POINT = "vertex", ccs.CONST_COLOR_INFO = "color", ccs.CONST_CONFIG_FILE_PATH = "config_file_path", ccs.CONST_CONTENT_SCALE = "content_scale", ccs.DataInfo = function() {
    this.asyncStruct = null, this.configFileQueue = [], this.contentScale = 1, this.baseFilePath = this.filename = "", this.cocoStudioVersion = this.flashToolVersion = 0
}, ccs.dataReaderHelper = {
    ConfigType: {
        DragonBone_XML: 0,
        CocoStudio_JSON: 1,
        CocoStudio_Binary: 2
    },
    _configFileList: [],
    _flashToolVersion: ccs.CONST_VERSION_2_0,
    _positionReadScale: 1,
    _asyncRefCount: 0,
    _asyncRefTotalCount: 0,
    _dataQueue: null,
    setPositionReadScale: function(a) {
        this._positionReadScale = a
    },
    getPositionReadScale: function() {
        return this._positionReadScale
    },
    addDataFromFile: function(a) {
        if (-1 == this._configFileList.indexOf(a)) {
            this._configFileList.push(a);
            var b = this._initBaseFilePath(a),
                c = cc.path.extname(a).toLowerCase(),
                d = new ccs.DataInfo;
            d.filename = a, d.basefilePath = b, ".xml" == c ? ccs.dataReaderHelper.addDataFromXML(a, d) : ".json" == c || ".exportjson" == c ? ccs.dataReaderHelper.addDataFromJson(a, d) : ".csb" == c && ccs.dataReaderHelper.addDataFromBinaryCache(a, d)
        }
    },
    addDataFromFileAsync: function(a, b, c, d, e) {
        if (-1 != this._configFileList.indexOf(c)) e && d && (0 == this._asyncRefTotalCount && 0 == this._asyncRefCount ? this._asyncCallBack(d, e, 1) : this._asyncCallBack(d, e, (this._asyncRefTotalCount - this._asyncRefCount) / this._asyncRefTotalCount));
        else {
            this._asyncRefTotalCount++, this._asyncRefCount++;
            var f = this;
            cc.director.getScheduler().scheduleCallbackForTarget(this, function() {
                f.addDataFromFile(c), f._asyncRefCount--, f._asyncCallBack(d, e, (f._asyncRefTotalCount - f._asyncRefCount) / f._asyncRefTotalCount)
            }, .1, !1)
        }
    },
    removeConfigFile: function(a) {
        for (var b = this._configFileList, c = b.length, d = b[c], e = 0; c > e; e++) b[e] == a && (d = e);
        d != b[c] && cc.arrayRemoveObject(b, a)
    },
    addDataFromCache: function(a, b) {
        if (a) {
            b.flashToolVersion = parseFloat(a.getAttribute(ccs.CONST_VERSION));
            var c, d = a.querySelectorAll(ccs.CONST_SKELETON + " > " + ccs.CONST_ARMATURES + " >  " + ccs.CONST_ARMATURE),
                e = ccs.armatureDataManager;
            for (c = 0; c < d.length; c++) {
                var f = this.decodeArmature(d[c], b);
                e.addArmatureData(f.name, f, b.filename)
            }
            for (d = a.querySelectorAll(ccs.CONST_SKELETON + " > " + ccs.CONST_ANIMATIONS + " >  " + ccs.CONST_ANIMATION), c = 0; c < d.length; c++) f = this.decodeAnimation(d[c], b), e.addAnimationData(f.name, f, b.filename);
            for (d = a.querySelectorAll(ccs.CONST_SKELETON + " > " + ccs.CONST_TEXTURE_ATLAS + " >  " + ccs.CONST_SUB_TEXTURE), c = 0; c < d.length; c++) f = this.decodeTexture(d[c], b), e.addTextureData(f.name, f, b.filename)
        } else cc.log("XML error  or  XML is empty.")
    },
    decodeArmature: function(a, b) {
        var c = new ccs.ArmatureData;
        c.init(), c.name = a.getAttribute(ccs.CONST_A_NAME);
        for (var d = a.querySelectorAll(ccs.CONST_ARMATURE + " > " + ccs.CONST_BONE), e = 0; e < d.length; e++) {
            var f = d[e],
                g = f.getAttribute(ccs.CONST_A_PARENT),
                h = null;
            if (g)
                for (var i = 0; i < d.length && (h = d[i], !(g == d[i].getAttribute(ccs.CONST_A_NAME))); i++);
            f = this.decodeBone(f, h, b), c.addBoneData(f)
        }
        return c
    },
    decodeArmatureFromJSON: function(a, b) {
        var c = new ccs.ArmatureData;
        c.init();
        var d = a[ccs.CONST_A_NAME];
        d && (c.name = d), b.cocoStudioVersion = c.dataVersion = a[ccs.CONST_VERSION] || .1;
        for (var d = a[ccs.CONST_BONE_DATA], e = 0; e < d.length; e++) {
            var f = this.decodeBoneFromJson(d[e], b);
            c.addBoneData(f)
        }
        return c
    },
    decodeBone: function(a, b, c) {
        b = new ccs.BoneData, b.init(), b.name = a.getAttribute(ccs.CONST_A_NAME), b.parentName = a.getAttribute(ccs.CONST_A_PARENT) || "", b.zOrder = parseInt(a.getAttribute(ccs.CONST_A_Z)) || 0, a = a.querySelectorAll(ccs.CONST_BONE + " > " + ccs.CONST_DISPLAY);
        for (var d = 0; d < a.length; d++) {
            var e = this.decodeBoneDisplay(a[d], c);
            b.addDisplayData(e)
        }
        return b
    },
    decodeBoneFromJson: function(a, b) {
        var c = new ccs.BoneData;
        c.init(), this.decodeNodeFromJson(c, a, b), c.name = a[ccs.CONST_A_NAME] || "", c.parentName = a[ccs.CONST_A_PARENT] || "";
        for (var d = a[ccs.CONST_DISPLAY_DATA] || [], e = 0; e < d.length; e++) {
            var f = this.decodeBoneDisplayFromJson(d[e], b);
            c.addDisplayData(f)
        }
        return c
    },
    decodeBoneDisplay: function(a) {
        var b = null;
        1 == (parseFloat(a.getAttribute(ccs.CONST_A_IS_ARMATURE)) || 0) ? (b = new ccs.ArmatureDisplayData, b.displayType = ccs.DISPLAY_TYPE_ARMATURE) : (b = new ccs.SpriteDisplayData, b.displayType = ccs.DISPLAY_TYPE_SPRITE);
        var c = a.getAttribute(ccs.CONST_A_NAME) || "";
        return c && (b.displayName = c), b
    },
    decodeBoneDisplayFromJson: function(a, b) {
        var c = a[ccs.CONST_A_DISPLAY_TYPE] || ccs.DISPLAY_TYPE_SPRITE,
            d = null;
        switch (c) {
            case ccs.DISPLAY_TYPE_SPRITE:
                var d = new ccs.SpriteDisplayData,
                    e = a[ccs.CONST_A_NAME];
                if (null != e && (d.displayName = e), e = (a[ccs.CONST_SKIN_DATA] || [])[0]) {
                    var f = d.skinData;
                    f.x = e[ccs.CONST_A_X] * this._positionReadScale, f.y = e[ccs.CONST_A_Y] * this._positionReadScale, f.scaleX = null == e[ccs.CONST_A_SCALE_X] ? 1 : e[ccs.CONST_A_SCALE_X], f.scaleY = null == e[ccs.CONST_A_SCALE_Y] ? 1 : e[ccs.CONST_A_SCALE_Y], f.skewX = null == e[ccs.CONST_A_SKEW_X] ? 1 : e[ccs.CONST_A_SKEW_X], f.skewY = null == e[ccs.CONST_A_SKEW_Y] ? 1 : e[ccs.CONST_A_SKEW_Y], f.x *= b.contentScale, f.y *= b.contentScale
                }
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                d = new ccs.ArmatureDisplayData, e = a[ccs.CONST_A_NAME], null != e && (d.displayName = a[ccs.CONST_A_NAME]);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                d = new ccs.ParticleDisplayData, e = a[ccs.CONST_A_PLIST], null != e && (d.displayName = b.asyncStruct ? b.asyncStruct.basefilePath + e : b.basefilePath + e);
                break;
            default:
                d = new ccs.SpriteDisplayData
        }
        return d.displayType = c, d
    },
    decodeAnimation: function(a, b) {
        var c = new ccs.AnimationData,
            d = a.getAttribute(ccs.CONST_A_NAME),
            e = ccs.armatureDataManager.getArmatureData(d);
        c.name = d;
        for (var d = a.querySelectorAll(ccs.CONST_ANIMATION + " > " + ccs.CONST_MOVEMENT), f = null, g = 0; g < d.length; g++) f = d[g], f = this.decodeMovement(f, e, b), c.addMovement(f);
        return c
    },
    decodeAnimationFromJson: function(a, b) {
        var c = new ccs.AnimationData;
        a[ccs.CONST_A_NAME] && (c.name = a[ccs.CONST_A_NAME]);
        for (var d = a[ccs.CONST_MOVEMENT_DATA] || [], e = 0; e < d.length; e++) {
            var f = this.decodeMovementFromJson(d[e], b);
            c.addMovement(f)
        }
        return c
    },
    decodeMovement: function(a, b, c) {
        var d = new ccs.MovementData;
        d.name = a.getAttribute(ccs.CONST_A_NAME);
        var e;
        e = 0, e = a.getAttribute(ccs.CONST_A_DURATION), d.duration = null == e ? 0 : parseFloat(e), e = a.getAttribute(ccs.CONST_A_DURATION_TO), d.durationTo = null == e ? 0 : parseFloat(e), e = a.getAttribute(ccs.CONST_A_DURATION_TWEEN), d.durationTween = null == e ? 0 : parseFloat(e), e = a.getAttribute(ccs.CONST_A_LOOP), d.loop = e ? Boolean(parseFloat(e)) : !0, (e = a.getAttribute(ccs.CONST_A_TWEEN_EASING)) && (e != ccs.CONST_FL_NAN ? (e = null == e ? 0 : parseFloat(e), d.tweenEasing = 2 == e ? ccs.TweenType.sineEaseInOut : e) : d.tweenEasing = ccs.TweenType.linear), a = a.querySelectorAll(ccs.CONST_MOVEMENT + " > " + ccs.CONST_BONE);
        var f = null;
        for (e = 0; e < a.length; e++) {
            var f = a[e],
                g = f.getAttribute(ccs.CONST_A_NAME);
            if (!d.getMovementBoneData(g)) {
                var g = b.getBoneData(g),
                    h = g.parentName,
                    i = null;
                if ("" != h)
                    for (var j = 0; j < a.length && (i = a[j], !(h == i.getAttribute(ccs.CONST_A_NAME))); j++);
                f = this.decodeMovementBone(f, i, g, c), d.addMovementBoneData(f)
            }
        }
        return d
    },
    decodeMovementFromJson: function(a, b) {
        var c = new ccs.MovementData;
        c.loop = null == a[ccs.CONST_A_LOOP] ? !1 : a[ccs.CONST_A_LOOP], c.durationTween = a[ccs.CONST_A_DURATION_TWEEN] || 0, c.durationTo = a[ccs.CONST_A_DURATION_TO] || 0, c.duration = a[ccs.CONST_A_DURATION] || 0, c.scale = null == a[ccs.CONST_A_DURATION] ? 1 : null == a[ccs.CONST_A_MOVEMENT_SCALE] ? 1 : a[ccs.CONST_A_MOVEMENT_SCALE], c.tweenEasing = null == a[ccs.CONST_A_TWEEN_EASING] ? ccs.TweenType.linear : a[ccs.CONST_A_TWEEN_EASING];
        var d = a[ccs.CONST_A_NAME];
        d && (c.name = d);
        for (var d = a[ccs.CONST_MOVEMENT_BONE_DATA] || [], e = 0; e < d.length; e++) {
            var f = this.decodeMovementBoneFromJson(d[e], b);
            c.addMovementBoneData(f)
        }
        return c
    },
    decodeMovementBone: function(a, b, c, d) {
        var e = new ccs.MovementBoneData;
        e.init();
        var f;
        a && (f = parseFloat(a.getAttribute(ccs.CONST_A_MOVEMENT_SCALE)) || 0, e.scale = f, f = parseFloat(a.getAttribute(ccs.CONST_A_MOVEMENT_DELAY)) || 0, f > 0 && (f -= 1), e.delay = f);
        var g = 0,
            h = f = 0,
            i = null,
            j = [];
        if (null != b) {
            for (var k = b.querySelectorAll(ccs.CONST_BONE + " > " + ccs.CONST_FRAME), g = 0; g < k.length; g++) j.push(k[g]);
            g = j.length
        }
        e.name = a.getAttribute(ccs.CONST_A_NAME), a = a.querySelectorAll(ccs.CONST_BONE + " > " + ccs.CONST_FRAME);
        for (var l = k = 0, m = 0; m < a.length; m++) {
            var n = a[m];
            if (b)
                for (; g > k && (i ? f > l || l >= f + h : 1);) i = j[k], f += h, h = parseFloat(i.getAttribute(ccs.CONST_A_DURATION)), k++;
            n = this.decodeFrame(n, i, c, d), e.addFrameData(n), n.frameID = l, l += n.duration, e.duration = l
        }
        for (b = e.frameList, c = Math.PI, g = b.length - 1; g >= 0; g--) g > 0 && (d = b[g].skewX - b[g - 1].skewX, f = b[g].skewY - b[g - 1].skewY, (-c > d || d > c) && (b[g - 1].skewX = 0 > d ? b[g - 1].skewX - 2 * c : b[g - 1].skewX + 2 * c), (-c > f || f > c) && (b[g - 1].skewY = 0 > f ? b[g - 1].skewY - 2 * c : b[g - 1].skewY + 2 * c));
        return b = new ccs.FrameData, b.copy(e.frameList[e.frameList.length - 1]), b.frameID = e.duration, e.addFrameData(b), e
    },
    decodeMovementBoneFromJson: function(a, b) {
        var c = new ccs.MovementBoneData;
        c.init(), c.delay = a[ccs.CONST_A_MOVEMENT_DELAY] || 0;
        var d = a[ccs.CONST_A_NAME];
        d && (c.name = d);
        for (var e = (a[ccs.CONST_FRAME_DATA] || []).length, d = 0; e > d; d++) {
            var f = this.decodeFrameFromJson(a[ccs.CONST_FRAME_DATA][d], b);
            c.addFrameData(f), b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED && (f.frameID = c.duration, c.duration += f.duration)
        }
        if (b.cocoStudioVersion < ccs.VERSION_CHANGE_ROTATION_RANGE)
            for (e = c.frameList, f = Math.PI, d = e.length - 1; d >= 0; d--)
                if (d > 0) {
                    var g = e[d].skewX - e[d - 1].skewX,
                        h = e[d].skewY - e[d - 1].skewY;
                    (-f > g || g > f) && (e[d - 1].skewX = 0 > g ? e[d - 1].skewX - 2 * f : e[d - 1].skewX + 2 * f), (-f > h || h > f) && (e[d - 1].skewY = 0 > h ? e[d - 1].skewY - 2 * f : e[d - 1].skewY + 2 * f)
                }
        return b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED && 0 < c.frameList.length && (f = new ccs.FrameData, f.copy(c.frameList[c.frameList.length - 1]), c.addFrameData(f), f.frameID = c.duration), c
    },
    decodeFrame: function(a, b, c, d) {
        var e = 0,
            e = e = e = e = e = e = e = e = e = e = e = 0;
        if (c = new ccs.FrameData, c.strMovement = a.getAttribute(ccs.CONST_A_MOVEMENT) || "", c.movement = c.strMovement, c.strEvent = a.getAttribute(ccs.CONST_A_EVENT) || "", c.event = c.strEvent, c.strSound = a.getAttribute(ccs.CONST_A_SOUND) || "", c.sound = c.strSound, c.strSoundEffect = a.getAttribute(ccs.CONST_A_SOUND_EFFECT) || "", c.soundEffect = c.strSoundEffect, e = a.getAttribute(ccs.CONST_A_TWEEN_FRAME), c.isTween = !(void 0 != e && "false" == e), d.flashToolVersion >= ccs.CONST_VERSION_2_0 ? ((e = a.getAttribute(ccs.CONST_A_COCOS2DX_X)) && (c.x = parseFloat(e), c.x *= this._positionReadScale), e = a.getAttribute(ccs.CONST_A_COCOS2DX_Y)) : ((e = a.getAttribute(ccs.CONST_A_X)) && (c.x = parseFloat(e), c.x *= this._positionReadScale), e = a.getAttribute(ccs.CONST_A_Y)), e && (c.y = -parseFloat(e), c.y *= this._positionReadScale), e = a.getAttribute(ccs.CONST_A_SCALE_X), null != e && (c.scaleX = parseFloat(e)), e = a.getAttribute(ccs.CONST_A_SCALE_Y), null != e && (c.scaleY = parseFloat(e)), e = a.getAttribute(ccs.CONST_A_SKEW_X), null != e && (c.skewX = cc.degreesToRadians(parseFloat(e))), e = a.getAttribute(ccs.CONST_A_SKEW_Y), null != e && (c.skewY = cc.degreesToRadians(-parseFloat(e))), e = a.getAttribute(ccs.CONST_A_DURATION), null != e && (c.duration = parseFloat(e)), e = a.getAttribute(ccs.CONST_A_DISPLAY_INDEX), null != e && (c.displayIndex = parseFloat(e)), e = a.getAttribute(ccs.CONST_A_Z), null != e && (c.zOrder = parseInt(e)), e = a.getAttribute(ccs.CONST_A_TWEEN_ROTATE), null != e && (c.tweenRotate = parseFloat(e)), e = a.getAttribute(ccs.CONST_A_BLEND_TYPE), null != e) {
            var f = c.blendFunc;
            switch (e) {
                case ccs.BLEND_TYPE_NORMAL:
                    f.src = cc.BLEND_SRC, f.dst = cc.BLEND_DST;
                    break;
                case ccs.BLEND_TYPE_ADD:
                    f.src = cc.SRC_ALPHA, f.dst = cc.ONE;
                    break;
                case ccs.BLEND_TYPE_MULTIPLY:
                    f.src = cc.DST_COLOR, f.dst = cc.ONE_MINUS_SRC_ALPHA;
                    break;
                case ccs.BLEND_TYPE_SCREEN:
                    f.src = cc.ONE, f.dst = cc.ONE_MINUS_DST_COLOR;
                    break;
                default:
                    c.blendFunc.src = cc.BLEND_SRC, c.blendFunc.dst = cc.BLEND_DST
            }
        }
        var g = a.querySelectorAll(ccs.CONST_FRAME + " > " + ccs.CONST_A_COLOR_TRANSFORM);
        if (g && 0 < g.length) {
            var h, i, j, k, l, g = g[0],
                e = parseFloat(g.getAttribute(ccs.CONST_A_ALPHA)) || 0,
                f = parseFloat(g.getAttribute(ccs.CONST_A_RED)) || 0;
            h = parseFloat(g.getAttribute(ccs.CONST_A_GREEN)) || 0, i = parseFloat(g.getAttribute(ccs.CONST_A_BLUE)) || 0, j = parseFloat(g.getAttribute(ccs.CONST_A_ALPHA_OFFSET)) || 0, k = parseFloat(g.getAttribute(ccs.CONST_A_RED_OFFSET)) || 0, l = parseFloat(g.getAttribute(ccs.CONST_A_GREEN_OFFSET)) || 0, g = parseFloat(g.getAttribute(ccs.CONST_A_BLUE_OFFSET)) || 0, c.a = 2.55 * j + e, c.r = 2.55 * k + f, c.g = 2.55 * l + h, c.b = 2.55 * g + i, c.isUseColorInfo = !0
        }
        return e = a.getAttribute(ccs.CONST_A_TWEEN_EASING), null != e && (e != ccs.CONST_FL_NAN ? (e = a.getAttribute(ccs.CONST_A_TWEEN_EASING)) && (c.tweenEasing = 2 == e ? ccs.TweenType.sineEaseInOut : e) : c.tweenEasing = ccs.TweenType.linear), b && (a = new ccs.BaseData, d.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (a.x = parseFloat(b.getAttribute(ccs.CONST_A_COCOS2DX_X)), a.y = parseFloat(b.getAttribute(ccs.CONST_A_COCOS2DX_Y))) : (a.x = parseFloat(b.getAttribute(ccs.CONST_A_X)), a.y = parseFloat(b.getAttribute(ccs.CONST_A_Y))), a.skewX = parseFloat(b.getAttribute(ccs.CONST_A_SKEW_X)), a.skewY = parseFloat(b.getAttribute(ccs.CONST_A_SKEW_Y)), a.y = -a.y, a.skewX = cc.degreesToRadians(a.skewX), a.skewY = cc.degreesToRadians(-a.skewY), ccs.TransformHelp.transformFromParent(c, a)), c
    },
    decodeFrameFromJson: function(a, b) {
        var c = new ccs.FrameData;
        this.decodeNodeFromJson(c, a, b), c.tweenEasing = a[ccs.CONST_A_TWEEN_EASING] || ccs.TweenType.linear, c.displayIndex = a[ccs.CONST_A_DISPLAY_INDEX];
        var d = null == a[ccs.CONST_A_BLEND_DST] ? cc.BLEND_DST : a[ccs.CONST_A_BLEND_DST];
        c.blendFunc.src = null == a[ccs.CONST_A_BLEND_SRC] ? cc.BLEND_SRC : a[ccs.CONST_A_BLEND_SRC], c.blendFunc.dst = d, c.isTween = null == a[ccs.CONST_A_TWEEN_FRAME] ? !0 : a[ccs.CONST_A_TWEEN_FRAME], d = a[ccs.CONST_A_EVENT], null != d && (c.strEvent = d, c.event = d), b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED ? c.duration = null == a[ccs.CONST_A_DURATION] ? 1 : a[ccs.CONST_A_DURATION] : c.frameID = a[ccs.CONST_A_FRAME_INDEX];
        for (var d = a[ccs.CONST_A_EASING_PARAM] || [], e = 0; e < d.length; e++) c.easingParams[e] = d[e];
        return c
    },
    decodeTexture: function(a, b) {
        var c = new ccs.TextureData;
        c.init(), a.getAttribute(ccs.CONST_A_NAME) && (c.name = a.getAttribute(ccs.CONST_A_NAME));
        var d, e;
        b.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (d = parseFloat(a.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_X)) || 0, e = parseFloat(a.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_Y)) || 0) : (d = parseFloat(a.getAttribute(ccs.CONST_A_PIVOT_X)) || 0, e = parseFloat(a.getAttribute(ccs.CONST_A_PIVOT_Y)) || 0);
        var f = parseFloat(a.getAttribute(ccs.CONST_A_WIDTH)) || 0,
            g = parseFloat(a.getAttribute(ccs.CONST_A_HEIGHT)) || 0;
        for (c.pivotX = d / f, c.pivotY = (g - e) / g, d = a.querySelectorAll(ccs.CONST_SUB_TEXTURE + " > " + ccs.CONST_CONTOUR), e = 0; e < d.length; e++) c.addContourData(this.decodeContour(d[e], b));
        return c
    },
    decodeTextureFromJson: function(a) {
        var b = new ccs.TextureData;
        b.init();
        var c = a[ccs.CONST_A_NAME];
        for (null != c && (b.name = c), b.width = a[ccs.CONST_A_WIDTH] || 0, b.height = a[ccs.CONST_A_HEIGHT] || 0, b.pivotX = a[ccs.CONST_A_PIVOT_X] || 0, b.pivotY = a[ccs.CONST_A_PIVOT_Y] || 0, a = a[ccs.CONST_CONTOUR_DATA] || [], c = 0; c < a.length; c++) b.contourDataList.push(this.decodeContourFromJson(a[c]));
        return b
    },
    decodeContour: function(a) {
        var b = new ccs.ContourData;
        b.init();
        for (var c, d = a.querySelectorAll(ccs.CONST_CONTOUR + " > " + ccs.CONST_CONTOUR_VERTEX), e = 0; e < d.length; e++) {
            c = d[e];
            var f = cc.p(0, 0);
            f.x = parseFloat(c.getAttribute(ccs.CONST_A_X)) || 0, f.y = parseFloat(c.getAttribute(ccs.CONST_A_Y)) || 0, f.y = -f.y, b.vertexList.push(f)
        }
        return b
    },
    decodeContourFromJson: function(a) {
        var b = new ccs.ContourData;
        b.init(), a = a[ccs.CONST_VERTEX_POINT] || [];
        for (var c = a.length, d = 0; c > d; d++) {
            var e = a[d],
                f = cc.p(0, 0);
            f.x = e[ccs.CONST_A_X] || 0, f.y = e[ccs.CONST_A_Y] || 0, b.vertexList.push(f)
        }
        return b
    },
    addDataFromJsonCache: function(a, b) {
        b.contentScale = null == a[ccs.CONST_CONTENT_SCALE] ? 1 : a[ccs.CONST_CONTENT_SCALE];
        var c, d, e = a[ccs.CONST_ARMATURE_DATA] || [];
        for (c = 0; c < e.length; c++) d = this.decodeArmatureFromJSON(e[c], b), ccs.armatureDataManager.addArmatureData(d.name, d, b.filename);
        for (e = a[ccs.CONST_ANIMATION_DATA] || [], c = 0; c < e.length; c++) d = this.decodeAnimationFromJson(e[c], b), ccs.armatureDataManager.addAnimationData(d.name, d, b.filename);
        for (e = a[ccs.CONST_TEXTURE_DATA] || [], c = 0; c < e.length; c++) d = this.decodeTextureFromJson(e[c], b), ccs.armatureDataManager.addTextureData(d.name, d, b.filename);
        if (null == b.asyncStruct ? ccs.armatureDataManager.isAutoLoadSpriteFile() : b.asyncStruct.autoLoadSpriteFile) {
            var f, e = a[ccs.CONST_CONFIG_FILE_PATH] || [];
            for (c = 0; c < e.length; c++) d = e[c], f = d.lastIndexOf("."), d = d.substring(0, f), f = b.basefilePath + d + ".plist", d = b.basefilePath + d + ".png", ccs.armatureDataManager.addSpriteFrameFromFile(f, d, b.filename)
        }
    },
    decodeNodeFromJson: function(a, b, c) {
        a.x = b[ccs.CONST_A_X] * this._positionReadScale, a.y = b[ccs.CONST_A_Y] * this._positionReadScale, a.x *= c.contentScale, a.y *= c.contentScale, a.zOrder = b[ccs.CONST_A_Z], a.skewX = b[ccs.CONST_A_SKEW_X] || 0, a.skewY = b[ccs.CONST_A_SKEW_Y] || 0, a.scaleX = null == b[ccs.CONST_A_SCALE_X] ? 1 : b[ccs.CONST_A_SCALE_X], a.scaleY = null == b[ccs.CONST_A_SCALE_Y] ? 1 : b[ccs.CONST_A_SCALE_Y], (b = c.cocoStudioVersion < ccs.VERSION_COLOR_READING ? b[0] : b[ccs.CONST_COLOR_INFO] || null) && (a.a = null == b[ccs.CONST_A_ALPHA] ? 255 : b[ccs.CONST_A_ALPHA], a.r = null == b[ccs.CONST_A_RED] ? 255 : b[ccs.CONST_A_RED], a.g = null == b[ccs.CONST_A_GREEN] ? 255 : b[ccs.CONST_A_GREEN], a.b = null == b[ccs.CONST_A_BLUE] ? 255 : b[ccs.CONST_A_BLUE], a.isUseColorInfo = !0)
    },
    clear: function() {
        this._configFileList = [], this._asyncRefTotalCount = this._asyncRefCount = 0
    },
    _asyncCallBack: function(a, b, c) {
        a && "function" == typeof a && a.call(b, c), b && a && "string" == typeof a && b[a](c)
    },
    _initBaseFilePath: function(a) {
        var b = a.lastIndexOf("/");
        return a = b > -1 ? a.substr(0, b + 1) : ""
    },
    addDataFromXML: function(a, b) {
        var c = cc.loader.getRes(a);
        if (!c) throw "Please load the resource first : " + a;
        (c = cc.saxParser.parse(c).documentElement) && this.addDataFromCache(c, b)
    },
    addDataFromJson: function(a, b) {
        var c = cc.loader.getRes(a);
        this.addDataFromJsonCache(c, b)
    }
}, ccs.spriteFrameCacheHelper = {
    _textureAtlasDic: {},
    _imagePaths: [],
    addSpriteFrameFromFile: function(a, b) {
        cc.spriteFrameCache.addSpriteFrames(a, b)
    },
    getTexureAtlasWithTexture: function() {
        return null
    },
    clear: function() {
        this._textureAtlasDic = {}, this._imagePaths = []
    }
}, ccs.TransformHelp = ccs.TransformHelp || ccs.Class.extend({}), ccs.TransformHelp.helpMatrix1 = cc.affineTransformMake(1, 0, 0, 1, 0, 0), ccs.TransformHelp.helpMatrix2 = cc.affineTransformMake(1, 0, 0, 1, 0, 0), ccs.TransformHelp.helpPoint1 = cc.p(0, 0), ccs.TransformHelp.helpPoint2 = cc.p(0, 0), ccs.TransformHelp.helpParentNode = {}, ccs.TransformHelp.transformFromParent = function(a, b) {
    this.nodeToMatrix(a, this.helpMatrix1), this.nodeToMatrix(b, this.helpMatrix2), this.helpMatrix2 = cc.affineTransformInvert(this.helpMatrix2), this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2), this.matrixToNode(this.helpMatrix1, a)
}, ccs.TransformHelp.transformToParent = function(a, b) {
    this.nodeToMatrix(a, this.helpMatrix1), this.nodeToMatrix(b, this.helpMatrix2), this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2), this.matrixToNode(this.helpMatrix1, a)
}, ccs.TransformHelp.transformFromParentWithoutScale = function(a, b) {
    for (var c in b) this.helpParentNode[c] = b[c];
    this.helpParentNode.scaleX = 1, this.helpParentNode.scaleY = 1, this.nodeToMatrix(a, this.helpMatrix1), this.nodeToMatrix(this.helpParentNode, this.helpMatrix2), this.helpMatrix2 = cc.affineTransformInvert(this.helpMatrix2), this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2), this.matrixToNode(this.helpMatrix1, a)
}, ccs.TransformHelp.transformToParentWithoutScale = function(a, b) {
    for (var c in b) this.helpParentNode[c] = b[c];
    this.helpParentNode.scaleX = 1, this.helpParentNode.scaleY = 1, this.nodeToMatrix(a, this.helpMatrix1), this.nodeToMatrix(this.helpParentNode, this.helpMatrix2), this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2), this.matrixToNode(this.helpMatrix1, a)
}, ccs.TransformHelp.nodeToMatrix = function(a, b) {
    if (a.skewX == -a.skewY) {
        var c = Math.sin(a.skewX),
            d = Math.cos(a.skewX);
        b.a = a.scaleX * d, b.b = a.scaleX * -c, b.c = a.scaleY * c, b.d = a.scaleY * d
    } else b.a = a.scaleX * Math.cos(a.skewY), b.b = a.scaleX * Math.sin(a.skewY), b.c = a.scaleY * Math.sin(a.skewX), b.d = a.scaleY * Math.cos(a.skewX);
    b.tx = a.x, b.ty = a.y
}, ccs.TransformHelp.matrixToNode = function(a, b) {
    this.helpPoint1.x = 0, this.helpPoint1.y = 1, this.helpPoint1 = cc.pointApplyAffineTransform(this.helpPoint1, a), this.helpPoint1.x -= a.tx, this.helpPoint1.y -= a.ty, this.helpPoint2.x = 1, this.helpPoint2.y = 0, this.helpPoint2 = cc.pointApplyAffineTransform(this.helpPoint2, a), this.helpPoint2.x -= a.tx, this.helpPoint2.y -= a.ty, b.skewX = -(Math.atan2(this.helpPoint1.y, this.helpPoint1.x) - 1.5707964), b.skewY = Math.atan2(this.helpPoint2.y, this.helpPoint2.x), b.scaleX = Math.sqrt(a.a * a.a + a.b * a.b), b.scaleY = Math.sqrt(a.c * a.c + a.d * a.d), b.x = a.tx, b.y = a.ty
}, ccs.TransformHelp.nodeConcat = function(a, b) {
    a.x += b.x, a.y += b.y, a.skewX += b.skewX, a.skewY += b.skewY, a.scaleX += b.scaleX, a.scaleY += b.scaleY
}, ccs.TransformHelp.nodeSub = function(a, b) {
    a.x -= b.x, a.y -= b.y, a.skewX -= b.skewX, a.skewY -= b.skewY, a.scaleX -= b.scaleX, a.scaleY -= b.scaleY
}, ccs.TweenType = {
    customEasing: -1,
    linear: 0,
    sineEaseIn: 1,
    sineEaseOut: 2,
    sineEaseInOut: 3,
    quadEaseIn: 4,
    quadEaseOut: 5,
    quadEaseInOut: 6,
    cubicEaseIn: 7,
    cubicEaseOut: 8,
    cubicEaseInOut: 9,
    quartEaseIn: 10,
    quartEaseOut: 11,
    quartEaseInOut: 12,
    quintEaseIn: 13,
    quintEaseOut: 14,
    quintEaseInOut: 15,
    expoEaseIn: 16,
    expoEaseOut: 17,
    expoEaseInOut: 18,
    circEaseIn: 19,
    eircEaseOut: 20,
    circEaseInOut: 21,
    elasticEaseIn: 22,
    elasticEaseOut: 23,
    elasticEaseInOut: 24,
    backEaseIn: 25,
    backEaseOut: 26,
    backEaseInOut: 27,
    bounceEaseIn: 28,
    bounceEaseOut: 29,
    bounceEaseInOut: 30,
    tweenEasingMax: 1e4
}, ccs.TweenFunction = ccs.TweenFunction || ccs.Class.extend({}), ccs.DOUBLE_PI = ccs.M_PI_X_2 = 2 * Math.PI, ccs.HALF_PI = ccs.M_PI_2 = Math.PI / 2, ccs.M_PI = Math.PI, ccs.TweenFunction.tweenTo = function(a, b, c) {
    var d = 0;
    switch (b) {
        case ccs.TweenType.customEasing:
            d = this.customEase(a, c);
            break;
        case ccs.TweenType.linear:
            d = this.linear(a);
            break;
        case ccs.TweenType.sineEaseIn:
            d = this.sineEaseIn(a);
            break;
        case ccs.TweenType.sineEaseOut:
            d = this.sineEaseOut(a);
            break;
        case ccs.TweenType.sineEaseInOut:
            d = this.sineEaseInOut(a);
            break;
        case ccs.TweenType.quadEaseIn:
            d = this.quadEaseIn(a);
            break;
        case ccs.TweenType.quadEaseOut:
            d = this.quadEaseOut(a);
            break;
        case ccs.TweenType.quadEaseInOut:
            d = this.quadEaseInOut(a);
            break;
        case ccs.TweenType.cubicEaseIn:
            d = this.cubicEaseIn(a);
            break;
        case ccs.TweenType.cubicEaseOut:
            d = this.cubicEaseOut(a);
            break;
        case ccs.TweenType.cubicEaseInOut:
            d = this.cubicEaseInOut(a);
            break;
        case ccs.TweenType.quartEaseIn:
            d = this.quartEaseIn(a);
            break;
        case ccs.TweenType.quartEaseOut:
            d = this.quartEaseOut(a);
            break;
        case ccs.TweenType.quartEaseInOut:
            d = this.quartEaseInOut(a);
            break;
        case ccs.TweenType.quintEaseIn:
            d = this.quintEaseIn(a);
            break;
        case ccs.TweenType.quintEaseOut:
            d = this.quintEaseOut(a);
            break;
        case ccs.TweenType.quintEaseInOut:
            d = this.quintEaseInOut(a);
            break;
        case ccs.TweenType.expoEaseIn:
            d = this.expoEaseIn(a);
            break;
        case ccs.TweenType.expoEaseOut:
            d = this.expoEaseOut(a);
            break;
        case ccs.TweenType.expoEaseInOut:
            d = this.expoEaseInOut(a);
            break;
        case ccs.TweenType.circEaseIn:
            d = this.circEaseIn(a);
            break;
        case ccs.TweenType.eircEaseOut:
            d = this.circEaseOut(a);
            break;
        case ccs.TweenType.circEaseInOut:
            d = this.circEaseInOut(a);
            break;
        case ccs.TweenType.elasticEaseIn:
            b = .3, null != c && 0 < c.length && (b = c[0]), d = this.elasticEaseIn(a, b);
            break;
        case ccs.TweenType.elasticEaseOut:
            b = .3, null != c && 0 < c.length && (b = c[0]), d = this.elasticEaseOut(a, b);
            break;
        case ccs.TweenType.elasticEaseInOut:
            b = .3, null != c && 0 < c.length && (b = c[0]), d = this.elasticEaseInOut(a, b);
            break;
        case ccs.TweenType.backEaseIn:
            d = this.backEaseIn(a);
            break;
        case ccs.TweenType.backEaseOut:
            d = this.backEaseOut(a);
            break;
        case ccs.TweenType.backEaseInOut:
            d = this.backEaseInOut(a);
            break;
        case ccs.TweenType.bounceEaseIn:
            d = this.bounceEaseIn(a);
            break;
        case ccs.TweenType.bounceEaseOut:
            d = this.bounceEaseOut(a);
            break;
        case ccs.TweenType.bounceEaseInOut:
            d = this.bounceEaseInOut(a);
            break;
        default:
            d = this.sineEaseInOut(a)
    }
    return d
}, ccs.TweenFunction.linear = function(a) {
    return a
}, ccs.TweenFunction.sineEaseIn = function(a) {
    return -1 * Math.cos(a * ccs.HALF_PI) + 1
}, ccs.TweenFunction.sineEaseOut = function(a) {
    return Math.sin(a * ccs.HALF_PI)
}, ccs.TweenFunction.sineEaseInOut = function(a) {
    return -.5 * (Math.cos(ccs.M_PI * a) - 1)
}, ccs.TweenFunction.quadEaseIn = function(a) {
    return a * a
}, ccs.TweenFunction.quadEaseOut = function(a) {
    return -1 * a * (a - 2)
}, ccs.TweenFunction.quadEaseInOut = function(a) {
    return a *= 2, 1 > a ? .5 * a * a : (--a, -.5 * (a * (a - 2) - 1))
}, ccs.TweenFunction.cubicEaseIn = function(a) {
    return a * a * a
}, ccs.TweenFunction.cubicEaseOut = function(a) {
    return a -= 1, a * a * a + 1
}, ccs.TweenFunction.cubicEaseInOut = function(a) {
    return a *= 2, 1 > a ? .5 * a * a * a : (a -= 2, .5 * (a * a * a + 2))
}, ccs.TweenFunction.quartEaseIn = function(a) {
    return a * a * a * a
}, ccs.TweenFunction.quartEaseOut = function(a) {
    return a -= 1, -(a * a * a * a - 1)
}, ccs.TweenFunction.quartEaseInOut = function(a) {
    return a *= 2, 1 > a ? .5 * a * a * a * a : (a -= 2, -.5 * (a * a * a * a - 2))
}, ccs.TweenFunction.quintEaseIn = function(a) {
    return a * a * a * a * a
}, ccs.TweenFunction.quintEaseOut = function(a) {
    return a -= 1, a * a * a * a * a + 1
}, ccs.TweenFunction.quintEaseInOut = function(a) {
    return a *= 2, 1 > a ? .5 * a * a * a * a * a : (a -= 2, .5 * (a * a * a * a * a + 2))
}, ccs.TweenFunction.expoEaseIn = function(a) {
    return 0 == a ? 0 : Math.pow(2, 10 * (a - 1)) - .001
}, ccs.TweenFunction.expoEaseOut = function(a) {
    return 1 == a ? 1 : -Math.pow(2, -10 * a) + 1
}, ccs.TweenFunction.expoEaseInOut = function(a) {
    return a /= .5, a = 1 > a ? .5 * Math.pow(2, 10 * (a - 1)) : .5 * (-Math.pow(2, -10 * (a - 1)) + 2)
}, ccs.TweenFunction.circEaseIn = function(a) {
    return -1 * (Math.sqrt(1 - a * a) - 1)
}, ccs.TweenFunction.circEaseOut = function(a) {
    return a -= 1, Math.sqrt(1 - a * a)
}, ccs.TweenFunction.circEaseInOut = function(a) {
    return a *= 2, 1 > a ? -.5 * (Math.sqrt(1 - a * a) - 1) : (a -= 2, .5 * (Math.sqrt(1 - a * a) + 1))
}, ccs.TweenFunction.elasticEaseIn = function(a, b) {
    var c = .3;
    0 < b.length && (c = b[0]);
    var d = 0;
    return 0 == a || 1 == a ? d = a : (d = c / 4, a -= 1, d = -Math.pow(2, 10 * a) * Math.sin((a - d) * ccs.DOUBLE_PI / c)), d
}, ccs.TweenFunction.elasticEaseOut = function(a, b) {
    var c = .3;
    0 < b.length && (c = b[0]);
    var d = 0;
    return 0 == a || 1 == a ? d = a : (d = c / 4, d = Math.pow(2, -10 * a) * Math.sin((a - d) * ccs.DOUBLE_PI / c) + 1), d
}, ccs.TweenFunction.elasticEaseInOut = function(a, b) {
    var c = .3;
    0 < b.length && (c = b[0]);
    var d = 0;
    return 0 == a || 1 == a ? d = a : (c || (c = .3 * 1.5), d = c / 4, a = 2 * a - 1, d = 0 > a ? -.5 * Math.pow(2, 10 * a) * Math.sin((a - d) * ccs.DOUBLE_PI / c) : .5 * Math.pow(2, -10 * a) * Math.sin((a - d) * ccs.DOUBLE_PI / c) + 1), d
}, ccs.TweenFunction.backEaseIn = function(a) {
    return a * a * (2.70158 * a - 1.70158)
}, ccs.TweenFunction.backEaseOut = function(a) {
    return a -= 1, a * a * (2.70158 * a + 1.70158) + 1
}, ccs.TweenFunction.backEaseInOut = function(a) {
    return a *= 2, 1 > a ? a * a * (3.5949095 * a - 2.5949095) / 2 : (a -= 2, a * a * (3.5949095 * a + 2.5949095) / 2 + 1)
}, ccs.bounceTime = function(a) {
    return 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? (a -= 1.5 / 2.75, 7.5625 * a * a + .75) : 2.5 / 2.75 > a ? (a -= 2.25 / 2.75, 7.5625 * a * a + .9375) : (a -= 2.625 / 2.75, 7.5625 * a * a + .984375)
}, ccs.TweenFunction.bounceEaseIn = function(a) {
    return 1 - ccs.bounceTime(1 - a)
}, ccs.TweenFunction.bounceEaseOut = function(a) {
    return ccs.bounceTime(a)
}, ccs.TweenFunction.bounceEaseInOut = function(a) {
    var b = 0;
    return b = .5 > a ? .5 * (1 - ccs.bounceTime(1 - 2 * a)) : .5 * ccs.bounceTime(2 * a - 1) + .5
}, ccs.TweenFunction.customEase = function(a, b) {
    if (0 < b.length) {
        var c = 1 - a;
        return b[1] * c * c * c + 3 * b[3] * a * c * c + 3 * b[5] * a * a * c + b[7] * a * a * a
    }
    return a
}, ccs.TweenFunction.easeIn = function(a, b) {
    return Math.pow(a, b)
}, ccs.TweenFunction.easeOut = function(a, b) {
    return Math.pow(a, 1 / b)
}, ccs.TweenFunction.easeInOut = function(a, b) {
    return a *= 2, 1 > a ? .5 * Math.pow(a, b) : 1 - .5 * Math.pow(2 - a, b)
}, ccs.TweenFunction.quadraticIn = function(a) {
    return Math.pow(a, 2)
}, ccs.TweenFunction.quadraticOut = function(a) {
    return -a * (a - 2)
}, ccs.TweenFunction.bezieratFunction = function(a, b, c, d, e) {
    return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
};
var ENABLE_PHYSICS_DETECT = !1;
ccs.fmodf = function(a, b) {
    for (; a > b;) a -= b;
    return a
};
var CC_SAFE_RELEASE = function(a) {
    a && a.release && a.release()
};
ccs.isSpriteContainPoint = function(a, b, c) {
    return b = a.convertToNodeSpace(b), c && (c.x = b.x, c.y = b.y), a = a.getContentSize(), cc.rectContainsPoint(cc.rect(0, 0, a.width, a.height), b)
}, ccs.SPRITE_CONTAIN_POINT = ccs.isSpriteContainPoint, ccs.SPRITE_CONTAIN_POINT_WITH_RETURN = ccs.isSpriteContainPoint, ccs.extBezierTo = function(a, b, c, d, e) {
    var f = cc.p(0, 0);
    return d && !e && (f.x = Math.pow(1 - a, 2) * b.x + 2 * a * (1 - a) * c.x + Math.pow(a, 2) * d.x, f.y = Math.pow(1 - a, 2) * b.y + 2 * a * (1 - a) * c.y + Math.pow(a, 2) * d.y), e && (f.x = b.x * Math.pow(1 - a, 3) + 3 * a * c.x * Math.pow(1 - a, 2) + 3 * d.x * Math.pow(a, 2) * (1 - a) + e.x * Math.pow(a, 3), f.y = b.y * Math.pow(1 - a, 3) + 3 * a * c.y * Math.pow(1 - a, 2) + 3 * d.y * Math.pow(a, 2) * (1 - a) + e.y * Math.pow(a, 3)), f
}, ccs.extCircleTo = function(a, b, c, d, e) {
    var f = cc.p(0, 0);
    return f.x = b.x + c * Math.cos(d + e * a), f.y = b.y + c * Math.sin(d + e * a), f
}, ccs.RelativeData = function() {
    this.plistFiles = [], this.armatures = [], this.animations = [], this.textures = []
}, ccs.armatureDataManager = {
    _animationDatas: {},
    _armarureDatas: {},
    _textureDatas: {},
    _autoLoadSpriteFile: !1,
    _relativeDatas: {},
    s_sharedArmatureDataManager: null,
    removeArmatureFileInfo: function(a) {
        var b = this.getRelativeData(a);
        if (b) {
            for (var c = 0; c < b.armatures.length; c++) {
                var d = b.armatures[c];
                this.removeArmatureData(d)
            }
            for (c = 0; c < b.animations.length; c++) d = b.animations[c], this.removeAnimationData(d);
            for (c = 0; c < b.textures.length; c++) d = b.textures[c], this.removeTextureData(d);
            for (c = 0; c < b.plistFiles.length; c++) d = b.plistFiles[c], cc.spriteFrameCache.removeSpriteFramesFromFile(d);
            delete this._relativeDatas[a], ccs.dataReaderHelper.removeConfigFile(a)
        }
    },
    addArmatureData: function(a, b, c) {
        (c = this.getRelativeData(c)) && c.armatures.push(a), this._armarureDatas[a] = b
    },
    getArmatureData: function(a) {
        var b = null;
        return this._armarureDatas && (b = this._armarureDatas[a]), b
    },
    removeArmatureData: function(a) {
        this._armarureDatas[a] && delete this._armarureDatas[a]
    },
    addAnimationData: function(a, b, c) {
        (c = this.getRelativeData(c)) && c.animations.push(a), this._animationDatas[a] = b
    },
    getAnimationData: function(a) {
        var b = null;
        return this._animationDatas[a] && (b = this._animationDatas[a]), b
    },
    removeAnimationData: function(a) {
        this._animationDatas[a] && delete this._animationDatas[a]
    },
    addTextureData: function(a, b, c) {
        (c = this.getRelativeData(c)) && c.textures.push(a), this._textureDatas[a] = b
    },
    getTextureData: function(a) {
        var b = null;
        return this._textureDatas && (b = this._textureDatas[a]), b
    },
    removeTextureData: function(a) {
        this._textureDatas[a] && delete this._textureDatas[a]
    },
    addArmatureFileInfo: function() {
        var a, b, c;
        switch (arguments.length) {
            case 1:
                c = arguments[0], this.addRelativeData(c), this._autoLoadSpriteFile = !0, ccs.dataReaderHelper.addDataFromFile(c);
                break;
            case 3:
                a = arguments[0], b = arguments[1], c = arguments[2], this.addRelativeData(c), this._autoLoadSpriteFile = !1, ccs.dataReaderHelper.addDataFromFile(c), this.addSpriteFrameFromFile(b, a)
        }
    },
    addArmatureFileInfoAsync: function() {
        var a, b, c, d, e;
        switch (arguments.length) {
            case 3:
                c = arguments[0], d = arguments[2], e = arguments[1], this.addRelativeData(c), this._autoLoadSpriteFile = !0, ccs.dataReaderHelper.addDataFromFileAsync("", "", c, e, d);
                break;
            case 5:
                a = arguments[0], b = arguments[1], c = arguments[2], d = arguments[4], e = arguments[3], this.addRelativeData(c), this._autoLoadSpriteFile = !1, ccs.dataReaderHelper.addDataFromFileAsync(a, b, c, e, d), this.addSpriteFrameFromFile(b, a)
        }
    },
    addSpriteFrameFromFile: function(a, b, c) {
        (c = this.getRelativeData(c)) && c.plistFiles.push(a), ccs.spriteFrameCacheHelper.addSpriteFrameFromFile(a, b)
    },
    isAutoLoadSpriteFile: function() {
        return this._autoLoadSpriteFile
    },
    getArmatureDatas: function() {
        return this._armarureDatas
    },
    getAnimationDatas: function() {
        return this._animationDatas
    },
    getTextureDatas: function() {
        return this._textureDatas
    },
    addRelativeData: function(a) {
        this._relativeDatas[a] || (this._relativeDatas[a] = new ccs.RelativeData)
    },
    getRelativeData: function(a) {
        return this._relativeDatas[a]
    },
    clear: function() {
        this._animationDatas = {}, this._armarureDatas = {}, this._textureDatas = {}, ccs.spriteFrameCacheHelper.clear(), ccs.dataReaderHelper.clear()
    }
}, ccs.BLEND_TYPE_NORMAL = 0, ccs.BLEND_TYPE_LAYER = 1, ccs.BLEND_TYPE_DARKEN = 2, ccs.BLEND_TYPE_MULTIPLY = 3, ccs.BLEND_TYPE_LIGHTEN = 4, ccs.BLEND_TYPE_SCREEN = 5, ccs.BLEND_TYPE_OVERLAY = 6, ccs.BLEND_TYPE_HIGHLIGHT = 7, ccs.BLEND_TYPE_ADD = 8, ccs.BLEND_TYPE_SUBTRACT = 9, ccs.BLEND_TYPE_DIFFERENCE = 10, ccs.BLEND_TYPE_INVERT = 11, ccs.BLEND_TYPE_ALPHA = 12, ccs.BLEND_TYPE_ERASE = 13, ccs.DISPLAY_TYPE_SPRITE = 0, ccs.DISPLAY_TYPE_ARMATURE = 1, ccs.DISPLAY_TYPE_PARTICLE = 2, ccs.DISPLAY_TYPE_MAX = 3, ccs.BaseData = ccs.Class.extend({
    x: 0,
    y: 0,
    zOrder: 0,
    skewX: 0,
    skewY: 0,
    scaleX: 1,
    scaleY: 1,
    tweenRotate: 0,
    isUseColorInfo: !1,
    r: 255,
    g: 255,
    b: 255,
    a: 255,
    ctor: function() {
        this.skewY = this.skewX = this.zOrder = this.y = this.x = 0, this.scaleY = this.scaleX = 1, this.tweenRotate = 0, this.isUseColorInfo = !1, this.a = this.b = this.g = this.r = 255
    },
    copy: function(a) {
        this.x = a.x, this.y = a.y, this.zOrder = a.zOrder, this.scaleX = a.scaleX, this.scaleY = a.scaleY, this.skewX = a.skewX, this.skewY = a.skewY, this.tweenRotate = a.tweenRotate, this.isUseColorInfo = a.isUseColorInfo, this.r = a.r, this.g = a.g, this.b = a.b, this.a = a.a
    },
    setColor: function(a) {
        this.r = a.r, this.g = a.g, this.b = a.b, this.a = a.a
    },
    getColor: function() {
        return cc.color(this.r, this.g, this.b, this.a)
    },
    subtract: function(a, b, c) {
        this.x = b.x - a.x, this.y = b.y - a.y, this.scaleX = b.scaleX - a.scaleX, this.scaleY = b.scaleY - a.scaleY, this.skewX = b.skewX - a.skewX, this.skewY = b.skewY - a.skewY, this.isUseColorInfo || a.isUseColorInfo || b.isUseColorInfo ? (this.a = b.a - a.a, this.r = b.r - a.r, this.g = b.g - a.g, this.b = b.b - a.b, this.isUseColorInfo = !0) : (this.a = this.r = this.g = this.b = 0, this.isUseColorInfo = !1), c && (this.skewX > ccs.M_PI && (this.skewX -= ccs.DOUBLE_PI), this.skewX < -ccs.M_PI && (this.skewX += ccs.DOUBLE_PI), this.skewY > ccs.M_PI && (this.skewY -= ccs.DOUBLE_PI), this.skewY < -ccs.M_PI && (this.skewY += ccs.DOUBLE_PI)), b.tweenRotate && (this.skewX += 2 * b.tweenRotate * ccs.PI, this.skewY -= 2 * b.tweenRotate * ccs.PI)
    }
}), ccs.DisplayData = ccs.Class.extend({
    displayType: ccs.DISPLAY_TYPE_MAX,
    displayName: "",
    ctor: function() {
        this.displayType = ccs.DISPLAY_TYPE_MAX
    },
    changeDisplayToTexture: function(a) {
        var b = a.lastIndexOf(".");
        return -1 != b && (a = a.substring(0, b)), a
    },
    copy: function(a) {
        this.displayName = a.displayName, this.displayType = a.displayType
    }
}), ccs.SpriteDisplayData = ccs.DisplayData.extend({
    skinData: null,
    ctor: function() {
        this.skinData = new ccs.BaseData, this.displayType = ccs.DISPLAY_TYPE_SPRITE
    },
    copy: function(a) {
        ccs.DisplayData.prototype.copy.call(this, a), this.skinData = a.skinData
    },
    SpriteDisplayData: function() {
        this.displayType = ccs.DISPLAY_TYPE_SPRITE
    }
}), ccs.ArmatureDisplayData = ccs.DisplayData.extend({
    displayName: "",
    ctor: function() {
        this.displayName = "", this.displayType = ccs.DISPLAY_TYPE_ARMATURE
    }
}), ccs.ParticleDisplayData = ccs.DisplayData.extend({
    ctor: function() {
        this.displayType = ccs.DISPLAY_TYPE_PARTICLE
    }
}), ccs.BoneData = ccs.BaseData.extend({
    displayDataList: null,
    name: "",
    parentName: "",
    boneDataTransform: null,

    ctor: function() {
        this.displayDataList = [], this.parentName = this.name = "", this.boneDataTransform = null
    },
    init: function() {
        return this.displayDataList.length = 0, !0
    },
    addDisplayData: function(a) {
        this.displayDataList.push(a)
    },
    getDisplayData: function(a) {
        return this.displayDataList[a]
    }
}), ccs.ArmatureData = ccs.Class.extend({
    boneDataDic: null,
    name: "",
    dataVersion: .1,
    ctor: function() {
        this.boneDataDic = {}, this.name = "", this.dataVersion = .1
    },
    init: function() {
        return !0
    },
    addBoneData: function(a) {
        this.boneDataDic[a.name] = a
    },
    getBoneDataDic: function() {
        return this.boneDataDic
    },
    getBoneData: function(a) {
        return this.boneDataDic[a]
    }
}), ccs.FrameData = ccs.BaseData.extend({
    duration: 0,
    tweenEasing: 0,
    easingParamNumber: 0,
    easingParams: null,
    displayIndex: -1,
    movement: "",
    event: "",
    sound: "",
    soundEffect: "",
    blendFunc: 0,
    frameID: 0,
    isTween: !0,
    ctor: function() {
        ccs.BaseData.prototype.ctor.call(this), this.duration = 1, this.tweenEasing = ccs.TweenType.linear, this.easingParamNumber = 0, this.easingParams = [], this.displayIndex = 0, this.soundEffect = this.sound = this.event = this.movement = "", this.blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), this.frameID = 0, this.isTween = !0
    },
    copy: function(a) {
        if (ccs.BaseData.prototype.copy.call(this, a), this.duration = a.duration, this.displayIndex = a.displayIndex, this.tweenEasing = a.tweenEasing, this.easingParamNumber = a.easingParamNumber, 0 != this.easingParamNumber)
            for (var b = 0; b < this.easingParamNumber; b++) this.easingParams[b] = a.easingParams[b];
        this.blendFunc = a.blendFunc, this.isTween = a.isTween
    }
}), ccs.MovementBoneData = ccs.Class.extend({
    delay: 0,
    scale: 1,
    duration: 0,
    frameList: null,
    name: "",
    ctor: function() {
        this.delay = 0, this.scale = 1, this.duration = 0, this.frameList = [], this.name = ""
    },
    init: function() {
        return !0
    },
    addFrameData: function(a) {
        this.frameList.push(a)
    },
    getFrameData: function(a) {
        return this.frameList[a]
    }
}), ccs.MovementData = function() {
    this.name = "", this.duration = 0, this.scale = 1, this.durationTween = this.durationTo = 0, this.loop = !0, this.tweenEasing = ccs.TweenType.linear, this.movBoneDataDic = {}
}, ccs.MovementData.prototype.addMovementBoneData = function(a) {
    this.movBoneDataDic[a.name] = a
}, ccs.MovementData.prototype.getMovementBoneData = function(a) {
    return this.movBoneDataDic[a]
}, ccs.AnimationData = function() {
    this.movementDataDic = {}, this.movementNames = [], this.name = ""
}, ccs.AnimationData.prototype.addMovement = function(a) {
    this.movementDataDic[a.name] = a, this.movementNames.push(a.name)
}, ccs.AnimationData.prototype.getMovement = function(a) {
    return this.movementDataDic[a]
}, ccs.AnimationData.prototype.getMovementCount = function() {
    return Object.keys(this.movementDataDic).length
}, ccs.ContourVertex2 = function(a, b) {
    this.x = a || 0, this.y = b || 0
}, ccs.ContourData = function() {
    this.vertexList = []
}, ccs.ContourData.prototype.init = function() {
    return this.vertexList.length = 0, !0
}, ccs.ContourData.prototype.addVertex = function(a) {
    this.vertexList.push(a)
}, ccs.TextureData = function() {
    this.width = this.height = 0, this.pivotY = this.pivotX = .5, this.name = "", this.contourDataList = []
}, ccs.TextureData.prototype.init = function() {
    this.contourDataList.length = 0
}, ccs.TextureData.prototype.addContourData = function(a) {
    this.contourDataList.push(a)
}, ccs.TextureData.prototype.getContourData = function(a) {
    return this.contourDataList[a]
}, ccs.DecorativeDisplay = ccs.Class.extend({
    _display: null,
    _colliderDetector: null,
    _displayData: null,
    ctor: function() {
        this._displayData = this._colliderDetector = this._display = null
    },
    init: function() {
        return !0
    },
    setDisplay: function(a) {
        this._display = a
    },
    getDisplay: function() {
        return this._display
    },
    setColliderDetector: function(a) {
        this._colliderDetector = a
    },
    getColliderDetector: function() {
        return this._colliderDetector
    },
    setDisplayData: function(a) {
        this._displayData = a
    },
    getDisplayData: function() {
        return this._displayData
    },
    release: function() {
        this._colliderDetector = this._displayData = this._display = null
    }
}), ccs.DecorativeDisplay.create = function() {
    var a = new ccs.DecorativeDisplay;
    return a && a.init() ? a : null
}, ccs.displayFactory = {
    addDisplay: function(a, b, c) {
        switch (c.displayType) {
            case ccs.DISPLAY_TYPE_SPRITE:
                this.addSpriteDisplay(a, b, c);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                this.addParticleDisplay(a, b, c);
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                this.addArmatureDisplay(a, b, c)
        }
    },
    createDisplay: function(a, b) {
        switch (b.getDisplayData().displayType) {
            case ccs.DISPLAY_TYPE_SPRITE:
                this.createSpriteDisplay(a, b);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                this.createParticleDisplay(a, b);
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                this.createArmatureDisplay(a, b)
        }
    },
    _helpTransform: {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    },
    updateDisplay: function(a, b, c) {
        var d = a.getDisplayRenderNode();
        if (d) {
            switch (a.getDisplayRenderNodeType()) {
                case ccs.DISPLAY_TYPE_SPRITE:
                    c && d.updateArmatureTransform();
                    break;
                case ccs.DISPLAY_TYPE_PARTICLE:
                    this.updateParticleDisplay(a, d, b);
                    break;
                case ccs.DISPLAY_TYPE_ARMATURE:
                    this.updateArmatureDisplay(a, d, b);
                    break;
                default:
                    b = a.getNodeToArmatureTransform(), d.setAdditionalTransform(b)
            }
            if ((ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && c && (d = a.getDisplayManager().getCurrentDecorativeDisplay(), c = d.getColliderDetector())) {
                b = d.getDisplay();
                var e = b.nodeToParentTransform(),
                    d = this._helpTransform;
                d.a = e.a, d.b = e.b, d.c = e.c, d.d = e.d, d.tx = e.tx, d.ty = e.ty, b = cc.pointApplyAffineTransform(b.getAnchorPointInPoints(), d), d.tx = b.x, d.ty = b.y, a = cc.affineTransformConcat(d, a.getArmature().nodeToParentTransform()), c.updateTransform(a)
            }
        }
    },
    addSpriteDisplay: function(a, b, c) {
        var d = new ccs.SpriteDisplayData;
        d.copy(c), b.setDisplayData(d), this.createSpriteDisplay(a, b)
    },
    createSpriteDisplay: function(a, b) {
        var c = null,
            d = b.getDisplayData(),
            c = d.displayName,
            e = c.lastIndexOf("."); - 1 != e && (c = c.substring(0, e)), c = "" == c ? ccs.Skin.create() : ccs.Skin.createWithSpriteFrameName(c + ".png"), b.setDisplay(c), null != c && (c.setBone(a), this.initSpriteDisplay(a, b, d.displayName, c), (e = a.getArmature()) && c.setSkinData(e.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED ? d.skinData : a.boneData))
    },
    initSpriteDisplay: function(a, b, c, d) {
        var e = c.lastIndexOf("."); - 1 != e && (c = c.substring(0, e)), (c = ccs.armatureDataManager.getTextureData(c)) && d.setAnchorPoint(cc.p(c.pivotX, c.pivotY)), (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && c && 0 < c.contourDataList.length && (a = ccs.ColliderDetector.create(a), a.addContourDataList(c.contourDataList), b.setColliderDetector(a))
    },
    addArmatureDisplay: function(a, b, c) {
        var d = new ccs.ArmatureDisplayData;
        d.copy(c), b.setDisplayData(d), this.createArmatureDisplay(a, b)
    },
    createArmatureDisplay: function(a, b) {
        var c = b.getDisplayData(),
            c = ccs.Armature.create(c.displayName, a);
        b.setDisplay(c)
    },
    updateArmatureDisplay: function(a, b, c) {
        b && (b.sortAllChildren(), b.update(c))
    },
    addParticleDisplay: function(a, b, c) {
        var d = new ccs.ParticleDisplayData;
        d.copy(c), b.setDisplayData(d), this.createParticleDisplay(a, b)
    },
    createParticleDisplay: function(a, b) {
        var c = b.getDisplayData(),
            c = cc.ParticleSystem.create(c.displayName);
        c.removeFromParent(), c.cleanup(), a.getArmature() && c.setParent(a.getArmature()), b.setDisplay(c)
    },
    updateParticleDisplay: function(a, b, c) {
        var d = new ccs.BaseData;
        ccs.TransformHelp.matrixToNode(a.nodeToArmatureTransform(), d), b.setPosition(d.x, d.y), b.setScaleX(d.scaleX), b.setScaleY(d.scaleY), b.update(c)
    }
}, ccs.DisplayManager = ccs.Class.extend({
    _decoDisplayList: null,
    _currentDecoDisplay: null,
    _displayRenderNode: null,
    _displayIndex: null,
    _forceChangeDisplay: !1,
    _bone: null,
    _visible: !0,
    _displayType: null,
    ctor: function() {
        this._decoDisplayList = [], this._displayIndex = this._displayRenderNode = this._currentDecoDisplay = null, this._forceChangeDisplay = !1, this._bone = null, this._visible = !0, this._displayType = ccs.DISPLAY_TYPE_MAX
    },
    init: function(a) {
        return this._bone = a, this.initDisplayList(a.getBoneData()), !0
    },
    addDisplay: function(a, b) {
        var c, d = this._decoDisplayList;
        if (b >= 0 && b < d.length ? c = d[b] : (c = ccs.DecorativeDisplay.create(), d.push(c)), a instanceof ccs.DisplayData) cc.displayFactory.addDisplay(this._bone, c, a);
        else {
            var e = null;
            if (a instanceof ccs.Skin) {
                a.setBone(this._bone), e = new ccs.SpriteDisplayData, ccs.displayFactory.initSpriteDisplay(this._bone, c, a.getDisplayName(), a);
                var f = c.getDisplayData();
                if (f instanceof ccs.SpriteDisplayData) a.setSkinData(f.skinData), e.skinData = f.skinData;
                else {
                    for (var f = !1, g = d.length - 2; g >= 0; g--) {
                        var h = d[g].getDisplayData();
                        if (h instanceof ccs.SpriteDisplayData) {
                            f = !0, a.setSkinData(h.skinData), e.skinData = h.skinData;
                            break
                        }
                    }
                    f || a.setSkinData(new ccs.BaseData)
                }
            } else a instanceof cc.ParticleSystem ? (e = new ccs.ParticleDisplayData, a.removeFromParent(), a.cleanup(), (d = this._bone.getArmature()) && a.setParent(d)) : a instanceof ccs.Armature ? (e = new ccs.ArmatureDisplayData, e.displayName = a.getName(), a.setParentBone(this._bone)) : e = new ccs.DisplayData;
            c.setDisplay(a), c.setDisplayData(e)
        }
        b == this._displayIndex && (this._displayIndex = -1, this.changeDisplayWithIndex(b, !1))
    },
    _addDisplayOther: function(a, b) {
        var c = null;
        if (b instanceof ccs.Skin) {
            b.setBone(this._bone), c = new ccs.SpriteDisplayData, c.displayName = b.getDisplayName(), ccs.displayFactory.initSpriteDisplay(this._bone, a, b.getDisplayName(), b);
            var d = a.getDisplayData();
            if (d instanceof ccs.SpriteDisplayData) b.setSkinData(d.skinData);
            else {
                for (var d = !1, e = this._decoDisplayList.length - 2; e >= 0; e--) {
                    var f = this._decoDisplayList[e].getDisplayData();
                    if (f) {
                        d = !0, b.setSkinData(f.skinData), c.skinData = f.skinData;
                        break
                    }
                }
                d || b.setSkinData(new ccs.BaseData), b.setSkinData(new ccs.BaseData)
            }
        } else b instanceof cc.ParticleSystem ? (c = new ccs.ParticleDisplayData, c.displayName = b._plistFile) : b instanceof ccs.Armature ? (c = new ccs.ArmatureDisplayData, c.displayName = b.getName(), b.setParentBone(this._bone)) : c = new ccs.DisplayData;
        a.setDisplay(b), a.setDisplayData(c)
    },
    removeDisplay: function(a) {
        this._decoDisplayList.splice(a, 1), a === this._displayIndex && (this.setCurrentDecorativeDisplay(null), this._displayIndex = -1)
    },
    getDecorativeDisplayList: function() {
        return this._decoDisplayList
    },
    changeDisplayWithIndex: function(a, b) {
        a >= this._decoDisplayList.length ? cc.log("the index value is out of range") : (this._forceChangeDisplay = b, this._displayIndex != a && (this._displayIndex = a, 0 > a ? this._displayRenderNode && (this._displayRenderNode.removeFromParent(!0), this.setCurrentDecorativeDisplay(null)) : this.setCurrentDecorativeDisplay(this._decoDisplayList[a])))
    },
    changeDisplayWithName: function(a, b) {
        for (var c = this._decoDisplayList, d = 0; d < c.length; d++)
            if (c[d].getDisplayData().displayName == a) {
                this.changeDisplayWithIndex(d, b);
                break
            }
    },
    setCurrentDecorativeDisplay: function(a) {
        var b = this._currentDecoDisplay;
        (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && b && b.getColliderDetector() && b.getColliderDetector().setActive(!1), b = this._currentDecoDisplay = a, (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && b && b.getColliderDetector() && b.getColliderDetector().setActive(!0), a = b ? b.getDisplay() : null;
        var b = this._displayRenderNode,
            c = this._bone;
        b && (b instanceof ccs.Armature && c.setChildArmature(null), b.removeFromParent(!0)), (this._displayRenderNode = a) ? (a instanceof ccs.Armature ? (this._bone.setChildArmature(a), a.setParentBone(this._bone)) : a instanceof cc.ParticleSystem && (a instanceof ccs.Armature ? (c.setChildArmature(a), a.setParentBone(c)) : a instanceof cc.ParticleSystem && a.resetSystem()), a.setColor(c.getDisplayedColor()), a.setOpacity(c.getDisplayedOpacity()), this._displayRenderNode.setVisible(this._visible), this._displayType = this._currentDecoDisplay.getDisplayData().displayType) : this._displayType = ccs.DISPLAY_TYPE_MAX
    },
    getDisplayRenderNode: function() {
        return this._displayRenderNode
    },
    getDisplayRenderNodeType: function() {
        return this._displayType
    },
    getCurrentDisplayIndex: function() {
        return this._displayIndex
    },
    getCurrentDecorativeDisplay: function() {
        return this._currentDecoDisplay
    },
    getDecorativeDisplayByIndex: function(a) {
        return this._decoDisplayList[a]
    },
    initDisplayList: function(a) {
        if (this._decoDisplayList.length = 0, a) {
            a = a.displayDataList;
            for (var b = this._decoDisplayList, c = this._bone, d = 0; d < a.length; d++) {
                var e = a[d],
                    f = ccs.DecorativeDisplay.create();
                f.setDisplayData(e), ccs.displayFactory.createDisplay(c, f), b.push(f)
            }
        }
    },
    containPoint: function(a, b) {
        if (!this._visible || 0 > this._displayIndex) return !1;
        if (void 0 !== b && (a = cc.p(a, b)), this._currentDecoDisplay.getDisplayData().displayType == ccs.DISPLAY_TYPE_SPRITE) {
            var c = this._currentDecoDisplay.getDisplay(),
                c = c.getChildByTag(0);
            return ccs.SPRITE_CONTAIN_POINT_WITH_RETURN(c, a)
        }
        return !1
    },
    setVisible: function(a) {
        this._displayRenderNode && (this._visible = a, this._displayRenderNode.setVisible(a))
    },
    isVisible: function() {
        return this._visible
    },
    getContentSize: function() {
        return this._displayRenderNode ? this._displayRenderNode.getContentSize() : cc.size(0, 0)
    },
    getBoundingBox: function() {
        return this._displayRenderNode ? this._displayRenderNode.getBoundingBox() : cc.rect(0, 0, 0, 0)
    },
    getAnchorPoint: function() {
        return this._displayRenderNode ? this._displayRenderNode.getAnchorPoint() : cc.p(0, 0)
    },
    getAnchorPointInPoints: function() {
        return this._displayRenderNode ? this._displayRenderNode.getAnchorPointInPoints() : cc.p(0, 0)
    },
    getForceChangeDisplay: function() {
        return this._forceChangeDisplay
    },
    release: function() {
        this._decoDisplayList = null, this._displayRenderNode && (this._displayRenderNode.removeFromParent(!0), this._displayRenderNode = null)
    }
}), ccs.DisplayManager.create = function(a) {
    var b = new ccs.DisplayManager;
    return b && b.init(a) ? b : null
}, ccs.Skin = ccs.Sprite.extend({
    _skinData: null,
    bone: null,
    _skinTransform: null,
    _displayName: "",
    _armature: null,
    _className: "Skin",
    ctor: function() {
        cc.Sprite.prototype.ctor.call(this), this.bone = this._skinData = null, this._displayName = "", this._skinTransform = cc.affineTransformIdentity(), this._armature = null
    },
    initWithSpriteFrameName: function(a) {
        if ("" == a) return !1;
        var b = cc.spriteFrameCache.getSpriteFrame(a),
            c = !0;
        return b ? this.initWithSpriteFrame(b) : (cc.log("Can't find CCSpriteFrame with %s. Please check your .plist file", a), c = !1), this._displayName = a, c
    },
    initWithFile: function(a) {
        var b = cc.Sprite.prototype.initWithFile.call(this, a);
        return this._displayName = a, b
    },
    setSkinData: function(a) {
        this._skinData = a, this.setScaleX(a.scaleX), this.setScaleY(a.scaleY), this.setRotationX(cc.radiansToDegrees(a.skewX)), this.setRotationY(cc.radiansToDegrees(-a.skewY)), this.setPosition(a.x, a.y), a = this.getNodeToParentTransform ? this.getNodeToParentTransform() : this.nodeToParentTransform();
        var b = this._skinTransform;
        b.a = a.a, b.b = a.b, b.c = a.c, b.d = a.d, b.tx = a.tx, b.ty = a.ty, this.updateArmatureTransform()
    },
    getSkinData: function() {
        return this._skinData
    },
    updateArmatureTransform: function() {
        this._transform = cc.affineTransformConcat(this._skinTransform, this.bone.getNodeToArmatureTransform())
    },
    _updateTransformForWebGL: function() {
        var a = this._quad;
        if (this._visible) {
            var b = this.getNodeToParentTransform ? this.getNodeToParentTransform() : this.nodeToParentTransform(),
                c = this._rect,
                d = this._offsetPosition.x,
                e = this._offsetPosition.y,
                f = d + c.width,
                g = e + c.height,
                h = b.tx,
                i = b.ty,
                j = b.a,
                k = b.b,
                l = b.d,
                m = -b.c,
                b = d * j - e * m + h,
                c = d * k + e * l + i,
                n = f * j - e * m + h,
                e = f * k + e * l + i,
                o = f * j - g * m + h,
                f = f * k + g * l + i,
                h = d * j - g * m + h,
                d = d * k + g * l + i,
                g = this._vertexZ;
            cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (b |= 0, c |= 0, n |= 0, e |= 0, o |= 0, f |= 0, h |= 0, d |= 0), this.SET_VERTEX3F(a.bl.vertices, b, c, g), this.SET_VERTEX3F(a.br.vertices, n, e, g), this.SET_VERTEX3F(a.tl.vertices, h, d, g), this.SET_VERTEX3F(a.tr.vertices, o, f, g)
        } else a.br.vertices = a.tl.vertices = a.tr.vertices = a.bl.vertices = {
            x: 0,
            y: 0,
            z: 0
        };
        this._textureAtlas && this._textureAtlas.updateQuad(a, this._textureAtlas.getTotalQuads()), this._quadDirty = !0
    },
    SET_VERTEX3F: function(a, b, c, d) {
        a.x = b, a.y = c, a.z = d
    },
    RENDER_IN_SUBPIXEL: function(a) {
        return cc.SPRITEBATCHNODE_RENDER_SUBPIXEL ? a : Math.ceil(a)
    },
    getNodeToWorldTransform: function() {
        return cc.affineTransformConcat(this._transform, this.bone.getArmature().getNodeToWorldTransform())
    },
    getNodeToWorldTransformAR: function() {
        var a = this._transform;
        return this._anchorPointInPoints = cc.pointApplyAffineTransform(this._anchorPointInPoints, a), a.tx = this._anchorPointInPoints.x, a.ty = this._anchorPointInPoints.y, cc.affineTransformConcat(a, this.bone.getArmature().nodeToWorldTransform())
    },
    setBone: function(a) {
        this.bone = a, (a = this.bone.getArmature()) && (this._armature = a)
    },
    getBone: function() {
        return this.bone
    },
    getDisplayName: function() {
        return this._displayName
    }
}), cc._renderType == cc._RENDER_TYPE_WEBGL && (ccs.Skin.prototype.updateTransform = ccs.Skin.prototype._updateTransformForWebGL), _p = ccs.Skin.prototype, cc.defineGetterSetter(_p, "skinData", _p.getSkinData, _p.setSkinData), cc.defineGetterSetter(_p, "displayName", _p.getDisplayName), _p = null, ccs.Skin.create = function(a, b) {
    var c = arguments.length,
        d = new ccs.Skin;
    if (0 === c || null == a || "" == a) {
        if (d.init()) return d
    } else if ("#" == a[0]) {
        if (d && d.initWithSpriteFrameName(a)) return d
    } else if (d && d.initWithFile(a, b)) return d;
    return null
}, ccs.Skin.createWithSpriteFrameName = function(a) {
    var b = new ccs.Skin;
    return b && b.initWithSpriteFrameName(a) ? b : null
}, ccs.ANIMATION_TYPE_SINGLE_FRAME = -4, ccs.ANIMATION_TYPE_NO_LOOP = -3, ccs.ANIMATION_TYPE_TO_LOOP_FRONT = -2, ccs.ANIMATION_TYPE_TO_LOOP_BACK = -1, ccs.ANIMATION_TYPE_LOOP_FRONT = 0, ccs.ANIMATION_TYPE_LOOP_BACK = 1, ccs.ANIMATION_TYPE_MAX = 2, ccs.ProcessBase = ccs.Class.extend({
    _processScale: 1,
    _isComplete: !0,
    _isPause: !0,
    _isPlaying: !1,
    _currentPercent: 0,
    _rawDuration: 0,
    _loopType: 0,
    _tweenEasing: 0,
    animationInternal: null,
    _currentFrame: 0,
    _durationTween: 0,
    _nextFrameIndex: 0,
    _curFrameIndex: null,
    _isLoopBack: !1,
    ctor: function() {
        this._processScale = 1, this._isPause = this._isComplete = !0, this._isPlaying = !1, this._rawDuration = this._durationTween = this._currentPercent = this._currentFrame = 0, this._loopType = ccs.ANIMATION_TYPE_LOOP_BACK, this._tweenEasing = ccs.TweenType.linear, this.animationInternal = 1 / 60, this._durationTween = this._curFrameIndex = 0, this._isLoopBack = !1
    },
    pause: function() {
        this._isPause = !0, this._isPlaying = !1
    },
    resume: function() {
        this._isPause = !1, this._isPlaying = !0
    },
    stop: function() {
        this._isComplete = !0, this._isPlaying = !1
    },
    play: function(a, b, c, d) {
        this._isPause = this._isComplete = !1, this._isPlaying = !0, this._currentFrame = 0, this._nextFrameIndex = a, this._tweenEasing = d
    },
    update: function(a) {
        if (!this._isComplete && !this._isPause && !(0 >= this._rawDuration || a > 1)) {
            var b = void 0 === this._nextFrameIndex ? 0 : this._nextFrameIndex,
                c = this._currentFrame;
            0 >= b ? (this._currentPercent = 1, c = 0) : (c += this._processScale * (a / this.animationInternal), this._currentPercent = c / b, c = ccs.fmodf(c, b)), this._currentFrame = c, this.updateHandler()
        }
    },
    gotoFrame: function(a) {
        var b = this._loopType;
        b == ccs.ANIMATION_TYPE_NO_LOOP ? b = ccs.ANIMATION_TYPE_MAX : b == ccs.ANIMATION_TYPE_TO_LOOP_FRONT && (b = ccs.ANIMATION_TYPE_LOOP_FRONT), this._loopType = b, this._curFrameIndex = a, this._nextFrameIndex = this._durationTween
    },
    getCurrentFrameIndex: function() {
        return this._curFrameIndex = (this._rawDuration - 1) * this._currentPercent
    },
    updateHandler: function() {},
    isPause: function() {
        return this._isPause
    },
    isComplete: function() {
        return this._isComplete
    },
    getCurrentPercent: function() {
        return this._currentPercent
    },
    getRawDuration: function() {
        return this._rawDuration
    },
    getLoop: function() {
        return this._loopType
    },
    getTweenEasing: function() {
        return this._tweenEasing
    },
    getAnimationInternal: function() {
        return this.animationInternal
    },
    setAnimationInternal: function(a) {
        this.animationInternal = a
    },
    getProcessScale: function() {
        return this._processScale
    },
    setProcessScale: function(a) {
        this._processScale = a
    },
    isPlaying: function() {
        return this._isPlaying
    }
}), _p = ccs.ProcessBase.prototype, cc.defineGetterSetter(_p, "currentFrameIndex", _p.getCurrentFrameIndex), cc.defineGetterSetter(_p, "paused", _p.isPause), cc.defineGetterSetter(_p, "completed", _p.isComplete), cc.defineGetterSetter(_p, "currentPercent", _p.getCurrentPercent), cc.defineGetterSetter(_p, "rawDuration", _p.getRawDuration), cc.defineGetterSetter(_p, "loop", _p.getLoop), cc.defineGetterSetter(_p, "tweenEasing", _p.getTweenEasing), cc.defineGetterSetter(_p, "playing", _p.isPlaying), _p = null, ccs.MovementEventType = {
    start: 0,
    complete: 1,
    loopComplete: 2
}, ccs.AnimationEvent = ccs.Class.extend({
    _arguments: null,
    _callFunc: null,
    _selectorTarget: null,
    ctor: function(a, b, c) {
        this._data = c, this._callFunc = a, this._selectorTarget = b
    },
    call: function() {
        this._callFunc && this._callFunc.apply(this._selectorTarget, this._arguments)
    },
    setArguments: function(a) {
        this._arguments = a
    }
}), ccs.MovementEvent = function() {
    this.armature = null, this.movementID = this.movementType = ""
}, ccs.FrameEvent = function() {
    this.bone = null, this.frameEventName = "", this.currentFrameIndex = this.originFrameIndex = 0
}, ccs.ArmatureAnimation = ccs.ProcessBase.extend({
    _animationData: null,
    _movementData: null,
    _armature: null,
    _movementID: "",
    _toIndex: 0,
    _tweenList: null,
    _speedScale: 1,
    _ignoreFrameEvent: !1,
    _frameEventQueue: null,
    _movementEventQueue: null,
    _movementList: null,
    _onMovementList: !1,
    _movementListLoop: !1,
    _movementIndex: 0,
    _movementListDurationTo: -1,
    _movementEventCallFunc: null,
    _frameEventCallFunc: null,
    _movementEventTarget: null,
    _frameEventTarget: null,
    _movementEventListener: null,
    _frameEventListener: null,
    ctor: function() {
        ccs.ProcessBase.prototype.ctor.call(this), this._tweenList = [], this._movementList = [], this._frameEventQueue = [], this._movementEventQueue = []
    },
    init: function(a) {
        return this._armature = a, this._tweenList.length = 0, !0
    },
    pause: function() {
        for (var a = this._tweenList, b = 0; b < a.length; b++) a[b].pause();
        ccs.ProcessBase.prototype.pause.call(this)
    },
    resume: function() {
        for (var a = this._tweenList, b = 0; b < a.length; b++) a[b].resume();
        ccs.ProcessBase.prototype.resume.call(this)
    },
    stop: function() {
        for (var a = this._tweenList, b = 0; b < a.length; b++) a[b].stop();
        a.length = 0, ccs.ProcessBase.prototype.stop.call(this)
    },
    setAnimationScale: function(a) {
        return this.setSpeedScale(a)
    },
    getAnimationScale: function() {
        return this.getSpeedScale()
    },
    setSpeedScale: function(a) {
        if (a != this._speedScale) {
            this._speedScale = a, this._processScale = this._movementData ? this._speedScale * this._movementData.scale : this._speedScale, a = this._armature.getBoneDic();
            for (var b in a) {
                var c = a[b];
                c.getTween().setProcessScale(this._processScale), c.getChildArmature() && c.getChildArmature().getAnimation().setSpeedScale(this._processScale)
            }
        }
    },
    getSpeedScale: function() {
        return this._speedScale
    },
    play: function(a, b, c) {
        cc.assert(this._animationData, "this.animationData can not be null"), this._movementData = this._animationData.getMovement(a), cc.assert(this._movementData, "this._movementData can not be null"), b = void 0 === b ? -1 : b, c = void 0 === c ? -1 : c, this._rawDuration = this._movementData.duration, this._movementID = a, this._processScale = this._speedScale * this._movementData.scale, b = -1 == b ? this._movementData.durationTo : b, a = 0 == this._movementData.durationTween ? this._rawDuration : this._movementData.durationTween;
        var d = this._movementData.tweenEasing;
        c = 0 > c ? this._movementData.loop : c, this._onMovementList = !1, ccs.ProcessBase.prototype.play.call(this, b, a, c, d), 0 == this._rawDuration ? this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME : (this._loopType = c ? ccs.ANIMATION_TYPE_TO_LOOP_FRONT : ccs.ANIMATION_TYPE_NO_LOOP, this._durationTween = a);
        var e;
        this._tweenList = [];
        var f, g = this._armature.getBoneDic();
        for (f in g) {
            var h = g[f];
            e = this._movementData.movBoneDataDic[h.getName()];
            var i = h.getTween();
            e && 0 < e.frameList.length ? (this._tweenList.push(i), e.duration = this._movementData.duration, i.play(e, b, a, c, d), i.setProcessScale(this._processScale), h.getChildArmature() && h.getChildArmature().getAnimation().setSpeedScale(this._processScale)) : h.isIgnoreMovementBoneData() || (h.getDisplayManager().changeDisplayWithIndex(-1, !1), i.stop())
        }
        this._armature.update(0)
    },
    playByIndex: function(a, b, c, d) {
        cc.log("playByIndex is deprecated. Use playWithIndex instead."), this.playWithIndex(a, b, d)
    },
    playWithIndex: function(a, b, c) {
        var d = this._animationData.movementNames;
        cc.assert(a > -1 && a < d.length), this.play(d[a], b, c)
    },
    playWithNames: function(a, b, c) {
        this._movementListLoop = void 0 === c ? !0 : c, this._movementListDurationTo = void 0 === b ? -1 : b, this._onMovementList = !0, this._movementIndex = 0, a instanceof Array ? this._movementList = a : this._movementList.length = 0, this.updateMovementList()
    },
    playWithIndexes: function(a, b, c) {
        for (this._movementList.length = 0, this._movementListLoop = void 0 === c ? !0 : c, this._movementListDurationTo = void 0 === b ? -1 : b, this._onMovementList = !0, this._movementIndex = 0, b = this._animationData.movementNames, c = 0; c < a.length; c++) this._movementList.push(b[a[c]]);
        this.updateMovementList()
    },
    gotoAndPlay: function(a) {
        if (!this._movementData || 0 > a || a >= this._movementData.duration) cc.log("Please ensure you have played a movement, and the frameIndex is in the range.");
        else {
            var b = this._ignoreFrameEvent;
            this._isPlaying = this._ignoreFrameEvent = !0, this._isComplete = this._isPause = !1, ccs.ProcessBase.prototype.gotoFrame.call(this, a), this._currentPercent = this._curFrameIndex / (this._movementData.duration - 1), this._currentFrame = this._nextFrameIndex * this._currentPercent;
            for (var c = this._tweenList, d = 0; d < c.length; d++) c[d].gotoAndPlay(a);
            this._armature.update(0), this._ignoreFrameEvent = b
        }
    },
    gotoAndPause: function(a) {
        this.gotoAndPlay(a), this.pause()
    },
    getMovementCount: function() {
        return this._animationData.getMovementCount()
    },
    update: function(a) {
        ccs.ProcessBase.prototype.update.call(this, a);
        for (var b = this._tweenList, c = 0; c < b.length; c++) b[c].update(a);
        for (b = this._frameEventQueue; 0 < b.length;) a = b.shift(), this._ignoreFrameEvent = !0, this._frameEventCallFunc && this._frameEventCallFunc.call(this._frameEventTarget, a.bone, a.frameEventName, a.originFrameIndex, a.currentFrameIndex), this._frameEventListener && this._frameEventListener(a.bone, a.frameEventName, a.originFrameIndex, a.currentFrameIndex), this._ignoreFrameEvent = !1;
        for (b = this._movementEventQueue; 0 < b.length;) a = b.shift(), this._movementEventCallFunc && this._movementEventCallFunc.call(this._movementEventTarget, a.armature, a.movementType, a.movementID), this._movementEventListener && this._movementEventListener(a.armature, a.movementType, a.movementID)
    },
    updateHandler: function() {
        var a = this._currentPercent;
        if (a >= 1) {
            switch (this._loopType) {
                case ccs.ANIMATION_TYPE_NO_LOOP:
                    if (this._loopType = ccs.ANIMATION_TYPE_MAX, this._currentFrame = (a - 1) * this._nextFrameIndex, a = this._currentFrame / this._durationTween, 1 > a) {
                        this._nextFrameIndex = this._durationTween, this.movementEvent(this._armature, ccs.MovementEventType.start, this._movementID);
                        break
                    }
                    break;
                case ccs.ANIMATION_TYPE_MAX:
                case ccs.ANIMATION_TYPE_SINGLE_FRAME:
                    a = 1, this._isComplete = !0, this._isPlaying = !1, this.movementEvent(this._armature, ccs.MovementEventType.complete, this._movementID), this.updateMovementList();
                    break;
                case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
                    this._loopType = ccs.ANIMATION_TYPE_LOOP_FRONT, a = ccs.fmodf(a, 1), this._currentFrame = 0 == this._nextFrameIndex ? 0 : ccs.fmodf(this._currentFrame, this._nextFrameIndex), this._nextFrameIndex = 0 < this._durationTween ? this._durationTween : 1, this.movementEvent(this, ccs.MovementEventType.start, this._movementID);
                    break;
                default:
                    this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex), this._toIndex = 0, this.movementEvent(this._armature, ccs.MovementEventType.loopComplete, this._movementID)
            }
            this._currentPercent = a
        }
    },
    getCurrentMovementID: function() {
        return this._isComplete ? "" : this._movementID
    },
    setMovementEventCallFunc: function(a, b) {
        1 == arguments.length ? this._frameEventListener = b : 2 == arguments.length && (this._movementEventTarget = b, this._movementEventCallFunc = a)
    },
    setFrameEventCallFunc: function(a, b) {
        1 == arguments.length ? this._frameEventListener = b : 2 == arguments.length && (this._frameEventTarget = b, this._frameEventCallFunc = a)
    },
    setUserObject: function(a) {
        this._userObject = a
    },
    frameEvent: function(a, b, c, d) {
        if (this._frameEventTarget && this._frameEventCallFunc || this._frameEventListener) {
            var e = new ccs.FrameEvent;
            e.bone = a, e.frameEventName = b, e.originFrameIndex = c, e.currentFrameIndex = d, this._frameEventQueue.push(e)
        }
    },
    movementEvent: function(a, b, c) {
        if (this._movementEventTarget && this._movementEventCallFunc || this._movementEventListener) {
            var d = new ccs.MovementEvent;
            d.armature = a, d.movementType = b, d.movementID = c, this._movementEventQueue.push(d)
        }
    },
    updateMovementList: function() {
        if (this._onMovementList) {
            var a, b = this._movementList;
            this._movementListLoop ? (a = b[this._movementIndex], this.play(a, a.durationTo, 0), this._movementIndex++, this._movementIndex >= b.length && (this._movementIndex = 0)) : this._movementIndex < b.length ? (a = b[this._movementIndex], this.play(a, a.durationTo, 0), this._movementIndex++) : this._onMovementList = !1, this._onMovementList = !0
        }
    },
    setAnimationData: function(a) {

        this._animationData != a && (this._animationData = a)
    },
    getAnimationData: function() {
        return this._animationData
    },
    getUserObject: function() {
        return this._userObject
    },
    isIgnoreFrameEvent: function() {
        return this._ignoreFrameEvent
    }
}), _p = ccs.ArmatureAnimation.prototype, cc.defineGetterSetter(_p, "speedScale", _p.getSpeedScale, _p.setSpeedScale), cc.defineGetterSetter(_p, "animationScale", _p.getAnimationScale, _p.setAnimationScale), _p = null, ccs.ArmatureAnimation.create = function(a) {
    var b = new ccs.ArmatureAnimation;
    return b && b.init(a) ? b : null
}, ccs.Tween = ccs.ProcessBase.extend({
    _tweenData: null,
    _to: null,
    _from: null,
    _between: null,
    _movementBoneData: null,
    _bone: null,
    _frameTweenEasing: 0,
    _betweenDuration: 0,
    _totalDuration: 0,
    _toIndex: 0,
    _fromIndex: 0,
    _animation: null,
    _passLastFrame: !1,
    ctor: function() {
        ccs.ProcessBase.prototype.ctor.call(this), this._frameTweenEasing = ccs.TweenType.linear
    },
    init: function(a) {
        return this._from = new ccs.FrameData, this._between = new ccs.FrameData, this._bone = a, this._tweenData = this._bone.getTweenData(), this._tweenData.displayIndex = -1, this._animation = null != this._bone.getArmature() ? this._bone.getArmature().getAnimation() : null, !0
    },
    play: function(a, b, c, d, e) {
        ccs.ProcessBase.prototype.play.call(this, b, c, d, e), this._loopType = d ? ccs.ANIMATION_TYPE_TO_LOOP_FRONT : ccs.ANIMATION_TYPE_NO_LOOP, this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0, e = a != this._movementBoneData, this.setMovementBoneData(a), this._rawDuration = this._movementBoneData.duration, a = this._movementBoneData.getFrameData(0), this._tweenData.displayIndex = a.displayIndex, this._bone.getArmature().getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED && (ccs.TransformHelp.nodeSub(this._tweenData, this._bone.getBoneData()), this._tweenData.scaleX += 1, this._tweenData.scaleY += 1), 0 == this._rawDuration ? (this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME, 0 == b ? this.setBetween(a, a) : this.setBetween(this._tweenData, a), this._frameTweenEasing = ccs.TweenType.linear) : 1 < this._movementBoneData.frameList.length && (this._durationTween = c * this._movementBoneData.scale, d && 0 != this._movementBoneData.delay ? this.setBetween(this._tweenData, this.tweenNodeTo(this.updateFrameData(1 - this._movementBoneData.delay), this._between)) : e && 0 != b ? this.setBetween(this._tweenData, a) : this.setBetween(a, a)), this.tweenNodeTo(0)
    },
    gotoAndPlay: function(a) {
        ccs.ProcessBase.prototype.gotoFrame.call(this, a), this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0, this._isPlaying = !0, this._isComplete = this._isPause = !1, this._currentPercent = this._curFrameIndex / (this._rawDuration - 1), this._currentFrame = this._nextFrameIndex * this._currentPercent
    },
    gotoAndPause: function(a) {
        this.gotoAndPlay(a), this.pause()
    },
    updateHandler: function() {
        var a = this._currentPercent || 1,
            b = this._loopType;
        if (a >= 1) switch (b) {
            case ccs.ANIMATION_TYPE_SINGLE_FRAME:
                a = 1, this._isComplete = !0, this._isPlaying = !1;
                break;
            case ccs.ANIMATION_TYPE_NO_LOOP:
                b = ccs.ANIMATION_TYPE_MAX, a = 0 >= this._durationTween ? 1 : (a - 1) * this._nextFrameIndex / this._durationTween, a >= 1 ? (a = 1, this._isComplete = !0, this._isPlaying = !1) : (this._nextFrameIndex = this._durationTween, this._currentFrame = a * this._nextFrameIndex, this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0);
                break;
            case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
                b = ccs.ANIMATION_TYPE_LOOP_FRONT, this._nextFrameIndex = 0 < this._durationTween ? this._durationTween : 1, 0 != this._movementBoneData.delay ? (this._currentFrame = (1 - this._movementBoneData.delay) * this._nextFrameIndex, a = this._currentFrame / this._nextFrameIndex) : this._currentFrame = a = 0, this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0;
                break;
            case ccs.ANIMATION_TYPE_MAX:
                a = 1, this._isComplete = !0, this._isPlaying = !1;
                break;
            default:
                this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex)
        }
        1 > a && b < ccs.ANIMATION_TYPE_TO_LOOP_BACK && (a = Math.sin(a * cc.PI / 2)), this._currentPercent = a, this._loopType = b, b > ccs.ANIMATION_TYPE_TO_LOOP_BACK && (a = this.updateFrameData(a)), this._frameTweenEasing != ccs.TweenType.tweenEasingMax && this.tweenNodeTo(a)
    },
    setBetween: function(a, b, c) {
        void 0 === c && (c = !0), 0 > a.displayIndex && 0 <= b.displayIndex ? (this._from.copy(b), this._between.subtract(b, b, c)) : 0 > b.displayIndex && 0 <= a.displayIndex ? (this._from.copy(a), this._between.subtract(b, b, c)) : (this._from.copy(a), this._between.subtract(a, b, c)), a.isTween || (this._tweenData.copy(a), this._tweenData.isTween = !0), this.arriveKeyFrame(a)
    },
    arriveKeyFrame: function(a) {
        if (a) {
            var b = this._bone,
                c = b.getDisplayManager(),
                d = a.displayIndex;
            c.getForceChangeDisplay() || c.changeDisplayWithIndex(d, !1), this._tweenData.zOrder = a.zOrder, b.updateZOrder(), this._bone.setBlendFunc(a.blendFunc), (b = b.getChildArmature()) && "" != a.movement && b.getAnimation().play(a.movement)
        }
    },
    tweenNodeTo: function(a, b) {
        b || (b = this._tweenData);
        var c = this._from,
            d = this._between;
        return c.isTween || (a = 0), b.x = c.x + a * d.x, b.y = c.y + a * d.y, b.scaleX = c.scaleX + a * d.scaleX, b.scaleY = c.scaleY + a * d.scaleY, b.skewX = c.skewX + a * d.skewX, b.skewY = c.skewY + a * d.skewY, this._bone.setTransformDirty(!0), b && d.isUseColorInfo && this.tweenColorTo(a, b), b
    },
    tweenColorTo: function(a, b) {
        var c = this._from,
            d = this._between;
        b.a = c.a + a * d.a, b.r = c.r + a * d.r, b.g = c.g + a * d.g, b.b = c.b + a * d.b, this._bone.updateColor()
    },
    updateFrameData: function(a) {
        a > 1 && 0 != this._movementBoneData.delay && (a = ccs.fmodf(a, 1)), a *= this._rawDuration - 1;
        var b, c, d = this._totalDuration,
            e = this._betweenDuration,
            f = this._toIndex;
        if (d > a || a >= d + e) {
            var e = this._movementBoneData.frameList,
                g = e.length;
            if (a < e[0].frameID) return b = c = e[0], this.setBetween(b, c), this._currentPercent;
            if (a >= e[g - 1].frameID) {
                if (this._passLastFrame) return b = c = e[g - 1], this.setBetween(b, c), this._currentPercent;
                this._passLastFrame = !0
            } else this._passLastFrame = !1;
            do
                if (this._fromIndex = f, b = e[this._fromIndex], d = b.frameID, f = this._fromIndex + 1, f >= g && (f = 0), c = e[f], b.strEvent && !this._animation.isIgnoreFrameEvent() && this._animation.frameEvent(this._bone, b.strEvent, b.frameID, a), a == b.frameID || this._passLastFrame && this._fromIndex == g - 1) break; while (a < b.frameID || a >= c.frameID);
            e = c.frameID - b.frameID, this._frameTweenEasing = b.tweenEasing, this.setBetween(b, c, !1), this._totalDuration = d, this._betweenDuration = e, this._toIndex = f
        }
        return a = 0 == e ? 0 : (a - this._totalDuration) / this._betweenDuration, b = this._frameTweenEasing != ccs.TweenType.linear ? this._frameTweenEasing : this._tweenEasing, b != ccs.TweenType.tweenEasingMax && b != ccs.TweenType.linear && !this._passLastFrame && (a = ccs.TweenFunction.tweenTo(a, b, this._from.easingParams)), a
    },
    setAnimation: function(a) {
        this._animation = a
    },
    getAnimation: function() {
        return this._animation
    },
    setMovementBoneData: function(a) {
        this._movementBoneData = a
    }
}), _p = ccs.Tween.prototype, cc.defineGetterSetter(_p, "animation", _p.getAnimation, _p.setAnimation), _p = null, ccs.Tween.create = function(a) {
    var b = new ccs.Tween;
    return b && b.init(a) ? b : null
}, ccs.PT_RATIO = 32, ccs.ColliderFilter = ccs.Class.extend({
    _collisionType: 0,
    _group: 0,
    _categoryBits: 0,
    _groupIndex: 0,
    _maskBits: 0,
    ctor: function(a, b) {
        this._collisionType = a || 0, this._group = b || 0
    },
    updateShape: function(a) {
        if (a instanceof cp.Shape) a.collision_type = this._collisionType, a.group = this._group;
        else if (a instanceof Box2D.b2FilterData) {
            var b = new Box2D.b2FilterData;
            b.categoryBits = this._categoryBits, b.groupIndex = this._groupIndex, b.maskBits = this._maskBits, a.SetFilterData(b)
        }
    }
}), ccs.ColliderBody = ccs.Class.extend({
    shape: null,
    coutourData: null,
    colliderFilter: null,
    _calculatedVertexList: null,
    ctor: function(a) {
        this.shape = null, this.coutourData = a, this.colliderFilter = new ccs.ColliderFilter, ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX && (this._calculatedVertexList = [])
    },
    getContourData: function() {
        return this.coutourData
    },
    setColliderFilter: function(a) {
        this.colliderFilter = a
    },
    getCalculatedVertexList: function() {
        return this._calculatedVertexList
    },
    setB2Fixture: function(a) {
        this._fixture = a
    },
    getB2Fixture: function() {
        return this._fixture
    },
    setShape: function(a) {
        this.shape = a
    },
    getShape: function() {
        return this.shape
    },
    setContourData: function(a) {
        this.coutourData = a
    },
    getColliderFilter: function() {
        return this.colliderFilter
    }
}), ccs.ColliderDetector = ccs.Class.extend({
    _colliderBodyList: null,
    _bone: null,
    _body: null,
    _active: !1,
    _filter: null,
    helpPoint: cc.p(0, 0),
    ctor: function() {
        this._colliderBodyList = [], this._body = this._bone = null, this._active = !1, this._filter = null
    },
    init: function(a) {
        return this._colliderBodyList.length = 0, a && (this._bone = a), this._filter = new ccs.ColliderFilter, !0
    },
    addContourData: function(a) {
        var b = new ccs.ColliderBody(a);
        if (this._colliderBodyList.push(b), ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {
            b = b.getCalculatedVertexList(), a = a.vertexList;
            for (var c = 0; c < a.length; c++) {
                var d = new ccs.ContourVertex2(0, 0);
                b.push(d)
            }
        }
    },
    addContourDataList: function(a) {
        for (var b = 0; b < a.length; b++) this.addContourData(a[b])
    },
    removeContourData: function(a) {
        var b, c = [],
            d = this._colliderBodyList;
        for (b = 0; b < d.length; b++) {
            var e = d[b];
            e && e.getContourData() == a && c.push(e)
        }
        for (b = 0; b < c.length; b++) cc.arrayRemoveObject(d, c[b])
    },
    removeAll: function() {
        this._colliderBodyList.length = 0
    },
    setActive: function(a) {
        if (this._active != a) {
            this._active = a, a = this._body;
            var b;
            if (a)
                if (b = null, this._active)
                    for (var c = 0; c < this._colliderBodyList.length; c++) b = this._colliderBodyList[c], b = b.getShape(), a.space.addShape(b);
                else
                    for (c = 0; c < this._colliderBodyList.length; c++) b = this._colliderBodyList[c], b = b.getShape(), a.space.removeShape(b)
        }
    },
    getActive: function() {
        return this._active
    },
    getColliderBodyList: function() {
        return this._colliderBodyList
    },
    setColliderFilter: function(a) {
        this._filter = a;
        for (var b = this._colliderBodyList, c = 0; c < b.length; c++) {
            var d = b[c];
            d.setColliderFilter(a), d.getShape() && d.getColliderFilter().updateShape(d.getShape())
        }
    },
    getColliderFilter: function() {
        return this._filter
    },
    updateTransform: function(a) {
        if (this._active)
            for (var b = null, c = this._body, d = this.helpPoint, e = 0; e < this._colliderBodyList.length; e++) {
                var b = this._colliderBodyList[e],
                    f = b.getContourData(),
                    g = null;
                c && (g = b.getShape());
                for (var f = f.vertexList, h = b.getCalculatedVertexList(), b = 0; b < f.length; b++) {
                    if (d.x = f[b].x, d.y = f[b].y, d = cc.pointApplyAffineTransform(d, a), ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {
                        var i = cc.p(0, 0);
                        i.x = d.x, i.y = d.y, h[b] = i
                    }
                    g && (g.verts[2 * b] = d.x, g.verts[2 * b + 1] = d.y)
                }
                if (g)
                    for (b = 0; b < f.length; b++) h = cp.v.normalize(cp.v.perp(cp.v.sub(g.verts[(b + 1) % g.verts.length], g.verts[b]))), g.axes[b].n = h, g.axes[b].d = cp.v.dot(h, g.verts[b])
            }
    },
    setBody: function(a) {
        this._body = a;
        for (var b = this._colliderBodyList, c = 0; c < b.length; c++) {
            a = b[c];
            for (var d = [], e = a.getContourData().vertexList, f = 0; f < e.length; f++) {
                var g = e[f];
                d.push(g.x), d.push(g.y)
            }
            d = new cp.PolyShape(this._body, d, cp.vzero), d.sensor = !0, d.data = this._bone, this._active && this._body.space.addShape(d), a.setShape(d), a.getColliderFilter().updateShape(d)
        }
    },
    getBody: function() {
        return this._body
    }
}), _p = ccs.ColliderDetector.prototype, cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter), cc.defineGetterSetter(_p, "active", _p.getActive, _p.setActive), cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody), _p = null, ccs.ColliderDetector.create = function(a) {
    var b = new ccs.ColliderDetector;
    return b && b.init(a) ? b : null
}, ccs.Armature = ccs.Node.extend({
    animation: null,
    armatureData: null,
    batchNode: null,
    _textureAtlas: null,
    _parentBone: null,
    _boneDic: null,
    _topBoneList: null,
    _armatureIndexDic: null,
    _offsetPoint: null,
    version: 0,
    _armatureTransformDirty: !0,
    _body: null,
    _blendFunc: null,
    _className: "Armature",
    _realAnchorPointInPoints: null,
    ctor: function(a, b) {
        cc.Node.prototype.ctor.call(this), this._name = "", this._topBoneList = [], this._armatureIndexDic = {}, this._offsetPoint = cc.p(0, 0), this._armatureTransformDirty = !0, this._realAnchorPointInPoints = cc.p(0, 0), a && ccs.Armature.prototype.init.call(this, a, b)
    },
    init: function(a, b) {
        cc.Node.prototype.init.call(this), b && (this._parentBone = b), this.removeAllChildren(), this.animation = new ccs.ArmatureAnimation, this.animation.init(this), this._boneDic = {}, this._topBoneList.length = 0, this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        }, this._name = a || "";
        var c, d = ccs.armatureDataManager;
        if ("" != a) {
            c = d.getAnimationData(a), cc.assert(c, "AnimationData not exist!"), this.animation.setAnimationData(c), d = d.getArmatureData(a), cc.assert(d, "ArmatureData not exist!"), this.armatureData = d;
            var e, d = d.getBoneDataDic();
            for (e in d) {
                var d = this.createBone(String(e)),
                    f = c.getMovement(c.movementNames[0]);
                !f || !(f = f.getMovementBoneData(d.getName())) || 0 >= f.frameList.length || (f = f.getFrameData(0)) && (d.getTweenData().copy(f), d.changeDisplayWithIndex(f.displayIndex, !1))
            }
            this.update(0), this.updateOffsetPoint()
        } else this._name = "new_armature", this.armatureData = ccs.ArmatureData.create(), this.armatureData.name = this._name, c = ccs.AnimationData.create(), c.name = this._name, d.addArmatureData(this._name, this.armatureData), d.addAnimationData(this._name, c), this.animation.setAnimationData(c);
        return cc._renderType === cc._RENDER_TYPE_WEBGL && this.setShaderProgram(cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)), this.setCascadeOpacityEnabled(!0), this.setCascadeColorEnabled(!0), !0
    },
    createBone: function(a) {
        var b = this.getBone(a);
        if (b) return b;
        var b = this.armatureData.getBoneData(a),
            c = b.parentName,
            d = null;
        return c ? (this.createBone(c), d = ccs.Bone.create(a), this.addBone(d, c)) : (d = ccs.Bone.create(a), this.addBone(d, "")), d.setBoneData(b), d.getDisplayManager().changeDisplayWithIndex(-1, !1), d
    },
    addBone: function(a, b) {
        cc.assert(a, "Argument must be non-nil");
        var c = this._boneDic;
        if (a.getName() && cc.assert(!c[a.getName()], "bone already added. It can't be added again"), b) {
            var d = c[b];
            d ? d.addChildBone(a) : this._topBoneList.push(a)
        } else this._topBoneList.push(a);
        a.setArmature(this), c[a.getName()] = a, this.addChild(a)
    },
    removeBone: function(a, b) {
        cc.assert(a, "bone must be added to the bone dictionary!"), a.setArmature(null), a.removeFromParent(b), cc.arrayRemoveObject(this._topBoneList, a), delete this._boneDic[a.getName()], this.removeChild(a, !0)
    },
    getBone: function(a) {
        return this._boneDic[a]
    },
    changeBoneParent: function(a, b) {
        cc.assert(a, "bone must be added to the bone dictionary!");
        var c = a.getParentBone();
        c && (cc.arrayRemoveObject(c.getChildren(), a), a.setParentBone(null)), b && ((c = this._boneDic[b]) ? (c.addChildBone(a), cc.arrayRemoveObject(this._topBoneList, a)) : this._topBoneList.push(a))
    },
    getBoneDic: function() {
        return this._boneDic
    },
    updateOffsetPoint: function() {
        var a = this.getBoundingBox();
        this.setContentSize(a);
        var b = this._offsetPoint;
        b.x = -a.x, b.y = -a.y, 0 != a.width && 0 != a.height && this.setAnchorPoint(b.x / a.width, b.y / a.height)
    },
    setAnchorPoint: function(a, b) {
        var c, d;
        void 0 !== b ? (c = a, d = b) : (c = a.x, d = a.y);
        var e = this._anchorPoint;
        if (c != e.x || d != e.y) {
            var f = this._contentSize;
            e.x = c, e.y = d, this._anchorPointInPoints.x = f.width * e.x - this._offsetPoint.x, this._anchorPointInPoints.y = f.height * e.y - this._offsetPoint.y, this._realAnchorPointInPoints.x = f.width * e.x, this._realAnchorPointInPoints.y = f.height * e.y, this.setNodeDirty()
        }
    },
    _setAnchorX: function(a) {
        this._anchorPoint.x !== a && (this._anchorPoint.x = a, this._anchorPointInPoints.x = this._contentSize.width * a - this._offsetPoint.x, this._realAnchorPointInPoints.x = this._contentSize.width * a, this.setNodeDirty())
    },
    _setAnchorY: function(a) {
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._anchorPointInPoints.y = this._contentSize.height * a - this._offsetPoint.y, this._realAnchorPointInPoints.y = this._contentSize.height * a, this.setNodeDirty())
    },
    getAnchorPointInPoints: function() {
        return this._realAnchorPointInPoints
    },
    setAnimation: function(a) {
        this.animation = a
    },
    getAnimation: function() {
        return this.animation
    },
    getArmatureTransformDirty: function() {
        return this._armatureTransformDirty
    },
    update: function(a) {
        this.animation.update(a);
        for (var b = this._topBoneList, c = 0; c < b.length; c++) b[c].update(a);
        this._armatureTransformDirty = !1
    },
    draw: function(a) {
        for (var b = this._children, c = cc.BlendFunc.ALPHA_PREMULTIPLIED, d = cc.BlendFunc.ALPHA_NON_PREMULTIPLIED, e = 0, f = b.length; f > e; e++) {
            var g = b[e];
            if (g && g.getDisplayRenderNode) {
                var h = g.getDisplayRenderNode();
                if (null != h) switch (cc._renderType === cc._RENDER_TYPE_WEBGL && h.setShaderProgram(this._shaderProgram), g.getDisplayRenderNodeType()) {
                    case ccs.DISPLAY_TYPE_SPRITE:
                        if (h instanceof ccs.Skin)
                            if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
                                h.updateTransform();
                                var i = g.getBlendFunc();
                                h.setBlendFunc(i.src != c.src || i.dst != c.dst ? g.getBlendFunc() : this._blendFunc.src != c.src || this._blendFunc.dst != c.dst || h.getTexture().hasPremultipliedAlpha() ? this._blendFunc : d), h.draw(a)
                            } else h.visit(a);
                        break;
                    case ccs.DISPLAY_TYPE_ARMATURE:
                        h.draw(a);
                        break;
                    default:
                        h.visit(a)
                }
            } else g instanceof cc.Node && (cc._renderType === cc._RENDER_TYPE_WEBGL && g.setShaderProgram(this._shaderProgram), g.visit(a))
        }
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this), this.scheduleUpdate()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this), this.unscheduleUpdate()
    },
    visit: null,
    _visitForCanvas: function(a) {
        var b = a || cc._renderContext;
        this._visible && (b.save(), this.transform(b), this.sortAllChildren(), this.draw(a), this._cacheDirty = !1, this.arrivalOrder = 0, b.restore())
    },
    _visitForWebGL: function() {
        if (this._visible) {
            var a = cc._renderContext,
                b = cc.current_stack;
            b.stack.push(b.top), cc.kmMat4Assign(this._stackMatrix, b.top), b.top = this._stackMatrix, this.transform(), this.sortAllChildren(), this.draw(a), this.arrivalOrder = 0, b.top = b.stack.pop()
        }
    },
    getBoundingBox: function() {
        for (var a, b, c, d = 0, e = !0, f = cc.rect(0, 0, 0, 0), g = this._children, h = g.length, i = 0; h > i; i++)(a = g[i]) && (d = a.getDisplayManager().getBoundingBox(), 0 == d.x && 0 == d.y && 0 == d.width && 0 == d.height || (e ? (a = d.x, b = d.y, c = d.x + d.width, d = d.y + d.height, e = !1) : (a = d.x < f.x ? d.x : f.x, b = d.y < f.y ? d.y : f.y, c = d.x + d.width > f.x + f.width ? d.x + d.width : f.x + f.width, d = d.y + d.height > f.y + f.height ? d.y + d.height : f.y + f.height), f.x = a, f.y = b, f.width = c - a, f.height = d - b));
        return cc.rectApplyAffineTransform(f, this.getNodeToParentTransform())
    },
    getBoneAtPoint: function(a, b) {
        for (var c = this._children, d = c.length - 1; d >= 0; d--) {
            var e = c[d];
            if (e instanceof ccs.Bone && e.getDisplayManager().containPoint(a, b)) return e
        }
        return null
    },
    setParentBone: function(a) {
        this._parentBone = a, a = this._boneDic;
        for (var b in a) a[b].setArmature(this)
    },
    getParentBone: function() {
        return this._parentBone
    },
    drawContour: function() {
        cc._drawingUtil.setDrawColor(255, 255, 255, 255), cc._drawingUtil.setLineWidth(1);
        var a, b = this._boneDic;
        for (a in b) {
            var c = b[a].getColliderDetector();
            if (c)
                for (var c = c.getColliderBodyList(), d = 0; d < c.length; d++) {
                    var e = c[d].getCalculatedVertexList();
                    cc._drawingUtil.drawPoly(e, e.length, !0)
                }
        }
    },
    setBody: function(a) {
        if (this._body != a) {
            this._body = a, this._body.data = this;
            var b, c;
            a = this._children;
            for (var d = 0; d < a.length; d++)
                if (b = a[d], b instanceof ccs.Bone) {
                    b = b.getDisplayManager().getDecorativeDisplayList();
                    for (var e = 0; e < b.length; e++) c = b[e], (c = c.getColliderDetector()) && c.setBody(this._body)
                }
        }
    },
    getShapeList: function() {
        return this._body ? this._body.shapeList : null
    },
    getBody: function() {
        return this._body
    },
    setBlendFunc: function(a) {
        this._blendFunc = a
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setColliderFilter: function(a) {
        var b, c = this._boneDic;
        for (b in c) c[b].setColliderFilter(a)
    },
    getArmatureData: function() {
        return this.armatureData
    },
    setArmatureData: function(a) {
        this.armatureData = a
    },
    getBatchNode: function() {
        return this.batchNode
    },
    setBatchNode: function(a) {
        this.batchNode = a
    },
    getVersion: function() {
        return this.version
    },
    setVersion: function(a) {
        this.version = a
    }
}), ccs.Armature.prototype.visit = cc._renderType == cc._RENDER_TYPE_WEBGL ? ccs.Armature.prototype._visitForWebGL : ccs.Armature.prototype._visitForCanvas, _p = ccs.Armature.prototype, cc.defineGetterSetter(_p, "parentBone", _p.getParentBone, _p.setParentBone), cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody), cc.defineGetterSetter(_p, "colliderFilter", null, _p.setColliderFilter), _p = null, ccs.Armature.create = function(a, b) {
    var c = new ccs.Armature;
    return c.init(a, b) ? c : null
}, ccs.Bone = ccs.Node.extend({
    _boneData: null,
    _armature: null,
    _childArmature: null,
    _displayManager: null,
    ignoreMovementBoneData: !1,
    _tween: null,
    _tweenData: null,
    _parentBone: null,
    _boneTransformDirty: !1,
    _worldTransform: null,
    _blendFunc: 0,
    blendDirty: !1,
    _worldInfo: null,
    _armatureParentBone: null,
    _dataVersion: 0,
    _className: "Bone",
    ctor: function() {
        cc.Node.prototype.ctor.call(this), this._displayManager = this._tween = this._boneData = this._childArmature = this._armature = this._parentBone = this._tweenData = null, this.ignoreMovementBoneData = !1, this._worldTransform = cc.affineTransformMake(1, 0, 0, 1, 0, 0), this._boneTransformDirty = !0, this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), this.blendDirty = !1, this._armatureParentBone = this._worldInfo = null, this._dataVersion = 0
    },
    init: function(a) {
        return a && (this._name = a), this._tweenData = new ccs.FrameData, this._tween = new ccs.Tween, this._tween.init(this), this._displayManager = new ccs.DisplayManager, this._displayManager.init(this), this._worldInfo = new ccs.BaseData, this._boneData = new ccs.BaseData, !0
    },
    setBoneData: function(a) {
        cc.assert(a, "_boneData must not be null"), this._boneData != a && (this._boneData = a), this.setName(this._boneData.name), this._localZOrder = this._boneData.zOrder, this._displayManager.initDisplayList(a)
    },
    getBoneData: function() {
        return this._boneData
    },
    setArmature: function(a) {
        (this._armature = a) ? (this._tween.setAnimation(this._armature.getAnimation()), this._dataVersion = this._armature.getArmatureData().dataVersion, this._armatureParentBone = this._armature.getParentBone()) : this._armatureParentBone = null
    },
    getArmature: function() {
        return this._armature
    },
    update: function(a) {
        if (this._parentBone && (this._boneTransformDirty = this._boneTransformDirty || this._parentBone.isTransformDirty()), this._armatureParentBone && !this._boneTransformDirty && (this._boneTransformDirty = this._armatureParentBone.isTransformDirty()), this._boneTransformDirty) {
            var b = this._tweenData;
            this._dataVersion >= ccs.CONST_VERSION_COMBINED && (ccs.TransformHelp.nodeConcat(b, this._boneData), b.scaleX -= 1, b.scaleY -= 1);
            var c = this._worldInfo;
            c.copy(b), c.x = b.x + this._position.x, c.y = b.y + this._position.y, c.scaleX = b.scaleX * this._scaleX, c.scaleY = b.scaleY * this._scaleY, c.skewX = b.skewX + this._skewX + this._rotationX, c.skewY = b.skewY + this._skewY - this._rotationY, this._parentBone ? this.applyParentTransform(this._parentBone) : this._armatureParentBone && this.applyParentTransform(this._armatureParentBone), ccs.TransformHelp.nodeToMatrix(c, this._worldTransform), this._armatureParentBone && (this._worldTransform = cc.affineTransformConcat(this._worldTransform, this._armature.getNodeToParentTransform()))
        }
        for (ccs.displayFactory.updateDisplay(this, a, this._boneTransformDirty || this._armature.getArmatureTransformDirty()), b = 0; b < this._children.length; b++) this._children[b].update(a);
        this._boneTransformDirty = !1
    },
    applyParentTransform: function(a) {
        var b = this._worldInfo,
            c = a._worldTransform;
        a = a._worldInfo;
        var d = b.x,
            e = b.y;
        b.x = d * c.a + e * c.c + a.x, b.y = d * c.b + e * c.d + a.y, b.scaleX *= a.scaleX, b.scaleY *= a.scaleY, b.skewX += a.skewX, b.skewY += a.skewY
    },
    setBlendFunc: function(a) {
        (this._blendFunc.src != a.src || this._blendFunc.dst != a.dst) && (this._blendFunc = a, this.blendDirty = !0)
    },
    updateDisplayedColor: function(a) {
        this._realColor = cc.color(255, 255, 255), cc.Node.prototype.updateDisplayedColor.call(this, a), this.updateColor()
    },
    updateDisplayedOpacity: function(a) {
        this._realOpacity = 255, cc.Node.prototype.updateDisplayedOpacity.call(this, a), this.updateColor()
    },
    updateColor: function() {
        var a = this._displayManager.getDisplayRenderNode();
        null != a && (a.setColor(cc.color(this._displayedColor.r * this._tweenData.r / 255, this._displayedColor.g * this._tweenData.g / 255, this._displayedColor.b * this._tweenData.b / 255)), a.setOpacity(this._displayedOpacity * this._tweenData.a / 255))
    },
    updateZOrder: function() {
        this.setLocalZOrder(this._armature.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED ? this._tweenData.zOrder + this._boneData.zOrder : this._tweenData.zOrder)
    },
    addChildBone: function(a) {
        cc.assert(a, "Argument must be non-nil"), cc.assert(!a.parentBone, "child already added. It can't be added again"), 0 > this._children.indexOf(a) && (this._children.push(a), a.setParentBone(this))
    },
    removeChildBone: function(a, b) {
        if (0 < this._children.length && -1 != this._children.getIndex(a)) {
            if (b)
                for (var c = a._children, d = 0; d < c.length; d++) a.removeChildBone(c[d], b);
            a.setParentBone(null), a.getDisplayManager().setCurrentDecorativeDisplay(null), cc.arrayRemoveObject(this._children, a)
        }
    },
    removeFromParent: function(a) {
        this._parentBone && this._parentBone.removeChildBone(this, a)
    },
    setParentBone: function(a) {
        this._parentBone = a
    },
    getParentBone: function() {
        return this._parentBone
    },
    setChildArmature: function(a) {
        this._childArmature != a && (null == a && this._childArmature && this._childArmature.setParentBone(null), this._childArmature = a)
    },
    getChildArmature: function() {
        return this._childArmature
    },
    getTween: function() {
        return this._tween
    },
    setLocalZOrder: function(a) {
        this._localZOrder != a && cc.Node.prototype.setLocalZOrder.call(this, a)
    },
    getNodeToArmatureTransform: function() {
        return this._worldTransform
    },
    getNodeToWorldTransform: function() {
        return cc.affineTransformConcat(this._worldTransform, this._armature.getNodeToWorldTransform())
    },
    getDisplayRenderNode: function() {
        return this._displayManager.getDisplayRenderNode()
    },
    getDisplayRenderNodeType: function() {
        return this._displayManager.getDisplayRenderNodeType()
    },
    addDisplay: function(a, b) {
        return this._displayManager.addDisplay(a, b || 0)
    },
    removeDisplay: function(a) {
        this._displayManager.removeDisplay(a)
    },
    changeDisplayByIndex: function(a, b) {
        cc.log("changeDisplayByIndex is deprecated. Use changeDisplayWithIndex instead."), this.changeDisplayWithIndex(a, b)
    },
    changeDisplayByName: function(a, b) {
        this.changeDisplayWithName(a, b)
    },
    changeDisplayWithIndex: function(a, b) {
        this._displayManager.changeDisplayWithIndex(a, b)
    },
    changeDisplayWithName: function(a, b) {
        this._displayManager.changeDisplayWithName(a, b)
    },
    getColliderDetector: function() {
        var a = this._displayManager.getCurrentDecorativeDisplay();
        return a && (a = a.getColliderDetector()) ? a : null
    },
    setColliderFilter: function(a) {
        for (var b = this._displayManager.getDecorativeDisplayList(), c = 0; c < b.length; c++) {
            var d = b[c].getColliderDetector();
            d && d.setColliderFilter(a)
        }
    },
    getColliderFilter: function() {
        var a = this.displayManager.getCurrentDecorativeDisplay();
        return a && (a = a.getColliderDetector()) ? a.getColliderFilter() : null
    },
    setTransformDirty: function(a) {
        this._boneTransformDirty = a
    },
    isTransformDirty: function() {
        return this._boneTransformDirty
    },
    getDisplayManager: function() {
        return this._displayManager
    },
    setIgnoreMovementBoneData: function(a) {
        this._ignoreMovementBoneData = a
    },
    isIgnoreMovementBoneData: function() {
        return this._ignoreMovementBoneData
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendDirty: function(a) {
        this._blendDirty = a
    },
    isBlendDirty: function() {
        return this._blendDirty
    },
    getTweenData: function() {
        return this._tweenData
    },
    getWorldInfo: function() {
        return this._worldInfo
    },
    getChildrenBone: function() {
        return this._children
    },
    nodeToArmatureTransform: function() {
        return this.getNodeToArmatureTransform()
    },
    nodeToWorldTransform: function() {
        return this.getNodeToWorldTransform()
    },
    getColliderBodyList: function() {
        var a = this.getColliderDetector();
        return a ? a.getColliderBodyList() : null
    },
    getIgnoreMovementBoneData: function() {
        return this.isIgnoreMovementBoneData()
    }
}), _p = ccs.Bone.prototype, cc.defineGetterSetter(_p, "boneData", _p.getBoneData, _p.setBoneData), cc.defineGetterSetter(_p, "armature", _p.getArmature, _p.setArmature), cc.defineGetterSetter(_p, "childArmature", _p.getChildArmature, _p.setChildArmature), cc.defineGetterSetter(_p, "childrenBone", _p.getChildrenBone), cc.defineGetterSetter(_p, "tween", _p.getTween), cc.defineGetterSetter(_p, "tweenData", _p.getTweenData), cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter), _p = null, ccs.Bone.create = function(a) {
    var b = new ccs.Bone;
    return b && b.init(a) ? b : null
}, ccs.FRAME_TYPE_MOVE = 0, ccs.FRAME_TYPE_SCALE = 1, ccs.FRAME_TYPE_ROTATE = 2, ccs.FRAME_TYPE_TINT = 3, ccs.FRAME_TYPE_FADE = 4, ccs.FRAME_TYPE_MAX = 5, ccs.FrameEaseType = {
    Custom: -1,
    Linear: 0,
    Sine_EaseIn: 1,
    Sine_EaseOut: 2,
    Sine_EaseInOut: 3,
    Quad_EaseIn: 4,
    Quad_EaseOut: 5,
    Quad_EaseInOut: 6,
    Cubic_EaseIn: 7,
    Cubic_EaseOut: 8,
    Cubic_EaseInOut: 9,
    Quart_EaseIn: 10,
    Quart_EaseOut: 11,
    Quart_EaseInOut: 12,
    Quint_EaseIn: 13,
    Quint_EaseOut: 14,
    Quint_EaseInOut: 15,
    Expo_EaseIn: 16,
    Expo_EaseOut: 17,
    Expo_EaseInOut: 18,
    Circ_EaseIn: 19,
    Circ_EaseOut: 20,
    Circ_EaseInOut: 21,
    Elastic_EaesIn: 22,
    Elastic_EaesOut: 23,
    Elastic_EaesInOut: 24,
    Back_EaseIn: 25,
    Back_EaseOut: 26,
    Back_EaseInOut: 27,
    Bounce_EaseIn: 28,
    Bounce_EaseOut: 29,
    Bounce_EaseInOut: 30
}, ccs.ActionFrame = ccs.Class.extend({
    frameType: 0,
    easingType: 0,
    frameIndex: 0,
    _Parameter: null,
    time: 0,
    ctor: function() {
        this.frameType = 0, this.easingType = ccs.FrameEaseType.Linear, this.time = this.frameIndex = 0
    },
    getAction: function() {
        return cc.log("Need a definition of <getAction> for ActionFrame"), null
    },
    _getEasingAction: function(a) {
        if (null === a) return console.error("Action cannot be null!"), null;
        var b;
        switch (this.easingType) {
            case ccs.FrameEaseType.Linear:
                b = a;
                break;
            case ccs.FrameEaseType.Sine_EaseIn:
                b = a.easing(cc.easeSineIn());
                break;
            case ccs.FrameEaseType.Sine_EaseOut:
                b = a.easing(cc.easeSineOut());
                break;
            case ccs.FrameEaseType.Sine_EaseInOut:
                b = a.easing(cc.easeSineInOut());
                break;
            case ccs.FrameEaseType.Quad_EaseIn:
                b = a.easing(cc.easeQuadraticActionIn());
                break;
            case ccs.FrameEaseType.Quad_EaseOut:
                b = a.easing(cc.easeQuadraticActionOut());
                break;
            case ccs.FrameEaseType.Quad_EaseInOut:
                b = a.easing(cc.easeQuadraticActionInOut());
                break;
            case ccs.FrameEaseType.Cubic_EaseIn:
                b = a.easing(cc.easeCubicActionIn());
                break;
            case ccs.FrameEaseType.Cubic_EaseOut:
                b = a.easing(cc.easeCubicActionOut());
                break;
            case ccs.FrameEaseType.Cubic_EaseInOut:
                b = a.easing(cc.easeCubicActionInOut());
                break;
            case ccs.FrameEaseType.Quart_EaseIn:
                b = a.easing(cc.easeQuarticActionIn());
                break;
            case ccs.FrameEaseType.Quart_EaseOut:
                b = a.easing(cc.easeQuarticActionOut());
                break;
            case ccs.FrameEaseType.Quart_EaseInOut:
                b = a.easing(cc.easeQuarticActionInOut());
                break;
            case ccs.FrameEaseType.Quint_EaseIn:
                b = a.easing(cc.easeQuinticActionIn());
                break;
            case ccs.FrameEaseType.Quint_EaseOut:
                b = a.easing(cc.easeQuinticActionOut());
                break;
            case ccs.FrameEaseType.Quint_EaseInOut:
                b = a.easing(cc.easeQuinticActionInOut());
                break;
            case ccs.FrameEaseType.Expo_EaseIn:
                b = a.easing(cc.easeExponentialIn());
                break;
            case ccs.FrameEaseType.Expo_EaseOut:
                b = a.easing(cc.easeExponentialOut());
                break;
            case ccs.FrameEaseType.Expo_EaseInOut:
                b = a.easing(cc.easeExponentialInOut());
                break;
            case ccs.FrameEaseType.Circ_EaseIn:
                b = a.easing(cc.easeCircleActionIn());
                break;
            case ccs.FrameEaseType.Circ_EaseOut:
                b = a.easing(cc.easeCircleActionOut());
                break;
            case ccs.FrameEaseType.Circ_EaseInOut:
                b = a.easing(cc.easeCircleActionInOut());
                break;
            case ccs.FrameEaseType.Elastic_EaesIn:
                b = a.easing(cc.easeElasticIn());
                break;
            case ccs.FrameEaseType.Elastic_EaesOut:
                b = a.easing(cc.easeElasticOut());
                break;
            case ccs.FrameEaseType.Elastic_EaesInOut:
                b = a.easing(cc.easeElasticInOut());
                break;
            case ccs.FrameEaseType.Back_EaseIn:
                b = a.easing(cc.easeBackIn());
                break;
            case ccs.FrameEaseType.Back_EaseOut:
                b = a.easing(cc.easeBackOut());
                break;
            case ccs.FrameEaseType.Back_EaseInOut:
                b = a.easing(cc.easeBackInOut());
                break;
            case ccs.FrameEaseType.Bounce_EaseIn:
                b = a.easing(cc.easeBounceIn());
                break;
            case ccs.FrameEaseType.Bounce_EaseOut:
                b = a.easing(cc.easeBounceOut());
                break;
            case ccs.FrameEaseType.Bounce_EaseInOut:
                b = a.easing(cc.easeBounceInOut())
        }
        return b
    },
    setEasingParameter: function(a) {
        this._Parameter = [];
        for (var b = 0; b < a.length; b++) this._Parameter.push(a[b])
    },
    setEasingType: function(a) {
        this.easingType = a
    }
}), ccs.ActionMoveFrame = ccs.ActionFrame.extend({
    _position: null,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this), this._position = cc.p(0, 0), this.frameType = ccs.FRAME_TYPE_MOVE
    },
    setPosition: function(a, b) {
        void 0 === b ? (this._position.x = a.x, this._position.y = a.y) : (this._position.x = a, this._position.y = b)
    },
    getPosition: function() {
        return this._position
    },
    getAction: function(a) {
        return this._getEasingAction(cc.moveTo(a, this._position))
    }
}), ccs.ActionScaleFrame = ccs.ActionFrame.extend({
    _scaleX: 1,
    _scaleY: 1,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this), this._scaleY = this._scaleX = 1, this.frameType = ccs.FRAME_TYPE_SCALE
    },
    setScaleX: function(a) {
        this._scaleX = a
    },
    getScaleX: function() {
        return this._scaleX
    },
    setScaleY: function(a) {
        this._scaleY = a
    },
    getScaleY: function() {
        return this._scaleY
    },
    getAction: function(a) {
        return this._getEasingAction(cc.scaleTo(a, this._scaleX, this._scaleY))
    }
}), ccs.ActionRotationFrame = ccs.ActionFrame.extend({
    _rotation: 0,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this), this._rotation = 0, this.frameType = ccs.FRAME_TYPE_ROTATE
    },
    setRotation: function(a) {
        this._rotation = a
    },
    getRotation: function() {
        return this._rotation
    },
    getAction: function(a, b) {
        return void 0 === b ? this._getEasingAction(cc.rotateTo(a, this._rotation)) : b instanceof cc.ActionRotationFrame ? this._getEasingAction(cc.rotateBy(a, this._rotation - b._rotation)) : this.getAction(a)
    }
}), ccs.ActionFadeFrame = ccs.ActionFrame.extend({
    _opacity: 255,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this), this._opacity = 255, this.frameType = ccs.FRAME_TYPE_FADE
    },
    setOpacity: function(a) {
        this._opacity = a
    },
    getOpacity: function() {
        return this._opacity
    },
    getAction: function(a) {
        return this._getEasingAction(cc.fadeTo(a, this._opacity))
    }
}), ccs.ActionTintFrame = ccs.ActionFrame.extend({
    _color: null,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this), this._color = cc.color(255, 255, 255, 255), this.frameType = ccs.FRAME_TYPE_TINT
    },
    setColor: function(a) {
        var b = this._color;
        b.r = a.r, b.g = a.g, b.b = a.b
    },
    getColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getAction: function(a) {
        return this._getEasingAction(cc.tintTo(a, this._color.r, this._color.g, this._color.b))
    }
}), ccs.actionManager = {
    _actionDic: {},
    initWithDictionary: function(a, b, c) {
        var d = a.lastIndexOf("/");
        a = a.substr(d + 1, a.length), b = b.actionlist;
        for (var d = [], e = 0; e < b.length; e++) {
            var f = new ccs.ActionObject;
            f.initWithDictionary(b[e], c), d.push(f)
        }
        this._actionDic[a] = d
    },
    getActionByName: function(a, b) {
        var c = this._actionDic[a];
        if (!c) return null;
        for (var d = 0; d < c.length; d++) {
            var e = c[d];
            if (b == e.getName()) return e
        }
        return null
    },
    playActionByName: function(a, b, c) {
        (a = this.getActionByName(a, b)) && a.play(c)
    },
    releaseActions: function() {
        this._actionDic = {}
    },
    clear: function() {
        this._actionDic = {}
    }
}, ccs.ActionNode = ccs.Class.extend({
    _currentFrameIndex: 0,
    _destFrameIndex: 0,
    _unitTime: 0,
    _actionTag: 0,
    _bject: null,
    _actionSpawn: null,
    _action: null,
    _frameArray: null,
    _frameArrayNum: 0,
    ctor: function() {
        this._destFrameIndex = this._currentFrameIndex = 0, this._unitTime = .1, this._actionTag = 0, this._action = this._actionSpawn = this._bject = null, this._frameArray = [], this._frameArrayNum = ccs.FRAME_TYPE_MAX;
        for (var a = 0; a < this._frameArrayNum; a++) this._frameArray.push([])
    },
    initWithDictionary: function(a, b) {
        this.setActionTag(a.ActionTag);
        for (var c = a.actionframelist, d = 0; d < c.length; d++) {
            var e = c[d],
                f = e.frameid,
                g = e.tweenType;
            null == g && (g = 0);
            for (var h = e.tweenParameter, i = [], j = 0; h > j; j++) i.push(e.tweenParameter[j]);
            if (void 0 !== e.positionx) {
                var j = e.positionx,
                    k = e.positiony,
                    h = new ccs.ActionMoveFrame;
                h.frameIndex = f, h.setEasingType(g), h.setEasingParameter(i), h.setPosition(j, k), j = this._frameArray[ccs.FRAME_TYPE_MOVE], j.push(h)
            }
            void 0 !== e.scalex && (j = e.scalex, k = e.scaley, h = new ccs.ActionScaleFrame, h.frameIndex = f, h.setEasingType(g), h.setEasingParameter(i), h.setScaleX(j), h.setScaleY(k), j = this._frameArray[ccs.FRAME_TYPE_SCALE], j.push(h)), void 0 !== e.rotation && (j = e.rotation, h = new ccs.ActionRotationFrame, h.frameIndex = f, h.setEasingType(g), h.setEasingParameter(i), h.setRotation(j), j = this._frameArray[ccs.FRAME_TYPE_ROTATE], j.push(h)), void 0 !== e.opacity && (j = e.opacity, h = new ccs.ActionFadeFrame, h.frameIndex = f, h.setEasingType(g), h.setEasingParameter(i), h.setOpacity(j), j = this._frameArray[ccs.FRAME_TYPE_FADE], j.push(h)), void 0 !== e.colorr && (j = e.colorr, k = e.colorg, e = e.colorb, h = new ccs.ActionTintFrame, h.frameIndex = f, h.setEasingType(g), h.setEasingParameter(i), h.setColor(cc.color(j, k, e)), j = this._frameArray[ccs.FRAME_TYPE_TINT], j.push(h))
        }
        this.initActionNodeFromRoot(b)
    },
    initActionNodeFromRoot: function(a) {
        a instanceof ccui.Widget && (a = ccui.helper.seekActionWidgetByActionTag(a, this.getActionTag())) && this.setObject(a)
    },
    setUnitTime: function(a) {
        this._unitTime = a, this.refreshActionProperty()
    },
    getUnitTime: function() {
        return this._unitTime
    },
    setActionTag: function(a) {
        this._actionTag = a
    },
    getActionTag: function() {
        return this._actionTag
    },
    setObject: function(a) {
        this._object = a
    },
    getObject: function() {
        return this._object
    },
    getActionNode: function() {
        return this._object instanceof cc.Node || this._object instanceof ccui.Widget ? this._object : null
    },
    insertFrame: function(a, b) {
        null != b && this._frameArray[b.frameType].splice(a, 0, b)
    },
    addFrame: function(a) {
        a && this._frameArray[a.frameType].push(a)
    },
    deleteFrame: function(a) {
        null != a && cc.arrayRemoveObject(this._frameArray[a.frameType], a)
    },
    clearAllFrame: function() {
        for (var a = 0; a < this._frameArrayNum; a++) this._frameArray[a] = []
    },
    refreshActionProperty: function() {
        if (null == this._object) return null;
        for (var a = [], b = 0; b < this._frameArrayNum; b++) {
            var c = this._frameArray[b];
            if (!(0 >= c.length)) {
                for (var d = [], e = 0; e < c.length; e++) {
                    var f = c[e];
                    if (0 != e) {
                        var g = (f.frameIndex - c[e - 1].frameIndex) * this.getUnitTime();
                        (f = f.getAction(g)) && d.push(f)
                    }
                }
                d && (c = cc.sequence(d), null != c && a.push(c))
            }
        }
        return this._action = null, this._actionSpawn = cc.spawn(a)
    },
    playAction: function(a) {
        null == this._object || null == this._actionSpawn || (this._action = a ? cc.sequence(this._actionSpawn, a) : cc.sequence(this._actionSpawn), this.runAction())
    },
    runAction: function() {
        var a = this.getActionNode();
        null != a && null != this._action && a.runAction(this._action)
    },
    stopAction: function() {
        var a = this.getActionNode();
        null != a && null != this._action && (this._action.isDone() || a.stopAction(this._action))
    },
    getFirstFrameIndex: function() {
        for (var a = 99999, b = !1, c = 0; c < this._frameArrayNum; c++) {
            var d = this._frameArray[c];
            0 >= d.length || (b = !0, d = d[0].frameIndex, a = a > d ? d : a)
        }
        return b || (a = 0), a
    },
    getLastFrameIndex: function() {
        for (var a = -1, b = !1, c = 0; c < this._frameArrayNum; c++) {
            var d = this._frameArray[c];
            0 >= d.length || (b = !0, d = d[d.length - 1].frameIndex, a = d > a ? d : a)
        }
        return b || (a = 0), a
    },
    updateActionToTimeLine: function(a) {
        for (var b = !1, c = this.getUnitTime(), d = 0; d < this._frameArrayNum; d++) {
            var e = this._frameArray[d];
            if (null != e)
                for (var f = 0; f < e.length; f++) {
                    var g = e[f];
                    if (g.frameIndex * c == a) {
                        this.easingToFrame(1, 1, g), b = !0;
                        break
                    }
                    if (g.frameIndex * c > a) {
                        0 == f ? (this.easingToFrame(1, 1, g), b = !1) : (b = e[f - 1], e = (g.frameIndex - b.frameIndex) * c, f = a - b.frameIndex * c, this.easingToFrame(e, 1, b), this.easingToFrame(e, f / e, g), b = !0);
                        break
                    }
                }
        }
        return b
    },
    easingToFrame: function(a, b, c) {
        a = c.getAction(a), c = this.getActionNode(), null == a || null == c || (a.startWithTarget(c), a.update(b))
    },
    isActionDoneOnce: function() {
        return null == this._action ? !0 : this._action.isDone()
    }
}), ccs.ActionObject = ccs.Class.extend({
    _actionNodeList: null,
    _name: "",
    _loop: !1,
    _pause: !1,
    _playing: !1,
    _unitTime: 0,
    _currentTime: 0,
    _scheduler: null,
    _fTotalTime: 0,
    ctor: function() {
        this._actionNodeList = [], this._name = "", this._playing = this._pause = this._loop = !1, this._unitTime = .1, this._fTotalTime = this._currentTime = 0, this._scheduler = new cc.Scheduler, cc.director.getScheduler().scheduleUpdateForTarget(this._scheduler, 0, !1)
    },
    setName: function(a) {
        this._name = a
    },
    getName: function() {
        return this._name
    },
    setLoop: function(a) {
        this._loop = a
    },
    getLoop: function() {
        return this._loop
    },
    setUnitTime: function(a) {
        this._unitTime = a, a = this._actionNodeList.length;
        for (var b = 0; a > b; b++) this._actionNodeList[b].setUnitTime(this._unitTime)
    },
    getUnitTime: function() {
        return this._unitTime
    },
    getCurrentTime: function() {
        return this._currentTime
    },
    setCurrentTime: function(a) {
        this._currentTime = a
    },
    getTotalTime: function() {
        return this._fTotalTime
    },
    isPlaying: function() {
        return this._playing
    },
    initWithDictionary: function(a, b) {
        this.setName(a.name), this.setLoop(a.loop), this.setUnitTime(a.unittime);
        for (var c = a.actionnodelist, d = 0, e = 0; e < c.length; e++) {
            var f = new ccs.ActionNode;
            f.initWithDictionary(c[e], b), f.setUnitTime(this.getUnitTime()), this._actionNodeList.push(f), f = f.getLastFrameIndex() - f.getFirstFrameIndex(), f > d && (d = f)
        }
        this._fTotalTime = d * this._unitTime
    },
    addActionNode: function(a) {
        a && (this._actionNodeList.push(a), a.setUnitTime(this._unitTime))
    },
    removeActionNode: function(a) {
        null != a && cc.arrayRemoveObject(this._actionNodeList, a)
    },
    play: function(a) {
        this.stop(), this.updateToFrameByTime(0);
        for (var b = this._actionNodeList.length, c = 0; b > c; c++) this._actionNodeList[c].playAction(a);
        this._loop && this._scheduler.scheduleCallbackForTarget(this, this.simulationActionUpdate, 0, cc.REPEAT_FOREVER, 0, !1)
    },
    pause: function() {
        this._pause = !0
    },
    stop: function() {
        for (var a = 0; a < this._actionNodeList.length; a++) this._actionNodeList[a].stopAction();
        this._scheduler.unscheduleCallbackForTarget(this, this.simulationActionUpdate), this._pause = !1
    },
    updateToFrameByTime: function(a) {
        this._currentTime = a;
        for (var b = 0; b < this._actionNodeList.length; b++) this._actionNodeList[b].updateActionToTimeLine(a)
    },
    simulationActionUpdate: function(a) {
        if (this._loop) {
            a = !0;
            for (var b = this._actionNodeList, c = 0; c < b.length; c++)
                if (0 == b[c].isActionDoneOnce()) {
                    a = !1;
                    break
                }
            a && this.play()
        }
    }
}), ccs.ComAttribute = ccs.Component.extend({
    _jsonDict: null,
    _filePath: "",
    ctor: function() {
        cc.Component.prototype.ctor.call(this), this._jsonDict = {}, this._filePath = "", this._name = "CCComAttribute"
    },
    init: function() {
        return this._jsonDict = {}, !0
    },
    setInt: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setDouble: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setFloat: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setBool: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setString: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setObject: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    getInt: function(a) {
        return parseInt(this._jsonDict[a] || 0)
    },
    getDouble: function(a) {
        return parseFloat(this._jsonDict[a] || 0)
    },
    getFloat: function(a) {
        return parseFloat(this._jsonDict[a] || 0)
    },
    getBool: function(a) {
        return Boolean(this._jsonDict[a] || !1)
    },
    getString: function(a) {
        return this._jsonDict[a] || ""
    },
    getObject: function(a) {
        return this._jsonDict[a]
    },
    parse: function(a) {
        this._jsonDict = cc.loader.getRes(a)
    }
}), ccs.ComAttribute.create = function() {
    var a = new ccs.ComAttribute;
    return a && a.init() ? a : null
}, ccs.ComAudio = ccs.Component.extend({
    _filePath: "",
    _loop: !1,
    ctor: function() {
        cc.Component.prototype.ctor.call(this), this._name = "Audio"
    },
    init: function() {
        return !0
    },
    onEnter: function() {},
    onExit: function() {
        this.stopBackgroundMusic(!0), this.stopAllEffects()
    },
    end: function() {
        cc.audioEngine.end()
    },
    preloadBackgroundMusic: function(a) {
        cc.loader.load(a)
    },
    playBackgroundMusic: function(a, b) {

        a ? cc.audioEngine.playMusic(a, b) : cc.audioEngine.playMusic(this._filePath, this._loop)
    },
    stopBackgroundMusic: function(a) {
        cc.audioEngine.stopMusic(a)
    },
    pauseBackgroundMusic: function() {
        cc.audioEngine.pauseMusic()
    },
    resumeBackgroundMusic: function() {
        cc.audioEngine.resumeMusic()
    },
    rewindBackgroundMusic: function() {
        cc.audioEngine.rewindMusic()
    },
    willPlayBackgroundMusic: function() {
        return cc.audioEngine.willPlayMusic()
    },
    isBackgroundMusicPlaying: function() {
        return cc.audioEngine.isMusicPlaying()
    },
    getBackgroundMusicVolume: function() {
        return cc.audioEngine.getMusicVolume()
    },
    setBackgroundMusicVolume: function(a) {
        cc.audioEngine.setMusicVolume(a)
    },
    getEffectsVolume: function() {
        return cc.audioEngine.getEffectsVolume()
    },
    setEffectsVolume: function(a) {
        cc.audioEngine.setEffectsVolume(a)
    },
    playEffect: function(a, b) {
        return a ? cc.audioEngine.playEffect(a, b) : cc.audioEngine.playEffect(this._filePath, this._loop)
    },
    pauseEffect: function(a) {
        cc.audioEngine.pauseEffect(a)
    },
    pauseAllEffects: function() {
        cc.audioEngine.pauseAllEffects()
    },
    resumeEffect: function(a) {
        cc.audioEngine.resumeEffect(a)
    },
    resumeAllEffects: function() {
        cc.audioEngine.resumeAllEffects()
    },
    stopEffect: function(a) {
        cc.audioEngine.stopEffect(a)
    },
    stopAllEffects: function() {
        cc.audioEngine.stopAllEffects()
    },
    preloadEffect: function(a) {
        cc.loader.getRes(a), this.setFile(a), this.setLoop(!1)
    },
    unloadEffect: function(a) {
        cc.audioEngine.unloadEffect(a)
    },
    setFile: function(a) {
        this._filePath = a
    },
    setLoop: function(a) {
        this._loop = a
    },
    getFile: function() {
        return this._filePath
    },
    isLoop: function() {
        return this._loop
    }
}), ccs.ComAudio.create = function() {
    var a = new ccs.ComAudio;
    return a && a.init() ? a : null
}, ccs.ComController = ccs.Component.extend({
    ctor: function() {
        cc.Component.prototype.ctor.call(this), this._name = "ComController"
    },
    init: function() {
        return !0
    },
    onEnter: function() {
        null != this._owner && this._owner.scheduleUpdate()
    },
    onExit: function() {},
    update: function() {},
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function() {
        this._enabled = b
    }
}), ccs.ComController.create = function() {
    var a = new ccs.ComController;
    return a && a.init() ? a : null
}, ccs.ComRender = ccs.Component.extend({
    _render: null,
    ctor: function(a, b) {
        cc.Component.prototype.ctor.call(this), this._render = a, this._name = b, this.isRenderer = !0
    },
    onEnter: function() {
        this._owner && this._owner.addChild(this._render)
    },
    onExit: function() {
        this._owner && (this._owner.removeChild(this._render, !0), this._render = null)
    },
    getNode: function() {
        return this._render
    },
    setNode: function(a) {
        this._render = a
    }
}), ccs.ComRender.create = function(a, b) {
    var c = new ccs.ComRender(a, b);
    return c && c.init() ? c : null
}, ccs.objectFactory = {
    _typeMap: {},
    destroyInstance: function() {
        this._instance = null
    },
    createObject: function(a) {
        var b = null;
        return (a = this._typeMap[a]) && (b = "function" == typeof a._fun ? new a._fun : a._fun), b
    },
    registerType: function(a) {
        this._typeMap[a._className] = a
    },
    createGUI: function(a) {
        var b = null;
        return "Panel" === a ? a = "Layout" : "TextArea" === a ? a = "Label" : "TextButton" === a && (a = "Button"), (a = this._typeMap[a]) && a._fun && (b = a._fun), b
    },
    createWidgetReaderProtocol: function(a) {
        var b = null;
        return (a = this._typeMap[a]) && a._fun && (b = a._fun), b
    }
}, ccs.TInfo = ccs.Class.extend({
    _className: "",
    _fun: null,
    ctor: function(a, b) {
        b ? (this._className = a, this._fun = b) : (this._className = a._className, this._fun = a._fun), ccs.objectFactory.registerType(this)
    }
}), ccs.sendEvent = function(a) {
    if (a = ccs.triggerManager.get(a), null != a)
        for (var b = 0; b < a.length; b++) {
            var c = a[b];
            null != c && c.detect() && c.done()
        }
}, ccs.registerTriggerClass = function(a, b) {
    new ccs.TInfo(a, b)
}, ccs.triggerManager = {
    _eventTriggers: {},
    _triggerObjs: {},
    _movementDispatches: [],
    destroyInstance: function() {
        this.removeAll(), this._instance = null
    },
    parse: function(a) {
        for (var b = 0; b < a.length; ++b) {
            var c = a[b],
                d = ccs.TriggerObj.create();
            d.serialize(c);
            for (var c = d.getEvents(), e = 0; e < c.length; e++) this.add(c[e], d);
            this._triggerObjs[d.getId()] = d
        }
    },
    get: function(a) {
        return this._eventTriggers[a]
    },
    getTriggerObj: function(a) {
        return this._triggerObjs[a]
    },
    add: function(a, b) {
        var c = this._eventTriggers[a];
        c || (c = []), -1 == c.indexOf(b) && (c.push(b), this._eventTriggers[a] = c)
    },
    removeAll: function() {
        for (var a in this._eventTriggers)
            for (var b = this._eventTriggers[a], c = 0; c < b.length; c++) b[c].removeAll();
        this._eventTriggers = {}
    },
    remove: function(a, b) {
        if (b) return this._removeObj(a, b);
        var c = !1,
            d = this._eventTriggers[a];
        if (d) {
            for (c = 0; c < d.length; c++) {
                var e = d[c];
                e && e.removeAll()
            }
            delete this._eventTriggers[a], c = !0
        }
        return c
    },
    _removeObj: function(a, b) {
        var c = !1;
        do {
            var d = this._eventTriggers[a];
            if (d) {
                for (c = 0; c < d.length; c++) {
                    var e = d[c];
                    if (e && e == b) {
                        e.removeAll(), d.splice(c, 1);
                        break
                    }
                }
                c = !0
            }
        } while (0);
        return c
    },
    removeTriggerObj: function(a) {
        if (a = this.getTriggerObj(a), !a) return !1;
        for (var b = a.getEvents(), c = 0; c < b.length; c++) this.remove(b[c], a);
        return !0
    },
    isEmpty: function() {
        return !this._eventTriggers || 0 >= this._eventTriggers.length
    },
    addArmatureMovementCallBack: function(a, b, c) {
        if (null != a && null != c && null != b) {
            for (var d, e = !1, f = 0; f < this._movementDispatches.length; f++)(d = this._movementDispatches[f]) && d[0] == a && (d.addAnimationEventCallBack(b, c), e = !0);
            e || (d = new ccs.ArmatureMovementDispatcher, a.getAnimation().setMovementEventCallFunc(d.animationEvent, d), d.addAnimationEventCallBack(b, c), this._movementDispatches.push([a, d]))
        }
    },
    removeArmatureMovementCallBack: function(a, b, c) {
        if (null != a && null != b && null != c)
            for (var d, e = 0; e < this._movementDispatches.length; e++)(d = this._movementDispatches[e]) && d[0] == a && d.removeAnimationEventCallBack(c, b)
    },
    removeArmatureAllMovementCallBack: function(a) {
        if (null != a)
            for (var b, c = 0; c < this._movementDispatches.length; c++)
                if ((b = this._movementDispatches[c]) && b[0] == a) {
                    this._movementDispatches.splice(c, 1);
                    break
                }
    },
    removeAllArmatureMovementCallBack: function() {
        this._movementDispatches = []
    },
    version: function() {
        return "1.2.0.0"
    }
}, ccs.ArmatureMovementDispatcher = ccs.Class.extend({
    _mapEventAnimation: null,
    ctor: function() {
        this._mapEventAnimation = []
    },
    animationEvent: function(a, b, c) {
        for (var d, e, f = 0; f < this._mapEventAnimation.length; f++) d = this._mapEventAnimation[f], e = d[0], (d = d[1]) && d.call(e, a, b, c)
    },
    addAnimationEventCallBack: function(a, b) {
        this._mapEventAnimation.push([b, a])
    },
    removeAnimationEventCallBack: function(a, b) {
        for (var c, d = 0; d < this._mapEventAnimation.length; d++) c = this._mapEventAnimation[d], c[0] == b && this._mapEventAnimation.splice(d, 1)
    }
}), ccs.BaseTriggerCondition = ccs.Class.extend({
    ctor: function() {},
    init: function() {
        return !0
    },
    detect: function() {
        return !0
    },
    serialize: function() {},
    removeAll: function() {}
}), ccs.BaseTriggerAction = ccs.Class.extend({
    ctor: function() {},
    init: function() {
        return !0
    },
    done: function() {},
    serialize: function() {},
    removeAll: function() {}
}), ccs.TriggerObj = ccs.Class.extend({
    _cons: null,
    _acts: null,
    _id: 0,
    _enable: !0,
    _vInt: null,
    ctor: function() {
        this._id = 0, this._enable = !0
    },
    init: function() {
        return this._cons = [], this._acts = [], this._vInt = [], !0
    },
    detect: function() {
        if (!this._enable || 0 == this._cons.length) return !0;
        for (var a = !0, b = null, c = 0; c < this._cons.length; c++)(b = this._cons[c]) && b.detect && (a = a && b.detect());
        return a
    },
    done: function() {
        if (this._enable && 0 != this._acts.length)
            for (var a, b = 0; b < this._acts.length; b++)(a = this._acts[b]) && a.done && a.done()
    },
    removeAll: function() {
        for (var a = null, b = 0; b < this._cons.length; b++)(a = this._cons[b]) && a.removeAll();
        for (this._cons = [], b = 0; b < this._acts.length; b++)(a = this._acts[b]) && a.removeAll();
        this._acts = []
    },
    serialize: function(a) {
        this._id = a.id || 0;
        for (var b = a.conditions || [], c = 0; c < b.length; c++) {
            var d = b[c],
                e = d.classname,
                f = ccs.objectFactory.createObject(e);
            f ? (f.serialize(d), f.init(), this._cons.push(f)) : cc.log("class named classname(" + e + ") can not implement!")
        }
        for (b = a.actions || [], c = 0; c < b.length; c++) d = b[c], e = d.classname, (f = ccs.objectFactory.createObject(e)) ? (f.serialize(d), f.init(), this._acts.push(f)) : cc.log("class named classname(" + e + ") can not implement!");
        for (a = a.events || [], c = 0; c < a.length; c++) d = a[c], d = d.id, 0 > d || this._vInt.push(d)
    },
    getId: function() {
        return this._id
    },
    setEnable: function(a) {
        this._enable = a
    },
    getEvents: function() {
        return this._vInt
    }
}), ccs.TriggerObj.create = function() {
    var a = new ccs.TriggerObj;
    return a.init() ? a : null
}, ccs.ButtonReader = {
    getInstance: function() {
        return ccs.ButtonReader
    },
    setPropsFromJsonDictionary: function(a, b) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = b.scale9Enable;
        a.setScale9Enabled(d);
        var e = b.normalData;
        switch (e.resourceType) {
            case 0:
                e = e.path, a.loadTextureNormal(e && "" !== e ? c + e : null);
                break;
            case 1:
                e = e.path, a.loadTextureNormal(e, 1)
        }
        switch (e = b.pressedData, e.resourceType) {
            case 0:
                e = e.path, a.loadTexturePressed(e && "" !== e ? c + e : null);
                break;
            case 1:
                e = e.path, a.loadTexturePressed(e, 1)
        }
        switch (e = b.disabledData, e.resourceType) {
            case 0:
                e = e.path, a.loadTextureDisabled(e && "" !== e ? c + e : null);
                break;
            case 1:
                e = e.path, a.loadTextureDisabled(e, 1)
        }
        d && (a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), c = b.scale9Width, d = b.scale9Height, null != c && null != d && a.setSize(cc.size(c, d))), c = b.text, null != c && a.setTitleText(c), a.setTitleColor(cc.color(b.textColorR ? b.textColorR : 255, b.textColorG ? b.textColorG : 255, b.textColorB ? b.textColorB : 255)), null != b.fontSize && a.setTitleFontSize(b.fontSize), b.fontName && a.setTitleFontName(b.fontName), ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    }
}, ccs.CheckBoxReader = {
    getInstance: function() {
        return ccs.CheckBoxReader
    },
    setPropsFromJsonDictionary: function(a, b) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = b.backGroundBoxData,
            d = c.resourceType,
            c = ccs.WidgetReader.getResourcePath(c, "path", d);
        a.loadTextureBackGround(c, d);
        var e = b.backGroundBoxSelectedData,
            f = e.resourceType,
            e = ccs.WidgetReader.getResourcePath(e, "path", f);
        e || (f = d, e = c), a.loadTextureBackGroundSelected(e, f), c = b.frontCrossData, d = c.resourceType, c = ccs.WidgetReader.getResourcePath(c, "path", d), a.loadTextureFrontCross(c, d), e = b.backGroundBoxDisabledData, f = e.resourceType, e = ccs.WidgetReader.getResourcePath(e, "path", f), e || (f = d, e = c), a.loadTextureBackGroundDisabled(e, f), c = b.frontCrossDisabledData, d = c.resourceType, c = ccs.WidgetReader.getResourcePath(c, "path", d), a.loadTextureFrontCrossDisabled(c, d), b.selectedState && a.setSelectedState(b.selectedState), ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    }
}, ccs.ImageViewReader = {
    getInstance: function() {
        return ccs.ImageViewReader
    },
    setPropsFromJsonDictionary: function(a, b) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = b.fileNameData;
        switch (d.resourceType) {
            case 0:
                (d = d.path) && "" !== d && a.loadTexture(c + d);
                break;
            case 1:
                d = d.path, a.loadTexture(d, 1)
        }
        c = !1, b.scale9Enable && (c = b.scale9Enable), a.setScale9Enabled(c), c && (c = b.scale9Height, b.scale9Width && c && a.setSize(cc.size(b.scale9Width, b.scale9Height)), a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight))), ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    }
}, ccs.LabelAtlasReader = {
    getInstance: function() {
        return ccs.LabelAtlasReader
    },
    setPropsFromJsonDictionary: function(a, b) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = b.charMapFileData || b.charMapFile,
            e = b.itemWidth,
            f = b.itemHeight,
            g = b.startCharMap;
        if (null != b.stringValue && d && null != e && null != f && null != g) switch (d = b.charMapFileData, d.resourceType) {
            case 0:
                a.setProperty(b.stringValue, c + d.path, b.itemWidth, b.itemHeight, b.startCharMap);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    }
}, ccs.LabelBMFontReader = {
    getInstance: function() {
        return ccs.LabelBMFontReader
    },
    setPropsFromJsonDictionary: function(a, b) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = b.fileNameData;
        switch (d.resourceType) {
            case 0:
                a.setFntFile(c + d.path);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        a.setString(b.text), ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    }
}, ccs.LabelReader = {
    getInstance: function() {
        return ccs.LabelReader
    },
    setPropsFromJsonDictionary: function(a, b) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, b), a.setTouchScaleChangeEnabled(b.touchScaleEnable), a.setString(b.text), null != b.fontSize && a.setFontSize(b.fontSize), null != b.fontName && a.setFontName(b.fontName);
        var c = b.areaHeight;
        null != b.areaWidth && null != c && (c = cc.size(b.areaWidth, b.areaHeight), a.setTextAreaSize(c)), null != b.hAlignment && a.setTextHorizontalAlignment(b.hAlignment), null != b.vAlignment && a.setTextVerticalAlignment(b.vAlignment), ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    }
}, ccs.LayoutReader = {
    getInstance: function() {
        return ccs.LayoutReader
    },
    setPropsFromJsonDictionary: function(a, b) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = 0,
            e = 0;
        b.adaptScreen ? (e = cc.director.getWinSize(), d = e.width, e = e.height) : (d = b.width, e = b.height), a.setSize(cc.size(d, e)), a.setClippingEnabled(b.clipAble), d = b.backGroundScale9Enable, a.setBackGroundImageScale9Enabled(d);
        var e = b.bgColorR,
            f = b.bgColorG,
            g = b.bgColorB,
            h = b.bgStartColorR,
            i = b.bgStartColorG,
            j = b.bgStartColorB,
            k = b.bgEndColorR,
            l = b.bgEndColorG,
            m = b.bgEndColorB;
        a.setBackGroundColorVector(cc.p(b.vectorX, b.vectorY));
        var n = b.bgColorOpacity;
        if (a.setBackGroundColorType(b.colorType), a.setBackGroundColor(cc.color(h, i, j), cc.color(k, l, m)), a.setBackGroundColor(cc.color(e, f, g)), a.setBackGroundColorOpacity(n), e = b.backGroundImageData) switch (e.resourceType) {
            case 0:
                e = e.path, a.setBackGroundImage(e && "" !== e ? c + e : null);
                break;
            case 1:
                e = e.path, a.setBackGroundImage(e, 1)
        }
        d && a.setBackGroundImageCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), a.setLayoutType(b.layoutType), ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    }
}, ccs.ScrollViewReader = {
    getInstance: function() {
        return ccs.ScrollViewReader
    },
    setPropsFromJsonDictionary: function(a, b) {
        ccs.LayoutReader.setPropsFromJsonDictionary.call(this, a, b), a.setInnerContainerSize(cc.size(b.innerWidth || 200, b.innerHeight || 200)), a.setDirection(b.direction || 1), a.setBounceEnabled(b.bounceEnable), ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    }
}, ccs.ListViewReader = {
    getInstance: function() {
        return ccs.ListViewReader
    },
    setPropsFromJsonDictionary: function(a, b) {
        ccs.ScrollViewReader.setPropsFromJsonDictionary.call(this, a, b), a.setDirection(b.direction), a.setGravity(b.gravity), a.setItemsMargin(b.itemMargin)
    }
}, ccs.LoadingBarReader = {
    getInstance: function() {
        return ccs.LoadingBarReader
    },
    setPropsFromJsonDictionary: function(a, b) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = b.textureData;
        switch (d.resourceType) {
            case 0:
                (d = d.path) && "" !== d && a.loadTexture(c + d);
                break;
            case 1:
                d = d.path, a.loadTexture(d, 1)
        }
        c = b.scale9Enable, a.setScale9Enabled(c), c && (a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), a.setSize(cc.size(b.width, b.height))), a.setDirection(b.direction), a.setPercent(b.percent), ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    }
}, ccs.PageViewReader = {
    instancePageViewReader: null,
    getInstance: function() {
        return ccs.PageViewReader
    },
    setPropsFromJsonDictionary: function(a, b) {
        ccs.LayoutReader.setPropsFromJsonDictionary.call(this, a, b)
    }
}, ccs.SliderReader = {
    getInstance: function() {
        return ccs.SliderReader
    },
    setPropsFromJsonDictionary: function(a, b) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = b.scale9Enable;
        a.setScale9Enabled(d);
        var e = b.length,
            f = b.barFileNameData,
            g = f.resourceType,
            f = f.path;
        if (null != b.barFileName) {
            if (d) {
                switch (g) {
                    case 0:
                        a.loadBarTexture(f ? c + f : null);
                        break;
                    case 1:
                        a.loadBarTexture(f, 1)
                }
                a.setSize(cc.size(e, a.getContentSize().height))
            }
        } else switch (g) {
            case 0:
                a.loadBarTexture(f ? c + f : null);
                break;
            case 1:
                a.loadBarTexture(f, 1)
        }
        switch (e = b.ballNormalData, d = e.resourceType, e = e.path, d) {
            case 0:
                a.loadSlidBallTextureNormal(e ? c + e : null);
                break;
            case 1:
                a.loadSlidBallTextureNormal(e, 1)
        }
        switch (f = b.ballPressedData, g = f.resourceType, f = f.path, null === f && (g = d, f = e), g) {
            case 0:
                a.loadSlidBallTexturePressed(f ? c + f : null);
                break;
            case 1:
                a.loadSlidBallTexturePressed(f, 1)
        }
        switch (d = b.ballDisabledData, e = d.path, d.resourceType) {
            case 0:
                a.loadSlidBallTextureDisabled(e ? c + e : null);
                break;
            case 1:
                a.loadSlidBallTextureDisabled(e, 1)
        }
        switch (d = b.progressBarData, e = d.path, d.resourceType) {
            case 0:
                a.loadProgressBarTexture(e ? c + e : null);
                break;
            case 1:
                a.loadProgressBarTexture(e, 1)
        }
        ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    }
}, ccs.TextFieldReader = {
    getInstance: function() {
        return ccs.TextFieldReader
    },
    setPropsFromJsonDictionary: function(a, b) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = b.placeHolder;
        c && a.setPlaceHolder(c), a.setString(b.text), (c = b.fontSize1) && a.setFontSize(c), (c = b.fontName) && a.setFontName(c);
        var c = b.touchSizeWidth,
            d = b.touchSizeHeight;
        c && d && a.setTouchSize(c, d), c = b.maxLengthEnable, a.setMaxLengthEnabled(c), c && a.setMaxLength(b.maxLength), c = b.passwordEnable, a.setPasswordEnabled(c), c && a.setPasswordStyleText(b.passwordStyleText), c = b.areaWidth, d = b.areaHeight, c && d && (c = cc.size(c, d), a.setTextAreaSize(c)), (c = b.hAlignment) && a.setTextHorizontalAlignment(c), (c = b.vAlignment) && a.setTextVerticalAlignment(c), ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    }
}, ccs.WidgetReaderProtocol = ccs.Class.extend({
    setPropsFromJsonDictionary: function() {}
}), ccs.WidgetReader = {
    getInstance: function() {
        return ccs.WidgetReader
    },
    setPropsFromJsonDictionary: function(a, b) {
        var c = b.ignoreSize;
        null != c && a.ignoreContentAdaptWithSize(c), a.setSizeType(b.sizeType), a.setPositionType(b.positionType), a.setSizePercent(cc.p(b.sizePercentX, b.sizePercentY)), a.setPositionPercent(cc.p(b.positionPercentX, b.positionPercentY));
        var d = c = 0;
        if (b.adaptScreen ? (d = cc.director.getWinSize(), c = d.width, d = d.height) : (c = b.width, d = b.height), a.setContentSize(c, d), a.setTag(b.tag), a.setActionTag(b.actiontag), a.setTouchEnabled(b.touchAble), c = b.name, a.setName(c ? c : "default"), a.setPosition(b.x, b.y), a.setScaleX(b.scaleX || 1), a.setScaleY(b.scaleY || 1), a.setRotation(b.rotation || 0), c = b.visible || !1, null != c && a.setVisible(c), a.setLocalZOrder(b.ZOrder), null != b.layoutParameter) {
            switch (c = b.layoutParameter, d = null, c.type) {
                case 1:
                    d = new ccui.LinearLayoutParameter, d.setGravity(c.gravity);
                    break;
                case 2:
                    var e = d = new ccui.RelativeLayoutParameter;
                    e.setRelativeName(c.relativeName), e.setRelativeToWidgetName(c.relativeToName), e.setAlign(c.align)
            }
            null != d && (d.setMargin(c.marginLeft || 0, c.marginTop || 0, c.marginRight || 0, c.marginDown || 0), a.setLayoutParameter(d))
        }
    },
    setColorPropsFromJsonDictionary: function(a, b) {
        var c = b.opacity;
        null != c && a.setOpacity(c);
        var c = b.colorR,
            d = b.colorG,
            e = b.colorB;
        a.setColor(cc.color(null == c ? 255 : c, null == d ? 255 : d, null == e ? 255 : e)), ccs.WidgetReader.setAnchorPointForWidget(a, b), a.setFlippedX(b.flipX), a.setFlippedY(b.flipY)
    },
    setAnchorPointForWidget: function(a, b) {
        var c, d = b.anchorPointX;
        c = null != d ? b.anchorPointX : a.getAnchorPoint().x;
        var e, f = b.anchorPointY;
        e = null != f ? b.anchorPointY : a.getAnchorPoint().y, (null != d || null != f) && a.setAnchorPoint(cc.p(c, e))
    },
    getResourcePath: function(a, b, c) {
        a = a[b];
        var d;
        return null != a && (0 == c ? d = ccs.uiReader.getFilePath() + a : 1 == c ? d = a : cc.assert(0, "invalid TextureResType!!!")), d
    }
},
function() {
    var a = ccs.objectFactory;
    a.registerType({
        _className: "ButtonReader",
        _fun: ccs.ButtonReader
    }), a.registerType({
        _className: "CheckBoxReader",
        _fun: ccs.CheckBoxReader
    }), a.registerType({
        _className: "SliderReader",
        _fun: ccs.SliderReader
    }), a.registerType({
        _className: "ImageViewReader",
        _fun: ccs.ImageViewReader
    }), a.registerType({
        _className: "LoadingBarReader",
        _fun: ccs.LoadingBarReader
    }), a.registerType({
        _className: "TextAtlasReader",
        _fun: ccs.LabelAtlasReader
    }), a.registerType({
        _className: "TextReader",
        _fun: ccs.LabelReader
    }), a.registerType({
        _className: "TextBMFontReader",
        _fun: ccs.LabelBMFontReader
    }), a.registerType({
        _className: "TextFieldReader",
        _fun: ccs.TextFieldReader
    }), a.registerType({
        _className: "LayoutReader",
        _fun: ccs.LayoutReader
    }), a.registerType({
        _className: "PageViewReader",
        _fun: ccs.PageViewReader
    }), a.registerType({
        _className: "ScrollViewReader",
        _fun: ccs.ScrollViewReader
    }), a.registerType({
        _className: "ListViewReader",
        _fun: ccs.ListViewReader
    }), a.registerType({
        _className: "WidgetReader",
        _fun: ccs.WidgetReader
    }), a.registerType({
        _className: "Button",
        _fun: ccui.Button
    }), a.registerType({
        _className: "CheckBox",
        _fun: ccui.CheckBox
    }), a.registerType({
        _className: "ImageView",
        _fun: ccui.ImageView
    }), a.registerType({
        _className: "Text",
        _fun: ccui.Text
    }), a.registerType({
        _className: "TextAtlas",
        _fun: ccui.TextAtlas
    }), a.registerType({
        _className: "TextBMFont",
        _fun: ccui.TextBMFont
    }), a.registerType({
        _className: "LoadingBar",
        _fun: ccui.LoadingBar
    }), a.registerType({
        _className: "Slider",
        _fun: ccui.Slider
    }), a.registerType({
        _className: "TextField",
        _fun: ccui.TextField
    }), a.registerType({
        _className: "Layout",
        _fun: ccui.Layout
    }), a.registerType({
        _className: "ListView",
        _fun: ccui.ListView
    }), a.registerType({
        _className: "PageView",
        _fun: ccui.PageView
    }), a.registerType({
        _className: "ScrollView",
        _fun: ccui.ScrollView
    })
}(), ccs.uiReader = {
    _filePath: "",
    _olderVersion: !1,
    _fileDesignSizes: {},
    _mapObject: {},
    _mapParseSelector: {},
    getVersionInteger: function(a) {
        if (!a) return 0;
        var b = a,
            c = b.length;
        if (7 > c) return 0;
        var d = b.indexOf("."),
            e = b.substr(0, d),
            b = b.substr(d + 1, c - 1),
            d = b.indexOf("."),
            f = b.substr(0, d),
            b = b.substr(d + 1, c - 1),
            d = b.indexOf(".");
        return a = b.substr(0, d), b = b.substr(d + 1, c - 1), d = b.indexOf("."), b = -1 == d ? b : b.substr(0, d), e = parseInt(e), f = parseInt(f), a = parseInt(a), b = parseInt(b), 1e3 * e + 100 * f + 10 * a + b
    },
    storeFileDesignSize: function(a, b) {
        this._fileDesignSizes[a] = b
    },
    getFileDesignSize: function(a) {
        return this._fileDesignSizes[a]
    },
    widgetFromJsonFile: function(a) {
        var b = cc.loader.getRes(a);
        if (!b) throw "Please load the resource first : " + a;
        var c = cc.path.dirname(a);
        this._filePath = "" == c ? c : c + "/";
        var c = b.version,
            d = this.getVersionInteger(c);
        return a = (c ? 250 > d ? new ccs.WidgetPropertiesReader0250 : new ccs.WidgetPropertiesReader0300 : new ccs.WidgetPropertiesReader0250).createWidget(b, this._filePath, a), (!c || 250 > d) && (this._olderVersion = !0), a
    },
    clear: function() {
        this._filePath = "", this._olderVersion = !1, this._fileDesignSizes = {}
    },
    registerTypeAndCallBack: function(a, b, c, d) {
        var e = ccs.objectFactory;
        b = new ccs.TInfo(a, b), e.registerType(b), c && (this._mapObject[a] = c), d && (this._mapParseSelector[a] = d)
    },
    getFilePath: function() {
        return this._filePath
    },
    getParseObjectMap: function() {
        return this._mapObject
    },
    getParseCallBackMap: function() {
        return this._mapParseSelector
    }
}, ccs.WidgetPropertiesReader = ccs.Class.extend({
    _filePath: "",
    createWidget: function() {},
    widgetFromJsonDictionary: function() {},
    createGUI: function(a) {
        return a = this.getGUIClassName(a), ccs.objectFactory.createObject(a)
    },
    getGUIClassName: function(a) {
        var b = a;
        return "Panel" == a ? b = "Layout" : "TextArea" == a ? b = "Text" : "TextButton" == a ? b = "Button" : "Label" == a ? b = "Text" : "LabelAtlas" == a ? b = "TextAtlas" : "LabelBMFont" == a && (b = "TextBMFont"), b
    },
    getWidgetReaderClassName: function(a) {
        return "Panel" == a ? a = "Layout" : "TextArea" == a ? a = "Text" : "TextButton" == a ? a = "Button" : "Label" == a ? a = "Text" : "LabelAtlas" == a ? a = "TextAtlas" : "LabelBMFont" == a && (a = "TextBMFont"), a + "Reader"
    },
    getWidgetReaderClassNameFromWidget: function(a) {
        var b;
        return a instanceof ccui.Button ? b = "ButtonReader" : a instanceof ccui.CheckBox ? b = "CheckBoxReader" : a instanceof ccui.ImageView ? b = "ImageViewReader" : a instanceof ccui.TextAtlas ? b = "TextAtlasReader" : a instanceof ccui.TextBMFont ? b = "TextBMFontReader" : a instanceof ccui.Text ? b = "TextReader" : a instanceof ccui.LoadingBar ? b = "LoadingBarReader" : a instanceof ccui.Slider ? b = "SliderReader" : a instanceof ccui.TextField ? b = "TextFieldReader" : a instanceof ccui.ListView ? b = "ListViewReader" : a instanceof ccui.PageView ? b = "PageViewReader" : a instanceof ccui.ScrollView ? b = "ScrollViewReader" : a instanceof ccui.Layout ? b = "LayoutReader" : a instanceof ccui.Widget && (b = "WidgetReader"), b
    },
    createWidgetReaderProtocol: function(a) {
        return ccs.objectFactory.createObject(a)
    }
}), ccs.WidgetPropertiesReader0250 = ccs.WidgetPropertiesReader.extend({
    createWidget: function(a, b, c) {
        this._filePath = "" == b ? b : cc.path.join(b, "/");
        for (var d = a.textures, e = 0; e < d.length; e++) {
            var f = b,
                f = f + d[e];
            cc.spriteFrameCache.addSpriteFrames(f)
        }
        return b = a.designWidth, d = a.designHeight, 0 >= b || 0 >= d ? (cc.log("Read design size error!"), e = cc.director.getWinSize(), ccs.uiReader.storeFileDesignSize(c, e)) : ccs.uiReader.storeFileDesignSize(c, cc.size(b, d)), e = this.widgetFromJsonDictionary(a.widgetTree), f = e.getContentSize(), 0 == f.width && 0 == f.height && e.setSize(cc.size(b, d)), ccs.actionManager.initWithDictionary(c, a.animation, e), e
    },
    widgetFromJsonDictionary: function(a) {
        var b = null,
            c = a.classname,
            d = a.options;
        for ("Button" == c ? (b = ccui.Button.create(), this.setPropsForButtonFromJsonDictionary(b, d)) : "CheckBox" == c ? (b = ccui.CheckBox.create(), this.setPropsForCheckBoxFromJsonDictionary(b, d)) : "Label" == c ? (b = ccui.Text.create(), this.setPropsForLabelFromJsonDictionary(b, d)) : "LabelAtlas" == c ? (b = ccui.TextAtlas.create(), this.setPropsForLabelAtlasFromJsonDictionary(b, d)) : "LoadingBar" == c ? (b = ccui.LoadingBar.create(), this.setPropsForLoadingBarFromJsonDictionary(b, d)) : "ScrollView" == c ? (b = ccui.ScrollView.create(), this.setPropsForScrollViewFromJsonDictionary(b, d)) : "TextArea" == c ? (b = ccui.Text.create(), this.setPropsForLabelFromJsonDictionary(b, d)) : "TextButton" == c ? (b = ccui.Button.create(), this.setPropsForButtonFromJsonDictionary(b, d)) : "TextField" == c ? (b = ccui.TextField.create(), this.setPropsForTextFieldFromJsonDictionary(b, d)) : "ImageView" == c ? (b = ccui.ImageView.create(), this.setPropsForImageViewFromJsonDictionary(b, d)) : "Panel" == c ? (b = ccui.Layout.create(), this.setPropsForLayoutFromJsonDictionary(b, d)) : "Slider" == c ? (b = ccui.Slider.create(), this.setPropsForSliderFromJsonDictionary(b, d)) : "LabelBMFont" == c ? (b = ccui.TextBMFont.create(), this.setPropsForLabelBMFontFromJsonDictionary(b, d)) : "DragPanel" == c && (b = ccui.ScrollView.create(), this.setPropsForScrollViewFromJsonDictionary(b, d)), a = a.children, c = 0; c < a.length; c++)(d = this.widgetFromJsonDictionary(a[c])) && b.addChild(d);
        return b
    },
    setPropsForWidgetFromJsonDictionary: function(a, b) {
        void 0 !== b.ignoreSize && a.ignoreContentAdaptWithSize(b.ignoreSize), a.setSize(cc.size(b.width, b.height)), a.setTag(b.tag), a.setActionTag(b.actiontag), a.setTouchEnabled(b.touchAble);
        var c = b.name;
        a.setName(c ? c : "default"), a.setPosition(cc.p(b.x, b.y)), void 0 !== b.scaleX && a.setScaleX(b.scaleX), void 0 !== b.scaleY && a.setScaleY(b.scaleY), void 0 !== b.rotation && a.setRotation(b.rotation), void 0 !== b.visible && a.setVisible(b.visible), a.setLocalZOrder(b.ZOrder)
    },
    setPropsForAllWidgetFromJsonDictionary: function() {},
    setPropsForAllCustomWidgetFromJsonDictionary: function() {},
    setColorPropsForWidgetFromJsonDictionary: function(a, b) {
        void 0 !== b.opacity && a.setOpacity(b.opacity), a.setColor(cc.color(void 0 !== b.colorR ? b.colorR : 255, void 0 !== b.colorG ? b.colorG : 255, void 0 !== b.colorB ? b.colorB : 255));
        var c = void 0 !== b.anchorPointX ? b.anchorPointX : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? .5 : 0,
            d = void 0 !== b.anchorPointY ? b.anchorPointY : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? .5 : 0;
        a.setAnchorPoint(c, d), c = b.flipY, a.setFlippedX(b.flipX), a.setFlippedY(c)
    },
    setPropsForButtonFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.scale9Enable;
        a.setScale9Enabled(c);
        var d = b.normal,
            e = b.pressed,
            f = b.disabled,
            g = d ? this._filePath + d : null,
            h = e ? this._filePath + e : null,
            i = f ? this._filePath + f : null,
            j = b.useMergedTexture;
        c ? (j ? a.loadTextures(d, e, f, ccui.Widget.PLIST_TEXTURE) : a.loadTextures(g, h, i), void 0 !== b.scale9Width && void 0 !== b.scale9Height && a.setSize(cc.size(b.scale9Width, b.scale9Height))) : j ? a.loadTextures(d, e, f, ccui.Widget.PLIST_TEXTURE) : a.loadTextures(g, h, i), void 0 !== b.text && (c = b.text || "") && a.setTitleText(c), void 0 !== b.fontSize && a.setTitleFontSize(b.fontSize), void 0 !== b.fontName && a.setTitleFontName(b.fontName), c = cc.color(void 0 !== b.textColorR ? b.textColorR : 255, void 0 !== b.textColorG ? b.textColorG : 255, void 0 !== b.textColorB ? b.textColorB : 255), a.setTitleColor(c), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForCheckBoxFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.backGroundBox,
            d = b.backGroundBoxSelected,
            e = b.frontCross,
            f = b.backGroundBoxDisabled,
            g = b.frontCrossDisabled,
            h = this._filePath,
            i = c ? h + c : null,
            j = d ? h + d : null,
            k = e ? h + e : null,
            l = f ? h + f : null,
            h = g ? h + g : null;
        b.useMergedTexture ? a.loadTextures(c, d, e, f, g, ccui.Widget.PLIST_TEXTURE) : a.loadTextures(i, j, k, l, h), a.setSelectedState(b.selectedState || !1), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForImageViewFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.fileName,
            d = b.scale9Enable || !1;
        a.setScale9Enabled(d);
        var e = this._filePath,
            f = null;
        c && (f = e + c), e = b.useMergedTexture, d ? (e ? a.loadTexture(c, ccui.Widget.PLIST_TEXTURE) : a.loadTexture(f), void 0 !== b.scale9Width && void 0 !== b.scale9Height && a.setSize(cc.size(b.scale9Width, b.scale9Height)), a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight))) : e ? a.loadTexture(c, ccui.Widget.PLIST_TEXTURE) : a.loadTexture(f), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLabelFromJsonDictionary: function(a, b) {
        if (this.setPropsForWidgetFromJsonDictionary(a, b), a.setTouchScaleChangeEnabled(b.touchScaleEnable), a.setString(b.text), void 0 !== b.fontSize && a.setFontSize(b.fontSize), void 0 !== b.fontName && a.setFontName(b.fontName), void 0 !== b.areaWidth && void 0 !== b.areaHeight) {
            var c = cc.size(b.areaWidth, b.areaHeight);
            a.setTextAreaSize(c)
        }
        b.hAlignment && a.setTextHorizontalAlignment(b.hAlignment), b.vAlignment && a.setTextVerticalAlignment(b.vAlignment), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLabelAtlasFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = void 0 !== b.charMapFile,
            d = void 0 !== b.itemWidth,
            e = void 0 !== b.itemHeight,
            f = void 0 !== b.startCharMap;
        void 0 !== b.stringValue && c && d && e && f && b.charMapFile && a.setProperty(b.stringValue, this._filePath + b.charMapFile, b.itemWidth, b.itemHeight, b.startCharMap), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLayoutFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b), !(a instanceof ccui.ScrollView || a instanceof ccui.ListView || !a.setClippingEnabled(b.clipAble));
        var c = b.backGroundScale9Enable;
        a.setBackGroundImageScale9Enabled(c);
        var d = b.bgColorR,
            e = b.bgColorG,
            f = b.bgColorB,
            g = b.bgStartColorR,
            h = b.bgStartColorG,
            i = b.bgStartColorB,
            j = b.bgEndColorR,
            k = b.bgEndColorG,
            l = b.bgEndColorB;
        a.setBackGroundColorVector(cc.p(b.vectorX, b.vectorY));
        var m = b.bgColorOpacity;
        a.setBackGroundColorType(b.colorType), a.setBackGroundColor(cc.color(g, h, i), cc.color(j, k, l)), a.setBackGroundColor(cc.color(d, e, f)), a.setBackGroundColorOpacity(m), e = (d = b.backGroundImage) ? this._filePath + d : null, b.useMergedTexture ? a.setBackGroundImage(d, ccui.Widget.PLIST_TEXTURE) : a.setBackGroundImage(e), c && a.setBackGroundImageCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForScrollViewFromJsonDictionary: function(a, b) {
        this.setPropsForLayoutFromJsonDictionary(a, b), a.setInnerContainerSize(cc.size(b.innerWidth, b.innerHeight)), a.setDirection(b.direction), a.setBounceEnabled(b.bounceEnable), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForContainerWidgetFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b), (a instanceof ccui.ScrollView || a instanceof ccui.ListView) && a.setClippingEnabled(b.clipAble), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForSliderFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.barTextureScale9Enable || !1;
        a.setScale9Enabled(c);
        var d = b.length,
            e = b.useMergedTexture;
        if (void 0 !== b.barFileName)
            if (c) {
                var f = (c = b.barFileName) ? this._filePath + c : null;
                e ? a.loadBarTexture(c, ccui.Widget.PLIST_TEXTURE) : a.loadBarTexture(f), a.setSize(cc.size(d, a.getContentSize().height))
            } else f = (c = b.barFileName) ? this._filePath + c : null, e ? a.loadBarTexture(c, ccui.Widget.PLIST_TEXTURE) : a.loadBarTexture(f);
        var d = b.ballNormal,
            c = b.ballPressed,
            f = b.ballDisabled,
            g = d ? this._filePath + d : null,
            h = c ? this._filePath + c : null,
            i = f ? this._filePath + f : null;
        e ? a.loadSlidBallTextures(d, c, f, ccui.Widget.PLIST_TEXTURE) : a.loadSlidBallTextures(g, h, i), a.setPercent(b.percent), f = (c = b.progressBarFileName) ? this._filePath + c : null, e ? a.loadProgressBarTexture(c, ccui.Widget.PLIST_TEXTURE) : a.loadProgressBarTexture(f), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForTextAreaFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b), a.setString(b.text), void 0 !== b.fontSize && a.setFontSize(b.fontSize);
        var c = b.colorR,
            d = b.colorG,
            e = b.colorB;
        a.setColor(cc.color(null == c ? 255 : c, null == d ? 255 : d, null == e ? 255 : e)), a.setFontName(b.fontName), void 0 !== b.areaWidth && void 0 !== b.areaHeight && (c = cc.size(b.areaWidth, b.areaHeight), a.setTextAreaSize(c)), b.hAlignment && a.setTextHorizontalAlignment(b.hAlignment), b.vAlignment && a.setTextVerticalAlignment(b.vAlignment), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForTextButtonFromJsonDictionary: function(a, b) {
        this.setPropsForButtonFromJsonDictionary(a, b), a.setTitleText(b.text || ""), a.setTitleColor(cc.color(void 0 !== b.textColorR ? b.textColorR : 255, void 0 !== b.textColorG ? b.textColorG : 255, void 0 !== b.textColorB ? b.textColorB : 255)), void 0 !== b.fontSize && a.setTitleFontSize(b.fontSize), void 0 !== b.fontName && a.setTitleFontName(b.fontName), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForTextFieldFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b), void 0 !== b.placeHolder && a.setPlaceHolder(b.placeHolder), a.setString(b.text), void 0 !== b.fontSize && a.setFontSize(b.fontSize), void 0 !== b.fontName && a.setFontName(b.fontName), void 0 !== b.touchSizeWidth && void 0 !== b.touchSizeHeight && a.setTouchSize(cc.size(b.touchSizeWidth, b.touchSizeHeight));
        var c = b.maxLengthEnable;
        a.setMaxLengthEnabled(c), c && a.setMaxLength(b.maxLength), c = b.passwordEnable, a.setPasswordEnabled(c), c && a.setPasswordStyleText(b.passwordStyleText), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLoadingBarFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.texture,
            d = c ? this._filePath + c : null;
        b.useMergedTexture ? a.loadTexture(c, ccui.Widget.PLIST_TEXTURE) : a.loadTexture(d), a.setDirection(b.direction), a.setPercent(b.percent), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForListViewFromJsonDictionary: function(a, b) {
        this.setPropsForLayoutFromJsonDictionary(a, b)
    },
    setPropsForPageViewFromJsonDictionary: function(a, b) {
        this.setPropsForLayoutFromJsonDictionary(a, b)
    },
    setPropsForLabelBMFontFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b), a.setFntFile(this._filePath + b.fileName), a.setString(b.text), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    }
}), ccs.WidgetPropertiesReader0300 = ccs.WidgetPropertiesReader.extend({
    createWidget: function(a, b, c) {
        this._filePath = "" == b ? b : cc.path.join(b, "/");
        for (var d = a.textures, e = 0; e < d.length; e++) {
            var f = b,
                f = f + d[e];
            cc.spriteFrameCache.addSpriteFrames(f)
        }
        return b = a.designWidth, d = a.designHeight, 0 >= b || 0 >= d ? (cc.log("Read design size error!"), e = cc.director.getWinSize(), ccs.uiReader.storeFileDesignSize(c, e)) : ccs.uiReader.storeFileDesignSize(c, cc.size(b, d)), e = this.widgetFromJsonDictionary(a.widgetTree), f = e.getContentSize(), 0 == f.width && 0 == f.height && e.setSize(cc.size(b, d)), ccs.actionManager.initWithDictionary(c, a.animation, e), e
    },
    setPropsForAllWidgetFromJsonDictionary: function(a, b, c) {
        a && a.setPropsFromJsonDictionary && a.setPropsFromJsonDictionary(b, c)
    },
    setPropsForAllCustomWidgetFromJsonDictionary: function(a, b, c) {
        var d = ccs.uiReader,
            e = d.getParseObjectMap()[a],
            d = d.getParseCallBackMap()[a];
        e && d && d(a, b, c)
    },
    widgetFromJsonDictionary: function(a) {
        var b = a.classname,
            c = a.options,
            d = this.createGUI(b),
            e = this.getWidgetReaderClassName(b);
        for ((e = this.createWidgetReaderProtocol(e)) ? this.setPropsForAllWidgetFromJsonDictionary(e, d, c) : (e = this.getWidgetReaderClassNameFromWidget(d), (e = ccs.objectFactory.createObject(e)) && d ? (this.setPropsForAllWidgetFromJsonDictionary(e, d, c), c = JSON.parse(c.customProperty), this.setPropsForAllCustomWidgetFromJsonDictionary(b, d, c)) : cc.log("Widget or WidgetReader doesn't exists!!!  Please check your json file.")), a = a.children, b = 0; b < a.length; b++)
            if (c = this.widgetFromJsonDictionary(a[b]))
                if (d instanceof ccui.PageView) d.addPage(c);
                else if (d instanceof ccui.ListView) d.pushBackCustomItem(c);
        else {
            if (!(d instanceof ccui.Layout)) {
                if (c.getPositionType() == ccui.Widget.POSITION_PERCENT) {
                    var e = c.getPositionPercent(),
                        f = d.getAnchorPoint();
                    c.setPositionPercent(cc.p(e.x + f.x, e.y + f.y))
                }
                e = d.getAnchorPointInPoints(), c.setPosition(cc.p(c.getPositionX() + e.x, c.getPositionY() + e.y))
            }
            d.addChild(c)
        }
        return d
    },
    setPropsForWidgetFromJsonDictionary: function(a, b) {
        var c = b.name;
        if (a.setName(c ? c : "default"), void 0 !== b.ignoreSize && a.ignoreContentAdaptWithSize(b.ignoreSize), a.setSizeType(b.sizeType), a.setPositionType(b.positionType), a.setSizePercent(cc.p(b.sizePercentX, b.sizePercentY)), a.setPositionPercent(cc.p(b.positionPercentX, b.positionPercentY)), a.setSize(cc.size(b.width, b.height)), a.setTag(b.tag), a.setActionTag(b.actiontag), a.setTouchEnabled(b.touchAble), a.setPosition(cc.p(b.x, b.y)), void 0 !== b.scaleX && a.setScaleX(b.scaleX), void 0 !== b.scaleY && a.setScaleY(b.scaleY), void 0 !== b.rotation && a.setRotation(b.rotation), void 0 !== b.visible && a.setVisible(b.visible), a.setLocalZOrder(b.ZOrder), c = b.layoutParameter) {
            var d;
            switch (c.type) {
                case 1:
                    d = ccui.LinearLayoutParameter.create(), d.setGravity(c.gravity);
                    break;
                case 2:
                    d = ccui.RelativeLayoutParameter.create(), d.setRelativeName(c.relativeName), d.setRelativeToWidgetName(c.relativeToName), d.setAlign(c.align)
            }
            d.setMargin(new ccui.Margin(c.marginLeft, c.marginTop, c.marginRight, c.marginDown)), a.setLayoutParameter(d)
        }
    },
    setColorPropsForWidgetFromJsonDictionary: function(a, b) {
        void 0 !== b.opacity && a.setOpacity(b.opacity), a.setColor(cc.color(void 0 !== b.colorR ? b.colorR : 255, void 0 !== b.colorG ? b.colorG : 255, void 0 !== b.colorB ? b.colorB : 255));
        var c = void 0 !== b.anchorPointX ? b.anchorPointX : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? .5 : 0,
            d = void 0 !== b.anchorPointY ? b.anchorPointY : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? .5 : 0;
        a.setAnchorPoint(c, d), c = b.flipY, a.setFlippedX(b.flipX), a.setFlippedY(c)
    },
    setPropsForButtonFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.scale9Enable;
        a.setScale9Enabled(c);
        var d = b.normalData;
        switch (d.resourceType) {
            case 0:
                d = d.path, a.loadTextureNormal(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadTextureNormal(d, ccui.Widget.PLIST_TEXTURE)
        }
        switch (d = b.pressedData, d.resourceType) {
            case 0:
                d = d.path, a.loadTexturePressed(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadTexturePressed(d, ccui.Widget.PLIST_TEXTURE)
        }
        switch (d = b.disabledData, d.resourceType) {
            case 0:
                d = d.path, a.loadTextureDisabled(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadTextureDisabled(d, ccui.Widget.PLIST_TEXTURE)
        }
        c && (a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), void 0 !== b.scale9Width && void 0 !== b.scale9Height && a.setSize(cc.size(b.scale9Width, b.scale9Height))), void 0 !== b.text && (c = b.text || "") && a.setTitleText(c), void 0 !== b.fontSize && a.setTitleFontSize(b.fontSize), void 0 !== b.fontName && a.setTitleFontName(b.fontName), c = cc.color(void 0 !== b.textColorR ? b.textColorR : 255, void 0 !== b.textColorG ? b.textColorG : 255, void 0 !== b.textColorB ? b.textColorB : 255), a.setTitleColor(c), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForCheckBoxFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.backGroundBoxData;
        switch (c.resourceType) {
            case 0:
                c = c.path, a.loadTextureBackGround(c ? this._filePath + c : null);
                break;
            case 1:
                c = c.path, a.loadTextureBackGround(c, ccui.Widget.PLIST_TEXTURE)
        }
        switch (c = b.backGroundBoxSelectedData, c.resourceType) {
            case 0:
                c = c.path, a.loadTextureBackGroundSelected(c ? this._filePath + c : null);
                break;
            case 1:
                c = c.path, a.loadTextureBackGroundSelected(c, ccui.Widget.PLIST_TEXTURE)
        }
        switch (c = b.frontCrossData, c.resourceType) {
            case 0:
                c = c.path, a.loadTextureFrontCross(c ? this._filePath + c : null);
                break;
            case 1:
                c = c.path, a.loadTextureFrontCross(c, ccui.Widget.PLIST_TEXTURE)
        }
        switch (c = b.backGroundBoxDisabledData, c.resourceType) {
            case 0:
                c = c.path, a.loadTextureBackGroundDisabled(c ? this._filePath + c : null);
                break;
            case 1:
                c = c.path, a.loadTextureBackGroundDisabled(c, ccui.Widget.PLIST_TEXTURE)
        }
        switch (b.frontCrossDisabledData.resourceType) {
            case 0:
                c = b.path, a.loadTextureFrontCrossDisabled(c ? this._filePath + c : null);
                break;
            case 1:
                c = b.path, a.loadTextureFrontCrossDisabled(c, ccui.Widget.PLIST_TEXTURE)
        }
        a.setSelectedState(b.selectedState || !1), a.setSelectedState(b, "selectedState"), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForImageViewFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.fileNameData;
        switch (c.resourceType) {
            case 0:
                var d = this._filePath;
                (c = c.path) && a.loadTexture(d + c);
                break;
            case 1:
                c = c.path, a.loadTexture(c, ccui.Widget.PLIST_TEXTURE)
        }
        d = b.scale9Enable || !1, a.setScale9Enabled(d), d && (void 0 !== b.scale9Width && void 0 !== b.scale9Height && a.setSize(cc.size(b.scale9Width, b.scale9Height)), a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight))), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLabelFromJsonDictionary: function(a, b) {
        if (this.setPropsForWidgetFromJsonDictionary(a, b), a.setTouchScaleChangeEnabled(b.touchScaleEnable), a.setString(b.text), void 0 !== b.fontSize && a.setFontSize(b.fontSize), void 0 !== b.fontName && a.setFontName(b.fontName), void 0 !== b.areaWidth && void 0 !== b.areaHeight) {
            var c = cc.size(b.areaWidth, b.areaHeight);
            a.setTextAreaSize(c)
        }
        b.hAlignment && a.setTextHorizontalAlignment(b.hAlignment), b.vAlignment && a.setTextVerticalAlignment(b.vAlignment), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLabelAtlasFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = void 0 !== b.charMapFile,
            d = void 0 !== b.itemWidth,
            e = void 0 !== b.itemHeight,
            f = void 0 !== b.startCharMap;
        if (void 0 !== b.stringValue && c && d && e && f) switch (c = b.charMapFileData, c.resourceType) {
            case 0:
                a.setProperty(b.stringValue, this._filePath + c.path, b.itemWidth, b.itemHeight, b.startCharMap);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLayoutFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b), !(a instanceof ccui.ScrollView || a instanceof ccui.ListView || !a.setClippingEnabled(b.clipAble));
        var c = b.backGroundScale9Enable;
        a.setBackGroundImageScale9Enabled(c);
        var d = b.bgColorR,
            e = b.bgColorG,
            f = b.bgColorB,
            g = b.bgStartColorR,
            h = b.bgStartColorG,
            i = b.bgStartColorB,
            j = b.bgEndColorR,
            k = b.bgEndColorG,
            l = b.bgEndColorB;
        a.setBackGroundColorVector(cc.p(b.vectorX, b.vectorY));
        var m = b.bgColorOpacity;
        switch (a.setBackGroundColorType(b.colorType), a.setBackGroundColor(cc.color(g, h, i), cc.color(j, k, l)), a.setBackGroundColor(cc.color(d, e, f)), a.setBackGroundColorOpacity(m), d = b.backGroundImageData || {}, d.resourceType) {
            case 0:
                d = d.path, a.setBackGroundImage(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.setBackGroundImage(d, ccui.Widget.PLIST_TEXTURE)
        }
        c && a.setBackGroundImageCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), a.setLayoutType(b.layoutType), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForScrollViewFromJsonDictionary: function(a, b) {
        this.setPropsForLayoutFromJsonDictionary(a, b), a.setInnerContainerSize(cc.size(b.innerWidth, b.innerHeight)), a.setDirection(b.direction), a.setBounceEnabled(b.bounceEnable), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForSliderFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.barTextureScale9Enable || !1;
        a.setScale9Enabled(c);
        var d = b.length;
        if (void 0 !== b.barFileName)
            if (c) {
                var c = b.barFileNameData,
                    e = c.resourceType;
                switch (e) {
                    case 0:
                        c = (c = c.path) ? this._filePath + c : null, a.loadBarTexture(c);
                        break;
                    case 1:
                        c = c.path, a.loadBarTexture(c, ccui.Widget.PLIST_TEXTURE)
                }
                a.setSize(cc.size(d, a.getContentSize().height))
            } else switch (c = b.barFileNameData, e = c.resourceType) {
                case 0:
                    c = (c = c.path) ? this._filePath + c : null, a.loadBarTexture(c);
                    break;
                case 1:
                    c = c.path, a.loadBarTexture(c, ccui.Widget.PLIST_TEXTURE)
            }
            switch (d = b.ballNormalData, d.resourceType) {
                case 0:
                    d = d.path, a.loadSlidBallTextureNormal(d ? this._filePath + d : null);
                    break;
                case 1:
                    d = d.path, a.loadSlidBallTextureNormal(d, ccui.Widget.PLIST_TEXTURE)
            }
        switch (d = b.ballPressedData, d.resourceType) {
            case 0:
                d = d.path, a.loadSlidBallTexturePressed(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadSlidBallTexturePressed(d, ccui.Widget.PLIST_TEXTURE)
        }
        switch (d = b.ballDisabledData, d.resourceType) {
            case 0:
                d = d.path, a.loadSlidBallTextureDisabled(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadSlidBallTextureDisabled(d, ccui.Widget.PLIST_TEXTURE)
        }
        switch (d = b.progressBarData, d.resourceType) {
            case 0:
                c = (c = d.path) ? this._filePath + c : null, a.loadProgressBarTexture(c);
                break;
            case 1:
                c = d.path, a.loadProgressBarTexture(c, ccui.Widget.PLIST_TEXTURE)
        }
        this.setColorPropsForWidgetFromJsonDictionary(a, b), a.setPercent(b.percent)
    },
    setPropsForTextAreaFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b), a.setString(b.text), void 0 !== b.fontSize && a.setFontSize(b.fontSize);
        var c = b.colorR,
            d = b.colorG,
            e = b.colorB;
        a.setColor(cc.color(null == c ? 255 : c, null == d ? 255 : d, null == e ? 255 : e)), a.setFontName(b.fontName), void 0 !== b.areaWidth && void 0 !== b.areaHeight && (c = cc.size(b.areaWidth, b.areaHeight), a.setTextAreaSize(c)), b.hAlignment && a.setTextHorizontalAlignment(b.hAlignment), b.vAlignment && a.setTextVerticalAlignment(b.vAlignment), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForTextButtonFromJsonDictionary: function(a, b) {
        this.setPropsForButtonFromJsonDictionary(a, b), a.setTitleText(b.text || ""), a.setTitleColor(cc.color(void 0 !== b.textColorR ? b.textColorR : 255, void 0 !== b.textColorG ? b.textColorG : 255, void 0 !== b.textColorB ? b.textColorB : 255)), void 0 !== b.fontSize && a.setTitleFontSize(b.fontSize), void 0 !== b.fontName && a.setTitleFontName(b.fontName), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForTextFieldFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b), void 0 !== b.placeHolder && a.setPlaceHolder(b.placeHolder), a.setString(b.text), void 0 !== b.fontSize && a.setFontSize(b.fontSize), void 0 !== b.fontName && a.setFontName(b.fontName), void 0 !== b.touchSizeWidth && void 0 !== b.touchSizeHeight && a.setTouchSize(cc.size(b.touchSizeWidth, b.touchSizeHeight));
        var c = b.maxLengthEnable;
        a.setMaxLengthEnabled(c), c && a.setMaxLength(b.maxLength), c = b.passwordEnable, a.setPasswordEnabled(c), c && a.setPasswordStyleText(b.passwordStyleText), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLoadingBarFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.textureData;
        switch (c.resourceType) {
            case 0:
                var d = this._filePath;
                (c = c.path) && a.loadTexture(d + c);
                break;
            case 1:
                c = c.path, a.loadTexture(c, ccui.Widget.PLIST_TEXTURE)
        }
        d = b.scale9Enable, a.setScale9Enabled(d), d && (a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), a.setSize(cc.size(b.width, b.height))), a.setDirection(b.direction), a.setPercent(b.percent), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForListViewFromJsonDictionary: function(a, b) {
        this.setPropsForLayoutFromJsonDictionary(a, b), a.setInnerContainerSize(cc.size(b.innerWidth || 0, b.innerHeight || 0)), a.setDirection(b.direction || 0), a.setGravity(b.gravity || 0), a.setItemsMargin(b.itemMargin || 0)
    },
    setPropsForPageViewFromJsonDictionary: function(a, b) {
        this.setPropsForLayoutFromJsonDictionary(a, b)
    },
    setPropsForLabelBMFontFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.fileNameData;
        switch (c.resourceType) {
            case 0:
                a.setFntFile(this._filePath + c.path);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        a.setString(b.text), this.setColorPropsForWidgetFromJsonDictionary(a, b)
    }
}), ccs.sceneReader = {
    _baseBath: "",
    _listener: null,
    _selector: null,
    _node: null,
    createNodeWithSceneFile: function(a) {
        this._node = null, this._baseBath = cc.path.dirname(a);
        var b = cc.loader.getRes(a);
        if (!b) throw "Please load the resource first : " + a;
        return this._node = this.createObject(b, null), ccs.triggerManager.parse(b.Triggers || []), this._node
    },
    createObject: function(a, b) {
        var c = a.classname;
        if ("CCNode" == c) {
            var d = null;
            b ? (d = cc.Node.create(), b.addChild(d)) : d = cc.Node.create(), this.setPropertyFromJsonDict(d, a);
            for (var e = a.components, f = 0; f < e.length; f++) {
                var g = e[f];
                if (!g) break;
                var c = g.classname,
                    h = g.name,
                    i = g.fileData,
                    j = "",
                    k = "",
                    l = 0;
                null != i && (l = void 0 !== i.resourceType ? i.resourceType : -1, j = cc.path.join(this._baseBath, i.path), k = i.plistFile);
                var m = cc.path.extname(j);
                if ("CCSprite" == c) {
                    if (c = null, 0 == l) {
                        if (".png" != m) continue;
                        c = cc.Sprite.create(j)
                    } else {
                        if (1 != l) continue;
                        if (".plist" != m) continue;
                        k = cc.path.join(this._baseBath, k), j = cc.path.changeExtname(k, ".png"), cc.spriteFrameCache.addSpriteFrames(k, j), c = cc.Sprite.create("#" + i.path)
                    }
                    j = ccs.ComRender.create(c, "CCSprite"), null != h && j.setName(h), d.addComponent(j), this._callSelector(c, g)
                } else if ("CCTMXTiledMap" == c) i = null, 0 == l && ".tmx" == m && (i = cc.TMXTiledMap.create(j), j = ccs.ComRender.create(i, "CCTMXTiledMap"), null != h && j.setName(h), d.addComponent(j), this._callSelector(i, g));
                else if ("CCParticleSystemQuad" == c) ".plist" == m && (i = null, 0 == l ? (i = cc.ParticleSystem.create(j), i.setPosition(0, 0), j = ccs.ComRender.create(i, "CCParticleSystemQuad"), null != h && j.setName(h), d.addComponent(j), this._callSelector(i, g)) : cc.log("unknown resourcetype on CCParticleSystemQuad!"));
                else if ("CCArmature" == c) 0 == l && ((l = cc.loader.getRes(j)) || cc.log("Please load the resource [%s] first!", j), l = l.armature_data[0].name, ccs.armatureDataManager.addArmatureFileInfo(j), l = ccs.Armature.create(l), j = ccs.ComRender.create(l, "CCArmature"), null != h && j.setName(h), d.addComponent(j), (h = g.selectedactionname) && l.getAnimation() && l.getAnimation().play(h), this._callSelector(l, g));
                else if ("CCComAudio" == c) {
                    var n = null;
                    0 == l && (n = ccs.ComAudio.create(), n.preloadEffect(j), h && n.setName(h), d.addComponent(n), this._callSelector(n, g))
                } else "CCComAttribute" == c ? (i = null, 0 == l ? (i = ccs.ComAttribute.create(), "" != j && i.parse(j), h && i.setName(h), d.addComponent(i), this._callSelector(i, g)) : cc.log("unknown resourcetype on CCComAttribute!")) : "CCBackgroundAudio" == c ? m && 0 == l && (n = ccs.ComAudio.create(), n.preloadBackgroundMusic(j), n.setFile(j), l = Boolean(g.loop || 0), n.setLoop(l), h && n.setName(h), d.addComponent(n), n.playBackgroundMusic(j, l), this._callSelector(n, g)) : "GUIComponent" == c && (j = ccs.uiReader.widgetFromJsonFile(j), j = ccs.ComRender.create(j, "GUIComponent"), null != h && j.setName(h), d.addComponent(j), this._callSelector(n, g))
            }
            for (e = a.gameobjects, f = 0; f < e.length && (g = e[f], g); f++) this.createObject(g, d);
            return d
        }
        return null
    },
    nodeByTag: function(a, b) {
        if (null == a) return null;
        for (var c = null, d = a.getChildren(), e = 0; e < d.length && (!(c = d[e]) || c.getTag() != b) && !(c = this.nodeByTag(c, b)); e++);
        return c
    },
    getNodeByTag: function(a) {
        return null == this._node ? null : this._node.getTag() == a ? this._node : this.nodeByTag(this._node, a)
    },
    setPropertyFromJsonDict: function(a, b) {
        a.setPosition("undefined" == typeof b.x ? 0 : b.x, "undefined" == typeof b.y ? 0 : b.y), a.setVisible(Boolean("undefined" == typeof b.visible ? 1 : b.visible)), a.setTag("undefined" == typeof b.objecttag ? -1 : b.objecttag), a.setLocalZOrder("undefined" == typeof b.zorder ? 0 : b.zorder);
        var c = "undefined" == typeof b.scaley ? 1 : b.scaley;
        a.setScaleX("undefined" == typeof b.scalex ? 1 : b.scalex), a.setScaleY(c), a.setRotation("undefined" == typeof b.rotation ? 0 : b.rotation)
    },
    setTarget: function(a, b) {
        this._listener = b, this._selector = a
    },
    _callSelector: function(a, b) {
        this._selector && this._selector.call(this._listener, a, b)
    },
    version: function() {
        return "1.2.0.0"
    },
    clear: function() {
        ccs.triggerManager.removeAll(), cc.audioEngine.end()
    }
};
var spine = spine || {};
spine.BoneData = function(a, b) {
    this.name = a, this.parent = b
}, spine.BoneData.prototype = {
    length: 0,
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    inheritScale: !0,
    inheritRotation: !0
}, spine.SlotData = function(a, b) {
    this.name = a, this.boneData = b, this.r = this.g = this.b = this.a = 1
}, spine.SlotData.prototype = {
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    attachmentName: null,
    additiveBlending: !1
}, spine.Bone = function(a, b) {
    this.data = a, this.parent = b, this.setToSetupPose()
}, spine.Bone.yDown = !1, spine.Bone.prototype = {
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    m00: 0,
    m01: 0,
    worldX: 0,
    m10: 0,
    m11: 0,
    worldY: 0,
    worldRotation: 0,
    worldScaleX: 1,
    worldScaleY: 1,
    updateWorldTransform: function(a, b) {
        var c = this.parent;
        null != c ? (this.worldX = this.x * c.m00 + this.y * c.m01 + c.worldX, this.worldY = this.x * c.m10 + this.y * c.m11 + c.worldY, this.data.inheritScale ? (this.worldScaleX = c.worldScaleX * this.scaleX, this.worldScaleY = c.worldScaleY * this.scaleY) : (this.worldScaleX = this.scaleX, this.worldScaleY = this.scaleY), this.worldRotation = this.data.inheritRotation ? c.worldRotation + this.rotation : this.rotation) : (this.worldX = a ? -this.x : this.x, this.worldY = b != spine.Bone.yDown ? -this.y : this.y, this.worldScaleX = this.scaleX, this.worldScaleY = this.scaleY, this.worldRotation = this.rotation);
        var d = this.worldRotation * Math.PI / 180,
            c = Math.cos(d),
            d = Math.sin(d);
        this.m00 = c * this.worldScaleX, this.m10 = d * this.worldScaleX, this.m01 = -d * this.worldScaleY, this.m11 = c * this.worldScaleY, a && (this.m00 = -this.m00, this.m01 = -this.m01), b != spine.Bone.yDown && (this.m10 = -this.m10, this.m11 = -this.m11)
    },
    setToSetupPose: function() {
        var a = this.data;
        this.x = a.x, this.y = a.y, this.rotation = a.rotation, this.scaleX = a.scaleX, this.scaleY = a.scaleY
    }
}, spine.Slot = function(a, b, c) {
    this.data = a, this.skeleton = b, this.bone = c, this.setToSetupPose()
}, spine.Slot.prototype = {
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    _attachmentTime: 0,
    attachment: null,
    setAttachment: function(a) {
        this.attachment = a, this._attachmentTime = this.skeleton.time
    },
    setAttachmentTime: function(a) {
        this._attachmentTime = this.skeleton.time - a
    },
    getAttachmentTime: function() {
        return this.skeleton.time - this._attachmentTime
    },
    setToSetupPose: function() {
        var a = this.data;
        this.r = a.r, this.g = a.g, this.b = a.b, this.a = a.a;
        for (var b = this.skeleton.data.slots, c = 0, d = b.length; d > c; c++)
            if (b[c] == a) {
                this.setAttachment(a.attachmentName ? this.skeleton.getAttachmentBySlotIndex(c, a.attachmentName) : null);
                break
            }
    }
}, spine.Skin = function(a) {
    this.name = a, this.attachments = {}
}, spine.Skin.prototype = {
    addAttachment: function(a, b, c) {
        this.attachments[a + ":" + b] = c
    },
    getAttachment: function(a, b) {
        return this.attachments[a + ":" + b]
    },
    _attachAll: function(a, b) {
        for (var c in b.attachments) {
            var d = c.indexOf(":"),
                e = parseInt(c.substring(0, d)),
                f = c.substring(d + 1),
                d = a.slots[e];
            d.attachment && d.attachment.name == f && (e = this.getAttachment(e, f)) && d.setAttachment(e)
        }
    }
}, spine.Animation = function(a, b, c) {
    this.name = a, this.timelines = b, this.duration = c
}, spine.Animation.prototype = {
    apply: function(a, b, c, d, e) {
        d && 0 != this.duration && (c %= this.duration, b %= this.duration), d = this.timelines;
        for (var f = 0, g = d.length; g > f; f++) d[f].apply(a, b, c, e, 1)
    },
    mix: function(a, b, c, d, e, f) {
        d && 0 != this.duration && (c %= this.duration, b %= this.duration), d = this.timelines;
        for (var g = 0, h = d.length; h > g; g++) d[g].apply(a, b, c, e, f)
    }
}, spine.binarySearch = function(a, b, c) {
    var d = 0,
        e = Math.floor(a.length / c) - 2;
    if (0 == e) return c;
    for (var f = e >>> 1;;) {
        if (a[(f + 1) * c] <= b ? d = f + 1 : e = f, d == e) return (d + 1) * c;
        f = d + e >>> 1
    }
}, spine.linearSearch = function(a, b, c) {
    for (var d = 0, e = a.length - c; e >= d; d += c)
        if (a[d] > b) return d;
    return -1
}, spine.Curves = function(a) {
    this.curves = [], this.curves.length = 6 * (a - 1)
}, spine.Curves.prototype = {
    setLinear: function(a) {
        this.curves[6 * a] = 0
    },
    setStepped: function(a) {
        this.curves[6 * a] = -1
    },
    setCurve: function(a, b, c, d, e) {
        var f = .1 * .1,
            g = .1 * f,
            h = 3 * .1,
            i = 3 * f,
            f = 6 * f,
            j = 6 * g,
            k = 2 * -b + d,
            l = 2 * -c + e;
        d = 3 * (b - d) + 1, e = 3 * (c - e) + 1, a *= 6;
        var m = this.curves;
        m[a] = b * h + k * i + d * g, m[a + 1] = c * h + l * i + e * g, m[a + 2] = k * f + d * j, m[a + 3] = l * f + e * j, m[a + 4] = d * j, m[a + 5] = e * j
    },
    getCurvePercent: function(a, b) {
        b = 0 > b ? 0 : b > 1 ? 1 : b;
        var c = 6 * a,
            d = this.curves,
            e = d[c];
        if (!e) return b;
        if (-1 == e) return 0;
        for (var f = d[c + 1], g = d[c + 2], h = d[c + 3], i = d[c + 4], j = d[c + 5], c = e, d = f, k = 8;;) {
            if (c >= b) return e = c - e, f = d - f, f + (d - f) * (b - e) / (c - e);
            if (0 == k) break;
            k--, e += g, f += h, g += i, h += j, c += e, d += f
        }
        return d + (1 - d) * (b - c) / (1 - c)
    }
}, spine.RotateTimeline = function(a) {
    this.curves = new spine.Curves(a), this.frames = [], this.frames.length = 2 * a
}, spine.RotateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 2
    },
    setFrame: function(a, b, c) {
        a *= 2, this.frames[a] = b, this.frames[a + 1] = c
    },
    apply: function(a, b, c, d, e) {
        if (b = this.frames, !(c < b[0])) {
            if (a = a.bones[this.boneIndex], c >= b[b.length - 2]) b = a.data.rotation + b[b.length - 1] - a.rotation;
            else {
                var f = spine.binarySearch(b, c, 2);
                d = b[f - 1];
                var g = b[f];
                for (c = 1 - (c - g) / (b[f - 2] - g), c = this.curves.getCurvePercent(f / 2 - 1, c), b = b[f + 1] - d; b > 180;) b -= 360;
                for (; - 180 > b;) b += 360;
                b = a.data.rotation + (d + b * c) - a.rotation
            }
            for (; b > 180;) b -= 360;
            for (; - 180 > b;) b += 360;
            a.rotation += b * e
        }
    }
}, spine.TranslateTimeline = function(a) {
    this.curves = new spine.Curves(a), this.frames = [], this.frames.length = 3 * a
}, spine.TranslateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 3
    },
    setFrame: function(a, b, c, d) {
        a *= 3, this.frames[a] = b, this.frames[a + 1] = c, this.frames[a + 2] = d
    },
    apply: function(a, b, c, d, e) {
        if (b = this.frames, !(c < b[0]))
            if (a = a.bones[this.boneIndex], c >= b[b.length - 3]) a.x += (a.data.x + b[b.length - 2] - a.x) * e, a.y += (a.data.y + b[b.length - 1] - a.y) * e;
            else {
                d = spine.binarySearch(b, c, 3);
                var f = b[d - 2],
                    g = b[d - 1],
                    h = b[d];
                c = 1 - (c - h) / (b[d + -3] - h), c = this.curves.getCurvePercent(d / 3 - 1, c), a.x += (a.data.x + f + (b[d + 1] - f) * c - a.x) * e, a.y += (a.data.y + g + (b[d + 2] - g) * c - a.y) * e
            }
    }
}, spine.ScaleTimeline = function(a) {
    this.curves = new spine.Curves(a), this.frames = [], this.frames.length = 3 * a
}, spine.ScaleTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 3
    },
    setFrame: function(a, b, c, d) {
        a *= 3, this.frames[a] = b, this.frames[a + 1] = c, this.frames[a + 2] = d
    },
    apply: function(a, b, c, d, e) {
        if (b = this.frames, !(c < b[0]))
            if (a = a.bones[this.boneIndex], c >= b[b.length - 3]) a.scaleX += (a.data.scaleX - 1 + b[b.length - 2] - a.scaleX) * e, a.scaleY += (a.data.scaleY - 1 + b[b.length - 1] - a.scaleY) * e;
            else {
                d = spine.binarySearch(b, c, 3);
                var f = b[d - 2],
                    g = b[d - 1],
                    h = b[d];
                c = 1 - (c - h) / (b[d + -3] - h), c = this.curves.getCurvePercent(d / 3 - 1, c), a.scaleX += (a.data.scaleX - 1 + f + (b[d + 1] - f) * c - a.scaleX) * e, a.scaleY += (a.data.scaleY - 1 + g + (b[d + 2] - g) * c - a.scaleY) * e
            }
    }
}, spine.ColorTimeline = function(a) {
    this.curves = new spine.Curves(a), this.frames = [], this.frames.length = 5 * a
}, spine.ColorTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 5
    },
    setFrame: function(a, b, c, d, e, f) {
        a *= 5, this.frames[a] = b, this.frames[a + 1] = c, this.frames[a + 2] = d, this.frames[a + 3] = e, this.frames[a + 4] = f
    },
    apply: function(a, b, c, d, e) {
        if (b = this.frames, !(c < b[0]))
            if (a = a.slots[this.slotIndex], c >= b[b.length - 5]) e = b.length - 1, a.r = b[e - 3], a.g = b[e - 2], a.b = b[e - 1], a.a = b[e];
            else {
                d = spine.binarySearch(b, c, 5);
                var f = b[d - 4],
                    g = b[d - 3],
                    h = b[d - 2],
                    i = b[d - 1],
                    j = b[d];
                c = 1 - (c - j) / (b[d - 5] - j), c = this.curves.getCurvePercent(d / 5 - 1, c), f += (b[d + 1] - f) * c, g += (b[d + 2] - g) * c, h += (b[d + 3] - h) * c, b = i + (b[d + 4] - i) * c, 1 > e ? (a.r += (f - a.r) * e, a.g += (g - a.g) * e, a.b += (h - a.b) * e, a.a += (b - a.a) * e) : (a.r = f, a.g = g, a.b = h, a.a = b)
            }
    }
}, spine.AttachmentTimeline = function(a) {
    this.curves = new spine.Curves(a), this.frames = [], this.frames.length = a, this.attachmentNames = [], this.attachmentNames.length = a
}, spine.AttachmentTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(a, b, c) {
        this.frames[a] = b, this.attachmentNames[a] = c
    },
    apply: function(a, b, c) {
        b = this.frames, c < b[0] || (c = c >= b[b.length - 1] ? b.length - 1 : spine.binarySearch(b, c, 1) - 1, c = this.attachmentNames[c], a.slots[this.slotIndex].setAttachment(c ? a.getAttachmentBySlotIndex(this.slotIndex, c) : null))
    }
}, spine.EventTimeline = function(a) {
    this.frames = [], this.frames.length = a, this.events = [], this.events.length = a
}, spine.EventTimeline.prototype = {
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(a, b, c) {
        this.frames[a] = b, this.events[a] = c
    },
    apply: function(a, b, c, d, e) {
        if (d) {
            var f = this.frames,
                g = f.length;
            if (b > c) this.apply(a, b, Number.MAX_VALUE, d, e), b = -1;
            else if (b >= f[g - 1]) return;
            if (!(c < f[0])) {
                if (b < f[0]) a = 0;
                else
                    for (a = spine.binarySearch(f, b, 1), b = f[a]; a > 0 && f[a - 1] == b;) a--;
                for (b = this.events; g > a && c >= f[a]; a++) d.push(b[a])
            }
        }
    }
}, spine.DrawOrderTimeline = function(a) {
    this.frames = [], this.frames.length = a, this.drawOrders = [], this.drawOrders.length = a
}, spine.DrawOrderTimeline.prototype = {
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(a, b, c) {
        this.frames[a] = b, this.drawOrders[a] = c
    },
    apply: function(a, b, c, d, e) {
        if (b = this.frames, !(c < b[0]))
            if (d = c >= b[b.length - 1] ? b.length - 1 : spine.binarySearch(b, c, 1) - 1, c = a.drawOrder, b = a.slots, d = this.drawOrders[d])
                for (e = 0, f = d.length; f > e; e++) c[e] = a.slots[d[e]];
            else {
                e = 0;
                for (var f = b.length; f > e; e++) c[e] = b[e]
            }
    }
}, spine.SkeletonData = function() {
    this.bones = [], this.slots = [], this.skins = [], this.events = [], this.animations = []
}, spine.SkeletonData.prototype = {
    defaultSkin: null,
    findBone: function(a) {
        for (var b = this.bones, c = 0, d = b.length; d > c; c++)
            if (b[c].name == a) return b[c];
        return null
    },
    findBoneIndex: function(a) {
        for (var b = this.bones, c = 0, d = b.length; d > c; c++)
            if (b[c].name == a) return c;
        return -1
    },
    findSlot: function(a) {
        for (var b = this.slots, c = 0, d = b.length; d > c; c++)
            if (b[c].name == a) return b[c];
        return null
    },
    findSlotIndex: function(a) {
        for (var b = this.slots, c = 0, d = b.length; d > c; c++)
            if (b[c].name == a) return c;
        return -1
    },
    findSkin: function(a) {
        for (var b = this.skins, c = 0, d = b.length; d > c; c++)
            if (b[c].name == a) return b[c];
        return null
    },
    findEvent: function(a) {
        for (var b = this.events, c = 0, d = b.length; d > c; c++)
            if (b[c].name == a) return b[c];
        return null
    },
    findAnimation: function(a) {
        for (var b = this.animations, c = 0, d = b.length; d > c; c++)
            if (b[c].name == a) return b[c];
        return null
    }
}, spine.Skeleton = function(a) {
    this.data = a, this.bones = [];
    for (var b = 0, c = a.bones.length; c > b; b++) {
        var d = a.bones[b],
            e = d.parent ? this.bones[a.bones.indexOf(d.parent)] : null;
        this.bones.push(new spine.Bone(d, e))
    }
    for (this.slots = [], this.drawOrder = [], b = 0, c = a.slots.length; c > b; b++) d = a.slots[b], e = this.bones[a.bones.indexOf(d.boneData)], d = new spine.Slot(d, this, e), this.slots.push(d), this.drawOrder.push(d)
}, spine.Skeleton.prototype = {
    x: 0,
    y: 0,
    skin: null,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    time: 0,
    flipX: !1,
    flipY: !1,
    updateWorldTransform: function() {
        for (var a = this.flipX, b = this.flipY, c = this.bones, d = 0, e = c.length; e > d; d++) c[d].updateWorldTransform(a, b)
    },
    setToSetupPose: function() {
        this.setBonesToSetupPose(), this.setSlotsToSetupPose()
    },
    setBonesToSetupPose: function() {
        for (var a = this.bones, b = 0, c = a.length; c > b; b++) a[b].setToSetupPose()
    },
    setSlotsToSetupPose: function() {
        for (var a = this.slots, b = 0, c = a.length; c > b; b++) a[b].setToSetupPose(b)
    },
    getRootBone: function() {
        return 0 == this.bones.length ? null : this.bones[0]
    },
    findBone: function(a) {
        for (var b = this.bones, c = 0, d = b.length; d > c; c++)
            if (b[c].data.name == a) return b[c];
        return null
    },
    findBoneIndex: function(a) {
        for (var b = this.bones, c = 0, d = b.length; d > c; c++)
            if (b[c].data.name == a) return c;
        return -1
    },
    findSlot: function(a) {
        for (var b = this.slots, c = 0, d = b.length; d > c; c++)
            if (b[c].data.name == a) return b[c];
        return null
    },
    findSlotIndex: function(a) {
        for (var b = this.slots, c = 0, d = b.length; d > c; c++)
            if (b[c].data.name == a) return c;
        return -1
    },
    setSkinByName: function(a) {
        var b = this.data.findSkin(a);
        if (!b) throw "Skin not found: " + a;
        this.setSkin(b)
    },
    setSkin: function(a) {
        this.skin && a && a._attachAll(this, this.skin), this.skin = a
    },
    getAttachmentBySlotName: function(a, b) {
        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(a), b)
    },
    getAttachmentBySlotIndex: function(a, b) {
        if (this.skin) {
            var c = this.skin.getAttachment(a, b);
            if (c) return c
        }
        return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(a, b) : null
    },
    setAttachment: function(a, b) {
        for (var c = this.slots, d = 0, e = c.length; e > d; d++) {
            var f = c[d];
            if (f.data.name == a) {
                if (c = null, b && (c = this.getAttachment(d, b), !c)) throw "Attachment not found: " + b + ", for slot: " + a;
                return void f.setAttachment(c)
            }
        }
        throw "Slot not found: " + a
    },
    update: function(a) {
        this.time += a
    }
}, spine.EventData = function(a) {
    this.name = a
}, spine.EventData.prototype = {
    intValue: 0,
    floatValue: 0,
    stringValue: null
}, spine.Event = function(a) {
    this.data = a
}, spine.Event.prototype = {
    intValue: 0,
    floatValue: 0,
    stringValue: null
}, spine.AttachmentType = {
    region: 0,
    boundingbox: 1
}, spine.RegionAttachment = function(a) {
    this.name = a, this.offset = [], this.offset.length = 8, this.uvs = [], this.uvs.length = 8, this.type = spine.AttachmentType.region
}, spine.RegionAttachment.prototype = {
    type: spine.AttachmentType.region,
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    width: 0,
    height: 0,
    rendererObject: null,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    setUVs: function(a, b, c, d, e) {
        var f = this.uvs;
        e ? (f[2] = a, f[3] = d, f[4] = a, f[5] = b, f[6] = c, f[7] = b, f[0] = c, f[1] = d) : (f[0] = a, f[1] = d, f[2] = a, f[3] = b, f[4] = c, f[5] = b, f[6] = c, f[7] = d)
    },
    updateOffset: function() {
        var a = this.width / this.regionOriginalWidth * this.scaleX,
            b = this.height / this.regionOriginalHeight * this.scaleY,
            c = -this.width / 2 * this.scaleX + this.regionOffsetX * a,
            d = -this.height / 2 * this.scaleY + this.regionOffsetY * b,
            e = c + this.regionWidth * a,
            a = d + this.regionHeight * b,
            b = this.rotation * Math.PI / 180,
            f = Math.cos(b),
            g = Math.sin(b),
            b = c * f + this.x,
            c = c * g,
            h = d * f + this.y,
            d = d * g,
            i = e * f + this.x,
            e = e * g,
            f = a * f + this.y,
            a = a * g,
            g = this.offset;
        g[0] = b - d, g[1] = h + c, g[2] = b - a, g[3] = f + c, g[4] = i - a, g[5] = f + e, g[6] = i - d, g[7] = h + e
    },
    computeVertices: function(a, b, c, d) {
        a += c.worldX, b += c.worldY;
        var e = c.m00,
            f = c.m01,
            g = c.m10;
        c = c.m11;
        var h = this.offset;
        d[0] = h[0] * e + h[1] * f + a, d[1] = h[0] * g + h[1] * c + b, d[2] = h[2] * e + h[3] * f + a, d[3] = h[2] * g + h[3] * c + b, d[4] = h[4] * e + h[5] * f + a, d[5] = h[4] * g + h[5] * c + b, d[6] = h[6] * e + h[7] * f + a, d[7] = h[6] * g + h[7] * c + b
    }
}, spine.BoundingBoxAttachment = function(a) {
    this.name = a, this.vertices = [], this.type = spine.AttachmentType.boundingBox
}, spine.BoundingBoxAttachment.prototype = {
    type: spine.AttachmentType.boundingBox,
    computeWorldVertices: function(a, b, c, d) {
        a += c.worldX, b += c.worldY;
        var e = c.m00,
            f = c.m01,
            g = c.m10;
        c = c.m11;
        for (var h = this.vertices, i = 0, j = h.length; j > i; i += 2) {
            var k = h[i],
                l = h[i + 1];
            d[i] = k * e + l * f + a, d[i + 1] = k * g + l * c + b
        }
    }
}, spine.AnimationStateData = function(a) {
    this.skeletonData = a, this.animationToMixTime = {}
}, spine.AnimationStateData.prototype = {

    defaultMix: 0,
    setMixByName: function(a, b, c) {
        var d = this.skeletonData.findAnimation(a);
        if (!d) throw "Animation not found: " + a;
        if (a = this.skeletonData.findAnimation(b), !a) throw "Animation not found: " + b;
        this.setMix(d, a, c)
    },
    setMix: function(a, b, c) {
        this.animationToMixTime[a.name + ":" + b.name] = c
    },
    getMix: function(a, b) {
        var c = this.animationToMixTime[a.name + ":" + b.name];
        return c ? c : this.defaultMix
    }
}, spine.TrackEntry = function() {}, spine.TrackEntry.prototype = {
    next: null,
    previous: null,
    animation: null,
    loop: !1,
    delay: 0,
    time: 0,
    lastTime: -1,
    endTime: 0,
    timeScale: 1,
    mixTime: 0,
    mixDuration: 0,
    onStart: null,
    onEnd: null,
    onComplete: null,
    onEvent: null
}, spine.AnimationState = function(a) {
    this.data = a, this.tracks = [], this.events = []
}, spine.AnimationState.prototype = {
    onStart: null,
    onEnd: null,
    onComplete: null,
    onEvent: null,
    timeScale: 1,
    update: function(a) {
        a *= this.timeScale;
        for (var b = 0; b < this.tracks.length; b++) {
            var c = this.tracks[b];
            if (c) {
                var d = a * c.timeScale;
                c.time += d, c.previous && (c.previous.time += d, c.mixTime += d), (d = c.next) ? c.lastTime >= d.delay && this.setCurrent(b, d) : !c.loop && c.lastTime >= c.endTime && this.clearTrack(b)
            }
        }
    },
    apply: function(a) {
        for (var b = 0; b < this.tracks.length; b++) {
            var c = this.tracks[b];
            if (c) {
                this.events.length = 0;
                var d = c.time,
                    e = c.lastTime,
                    f = c.endTime,
                    g = c.loop;
                !g && d > f && (d = f);
                var h = c.previous;
                if (h) {
                    var i = h.time;
                    !h.loop && i > h.endTime && (i = h.endTime), h.animation.apply(a, i, i, h.loop, null), h = c.mixTime / c.mixDuration, h >= 1 && (h = 1, c.previous = null), c.animation.mix(a, c.lastTime, d, g, this.events, h)
                } else c.animation.apply(a, c.lastTime, d, g, this.events);
                for (h = 0, i = this.events.length; i > h; h++) {
                    var j = this.events[h];
                    null != c.onEvent && c.onEvent(b, j), null != this.onEvent && this.onEvent(b, j)
                }(g ? e % f > d % f : f > e && d >= f) && (d = Math.floor(d / f), c.onComplete && c.onComplete(b, d), this.onComplete && this.onComplete(b, d)), c.lastTime = c.time
            }
        }
    },
    clearTracks: function() {
        for (var a = 0, b = this.tracks.length; b > a; a++) this.clearTrack(a);
        this.tracks.length = 0
    },
    clearTrack: function(a) {
        if (!(a >= this.tracks.length)) {
            var b = this.tracks[a];
            b && (null != b.onEnd && b.onEnd(a), null != this.onEnd && this.onEnd(a), this.tracks[a] = null)
        }
    },
    _expandToIndex: function(a) {
        if (a < this.tracks.length) return this.tracks[a];
        for (; a >= this.tracks.length;) this.tracks.push(null);
        return null
    },
    setCurrent: function(a, b) {
        var c = this._expandToIndex(a);
        if (c) {
            var d = c.previous;
            c.previous = null, null != c.onEnd && c.onEnd(a), null != this.onEnd && this.onEnd(a), b.mixDuration = this.data.getMix(c.animation, b.animation), 0 < b.mixDuration && (b.mixTime = 0, b.previous = d && .5 > c.mixTime / c.mixDuration ? d : c)
        }
        this.tracks[a] = b, null != b.onStart && b.onStart(a), null != this.onStart && this.onStart(a)
    },
    setAnimationByName: function(a, b, c) {
        var d = this.data.skeletonData.findAnimation(b);
        if (!d) throw "Animation not found: " + b;
        return this.setAnimation(a, d, c)
    },
    setAnimation: function(a, b, c) {
        var d = new spine.TrackEntry;
        return d.animation = b, d.loop = c, d.endTime = b.duration, this.setCurrent(a, d), d
    },
    addAnimationByName: function(a, b, c, d) {
        var e = this.data.skeletonData.findAnimation(b);
        if (!e) throw "Animation not found: " + b;
        return this.addAnimation(a, e, c, d)
    },
    addAnimation: function(a, b, c, d) {
        var e = new spine.TrackEntry;
        if (e.animation = b, e.loop = c, e.endTime = b.duration, c = this._expandToIndex(a)) {
            for (; c.next;) c = c.next;
            c.next = e
        } else this.tracks[a] = e;
        return 0 >= d && (d = c ? d + (c.endTime - this.data.getMix(c.animation, b)) : 0), e.delay = d, e
    },
    getCurrent: function(a) {
        return a >= this.tracks.length ? null : this.tracks[a]
    }
}, spine.SkeletonJson = function(a) {
    this.attachmentLoader = a
}, spine.SkeletonJson.prototype = {
    scale: 1,
    readSkeletonData: function(a) {
        for (var b = new spine.SkeletonData, c = a.bones, d = 0, e = c.length; e > d; d++) {
            var f = c[d],
                g = null;
            if (f.parent && (g = b.findBone(f.parent), !g)) throw "Parent bone not found: " + f.parent;
            g = new spine.BoneData(f.name, g), g.length = (f.length || 0) * this.scale, g.x = (f.x || 0) * this.scale, g.y = (f.y || 0) * this.scale, g.rotation = f.rotation || 0, g.scaleX = f.scaleX || 1, g.scaleY = f.scaleY || 1, g.inheritScale = !f.inheritScale || "true" == f.inheritScale, g.inheritRotation = !f.inheritRotation || "true" == f.inheritRotation, b.bones.push(g)
        }
        for (c = a.slots, d = 0, e = c.length; e > d; d++) {
            if (f = c[d], g = b.findBone(f.bone), !g) throw "Slot bone not found: " + f.bone;
            var g = new spine.SlotData(f.name, g),
                h = f.color;
            h && (g.r = spine.SkeletonJson.toColor(h, 0), g.g = spine.SkeletonJson.toColor(h, 1), g.b = spine.SkeletonJson.toColor(h, 2), g.a = spine.SkeletonJson.toColor(h, 3)), g.attachmentName = f.attachment, g.additiveBlending = f.additive && "true" == f.additive, b.slots.push(g)
        }
        var i, d = a.skins;
        for (i in d)
            if (d.hasOwnProperty(i)) {
                var j, e = d[i],
                    g = new spine.Skin(i);
                for (j in e)
                    if (e.hasOwnProperty(j)) {
                        var k, c = b.findSlotIndex(j),
                            f = e[j];
                        for (k in f) f.hasOwnProperty(k) && (h = this.readAttachment(g, k, f[k]), null != h && g.addAttachment(c, k, h))
                    }
                b.skins.push(g), "default" == g.name && (b.defaultSkin = g)
            }
        i = a.events;
        for (var l in i) i.hasOwnProperty(l) && (j = i[l], k = new spine.EventData(l), k.intValue = j["int"] || 0, k.floatValue = j["float"] || 0, k.stringValue = j.string || null, b.events.push(k));
        a = a.animations;
        for (var m in a) a.hasOwnProperty(m) && this.readAnimation(m, a[m], b);
        return b
    },
    readAttachment: function(a, b, c) {
        b = c.name || b;
        var d = spine.AttachmentType[c.type || "region"];
        if (a = this.attachmentLoader.newAttachment(a, d, b), d == spine.AttachmentType.region) a.x = (c.x || 0) * this.scale, a.y = (c.y || 0) * this.scale, a.scaleX = c.scaleX || 1, a.scaleY = c.scaleY || 1, a.rotation = c.rotation || 0, a.width = (c.width || 32) * this.scale, a.height = (c.height || 32) * this.scale, a.updateOffset();
        else if (d == spine.AttachmentType.boundingBox)
            for (c = c.vertices, d = 0, b = c.length; b > d; d++) a.vertices.push(c[d] * this.scale);
        return a
    },
    readAnimation: function(a, b, c) {
        var d, e = [],
            f = 0,
            g = b.bones;
        for (d in g)
            if (g.hasOwnProperty(d)) {
                var h = c.findBoneIndex(d);
                if (-1 == h) throw "Bone not found: " + d;
                var i, j = g[d];
                for (i in j)
                    if (j.hasOwnProperty(i)) {
                        var k = j[i];
                        if ("rotate" == i) {
                            var l = new spine.RotateTimeline(k.length);
                            l.boneIndex = h;
                            for (var m = 0, n = 0, o = k.length; o > n; n++) {
                                var p = k[n];
                                l.setFrame(m, p.time, p.angle), spine.SkeletonJson.readCurve(l, m, p), m++
                            }
                            e.push(l), f = Math.max(f, l.frames[2 * l.getFrameCount() - 2])
                        } else {
                            if ("translate" != i && "scale" != i) throw "Invalid timeline type for a bone: " + i + " (" + d + ")";
                            var q = 1;
                            for ("scale" == i ? l = new spine.ScaleTimeline(k.length) : (l = new spine.TranslateTimeline(k.length), q = this.scale), l.boneIndex = h, n = m = 0, o = k.length; o > n; n++) p = k[n], l.setFrame(m, p.time, (p.x || 0) * q, (p.y || 0) * q), spine.SkeletonJson.readCurve(l, m, p), m++;
                            e.push(l), f = Math.max(f, l.frames[3 * l.getFrameCount() - 3])
                        }
                    }
            }
        d = b.slots;
        for (var r in d)
            if (d.hasOwnProperty(r))
                for (i in h = d[r], g = c.findSlotIndex(r), h)
                    if (h.hasOwnProperty(i))
                        if (k = h[i], "color" == i) {
                            for (l = new spine.ColorTimeline(k.length), l.slotIndex = g, n = m = 0, o = k.length; o > n; n++) {
                                var p = k[n],
                                    s = p.color,
                                    j = spine.SkeletonJson.toColor(s, 0),
                                    q = spine.SkeletonJson.toColor(s, 1),
                                    t = spine.SkeletonJson.toColor(s, 2),
                                    s = spine.SkeletonJson.toColor(s, 3);
                                l.setFrame(m, p.time, j, q, t, s), spine.SkeletonJson.readCurve(l, m, p), m++
                            }
                            e.push(l), f = Math.max(f, l.frames[5 * l.getFrameCount() - 5])
                        } else {
                            if ("attachment" != i) throw "Invalid timeline type for a slot: " + i + " (" + r + ")";
                            for (l = new spine.AttachmentTimeline(k.length), l.slotIndex = g, n = m = 0, o = k.length; o > n; n++) p = k[n], l.setFrame(m++, p.time, p.name);
                            e.push(l), f = Math.max(f, l.frames[l.getFrameCount() - 1])
                        }
        if (g = b.events) {
            for (l = new spine.EventTimeline(g.length), n = m = 0, o = g.length; o > n; n++) {
                if (i = g[n], k = c.findEvent(i.name), !k) throw "Event not found: " + i.name;
                p = new spine.Event(k), p.intValue = i.hasOwnProperty("int") ? i["int"] : k.intValue, p.floatValue = i.hasOwnProperty("float") ? i["float"] : k.floatValue, p.stringValue = i.hasOwnProperty("string") ? i.string : k.stringValue, l.setFrame(m++, i.time, p)
            }
            e.push(l), f = Math.max(f, l.frames[l.getFrameCount() - 1])
        }
        if (b = b.draworder) {
            for (l = new spine.DrawOrderTimeline(b.length), i = c.slots.length, n = m = 0, o = b.length; o > n; n++) {
                if (k = b[n], p = null, k.offsets) {
                    for (p = [], p.length = i, r = i - 1; r >= 0; r--) p[r] = -1;
                    for (d = k.offsets, h = [], h.length = i - d.length, r = q = j = 0, t = d.length; t > r; r++) {
                        if (s = d[r], g = c.findSlotIndex(s.slot), -1 == g) throw "Slot not found: " + s.slot;
                        for (; j != g;) h[q++] = j++;
                        p[j + s.offset] = j++
                    }
                    for (; i > j;) h[q++] = j++;
                    for (r = i - 1; r >= 0; r--) - 1 == p[r] && (p[r] = h[--q])
                }
                l.setFrame(m++, k.time, p)
            }
            e.push(l), f = Math.max(f, l.frames[l.getFrameCount() - 1])
        }
        c.animations.push(new spine.Animation(a, e, f))
    }
}, spine.SkeletonJson.readCurve = function(a, b, c) {
    (c = c.curve) && ("stepped" == c ? a.curves.setStepped(b) : c instanceof Array && a.curves.setCurve(b, c[0], c[1], c[2], c[3]))
}, spine.SkeletonJson.toColor = function(a, b) {
    if (8 != a.length) throw "Color hexidecimal length must be 8, recieved: " + a;
    return parseInt(a.substring(2 * b, 2 * b + 2), 16) / 255
}, spine.Atlas = function(a, b) {
    this.textureLoader = b, this.pages = [], this.regions = [];
    var c = new spine.AtlasReader(a),
        d = [];
    d.length = 4;
    for (var e = null;;) {
        var f = c.readLine();
        if (null == f) break;
        if (f = c.trim(f), 0 == f.length) e = null;
        else if (e) {
            var g = new spine.AtlasRegion;
            g.name = f, g.page = e, g.rotate = "true" == c.readValue(), c.readTuple(d);
            var f = parseInt(d[0]),
                h = parseInt(d[1]);
            c.readTuple(d);
            var i = parseInt(d[0]),
                j = parseInt(d[1]);
            g.u = f / e.width, g.v = h / e.height, g.rotate ? (g.u2 = (f + j) / e.width, g.v2 = (h + i) / e.height) : (g.u2 = (f + i) / e.width, g.v2 = (h + j) / e.height), g.x = f, g.y = h, g.width = Math.abs(i), g.height = Math.abs(j), 4 == c.readTuple(d) && (g.splits = [parseInt(d[0]), parseInt(d[1]), parseInt(d[2]), parseInt(d[3])], 4 == c.readTuple(d) && (g.pads = [parseInt(d[0]), parseInt(d[1]), parseInt(d[2]), parseInt(d[3])], c.readTuple(d))), g.originalWidth = parseInt(d[0]), g.originalHeight = parseInt(d[1]), c.readTuple(d), g.offsetX = parseInt(d[0]), g.offsetY = parseInt(d[1]), g.index = parseInt(c.readValue()), this.regions.push(g)
        } else e = new spine.AtlasPage, e.name = f, e.format = spine.Atlas.Format[c.readValue()], c.readTuple(d), e.minFilter = spine.Atlas.TextureFilter[d[0]], e.magFilter = spine.Atlas.TextureFilter[d[1]], g = c.readValue(), e.uWrap = spine.Atlas.TextureWrap.clampToEdge, e.vWrap = spine.Atlas.TextureWrap.clampToEdge, "x" == g ? e.uWrap = spine.Atlas.TextureWrap.repeat : "y" == g ? e.vWrap = spine.Atlas.TextureWrap.repeat : "xy" == g && (e.uWrap = e.vWrap = spine.Atlas.TextureWrap.repeat), b.load(e, f, this), this.pages.push(e)
    }
}, spine.Atlas.prototype = {
    findRegion: function(a) {
        for (var b = this.regions, c = 0, d = b.length; d > c; c++)
            if (b[c].name == a) return b[c];
        return null
    },
    dispose: function() {
        for (var a = this.pages, b = 0, c = a.length; c > b; b++) this.textureLoader.unload(a[b].rendererObject)
    },
    updateUVs: function(a) {
        for (var b = this.regions, c = 0, d = b.length; d > c; c++) {
            var e = b[c];
            e.page == a && (e.u = e.x / a.width, e.v = e.y / a.height, e.rotate ? (e.u2 = (e.x + e.height) / a.width, e.v2 = (e.y + e.width) / a.height) : (e.u2 = (e.x + e.width) / a.width, e.v2 = (e.y + e.height) / a.height))
        }
    }
}, spine.Atlas.Format = {
    Alpha: 0,
    Intensity: 1,
    LuminanceAlpha: 2,
    RGB565: 3,
    RGBA4444: 4,
    RGB888: 5,
    RGBA8888: 6
}, spine.Atlas.TextureFilter = {
    Nearest: 0,
    Linear: 1,
    MipMap: 2,
    MipMapNearestNearest: 3,
    MipMapLinearNearest: 4,
    MipMapNearestLinear: 5,
    MipMapLinearLinear: 6
}, spine.Atlas.TextureWrap = {
    mirroredRepeat: 0,
    clampToEdge: 1,
    repeat: 2
}, spine.AtlasPage = function() {}, spine.AtlasPage.prototype = {
    name: null,
    format: null,
    minFilter: null,
    magFilter: null,
    uWrap: null,
    vWrap: null,
    rendererObject: null,
    width: 0,
    height: 0
}, spine.AtlasRegion = function() {}, spine.AtlasRegion.prototype = {
    page: null,
    name: null,
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    u: 0,
    v: 0,
    u2: 0,
    v2: 0,
    offsetX: 0,
    offsetY: 0,
    originalWidth: 0,
    originalHeight: 0,
    index: 0,
    rotate: !1,
    splits: null,
    pads: null
}, spine.AtlasReader = function(a) {
    this.lines = a.split(/\r\n|\r|\n/)
}, spine.AtlasReader.prototype = {
    index: 0,
    trim: function(a) {
        return a.replace(/^\s+|\s+$/g, "")
    },
    readLine: function() {
        return this.index >= this.lines.length ? null : this.lines[this.index++]
    },
    readValue: function() {
        var a = this.readLine(),
            b = a.indexOf(":");
        if (-1 == b) throw "Invalid line: " + a;
        return this.trim(a.substring(b + 1))
    },
    readTuple: function(a) {
        var b = this.readLine(),
            c = b.indexOf(":");
        if (-1 == c) throw "Invalid line: " + b;
        for (var d = 0, c = c + 1; 3 > d; d++) {
            var e = b.indexOf(",", c);
            if (-1 == e) {
                if (0 == d) throw "Invalid line: " + b;
                break
            }
            a[d] = this.trim(b.substr(c, e - c)), c = e + 1
        }
        return a[d] = this.trim(b.substring(c)), d + 1
    }
}, spine.AtlasAttachmentLoader = function(a) {
    this.atlas = a
}, spine.AtlasAttachmentLoader.prototype = {
    newAttachment: function(a, b, c) {
        switch (b) {
            case spine.AttachmentType.boundingbox:
                return new spine.BoundingBoxAttachment(c);
            case spine.AttachmentType.region:
                if (a = this.atlas.findRegion(c), !a) throw "Region not found in atlas: " + c + " (" + b + ")";
                return b = new spine.RegionAttachment(c), b.rendererObject = a, b.setUVs(a.u, a.v, a.u2, a.v2, a.rotate), b.regionOffsetX = a.offsetX, b.regionOffsetY = a.offsetY, b.regionWidth = a.width, b.regionHeight = a.height, b.regionOriginalWidth = a.originalWidth, b.regionOriginalHeight = a.originalHeight, b
        }
        throw "Unknown attachment type: " + b
    }
}, spine.SkeletonBounds = function() {
    this.polygonPool = [], this.polygons = [], this.boundingBoxes = []
}, spine.SkeletonBounds.prototype = {
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0,
    update: function(a, b) {
        for (var c = a.slots, d = c.length, e = a.x, f = a.y, g = this.boundingBoxes, h = this.polygonPool, i = this.polygons, j = g.length = 0, k = i.length; k > j; j++) h.push(i[j]);
        for (j = i.length = 0; d > j; j++) {
            var k = c[j],
                l = k.attachment;
            if (l.type == spine.AttachmentType.boundingBox) {
                g.push(l);
                var m, n = h.length;
                n > 0 ? (m = h[n - 1], h.splice(n - 1, 1)) : m = [], i.push(m), m.length = l.vertices.length, l.computeWorldVertices(e, f, k.bone, m)
            }
        }
        b && this.aabbCompute()
    },
    aabbCompute: function() {
        for (var a = this.polygons, b = Number.MAX_VALUE, c = Number.MAX_VALUE, d = Number.MIN_VALUE, e = Number.MIN_VALUE, f = 0, g = a.length; g > f; f++)
            for (var h = a[f], i = 0, j = h.length; j > i; i += 2) var k = h[i],
        l = h[i + 1], b = Math.min(b, k), c = Math.min(c, l), d = Math.max(d, k), e = Math.max(e, l);
        this.minX = b, this.minY = c, this.maxX = d, this.maxY = e
    },
    aabbContainsPoint: function(a, b) {
        return a >= this.minX && a <= this.maxX && b >= this.minY && b <= this.maxY
    },
    aabbIntersectsSegment: function(a, b, c, d) {
        var e = this.minX,
            f = this.minY,
            g = this.maxX,
            h = this.maxY;
        return e >= a && e >= c || f >= b && f >= d || a >= g && c >= g || b >= h && d >= h ? !1 : (c = (d - b) / (c - a), d = c * (e - a) + b, d > f && h > d ? !0 : (d = c * (g - a) + b, d > f && h > d ? !0 : (f = (f - b) / c + a, f > e && g > f ? !0 : (f = (h - b) / c + a, f > e && g > f ? !0 : !1))))
    },
    aabbIntersectsSkeleton: function(a) {
        return this.minX < a.maxX && this.maxX > a.minX && this.minY < a.maxY && this.maxY > a.minY
    },
    containsPoint: function(a, b) {
        for (var c = this.polygons, d = 0, e = c.length; e > d; d++)
            if (this.polygonContainsPoint(c[d], a, b)) return this.boundingBoxes[d];
        return null
    },
    intersectsSegment: function(a, b, c, d) {
        for (var e = this.polygons, f = 0, g = e.length; g > f; f++)
            if (e[f].intersectsSegment(a, b, c, d)) return this.boundingBoxes[f];
        return null
    },
    polygonContainsPoint: function(a, b, c) {
        for (var d = a.length, e = d - 2, f = !1, g = 0; d > g; g += 2) {
            var h = a[g + 1],
                i = a[e + 1];
            if (c > h && i >= c || c > i && h >= c) {
                var j = a[g];
                j + (c - h) / (i - h) * (a[e] - j) < b && (f = !f)
            }
            e = g
        }
        return f
    },
    intersectsSegment: function(a, b, c, d, e) {
        for (var f = a.length, g = b - d, h = c - e, i = b * e - c * d, j = a[f - 2], k = a[f - 1], l = 0; f > l; l += 2) {
            var m = a[l],
                n = a[l + 1],
                o = j * n - k * m,
                p = j - m,
                q = k - n,
                r = g * q - h * p,
                p = (i * p - g * o) / r;
            if ((p >= j && m >= p || p >= m && j >= p) && (p >= b && d >= p || p >= d && b >= p) && (j = (i * q - h * o) / r, (j >= k && n >= j || j >= n && k >= j) && (j >= c && e >= j || j >= e && c >= j))) return !0;
            j = m, k = n
        }
        return !1
    },
    getPolygon: function(a) {
        return a = this.boundingBoxes.indexOf(a), -1 == a ? null : this.polygons[a]
    },
    getWidth: function() {
        return this.maxX - this.minX
    },
    getHeight: function() {
        return this.maxY - this.minY
    }
};
var sp = sp || {};
sp.VERTEX_INDEX = {
    X1: 0,
    Y1: 1,
    X2: 2,
    Y2: 3,
    X3: 4,
    Y3: 5,
    X4: 6,
    Y4: 7
}, sp.ATTACHMENT_TYPE = {
    REGION: 0,
    BOUNDING_BOX: 1,
    REGION_SEQUENCE: 2
}, sp.Skeleton = cc.Node.extend({
    _skeleton: null,
    _rootBone: null,
    _timeScale: 1,
    _debugSlots: !1,
    _debugBones: !1,
    _premultipliedAlpha: !1,
    _ownsSkeletonData: null,
    _atlas: null,
    _blendFunc: null,
    ctor: function(a, b, c) {
        cc.Node.prototype.ctor.call(this), this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        }, 0 === arguments.length ? this.init() : this.initWithArgs(a, b, c)
    },
    init: function() {
        cc.Node.prototype.init.call(this), this.setOpacityModifyRGB(!0), this._blendFunc.src = cc.ONE, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA, cc._renderType === cc._RENDER_TYPE_WEBGL && this.setShaderProgram(cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)), this.scheduleUpdate()
    },
    setDebugSolots: function(a) {
        this._debugSlots = a
    },
    setDebugBones: function(a) {
        this._debugBones = a
    },
    setTimeScale: function(a) {
        this._timeScale = a
    },
    initWithArgs: function(a, b, c) {
        if ("string" == typeof a) {
            if ("string" == typeof b) {
                var d = cc.loader.getRes(b);
                sp._atlasLoader.setAtlasFile(b), b = new spine.Atlas(d, sp._atlasLoader)
            }
            c = c || 1 / cc.director.getContentScaleFactor(), d = new spine.AtlasAttachmentLoader(b), d = new spine.SkeletonJson(d), d.scale = c, a = cc.loader.getRes(a), a = d.readSkeletonData(a), b.dispose(d), c = !0
        } else c = b;
        this.setSkeletonData(a, c), this.init()
    },
    boundingBox: function() {
        for (var a = cc.FLT_MAX, b = cc.FLT_MAX, c = cc.FLT_MIN, d = cc.FLT_MIN, e = this.getScaleX(), f = this.getScaleY(), g = [], h = this._skeleton.slots, i = sp.VERTEX_INDEX, j = 0, k = h.length; k > j; ++j) {
            var l = h[j];
            l.attachment && l.attachment.type == sp.ATTACHMENT_TYPE.REGION && (sp._regionAttachment_computeWorldVertices(l.attachment, l.skeleton.x, l.skeleton.y, l.bone, g), a = Math.min(a, g[i.X1] * e, g[i.X4] * e, g[i.X2] * e, g[i.X3] * e), b = Math.min(b, g[i.Y1] * f, g[i.Y4] * f, g[i.Y2] * f, g[i.Y3] * f), c = Math.max(c, g[i.X1] * e, g[i.X4] * e, g[i.X2] * e, g[i.X3] * e), d = Math.max(d, g[i.Y1] * f, g[i.Y4] * f, g[i.Y2] * f, g[i.Y3] * f))
        }
        return e = this.getPosition(), cc.rect(e.x + a, e.y + b, c - a, d - b)
    },
    updateWorldTransform: function() {
        this._skeleton.updateWorldTransform()
    },
    setToSetupPose: function() {
        this._skeleton.setToSetupPose()
    },
    setBonesToSetupPose: function() {
        this._skeleton.setBonesToSetupPose()
    },
    setSlotsToSetupPose: function() {
        this._skeleton.setSlotsToSetupPose()
    },
    findBone: function(a) {
        return this._skeleton.findBone(a)
    },
    findSlot: function(a) {
        return this._skeleton.findSlot(a)
    },
    setSkin: function(a) {
        return this._skeleton.setSkinByName(a)
    },
    getAttachment: function(a, b) {
        return this._skeleton.getAttachmentBySlotName(a, b)
    },
    setAttachment: function(a, b) {
        this._skeleton.setAttachment(a, b)
    },
    setOpacityModifyRGB: function(a) {
        this._premultipliedAlpha = a
    },
    isOpacityModifyRGB: function() {
        return this._premultipliedAlpha
    },
    setSkeletonData: function(a, b) {
        if (this._skeleton = new spine.Skeleton(a), this._rootBone = this._skeleton.getRootBone(), this._ownsSkeletonData = b, cc._renderType === cc._RENDER_TYPE_CANVAS)
            for (var c, d, e = this._skeleton, f = 0, g = e.drawOrder.length; g > f; f++) {
                var h = e.drawOrder[f];
                c = h.attachment, c instanceof spine.RegionAttachment && (c = c.rendererObject, d = cc.rect(c.x, c.y, c.width, c.height), c = cc.Sprite.create(c.page._texture, d, c.rotate), this.addChild(c, -1), h.currentSprite = c)
            }
    },
    getTextureAtlas: function(a) {
        return a.rendererObject.page.rendererObject
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        var c = this._blendFunc;
        void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b)
    },
    update: function(a) {
        if (this._skeleton.update(a), cc._renderType === cc._RENDER_TYPE_CANVAS) {
            this._skeleton.updateWorldTransform(), a = this._skeleton.drawOrder;
            for (var b = 0, c = a.length; c > b; b++) {
                var d = a[b],
                    e = d.attachment,
                    f = d.currentSprite;
                if (e instanceof spine.RegionAttachment) {
                    if (!f) {
                        var g = e.rendererObject,
                            h = cc.rect(g.x, g.y, g.width, g.height),
                            g = cc.Sprite.create(g.page._texture, h, g.rotate);
                        this.addChild(g, -1), d.currentSprite = g
                    }
                    f.setVisible(!0), f.setBlendFunc(cc.BLEND_SRC, d.data.additiveBlending ? cc.ONE : cc.BLEND_DST), g = d.bone, f.setPosition(g.worldX + e.x * g.m00 + e.y * g.m01, g.worldY + e.x * g.m10 + e.y * g.m11), f.setScale(g.worldScaleX, g.worldScaleY), f.setRotation(-(d.bone.worldRotation + e.rotation))
                } else f && f.setVisible(!1)
            }
        }
    },
    draw: null,
    _drawForWebGL: function() {
        cc.nodeDrawSetup(this);
        var a = this.getColor(),
            b = this._skeleton;
        b.r = a.r / 255, b.g = a.g / 255, b.b = a.b / 255, b.a = this.getOpacity() / 255, this._premultipliedAlpha && (b.r *= b.a, b.g *= b.a, b.b *= b.a);
        var c, d, e, f, g, h = new cc.V3F_C4B_T2F_Quad,
            i = this._blendFunc,
            a = 0;
        for (g = b.slots.length; g > a; a++)
            if (f = b.drawOrder[a], f.attachment && f.attachment.type == sp.ATTACHMENT_TYPE.REGION) {
                e = f.attachment;
                var j = this.getTextureAtlas(e);
                if (f.data.additiveBlending != c ? (d && (d.drawQuads(), d.removeAllQuads()), c = !c, cc.glBlendFunc(i.src, c ? cc.ONE : i.dst)) : j != d && d && (d.drawQuads(), d.removeAllQuads()), d = j, j = d.getTotalQuads(), d.getCapacity() == j && (d.drawQuads(), d.removeAllQuads(), !d.resizeCapacity(2 * d.getCapacity()))) return;
                sp._regionAttachment_updateQuad(e, f, h, this._premultipliedAlpha), d.updateQuad(h, j)
            }
        if (d && (d.drawQuads(), d.removeAllQuads()), c = cc._drawingUtil, this._debugSlots)
            for (c.setDrawColor(0, 0, 255, 255), c.setLineWidth(1), a = 0, g = b.slots.length; g > a; a++) f = b.drawOrder[a], f.attachment && f.attachment.type == sp.ATTACHMENT_TYPE.REGION && (e = f.attachment, h = new cc.V3F_C4B_T2F_Quad, sp._regionAttachment_updateQuad(e, f, h), d = [], d.push(cc.p(h.bl.vertices.x, h.bl.vertices.y)), d.push(cc.p(h.br.vertices.x, h.br.vertices.y)), d.push(cc.p(h.tr.vertices.x, h.tr.vertices.y)), d.push(cc.p(h.tl.vertices.x, h.tl.vertices.y)), c.drawPoly(d, 4, !0));
        if (this._debugBones) {
            for (c.setLineWidth(2), c.setDrawColor(255, 0, 0, 255), a = 0, g = b.bones.length; g > a; a++) h = b.bones[a], d = h.data.length * h.m00 + h.worldX, e = h.data.length * h.m10 + h.worldY, c.drawLine(cc.p(h.worldX, h.worldY), cc.p(d, e));
            for (c.setPointSize(4), c.setDrawColor(0, 0, 255, 255), a = 0, g = b.bones.length; g > a; a++) h = b.bones[a], c.drawPoint(cc.p(h.worldX, h.worldY)), 0 == a && c.setDrawColor(0, 255, 0, 255)
        }
    },
    _drawForCanvas: function() {
        if (this._debugSlots || this._debugBones) {
            var a, b, c, d, e = this._skeleton,
                f = cc._drawingUtil;
            if (this._debugSlots) {
                f.setDrawColor(0, 0, 255, 255), f.setLineWidth(1);
                var g = [];
                for (c = 0, d = e.slots.length; d > c; c++) b = e.drawOrder[c], b.attachment && b.attachment.type == sp.ATTACHMENT_TYPE.REGION && (a = b.attachment, sp._regionAttachment_updateSlotForCanvas(a, b, g), f.drawPoly(g, 4, !0))
            }
            if (this._debugBones) {
                for (f.setLineWidth(2), f.setDrawColor(255, 0, 0, 255), c = 0, d = e.bones.length; d > c; c++) a = e.bones[c], b = a.data.length * a.m00 + a.worldX, g = a.data.length * a.m10 + a.worldY, f.drawLine(cc.p(a.worldX, a.worldY), cc.p(b, g));
                for (f.setPointSize(4), f.setDrawColor(0, 0, 255, 255), c = 0, d = e.bones.length; d > c; c++) a = e.bones[c], f.drawPoint(cc.p(a.worldX, a.worldY)), 0 === c && f.setDrawColor(0, 255, 0, 255)
            }
        }
    }
}), sp.Skeleton.prototype.draw = cc._renderType === cc._RENDER_TYPE_WEBGL ? sp.Skeleton.prototype._drawForWebGL : sp.Skeleton.prototype._drawForCanvas, sp.Skeleton.create = function(a, b, c) {
    return new sp.Skeleton(a, b, c)
}, sp._atlasPage_createTexture_webGL = function(a, b) {
    var c = cc.textureCache.addImage(b);
    a.rendererObject = cc.TextureAtlas.create(c, 128), a.width = c.getPixelsWide(), a.height = c.getPixelsHigh()
}, sp._atlasPage_createTexture_canvas = function(a, b) {
    a._texture = cc.textureCache.addImage(b)
}, sp._atlasPage_disposeTexture = function(a) {
    a.rendererObject.release()
}, sp._atlasLoader = {
    spAtlasFile: null,
    setAtlasFile: function(a) {
        this.spAtlasFile = a
    },
    load: function(a, b) {
        b = cc.path.join(cc.path.dirname(this.spAtlasFile), b), cc._renderType === cc._RENDER_TYPE_WEBGL ? sp._atlasPage_createTexture_webGL(a, b) : sp._atlasPage_createTexture_canvas(a, b)
    },
    unload: function() {}
}, sp._regionAttachment_computeWorldVertices = function(a, b, c, d, e) {
    a = a.offset, b += d.worldX, c += d.worldY;
    var f = sp.VERTEX_INDEX;
    e[f.X1] = a[f.X1] * d.m00 + a[f.Y1] * d.m01 + b, e[f.Y1] = a[f.X1] * d.m10 + a[f.Y1] * d.m11 + c, e[f.X2] = a[f.X2] * d.m00 + a[f.Y2] * d.m01 + b, e[f.Y2] = a[f.X2] * d.m10 + a[f.Y2] * d.m11 + c, e[f.X3] = a[f.X3] * d.m00 + a[f.Y3] * d.m01 + b, e[f.Y3] = a[f.X3] * d.m10 + a[f.Y3] * d.m11 + c, e[f.X4] = a[f.X4] * d.m00 + a[f.Y4] * d.m01 + b, e[f.Y4] = a[f.X4] * d.m10 + a[f.Y4] * d.m11 + c
}, sp._regionAttachment_updateQuad = function(a, b, c, d) {
    var e = {};
    a.computeVertices(b.skeleton.x, b.skeleton.y, b.bone, e);
    var f = 255 * b.skeleton.r * b.r,
        g = 255 * b.skeleton.g * b.g,
        h = 255 * b.skeleton.b * b.b;
    b = b.skeleton.a * b.a, d && (f *= b, g *= b, h *= b), c.bl.colors.r = c.tl.colors.r = c.tr.colors.r = c.br.colors.r = f, c.bl.colors.g = c.tl.colors.g = c.tr.colors.g = c.br.colors.g = g, c.bl.colors.b = c.tl.colors.b = c.tr.colors.b = c.br.colors.b = h, c.bl.colors.a = c.tl.colors.a = c.tr.colors.a = c.br.colors.a = 255 * b, d = sp.VERTEX_INDEX, c.bl.vertices.x = e[d.X1], c.bl.vertices.y = e[d.Y1], c.tl.vertices.x = e[d.X2], c.tl.vertices.y = e[d.Y2], c.tr.vertices.x = e[d.X3], c.tr.vertices.y = e[d.Y3], c.br.vertices.x = e[d.X4], c.br.vertices.y = e[d.Y4], c.bl.texCoords.u = a.uvs[d.X1], c.bl.texCoords.v = a.uvs[d.Y1], c.tl.texCoords.u = a.uvs[d.X2], c.tl.texCoords.v = a.uvs[d.Y2], c.tr.texCoords.u = a.uvs[d.X3], c.tr.texCoords.v = a.uvs[d.Y3], c.br.texCoords.u = a.uvs[d.X4], c.br.texCoords.v = a.uvs[d.Y4]
}, sp._regionAttachment_updateSlotForCanvas = function(a, b, c) {
    if (c) {
        var d = {};
        a.computeVertices(b.skeleton.x, b.skeleton.y, b.bone, d), a = sp.VERTEX_INDEX, c.length = 0, c.push(cc.p(d[a.X1], d[a.Y1])), c.push(cc.p(d[a.X4], d[a.Y4])), c.push(cc.p(d[a.X3], d[a.Y3])), c.push(cc.p(d[a.X2], d[a.Y2]))
    }
}, sp.ANIMATION_EVENT_TYPE = {
    START: 0,
    END: 1,
    COMPLETE: 2,
    EVENT: 3
}, sp.SkeletonAnimation = sp.Skeleton.extend({
    _state: null,
    _target: null,
    _callback: null,
    init: function() {
        sp.Skeleton.prototype.init.call(this), this.setAnimationStateData(new spine.AnimationStateData(this._skeleton.data))
    },
    setAnimationStateData: function(a) {
        a = new spine.AnimationState(a), a.onStart = this._onAnimationStateStart.bind(this), a.onComplete = this._onAnimationStateComplete.bind(this), a.onEnd = this._onAnimationStateEnd.bind(this), a.onEvent = this._onAnimationStateEvent.bind(this), this._state = a
    },
    setMix: function(a, b, c) {
        this._state.data.setMixByName(a, b, c)
    },
    setAnimationListener: function(a, b) {
        this._target = a, this._callback = b
    },
    setAnimation: function(a, b, c) {
        var d = this._skeleton.data.findAnimation(b);
        return d ? this._state.setAnimation(a, d, c) : (cc.log("Spine: Animation not found: " + b), null)
    },
    addAnimation: function(a, b, c, d) {
        var e = this._skeleton.data.findAnimation(b);
        return e ? this._state.addAnimation(a, e, c, d) : (cc.log("Spine: Animation not found:" + b), null)
    },
    getCurrent: function(a) {
        return this._state.getCurrent(a)
    },
    clearTracks: function() {
        this._state.clearTracks()
    },
    clearTrack: function(a) {
        this._state.clearTrack(a)
    },
    update: function(a) {
        this._super(a), a *= this._timeScale, this._state.update(a), this._state.apply(this._skeleton), this._skeleton.updateWorldTransform()
    },
    _onAnimationStateStart: function(a) {
        this._animationStateCallback(a, sp.ANIMATION_EVENT_TYPE.START, null, 0)
    },
    _onAnimationStateEnd: function(a) {
        this._animationStateCallback(a, sp.ANIMATION_EVENT_TYPE.END, null, 0)
    },
    _onAnimationStateComplete: function(a, b) {
        this._animationStateCallback(a, sp.ANIMATION_EVENT_TYPE.COMPLETE, null, b)
    },
    _onAnimationStateEvent: function(a, b) {
        this._animationStateCallback(a, sp.ANIMATION_EVENT_TYPE.EVENT, b, 0)
    },
    _animationStateCallback: function(a, b, c, d) {
        this._target && this._callback && this._callback.call(this._target, this, a, b, c, d)
    }
}), sp.SkeletonAnimation.create = function(a, b, c) {
    return new sp.SkeletonAnimation(a, b, c)
}, cc.pool = {
    _pool: {},
    putInPool: function(a) {
        if (a instanceof cc.Node) {
            var b = a.constructor.prototype.__pid;
            if (!b) {
                var c = {
                    writable: !0,
                    enumerable: !1,
                    configurable: !0
                };
                c.value = ClassManager.getNewID(), Object.defineProperty(a.constructor.prototype, "__pid", c)
            }
            this._pool[b] || (this._pool[b] = []), a.unuse && a.unuse(), a.retain(), this._pool[b].push(a)
        }
    },
    hasObject: function(a) {
        return (a = this._pool[a.prototype.__pid]) && 0 < a.length
    },
    removeObject: function(a) {
        var b = a.constructor.prototype.__pid;
        if (b && (b = this._pool[b]))
            for (var c = 0; c < b.length; c++) a === b[c] && (a.release(), b.splice(c, 1))
    },
    getFromPool: function(a) {
        if (this.hasObject(a)) {
            var b = this._pool[a.prototype.__pid],
                c = Array.prototype.slice.call(arguments, 1),
                b = b.pop();
            return b.reuse && b.reuse.apply(b, c), b
        }
    },
    drainAllPools: function() {
        var a, b = this._pool;
        for (a in b)
            for (var c = 0; c < b[a].length; c++) {
                var d = b[a][c];
                d && d.release && d.release()
            }
        this._pool = {}
    }
};
var resDir = "res/",
    res = {
        mscNormal_mp3: resDir + "media/mscNormal.mp3",
        mscPower_mp3: resDir + "media/mscPower.mp3",
        sndAlert_mp3: resDir + "media/sndAlert.mp3",
        sndFail_mp3: resDir + "media/sndFail.mp3",
        sndOver_mp3: resDir + "media/sndOver.mp3",
        sndPowerSucc_mp3: resDir + "media/sndPowerSucc.mp3",
        sndReady_mp3: resDir + "media/sndReady.mp3",
        sndSucc1_mp3: resDir + "media/sndSucc1.mp3",
        sndSucc2_mp3: resDir + "media/sndSucc2.mp3",
        sndSucc3_mp3: resDir + "media/sndSucc3.mp3",
        sndSucc4_mp3: resDir + "media/sndSucc4.mp3",
        sndSucc5_mp3: resDir + "media/sndSucc5.mp3",
        sndSucc6_mp3: resDir + "media/sndSucc6.mp3",
        sndSucc7_mp3: resDir + "media/sndSucc7.mp3",
        sndSucc8_mp3: resDir + "media/sndSucc8.mp3",
        sndSucc9_mp3: resDir + "media/sndSucc9.mp3",
        sndSucc10_mp3: resDir + "media/sndSucc10.mp3",
        gameOverBg_jpg: resDir + "gameOverBg.jpg",
        logo_png: "logo.png",
        heart_png: resDir + "heart.png",
        loadingBar_png: resDir + "loadingBar.png",
        loadingProcess_png: resDir + "loadingProcess.png",
        aniCatch_ExportJson: resDir + "aniCatch.exportjson",
        aniCatch0_plist: resDir + "aniCatch0.plist",
        aniCatch0_png: resDir + "aniCatch0.png",
        aniPowerFrame_ExportJson: resDir + "aniPowerFrame.exportjson",
        aniPowerFrame0_plist: resDir + "aniPowerFrame0.plist",
        aniPowerFrame0_png: resDir + "aniPowerFrame0.png",
        aniSky_ExportJson: resDir + "aniSky.exportjson",
        aniSky0_plist: resDir + "aniSky0.plist",
        aniSky0_png: resDir + "aniSky0.png",
        game_ExportJson: resDir + "game.exportjson",
        gameOver_ExportJson: resDir + "gameOver.exportjson",
        gameUI0_plist: resDir + "gameUI0.plist",
        gameUI0_png: resDir + "gameUI0.png",
        objects_plist: resDir + "objects.plist",
        objects_png: resDir + "objects.png",
        score_png: resDir + "score.png",
        scoreSmall_png: resDir + "scoreSmall.png",
        terrain_plist: resDir + "terrain.plist",
        terrain_png: resDir + "terrain.png",
        title_ExportJson: resDir + "title.exportjson",
        titleBg_jpg: resDir + "titleBg.jpg"
    }, g_resources = [res.logo_png, res.mscNormal_mp3, res.mscPower_mp3, res.sndAlert_mp3, res.sndFail_mp3, res.sndOver_mp3, res.sndPowerSucc_mp3, res.sndReady_mp3, res.sndSucc1_mp3, res.sndSucc10_mp3, res.sndSucc2_mp3, res.sndSucc3_mp3, res.sndSucc4_mp3, res.sndSucc5_mp3, res.sndSucc6_mp3, res.sndSucc7_mp3, res.sndSucc8_mp3, res.sndSucc9_mp3, res.gameOverBg_jpg, res.heart_png, res.loadingBar_png, res.loadingProcess_png, res.aniCatch_ExportJson, res.aniCatch0_plist, res.aniCatch0_png, res.aniPowerFrame_ExportJson, res.aniPowerFrame0_plist, res.aniPowerFrame0_png, res.aniSky_ExportJson, res.aniSky0_plist, res.aniSky0_png, res.game_ExportJson, res.gameOver_ExportJson, res.gameUI0_plist, res.gameUI0_png, res.objects_plist, res.objects_png, res.score_png, res.scoreSmall_png, res.terrain_plist, res.terrain_png, res.title_ExportJson, res.titleBg_jpg],
    GameData = {
        score: 0,
        soundOpen: !0,
        gameTime: 60
    }, RoleManager = cc.Class.extend({
        DIR_LEFT: 0,
        DIR_RIGHT: 1,
        _roleQueue: null,
        ROLE_SIZE: 7,
        _rolePosYList: null,
        _roleLeader_Array: null,
        _roleLeaderData_Array: null,
        LEADER_LEFT_1: 0,
        LEADER_RIGHT_1: 1,
        LEADER_LEFT_2: 2,
        LEADER_RIGHT_2: 3,
        _leaderPos_Array: null,
        ROLE_LEADER_SIZE: 4,
        _roleLeaderShowLength: 2,
        _uiLayer: null,
        ROLE_LEADER_SCALE: .7,
        ctor: function(a) {
            this._uiLayer = a, this._roleQueue = [], this._rolePosYList = [];
            var b = 180;
            this._roleLeader_Array = Array(this.ROLE_LEADER_SIZE), this._roleLeaderData_Array = Array(this.ROLE_LEADER_SIZE), this._leaderPos_Array = Array(this.ROLE_LEADER_SIZE), this._leaderPos_Array[this.LEADER_LEFT_1] = cc.p(100, 450), this._leaderPos_Array[this.LEADER_RIGHT_1] = cc.p(cc.visibleRect.width - 100, 450), this._leaderPos_Array[this.LEADER_LEFT_2] = cc.p(100, 630), this._leaderPos_Array[this.LEADER_RIGHT_2] = cc.p(cc.visibleRect.width - 100, 630), b = 300, this._aniCatch = AniCatch.create(), this._aniCatch.x = cc.visibleRect.width >> 1, this._aniCatch.y = b, a.addChild(this._aniCatch, 11), this._starManager = StarManager.create(a);
            for (var c = 0; c < this.ROLE_SIZE; c++) {
                var d = RoleLeader.create();
                d.x = cc.visibleRect.width >> 1, this._roleQueue.push(d), a.addChild(d, 10), this._rolePosYList[c] = b, b += 90 * (1 - .1 * c)
            }
        },
        resetRoleLeader: function() {
            for (var a = this.shuffleArray(Role.data_Array), b = 0; b < this.ROLE_LEADER_SIZE; b++) {
                var c = this._roleLeader_Array[b];
                c ? c.initData(a[b]) : (c = RoleLeader.create(a[b]), this._roleLeader_Array[b] = c, this._uiLayer.addChild(c, 1 >= b ? 12 : 11)), c.scale = this.ROLE_LEADER_SCALE, b >= 2 && (c.scale = this.ROLE_LEADER_SCALE - .1), c.hide(), c.setDir(1 & b), c.setPosition(this._leaderPos_Array[b]), this._roleLeaderData_Array[b] = a[b]
            }
            for (this._roleLeaderShowLength = 2, b = 0; b < this._roleLeaderShowLength; b++) this._roleLeader_Array[b].show()
        },
        resetRoleQueue: function(a, b) {
            for (var c = 0; c < this.ROLE_SIZE; c++) {
                var d = this._roleQueue[c];
                if (d) {
                    if (a) {
                        var e = this.randomRange(0, this._roleLeaderShowLength);
                        d.initData(this._roleLeaderData_Array[e])
                    }
                    d.showNormalState(), d.setLocalZOrder(15 - c), d.stopAllActions(), b ? c == this.ROLE_SIZE - 1 ? (d.y = this._rolePosYList[c], d.scale = .9 - .1 * c) : (d.runAction(cc.moveTo(.1, d.x, this._rolePosYList[c])), d.runAction(cc.scaleTo(.1, .9 - .1 * c))) : (d.y = this._rolePosYList[c], d.scale = .9 - .1 * c)
                }
            }
            this._roleQueue[0].showSuccState()
        },
        dealTouchRoleQueue: function(a) {
            for (var b = this._roleQueue[0], c = !1, d = 0; d < this.ROLE_SIZE; d++) {
                var e = this._roleLeader_Array[d].checkWithRole(b, a);
                if (e >= 0) {
                    1 == e ? (this._uiLayer.addScore(10), this._uiLayer.addCombo(), this._uiLayer.addPower(8), this._aniCatch && this._aniCatch.show(), this._starManager.createStar(b.getPosition()), this._starManager.createStar(b.getPosition()), this._starManager.createStar(b.getPosition()), this._starManager.createStar(b.getPosition()), c = !0) : (this._uiLayer.resetCombo(), this._uiLayer.addPower(-15), b.showFailState(), b.runAction(cc.sequence(cc.moveBy(.05, -5, 0), cc.sequence(cc.moveBy(.05, 10, 0), cc.moveBy(.05, -10, 0)).repeat(6), cc.moveBy(.05, 5, 0))), c = !1);
                    break
                }
            }
            return c ? (b = this._roleQueue.shift(), a = this.randomRange(0, this._roleLeaderShowLength), b.initData(this._roleLeaderData_Array[a]), this._roleQueue.push(b), b.showNormalState(), this.resetRoleQueue(!1, !0)) : (this._uiLayer && this._uiLayer.canTouch(!1), this._uiLayer.runAction(cc.sequence(cc.delayTime(1), cc.callFunc(function() {
                b.showNormalState(), this._uiLayer && this._uiLayer.canTouch(!0)
            }, this)))), c
        },
        dealTouchEnded: function() {
            for (var a = 0; a < this._roleLeaderShowLength; a++) this._roleLeader_Array[a].showNormalState()
        },
        addRoleLeader: function() {
            this._roleLeader_Array[this._roleLeaderShowLength].show(), this._roleLeaderShowLength++
        },
        reset: function() {
            this.resetRoleLeader(), this.resetRoleQueue(!0, !1)
        },
        random: function(a) {
            return Math.floor(Math.random() * a)
        },
        randomRange: function(a, b) {
            return this.random(b - a) + a
        },
        shuffleArray: function(a) {
            if (!a || 0 == a.length) return a;
            for (var b = 0, c = 0, d = a.length; d > c; c++) {
                for (; b = this.randomRange(0, d), !(b != c););
                var e = a[c];
                a[c] = a[b], a[b] = e
            }
            return a
        }
    });
RoleManager.create = function(a) {
    return new RoleManager(a)
};
var StarManager = cc.Class.extend({
    DEFAULT_STAR_SIZE: 30,
    _starQueue: null,
    ctor: function(a) {
        this._uiLayer = a, this._starQueue = [];
        for (var b = 0; b < this.DEFAULT_STAR_SIZE; b++) {
            var c = cc.Sprite.create("#starLeft.png");
            this._starQueue.push(c), c.setVisible(!1), a.addChild(c, 10)
        }
    },
    createStar: function(a) {
        if (!(0 > this._starQueue.length)) {
            var b = this.randomRange(0, 2),
                c = this.randomRange(1, 2),
                d = this.randomRange(50, 200),
                e = this.randomRange(100, 200);
            0 == b && (e = -e);
            var b = this.randomRange(-50, 50),
                f = this.randomRange(-50, 50),
                c = 1,
                g = this._starQueue.shift();
            g.setVisible(!0), g.x = a.x + b, g.y = a.y + f, g.runAction(cc.scaleTo(c, .5, .5)), g.runAction(cc.fadeOut(c)), g.runAction(cc.sequence(cc.jumpBy(c, e, 0, d, 1), cc.callFunc(function() {
                g.setVisible(!1), g.runAction(cc.fadeIn(1e-4)), g.runAction(cc.scaleTo(1e-4, 1, 1)), this._starQueue.push(g)
            }, this)))
        }
    },
    random: function(a) {
        return Math.floor(Math.random() * a)
    },
    randomRange: function(a, b) {
        return this.random(b - a) + a
    }
});
StarManager.create = function(a) {
    return new StarManager(a)
};
var Role = cc.Sprite.extend({
    _icon: null,
    changeData: function(a) {
        this.initWithSpriteFrameName(a.pathNormal), this.setAnchorPoint(cc.p(.5, 0)), this._icon = a.icon
    },
    getIcon: function() {
        return this._icon
    }
});
Role.create = function() {
    var a = new Role;
    return a ? a : null
}, Role.data_Array = [{
    icon: 0,
    pathNormal: "checkWhiteNormal.png",
    pathSucc: "checkWhiteSucc.png",
    pathFail: "checkWhiteFail.png"
}, {
    icon: 1,
    pathNormal: "monkeyBlackNormal.png",
    pathSucc: "monkeyBlackSucc.png",
    pathFail: "monkeyBlackFail.png"
}, {
    icon: 2,
    pathNormal: "beanNormal.png",
    pathSucc: "beanSucc.png",
    pathFail: "beanFail.png"
}, {
    icon: 3,
    pathNormal: "tofuNormal.png",
    pathSucc: "tofuSucc.png",
    pathFail: "tofuFail.png"
}, {
    icon: 4,
    pathNormal: "checkGreenNormal.png",
    pathSucc: "checkGreenSucc.png",
    pathFail: "checkGreenFail.png"
}, {
    icon: 5,
    pathNormal: "monkeyRedNormal.png",
    pathSucc: "monkeyRedSucc.png",
    pathFail: "monkeyRedFail.png"
}];
var RoleLeader = cc.Node.extend({
    RESULT_NONE: -1,
    RESULT_FAIL: 0,
    RESULT_SUCC: 1,
    _normalSprite: null,
    _succSprite: null,
    _failSprite: null,
    _icon: null,
    _dir: null,
    _enabled: null,
    initData: function(a) {
        this._icon = a.icon, this._normalSprite || (this._normalSprite = cc.Sprite.create(), this.addChild(this._normalSprite)), this._normalSprite.initWithSpriteFrameName(a.pathNormal), this._succSprite || (this._succSprite = cc.Sprite.create(), this.addChild(this._succSprite)), this._succSprite.initWithSpriteFrameName(a.pathSucc), this._failSprite || (this._failSprite = cc.Sprite.create(), this.addChild(this._failSprite)), this._failSprite.initWithSpriteFrameName(a.pathFail)
    },
    show: function() {
        this._enabled = !0, this.setVisible(!0), this.showNormalState()
    },
    hide: function() {
        this._enabled = !1, this.setVisible(!1)
    },
    showNormalState: function() {
        this._normalSprite.setVisible(!0), this._succSprite.setVisible(!1), this._failSprite.setVisible(!1)
    },
    showSuccState: function() {
        this._normalSprite.setVisible(!1), this._succSprite.setVisible(!0), this._failSprite.setVisible(!1)
    },
    showFailState: function() {
        this._normalSprite.setVisible(!1), this._succSprite.setVisible(!1), this._failSprite.setVisible(!0)
    },
    setDir: function(a) {
        this._dir = a
    },
    getDir: function() {
        return this._dir
    },
    getIcon: function() {
        return this._icon
    },
    checkWithRole: function(a, b) {
        return a.getIcon() == this._icon ? b == this._dir ? this.RESULT_SUCC : this.RESULT_FAIL : (this.showNormalState(), this.RESULT_NONE)
    }
});
RoleLeader.create = function(a) {
    var b = new RoleLeader;
    return b ? (a && b.initData(a), b) : null
};
var AniBonus = cc.Node.extend({
    _armature: null,
    _armatureAnimation: null,
    _aniName: "aniPowerFrame",
    init: function() {
        return this._super() ? (this._armature = ccs.Armature.create(this._aniName), this.addChild(this._armature), this._armatureAnimation = this._armature.getAnimation(), void this._armature.setVisible(!1)) : !1
    },
    show: function() {
        this._armature.setVisible(!0), this._armatureAnimation.play(this._aniName)
    },
    hide: function() {
        this._armature.setVisible(!1)
    }
});
AniBonus.create = function() {
    var a = new AniBonus;
    return a && a.init(), a
};
var AniCatch = cc.Node.extend({
    _armature: null,
    _armatureAnimation: null,
    _aniName: "aniCatch",
    init: function() {
        return this._super() ? (this._armature = ccs.Armature.create(this._aniName), this.addChild(this._armature), this._armatureAnimation = this._armature.getAnimation(), this._armature.setVisible(!1), void(this._armature.scale = 1.2)) : !1
    },
    show: function() {
        this._armature.setVisible(!0), this._armatureAnimation.play(this._aniName), this.unscheduleUpdate(), this.scheduleUpdate()
    },
    hide: function() {
        this._armature.setVisible(!1), this.unscheduleUpdate()
    },
    update: function() {
        "" == this._armatureAnimation.getCurrentMovementID() && this.hide()
    }
});
AniCatch.create = function() {
    var a = new AniCatch;
    return a && a.init(), a
};
var AniSky = cc.Node.extend({
    _armature: null,
    _armatureAnimation: null,
    _aniName: "aniSky",
    init: function() {
        return this._super() ? (this._armature = ccs.Armature.create(this._aniName), this.addChild(this._armature), void(this._armatureAnimation = this._armature.getAnimation())) : !1
    },
    playAniSky: function() {
        this._armatureAnimation.play(this._aniName)
    },
    stopAniSky: function() {
        this._armatureAnimation.gotoAndPause(1)
    },
    getAniSkyHeight: function() {
        return this._armature.height
    }
});
AniSky.create = function() {
    var a = new AniSky;
    return a && a.init(), a
};
var Masses = cc.Node.extend({
    _normalState_Sprite: null,
    _leftState_Sprite: null,
    _rightlState_Sprite: null,
    ctor: function(a, b, c) {
        this._super(), this._normalState_Sprite = cc.Sprite.create(a), this._leftState_Sprite = cc.Sprite.create(b), this._rightlState_Sprite = cc.Sprite.create(c), this.addChild(this._normalState_Sprite), this.addChild(this._leftState_Sprite), this.addChild(this._rightlState_Sprite), this._normalState_Sprite.setVisible(!1), this._leftState_Sprite.setVisible(!1), this._rightlState_Sprite.setVisible(!1), this.changeState(Masses.STATE_NORMAL)
    },
    changeState: function(a) {
        switch (a) {
            case Masses.STATE_NORMAL:
                this._normalState_Sprite.setVisible(!0), this._leftState_Sprite.setVisible(!1), this._rightlState_Sprite.setVisible(!1);
                break;
            case Masses.STATE_LEFT:
                this._normalState_Sprite.setVisible(!1), this._leftState_Sprite.setVisible(!0), this._rightlState_Sprite.setVisible(!1);
                break;
            case Masses.STATE_RIGHT:
                this._normalState_Sprite.setVisible(!1), this._leftState_Sprite.setVisible(!1), this._rightlState_Sprite.setVisible(!0)
        }
    }
});
Masses.create = function(a, b, c) {
    return (a = new Masses(a, b, c)) ? a : null
}, Masses.STATE_NORMAL = -1, Masses.STATE_LEFT = 0, Masses.STATE_RIGHT = 1;
var GameLayer = cc.Layer.extend({
    _scene: null,
    _gameLayer: null,
    _score_AtlasLabel: null,
    _gameScore: null,
    _timeProgress_Image: null,
    _timer: null,
    _power_ProgressBar: null,
    _power: null,
    _textAtlasCombo: null,
    _txtCombo: null,
    _combos: null,
    _comboScoreManager: null,
    _left_Button: null,
    _right_Button: null,
    _roleManager: null,
    _canShake: null,
    _shakeTime: null,
    _openBonusTime: null,
    _bonusTime: 5,
    _aniBonus: null,
    _comboSoundPath_Array: null,
    _sun_Button: null,
    _clock_Image: null,
    _boy_roleLeader: null,
    _girl_roleLeader: null,
    _isGameOver: !1,
    MONKEY_SIZE: 4,
    init: function() {
        if (!this._super()) return !1;
        ccs.armatureDataManager.addArmatureFileInfo(res.aniPowerFrame_ExportJson), ccs.armatureDataManager.addArmatureFileInfo(res.aniCatch_ExportJson), ccs.armatureDataManager.addArmatureFileInfo(res.aniSky_ExportJson), cc.spriteFrameCache.addSpriteFrames(res.terrain_plist);
        var a = cc.director.getWinSize();
        this._aniSky = AniSky.create(), this._aniSky.setPosition(cc.p(a.width >> 1, a.height - (this._aniSky.getAniSkyHeight() >> 1))), this.addChild(this._aniSky, 0);
        var b = cc.Sprite.create("#cloud.png");
        for (b.setAnchorPoint(cc.p(.5, 1)), b.setPosition(cc.p(a.width >> 1, a.height)), this.addChild(b, 1), this._monkey_Masses_Array = Array(this.MONKEY_SIZE), b = 0; b < this.MONKEY_SIZE; b++) this._monkey_Masses_Array[b] = Masses.create("#monkeyNormal.png", "#monkeyLeft.png", "#monkeyRight.png"), this._monkey_Masses_Array[b].x = 1 >= b ? 100 + 110 * b : 440 + 110 * (b - 2), this._monkey_Masses_Array[b].y = a.height - 210, this.addChild(this._monkey_Masses_Array[b], 2);
        return b = cc.Sprite.create("#grassBg.png"), b.setAnchorPoint(cc.p(.5, 0)), b.setPosition(cc.p(a.width >> 1, 0)), this.addChild(b, 3), this._girl_roleLeader = RoleLeader.create({
            pathNormal: "girlNormal.png",
            pathSucc: "girlSucc.png",
            pathFail: "girlFail.png"
        }), this.addChild(this._girl_roleLeader, 4), this._girl_roleLeader.x = a.width >> 1, this._girl_roleLeader.y = a.height - 200, this._girl_roleLeader.show(), this._roleManager = RoleManager.create(this), this._gameLayer = ccs.uiReader.widgetFromJsonFile(res.game_ExportJson), this.addChild(this._gameLayer, 5), this._aniBonus = AniBonus.create(), this._aniBonus.setPosition(cc.p(cc.visibleRect.width >> 1, cc.visibleRect.height >> 1)), this.addChild(this._aniBonus, 300), this._score_AtlasLabel = this._gameLayer.getChildByName("score_AtlasLabel"), this._score_AtlasLabel.setVisible(!1), this._gameScore = new ccui.TextAtlas, this._gameScore.setProperty("0", res.scoreSmall_png, 28, 36, "0"), this._gameScore.x = this._score_AtlasLabel.x, this._gameScore.y = this._score_AtlasLabel.y + 10, this.addChild(this._gameScore, 200), this._power_ProgressBar = this._gameLayer.getChildByName("powerProgress_ProgressBar"), this._power = 0, this._power_ProgressBar.setPercent(this._power), this._timeProgress_Image = this._gameLayer.getChildByName("timeProgress_Image"), this._timeProgress_Image.setVisible(!1), this._timer = cc.ProgressTimer.create(cc.Sprite.create("#timeProgress.png")), this._timer.setType(cc.ProgressTimer.TYPE_BAR), this._timer.setPercentage(100), this._timer.midPoint = cc.p(0, 0), this._timer.barChangeRate = cc.p(1, 0), this._timer.setPosition(cc.p(this._timeProgress_Image.x, this._timeProgress_Image.y + 1)), this.addChild(this._timer, 100), this._clock_Image = this._gameLayer.getChildByName("clock_Image"), this._clock_Image.runAction(cc.sequence(cc.scaleTo(.5, 1.1, 1.1), cc.scaleTo(.5, 1, 1)).repeatForever()), this._whistle_Image = this._gameLayer.getChildByName("whistle_Image"), this._colorLayer = cc.LayerColor.create(cc.color(0, 0, 0, 160)), this._colorLayer.height = 150, this._colorLayer.y = 550, this.addChild(this._colorLayer, 14), this.txtReady = cc.Sprite.create("#txtReady.png"), this.txtReady.setPosition(cc.p(this._colorLayer.width >> 1, this._colorLayer.height >> 1)), this._colorLayer.addChild(this.txtReady, 15), this.txtStart = cc.Sprite.create("#txtStart.png"), this.txtStart.setPosition(cc.p(this._colorLayer.width >> 1, this._colorLayer.height >> 1)), this._colorLayer.addChild(this.txtStart, 16), this.txtTimesup = cc.Sprite.create("#txtTimesup.png"), this.txtTimesup.setVisible(!1), this._colorLayer.addChild(this.txtTimesup, 17), this.txtTimesup.setPosition(cc.p(this._colorLayer.width >> 1, this._colorLayer.height >> 1)), this._txtCombo = cc.Sprite.create("#txtCombo.png"), this.addChild(this._txtCombo, 18), this._txtCombo.setPosition(cc.p(cc.visibleRect.width >> 1, 250)), this._left_Button = this._gameLayer.getChildByName("left_Button"), this._left_Button.scale = .8, this._left_Button.addTouchEventListener(function(a, b) {
            switch (b) {
                case ccui.Widget.TOUCH_BEGAN:
                    this._girl_roleLeader.stopAllActions(), this._roleManager.dealTouchRoleQueue(0) ? (this.dealMassesAction(0), this._girl_roleLeader.runAction(cc.sequence(cc.callFunc(function() {
                        this._girl_roleLeader.showSuccState()
                    }, this), cc.delayTime(.1), cc.callFunc(function() {
                        this._girl_roleLeader.showNormalState()
                    }, this)))) : (this._girl_roleLeader.runAction(cc.sequence(cc.moveBy(.05, -5, 0), cc.sequence(cc.moveBy(.05, 10, 0), cc.moveBy(.05, -10, 0)).repeat(4), cc.moveBy(.05, 5, 0))), this._girl_roleLeader.runAction(cc.sequence(cc.callFunc(function() {
                        this._girl_roleLeader.showFailState()
                    }, this), cc.delayTime(.1), cc.callFunc(function() {
                        this._girl_roleLeader.showNormalState()
                    }, this))));
                    break;
                case ccui.Widget.TOUCH_ENDED:
                    this._roleManager.dealTouchEnded()
            }
        }, this), this._right_Button = this._gameLayer.getChildByName("right_Button"), this._right_Button.scale = .8, this._right_Button.addTouchEventListener(function(a, b) {
            switch (b) {
                case ccui.Widget.TOUCH_BEGAN:
                    this._girl_roleLeader.stopAllActions(), this._roleManager.dealTouchRoleQueue(1) ? (this.dealMassesAction(1), this._girl_roleLeader.runAction(cc.sequence(cc.callFunc(function() {
                        this._girl_roleLeader.showSuccState()
                    }, this), cc.delayTime(.5), cc.callFunc(function() {
                        this._girl_roleLeader.showNormalState()
                    }, this)))) : (this._girl_roleLeader.runAction(cc.sequence(cc.moveBy(.05, -5, 0), cc.sequence(cc.moveBy(.05, 10, 0), cc.moveBy(.05, -10, 0)).repeat(4), cc.moveBy(.05, 5, 0))), this._girl_roleLeader.runAction(cc.sequence(cc.callFunc(function() {
                        this._girl_roleLeader.showFailState()
                    }, this), cc.delayTime(.5), cc.callFunc(function() {
                        this._girl_roleLeader.showNormalState()
                    }, this))));
                    break;
                case ccui.Widget.TOUCH_ENDED:
                    this._roleManager.dealTouchEnded()
            }
        }, this), this._sun_Button = this._gameLayer.getChildByName("sun_Button"), this._sun_Button.runAction(cc.sequence(cc.moveBy(2, 0, -10), cc.moveBy(2, 0, 10)).repeatForever()), this._shakeData = [{
            x: -6,
            y: 0
        }, {
            x: 0,
            y: 0
        }, {
            x: 6,
            y: 0
        }, {
            x: 0,
            y: 0
        }, {
            x: 0,
            y: -6
        }, {
            x: 0,
            y: 0
        }, {
            x: 0,
            y: 6
        }, {
            x: 0,
            y: 0
        }, {
            x: -6,
            y: 0
        }, {
            x: 0,
            y: 0
        }, {
            x: 6,
            y: 0
        }, {
            x: 0,
            y: 0
        }, {
            x: 0,
            y: -6
        }, {
            x: 0,
            y: 0
        }, {
            x: 0,
            y: 6
        }, {
            x: 0,
            y: 0
        }], this._shakeTime = 0, this.hide(), !0
    },
    update: function() {
        this._canShake && this.shakeScreen()
    },
    canTouch: function(a) {
        (this._canTouch = a) ? (this._left_Button.setEnabled(!0), this._right_Button.setEnabled(!0)) : (this._left_Button.setEnabled(!1), this._right_Button.setEnabled(!1))
    },
    gameStart: function() {
        this._colorLayer.setVisible(!1), this._gameLayer.setEnabled(!0), this._left_Button.setVisible(!0), this._left_Button.setEnabled(!0), this._right_Button.setVisible(!0), this._right_Button.setEnabled(!0);
        var a = cc.ProgressFromTo.create(GameData.gameTime, 100, 0),
            b = cc.callFunc(this.gameOver, this),
            a = cc.sequence(a, b);
        this._timer.runAction(a), this.runAction(cc.sequence(cc.delayTime(GameData.gameTime - 6), cc.callFunc(function() {
            GameData.soundOpen && cc.audioEngine.playEffect(res.sndAlert_mp3)
        }, this))), this.runAction(cc.sequence(cc.delayTime(1 * (GameData.gameTime / 6)), cc.callFunc(function() {
            this._roleManager.addRoleLeader()
        }, this))), this.runAction(cc.sequence(cc.delayTime(3 * (GameData.gameTime / 6)), cc.callFunc(function() {
            this._roleManager.addRoleLeader()
        }, this))), this.scheduleUpdate()
    },
    gameOver: function() {
        cc.log("game over"), this._isGameOver = !0, this.pauseGameMusic(), this.stopGameMusic(), GameData.soundOpen && cc.audioEngine.playEffect(res.sndOver_mp3), this._txtCombo && this._txtCombo.setVisible(!1), this._colorLayer && this._colorLayer.setVisible(!0), this.txtTimesup && this.txtTimesup.setVisible(!0), this._left_Button.setVisible(!1), this._left_Button.setEnabled(!1), this._right_Button.setVisible(!1), this._right_Button.setEnabled(!1), this._roleManager.dealTouchEnded(), this.dealMassesAction(-1), this.unscheduleUpdate(), this._aniBonus.hide(), this._openBonusTime = !1, this.runAction(cc.sequence(cc.delayTime(2), cc.callFunc(function() {
            this.stopAllActions(), this._scene.changeLayer(this._scene.ID_GAME_OVER)
        }, this)))
		dp_submitScore( GameData.score);
    },
    playGameMusic: function(a) {
        a ? (cc.audioEngine.playMusic(res.mscNormal_mp3, !0), this._isStopMusic = !1) : this._isStopMusic ? (cc.audioEngine.playMusic(res.mscNormal_mp3, !0), this._isStopMusic = !1) : cc.audioEngine.resumeMusic()
    },
    pauseGameMusic: function() {
        cc.audioEngine.pauseMusic()
    },
    stopGameMusic: function() {
        cc.audioEngine.stopMusic(), this._isStopMusic = !0
    },
    addCombo: function() {
        this._combos++;
        var a = this._combos;
        a >= 10 && (a = 10), GameData.soundOpen && cc.audioEngine.playEffect(this._openBonusTime ? res.sndPowerSucc_mp3 : res["sndSucc" + a + "_mp3"]), this._txtCombo && (this._txtCombo.setVisible(!0), this._txtCombo.stopAllActions(), this._txtCombo.scale = .6, this._txtCombo.setRotation(this.randomRange(-15, 15)), this._txtCombo.runAction(cc.sequence(cc.fadeIn(1e-4), cc.scaleTo(.1, 1), cc.scaleTo(.2, .6), cc.fadeOut(.5))))
    },
    resetCombo: function() {
        this._combos = 0, this._txtCombo && (this._txtCombo.setVisible(!1), this._txtCombo.stopAllActions()), this._openBonusTime && (this.stopActionByTag(1e4), this.resetPower(), this.endBonusTime())
    },
    addPower: function(a) {
        this._openBonusTime || (this._power += a, 0 > this._power && (this._power = 0), 100 <= this._power && (this._power = 100, this.startBonusTime()), this._power_ProgressBar.setPercent(this._power)), a > 0 ? this._whistle_Image && (this._whistle_Image.stopAllActions(), this._whistle_Image.scale = .8, this._whistle_Image.runAction(cc.sequence(cc.scaleTo(.1, 1.3), cc.scaleTo(.2, 1)))) : GameData.soundOpen && cc.audioEngine.playEffect(res.sndFail_mp3)
    },
    resetPower: function() {
        this._power = 0, this._power_ProgressBar.setPercent(this._power)
    },
    addScore: function(a) {
        return this._openBonusTime && (a <<= 1), GameData.score += a, 0 > GameData.score && (GameData.score = 0), this._gameScore.setString(GameData.score), a
    },
    resetScore: function() {
        GameData.score = 0, this._gameScore.setString(GameData.score)
    },
    show: function() {
        this.setVisible(!0), GameData.soundOpen && (this.playGameMusic(!0), cc.audioEngine.playEffect(res.sndReady_mp3)), this._isGameOver = !1, this._roleManager.reset(), this.resetCombo(), this.resetScore(), this.resetPower(), this._left_Button.setVisible(!1), this._left_Button.setEnabled(!1), this._right_Button.setVisible(!1), this._right_Button.setEnabled(!1), this._txtCombo.setVisible(!1), this.txtTimesup && this.txtTimesup.setVisible(!1), this._timer.setPercentage(100), this._colorLayer.setVisible(!0), this.txtStart.runAction(cc.fadeOut(.001)), this.txtReady.runAction(cc.sequence(cc.fadeIn(.5), cc.fadeOut(.1), cc.callFunc(function() {
            this.txtStart.runAction(cc.sequence(cc.fadeIn(.2), cc.delayTime(.5), cc.callFunc(function() {
                this.gameStart()
            }, this)))
        }, this)))
    },
    hide: function() {
        this.setVisible(!1), this._gameLayer.setEnabled(!1)
    },
    startShake: function() {
        this._canShake = !0, this._shakeTime = 0
    },
    shakeScreen: function() {
        var a = this._shakeData[this._shakeTime];
        this.x = a.x, this.y = a.y, ++this._shakeTime == this._shakeData.length && (this._canShake = !1, this._shakeTime = 0)
    },
    startBonusTime: function() {
        this._openBonusTime = !0, cc.audioEngine.pauseMusic(), cc.audioEngine.stopMusic(), GameData.soundOpen && cc.audioEngine.playMusic(res.mscPower_mp3), this._aniSky && this._aniSky.playAniSky(), this._aniBonus.show();
        var a = cc.sequence(cc.delayTime(this._bonusTime), cc.callFunc(function() {
            cc.log("endBonusTime"), this.resetPower(), this.resetCombo(), this.endBonusTime()
        }, this));
        a.setTag(1e4), this.runAction(a)
    },
    endBonusTime: function() {
        this._openBonusTime && (this._aniBonus.hide(), this._openBonusTime = !1, this._aniSky && this._aniSky.stopAniSky(), cc.audioEngine.pauseMusic(), cc.audioEngine.stopMusic(), GameData.soundOpen && !this._isGameOver && cc.audioEngine.playMusic(res.mscNormal_mp3, !0))
    },
    dealMassesAction: function(a) {
        switch (a) {
            case -1:
                a = 0;
                for (var b = this._monkey_Masses_Array.length; b > a; a++) this._monkey_Masses_Array[a].changeState(Masses.STATE_NORMAL);
                break;
            case 0:
                for (a = 0, b = this._monkey_Masses_Array.length; b > a; a++) this._monkey_Masses_Array[a].runAction(cc.sequence(cc.callFunc(function() {
                    this.changeState(Masses.STATE_LEFT)
                }, this._monkey_Masses_Array[a]), cc.delayTime(.1), cc.callFunc(function() {
                    this.changeState(Masses.STATE_NORMAL)
                }, this._monkey_Masses_Array[a])));
                break;
            case 1:
                for (a = 0, b = this._monkey_Masses_Array.length; b > a; a++) this._monkey_Masses_Array[a].runAction(cc.sequence(cc.callFunc(function() {
                    this.changeState(Masses.STATE_RIGHT)
                }, this._monkey_Masses_Array[a]), cc.delayTime(.1), cc.callFunc(function() {
                    this.changeState(Masses.STATE_NORMAL)
                }, this._monkey_Masses_Array[a])))
        }
    },
    random: function(a) {
        return Math.floor(Math.random() * a)
    },
    randomRange: function(a, b) {
        return this.random(b - a) + a
    }
});
GameLayer.create = function(a) {
    var b = new GameLayer;
    return b && b.init() && (b._scene = a), b
};
var GameOverLayer = cc.Layer.extend({
    _scene: null,
    _score_AtlasLabel: null,
    _again_Button: null,
    _moreGame_Button: null,
    _isShowMoreGameButton: !0,
    _enableSendButton: null,
    init: function() {
        if (!this._super()) return !1;
        var a = cc.director.getWinSize(),
            b = cc.Sprite.create(res.gameOverBg_jpg);
        return b.setPosition(cc.p(a.width >> 1, a.height >> 1)), this.addChild(b, 0), this._gameOverLayer = ccs.uiReader.widgetFromJsonFile(res.gameOver_ExportJson), this.addChild(this._gameOverLayer, 2), a = this._gameOverLayer.getChildByName("score_AtlasLabel"), a.setVisible(!1), this._score_AtlasLabel = new ccui.TextAtlas, this._score_AtlasLabel.setProperty("0", res.scoreSmall_png, 28, 36, "0"), this._score_AtlasLabel.x = a.x + 20, this._score_AtlasLabel.y = a.y, this.addChild(this._score_AtlasLabel, 2), this._again_Button = this._gameOverLayer.getChildByName("again_Button"), this._moreGame_Button = this._gameOverLayer.getChildByName("moreGame_Button"), this._moreGame_Button.runAction(cc.sequence(cc.moveBy(.5, 0, -10), cc.moveBy(.5, 0, 10)).repeatForever()), this._send1_Button = this._gameOverLayer.getChildByName("send2_Button"), this._txt1_Image = this._gameOverLayer.getChildByName("txtSend1_Image"), this._txt2_Image = this._gameOverLayer.getChildByName("txtSend2_Image"), this._txt3_Image = this._gameOverLayer.getChildByName("txtSend5_Image"), this.initEvent(), this.hide(), !0
    },
    initEvent: function() {
        this._send1_Button.addTouchEventListener(function(a, b) {
            switch (b) {
                case ccui.Widget.TOUCH_ENDED:
                    this.goToShareHtml()
            }
        }, this), this._again_Button.addTouchEventListener(function(a, b) {
            switch (b) {
                case ccui.Widget.TOUCH_ENDED:
                    this._scene.changeLayer(this._scene.ID_GAME)
            }
        }, this), this._isShowMoreGameButton && this._moreGame_Button && this._moreGame_Button.addTouchEventListener(function(a, b) {
            switch (b) {
                case ccui.Widget.TOUCH_ENDED:
                    this.goToMoreGameHtml()
            }
        }, this)
    },
    showShareInfoLayer: function() {
        cc.director.getScheduler().scheduleCallbackForTarget(this, this.hideShareInfoLayer, 0, 0, 3)
    },
    hideShareInfoLayer: function() {},
    show: function() {
        this.setVisible(!0), this._gameOverLayer.setEnabled(!0), this._score_AtlasLabel.setString(GameData.score), this._txt1_Image.setVisible(!1), this._txt2_Image.setVisible(!1), this._txt3_Image.setVisible(!1), this._enableSendButton && this._enableSendButton.stopAllActions(), console.log("GameData.score:" + GameData.score), 500 >= GameData.score ? this._txt1_Image.setVisible(!0) : 1200 >= GameData.score ? this._txt2_Image.setVisible(!0) : this._txt3_Image.setVisible(!0), this._enableSendButton = this._send1_Button, this._enableSendButton && this._enableSendButton.runAction(cc.sequence(cc.scaleTo(1, 1.05, 1.05), cc.scaleTo(1, 1, 1)).repeatForever());
		var mescore=GameData.score;
		var mefont="分";
		var melevel="";
		//Getscore(mescore,1281,mefont,melevel);
		
    },
    hide: function() {
        this.setVisible(!1), this._gameOverLayer.setEnabled(!1), this._balloonManager && this._balloonManager.stopSchedule()
    },
    goToShareHtml: function() {
       dp_share();
    },
    goToMoreGameHtml: function() {
		clickMore();
    },
    goToRuleHtml: function() {},
    showShareInfoLayer: function() {
       
    },
    hideShareInfoLayer: function() {
        cc.eventManager.removeListener(this._shareInfoLayerTouchListener)
    }
});
GameOverLayer.create = function(a) {
    var b = new GameOverLayer;
    return b && b.init() && (b._scene = a), b
};
var StartLayer = cc.Layer.extend({
    _bg: null,
    _scene: null,
    _balloonManager: null,
    init: function() {
        if (!this._super()) return !1;
        cc.spriteFrameCache.addSpriteFrames(res.objects_plist);
        var a = cc.director.getWinSize(),
            b = cc.Sprite.create(res.titleBg_jpg);
        return b.setPosition(cc.p(a.width >> 1, a.height >> 1)), this.addChild(b, 0), this._startLayer = ccs.uiReader.widgetFromJsonFile(res.title_ExportJson), this.addChild(this._startLayer, 2), this._startButton = this._startLayer.getChildByName("start_Button"), this._startButton.runAction(cc.sequence(cc.moveBy(.6, cc.p(0, -10)), cc.moveBy(.6, cc.p(0, 10))).repeatForever()), this.initEvent(), this.hide(), !0
    },
    initEvent: function() {
        this._startButton.addTouchEventListener(function(a, b) {
            switch (b) {
                case ccui.Widget.TOUCH_ENDED:
                    this._scene.changeLayer(this._scene.ID_GAME)
            }
        }, this)
    },
    show: function() {
        this.setVisible(!0), this._startLayer.setEnabled(!0)
    },
    hide: function() {
        this.setVisible(!1), this._startLayer.setEnabled(!1)
    }
});
StartLayer.create = function(a) {
    var b = new StartLayer;
    return b && b.init() && (b._scene = a), b
};
var GameScene = cc.Scene.extend({
    ID_START: 0,
    ID_GAME: 1,
    ID_GAME_OVER: 2,
    _startLayer: null,
    _gameLayer: null,
    _gameOverLayer: null,
    init: function() {
        return this._super() ? (this._startLayer = StartLayer.create(this), this._gameLayer = GameLayer.create(this), this._gameOverLayer = GameOverLayer.create(this), this._startLayer && this.addChild(this._startLayer, 1), this._gameLayer && this.addChild(this._gameLayer, 0), this._gameOverLayer && this.addChild(this._gameOverLayer, 2), cc.log("init finish"), this._startLayer.show(), !0) : !1
    },
    changeLayer: function(a) {
        switch (this._startLayer && this._startLayer.hide(), this._gameLayer && this._gameLayer.hide(), this._gameOverLayer && this._gameOverLayer.hide(), a) {
            case this.ID_START:
                this._startLayer && this._startLayer.show();
                break;
            case this.ID_GAME:
                this._gameLayer && this._gameLayer.show();
                break;
            case this.ID_GAME_OVER:
                this._gameOverLayer && this._gameOverLayer.show()
        }
    }
});
GameScene.create = function() {
    var a = new GameScene;
    return a && a.init() ? a : null
};
var LoadingScene = cc.Scene.extend({
    init: function() {
        cc.director.getWinSize();
        return this.loadingSlider = new ccui.Slider, this.loadingSlider.loadBarTexture(res.loadingBar_png), this.loadingSlider.loadSlidBallTextures(res.heart_png, "", ""), this.loadingSlider.loadProgressBarTexture(res.loadingProcess_png), this.loadingSlider.x = cc.visibleRect.width >> 1, this.loadingSlider.y = 300, this.loadingText = cc.LabelTTF.create("穿越中... 0%", "Arial", 32), this.loadingText.setAnchorPoint(.5, 0), this.loadingText.x = cc.visibleRect.width / 2, this.loadingText.y = 320, this.addChild(this.loadingSlider, 10), this.addChild(this.loadingText, 10), !0
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this), this.schedule(this._startLoading, .3)
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this)
    },
    initWithResources: function(a, b) {
        "string" == typeof a && (a = [a]), this.resources = a || [], this.cb = b
    },
    _startLoading: function() {
        var a = this;
        a.unschedule(a._startLoading), cc.loader.load([res.logo_png], function(b) {
            if (b.src && b.src.indexOf("/logo.png") > 0) {
                var c = cc.director.getWinSize();
                b = cc.Sprite.create(res.logo_png), b.setPosition(cc.p(c.width >> 1, c.height >> 1)), a.addChild(b, 0)
            }
            a.loadingSlider.setPercent(0), a.loadingText.setString("穿越中... 0%")
        }, function() {
            cc.loader.load(a.resources, function(b, c, d) {
                b = Math.min(100 * (d / c) | 0, 100), a.loadingSlider.setPercent(b), a.loadingText.setString("穿越中... " + b + "%")
            }, function() {
                a.cb && a.cb()
            })
        })
    }
});
LoadingScene.preload = function(a, b) {
    var c = new LoadingScene;
    return c ? (c.init(), c.initWithResources(a, b), cc.director.runScene(c), c) : null
}, cc.isHtml = window.navigator ? !0 : !1, cc.game.onStart = function() {
    cc.view.adjustViewPort(!0), cc.view.setDesignResolutionSize(640, 960, cc.ResolutionPolicy.SHOW_ALL), cc.view.resizeWithBrowserSize(!0), LoadingScene.preload(g_resources, function() {
        cc.director.runScene(window.gameTmp = GameScene.create())
    }, this)
}, cc.game.run();